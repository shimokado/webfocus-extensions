/*!
 * WebFOCUS tdg v9.3.1
 * Copyright (C) 1996-2023. Cloud Software Group, Inc. All rights reserved.
 */
(function() {
    if (!String.prototype.startsWith)
        String.prototype.startsWith = function(searchString, position) {
            position = position || 0;
            return this.indexOf(searchString, position) === position
        }
        ;
    if (!String.prototype.endsWith)
        String.prototype.endsWith = function(searchString, position) {
            var subjectString = this.toString();
            if (position == null || position > subjectString.length)
                position = subjectString.length;
            position -= searchString.length;
            var lastIndex = subjectString.indexOf(searchString, position);
            return lastIndex !== -1 && lastIndex === position
        }
        ;
    if (!String.prototype.repeat)
        String.prototype.repeat = function(count) {
            if (this == null)
                throw new TypeError("can't convert " + this + " to object");
            var str = "" + this;
            count = +count;
            if (count != count)
                count = 0;
            if (count < 0)
                throw new RangeError("repeat count must be non-negative");
            if (count == Infinity)
                throw new RangeError("repeat count must be less than infinity");
            count = Math.floor(count);
            if (str.length == 0 || count == 0)
                return "";
            if (str.length * count >= 1 << 28)
                throw new RangeError("repeat count must not overflow maximum string size");
            var rpt = "";
            for (; ; ) {
                if ((count & 1) == 1)
                    rpt += str;
                count >>>= 1;
                if (count == 0)
                    break;
                str += str
            }
            return rpt
        }
        ;
    if (!String.prototype.includes)
        String.prototype.includes = function() {
            return String.prototype.indexOf.apply(this, arguments) !== -1
        }
        ;
    if (!String.prototype.padStart)
        String.prototype.padStart = function padStart(targetLength, padString) {
            targetLength = targetLength >> 0;
            padString = String(typeof padString !== "undefined" ? padString : " ");
            if (this.length > targetLength)
                return String(this);
            else {
                targetLength = targetLength - this.length;
                if (targetLength > padString.length)
                    padString += padString.repeat(targetLength / padString.length);
                return padString.slice(0, targetLength) + String(this)
            }
        }
        ;
    if (!Array.isArray)
        Array.isArray = function(a) {
            return Object.prototype.toString.call(a) === "[object Array]"
        }
        ;
    if (!Array.prototype.includes)
        Array.prototype.includes = function(searchElement) {
            var O = Object(this);
            var len = parseInt(O.length, 10) || 0;
            if (len === 0)
                return false;
            var n = parseInt(arguments[1], 10) || 0;
            var k;
            if (n >= 0)
                k = n;
            else {
                k = len + n;
                if (k < 0)
                    k = 0
            }
            var currentElement;
            while (k < len) {
                currentElement = O[k];
                if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement)
                    return true;
                k++
            }
            return false
        }
        ;
    if (!Array.prototype.every)
        Array.prototype.every = function(fun) {
            if (this === void 0 || this === null)
                throw new TypeError;
            var t = Object(this);
            var len = t.length >>> 0;
            if (typeof fun !== "function")
                throw new TypeError;
            var thisp = arguments[1];
            for (var i = 0; i < len; i++)
                if (i in t && !fun.call(thisp, t[i], i, t))
                    return false;
            return true
        }
        ;
    if (!Array.prototype.some)
        Array.prototype.some = function(fun) {
            if (this === void 0 || this === null)
                throw new TypeError;
            var t = Object(this);
            var len = t.length >>> 0;
            if (typeof fun !== "function")
                throw new TypeError;
            var thisp = arguments[1];
            for (var i = 0; i < len; i++)
                if (i in t && fun.call(thisp, t[i], i, t))
                    return true;
            return false
        }
        ;
    if (!Array.prototype.find)
        Array.prototype.find = function(predicate) {
            if (this === null)
                throw new TypeError("Array.prototype.find called on null or undefined");
            if (typeof predicate !== "function")
                throw new TypeError("predicate must be a function");
            var list = Object(this);
            var length = list.length >>> 0;
            var thisArg = arguments[1];
            var value;
            for (var i = 0; i < length; i++) {
                value = list[i];
                if (predicate.call(thisArg, value, i, list))
                    return value
            }
            return undefined
        }
        ;
    if (!Object.values || !Object.entries) {
        var reduce = Function.bind.call(Function.call, Array.prototype.reduce);
        var isEnumerable = Function.bind.call(Function.call, Object.prototype.propertyIsEnumerable);
        var concat = Function.bind.call(Function.call, Array.prototype.concat);
        if (!Object.values)
            Object.values = function values(O) {
                return reduce(Object.getOwnPropertyNames(O), function(v, k) {
                    return concat(v, typeof k === "string" && isEnumerable(O, k) ? [O[k]] : [])
                }, [])
            }
            ;
        if (!Object.entries)
            Object.entries = function entries(O) {
                return reduce(Object.getOwnPropertyNames(O), function(e, k) {
                    return concat(e, typeof k === "string" && isEnumerable(O, k) ? [[k, O[k]]] : [])
                }, [])
            }
    }
    Math.log10 = Math.log10 || function(x) {
        return Math.log(x) / Math.LN10
    }
    ;
    (function() {
        var base64EncodeChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var base64DecodeChars = new Array(-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1);
        function base64encode(str) {
            var out, i, len;
            var c1, c2, c3;
            len = str.length;
            i = 0;
            out = "";
            while (i < len) {
                c1 = str.charCodeAt(i++) & 255;
                if (i === len) {
                    out += base64EncodeChars.charAt(c1 >> 2);
                    out += base64EncodeChars.charAt((c1 & 3) << 4);
                    out += "==";
                    break
                }
                c2 = str.charCodeAt(i++);
                if (i === len) {
                    out += base64EncodeChars.charAt(c1 >> 2);
                    out += base64EncodeChars.charAt((c1 & 3) << 4 | (c2 & 240) >> 4);
                    out += base64EncodeChars.charAt((c2 & 15) << 2);
                    out += "=";
                    break
                }
                c3 = str.charCodeAt(i++);
                out += base64EncodeChars.charAt(c1 >> 2);
                out += base64EncodeChars.charAt((c1 & 3) << 4 | (c2 & 240) >> 4);
                out += base64EncodeChars.charAt((c2 & 15) << 2 | (c3 & 192) >> 6);
                out += base64EncodeChars.charAt(c3 & 63)
            }
            return out
        }
        function base64decode(str) {
            var c1, c2, c3, c4;
            var i, len, out;
            len = str.length;
            i = 0;
            out = "";
            while (i < len) {
                do
                    c1 = base64DecodeChars[str.charCodeAt(i++) & 255];
                while (i < len && c1 === -1);
                if (c1 === -1)
                    break;
                do
                    c2 = base64DecodeChars[str.charCodeAt(i++) & 255];
                while (i < len && c2 === -1);
                if (c2 === -1)
                    break;
                out += String.fromCharCode(c1 << 2 | (c2 & 48) >> 4);
                do {
                    c3 = str.charCodeAt(i++) & 255;
                    if (c3 === 61)
                        return out;
                    c3 = base64DecodeChars[c3]
                } while (i < len && c3 === -1);
                if (c3 === -1)
                    break;
                out += String.fromCharCode((c2 & 15) << 4 | (c3 & 60) >> 2);
                do {
                    c4 = str.charCodeAt(i++) & 255;
                    if (c4 === 61)
                        return out;
                    c4 = base64DecodeChars[c4]
                } while (i < len && c4 === -1);
                if (c4 === -1)
                    break;
                out += String.fromCharCode((c3 & 3) << 6 | c4)
            }
            return out
        }
        if (typeof window !== "undefined") {
            if (!window.btoa)
                window.btoa = base64encode;
            if (!window.atob)
                window.atob = base64decode
        }
    }
    )();
    if (typeof DOMParser !== "undefined")
        (function(DOMParser) {
            var nativeParse = DOMParser.prototype.parseFromString;
            try {
                if ((new DOMParser).parseFromString("", "text/html"))
                    return
            } catch (ex) {}
            DOMParser.prototype.parseFromString = function(markup, type) {
                if (/^\s*text\/html\s*(?:;|$)/i.test(type)) {
                    var doc = document.implementation.createHTMLDocument("");
                    if (markup.toLowerCase().indexOf("<!doctype") > -1)
                        doc.documentElement.innerHTML = markup;
                    else
                        doc.body.innerHTML = markup;
                    return doc
                } else
                    return nativeParse.apply(this, arguments)
            }
        }
        )(DOMParser)
}
)();
tdgchart = function() {
    var loadExternalProperties = function() {
        var loadedProps = null;
        return function() {
            if (loadedProps != null)
                return loadedProps;
            loadedProps = {};
            return loadedProps
        }
    }();
    function saveScriptConfig(props) {
        var configVars = ["webappContext", "htmlKey", "extensionKey"];
        configVars.forEach(function(name) {
            if (props[name] != undefined)
                tdgchart.scriptConfig[name] = props[name]
        })
    }
    function tdgchart(props) {
        var chart = this;
        chart.cache = new chart.cacheEngine(chart);
        saveScriptConfig(props || {});
        if (typeof window !== "undefined") {
            tdgchart.extensionManager.loadExtensionAPIResources();
            tdgchart.extensionManager.initExtensionProperties(this)
        }
        chart.set(tdgchart.defaultProperties);
        chart.set(loadExternalProperties());
        chart.set(props || {})
    }
    if (typeof module === "object" && typeof module.exports === "object")
        module.exports.tdgchart = tdgchart;
    return tdgchart
}();
(function() {
    tdgchart.util = {};
    var tdg = tdgchart.util;
    tdgchart.util.ns = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: "http://www.w3.org/1999/xhtml",
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    };
    tdgchart.util.identity = function(x) {
        return x
    }
    ;
    tdgchart.util.get = function(prop, root, defaultValue) {
        root = root || {};
        prop = (prop + "").split(".");
        for (var i = 0, n = prop.length; i < n; i++) {
            var p = prop[i];
            var match = p.match(/(.*)\[(\d*)\]/);
            if (match && match.length > 2) {
                root = root[match[1]];
                if (root && Array.isArray(root) && root.length >= match[2])
                    root = root[match[2]];
                else
                    return defaultValue
            } else if (root.hasOwnProperty(p) && root[p] != null)
                root = root[p];
            else
                return defaultValue
        }
        return root
    }
    ;
    tdgchart.util.flattenProperty = tdgchart.util.get;
    tdgchart.util.set = function(prop, value, obj) {
        obj = obj || {};
        var target, match = prop.match(/^([^.[]*)[.]?(.*)$/);
        if (!match || match.length < 3)
            return;
        if (match[1])
            target = match[1];
        else {
            match = match[2].match(/^\[(\d*)\][.]?(.*)$/);
            target = parseInt(match[1], 10)
        }
        if (match[2]) {
            obj[target] = obj[target] || (match[2].startsWith("[") ? [] : {});
            tdg.set(match[2], value, obj[target])
        } else
            obj[target] = value
    }
    ;
    tdgchart.util.clone = tdgchart.util.cloneObject = function(src) {
        var t = typeof src;
        if (t === "string" || t === "number" || t === "boolean" || src == null)
            return src;
        if (Array.isArray(src))
            return tdg.arrayDeepCopy(src);
        return tdg.mergeObjects(src, {})
    }
    ;
    tdgchart.util.merge = tdgchart.util.mergeObjects = function(src, dest) {
        for (var prop in src)
            if (src[prop] && src[prop].constructor === Object) {
                if (dest[prop] && dest[prop].constructor !== Object)
                    dest[prop] = {};
                dest[prop] = dest[prop] || {};
                tdg.mergeObjects(src[prop], dest[prop])
            } else if (src[prop] && Array.isArray(src[prop]))
                dest[prop] = tdg.arrayDeepCopy(src[prop]);
            else
                dest[prop] = src[prop];
        return dest
    }
    ;
    tdgchart.util.additiveMerge = function(src, dest) {
        if (Array.isArray(src)) {
            if (!Array.isArray(dest))
                return tdg.arrayDeepCopy(src);
            for (var i = 0; i < src.length; i++)
                dest[i] = tdgchart.util.additiveMerge(src[i], dest[i])
        } else if (typeof src !== "object")
            return src;
        else if (dest == null)
            return tdg.clone(src);
        else
            for (var prop in src)
                dest[prop] = tdgchart.util.additiveMerge(src[prop], dest[prop]);
        return dest
    }
    ;
    tdgchart.util.arrayDeepCopy = function(src) {
        return src.map(function(el) {
            if (el && el.constructor === Object)
                return tdg.cloneObject(el);
            else if (el && Array.isArray(el))
                return tdg.arrayDeepCopy(el);
            return el === null ? undefined : el
        })
    }
    ;
    tdgchart.util.keys = function(obj) {
        var res = [];
        for (var k in obj)
            if (obj.hasOwnProperty(k))
                res.push(k);
        return res
    }
    ;
    tdgchart.util.values = function(obj) {
        var res = [];
        for (var k in obj)
            if (obj.hasOwnProperty(k))
                res.push(obj[k]);
        return res
    }
    ;
    tdgchart.util.uniqueEntries = function(a) {
        var o = [];
        for (var i = 0; i < a.length; i++)
            o[a[i]] = a[i];
        return tdgchart.util.values(o)
    }
    ;
    tdgchart.util.isEmpty = function(p) {
        if (typeof p === "number" || typeof p === "function")
            return false;
        else if (typeof p === "boolean")
            return !p;
        else if (Array.isArray(p) || typeof p === "string")
            return p.length <= 0;
        for (var x in p)
            if (p.hasOwnProperty(x))
                return false;
        return true
    }
    ;
    tdgchart.util.isNotEmpty = function(p) {
        return !tdg.isEmpty(p)
    }
    ;
    tdgchart.__internalFnCache = {};
    tdgchart.util.memoize = function(name, cloneRes, fn) {
        if (tdgchart.__internalFnCache[name] == null)
            tdgchart.__internalFnCache[name] = {};
        return function() {
            var args = Array.prototype.slice.call(arguments);
            var res, hash = "";
            for (var i = 0; i < args.length; i++)
                hash += args[i] + "";
            if (hash in tdgchart.__internalFnCache[name])
                res = tdgchart.__internalFnCache[name][hash];
            else
                res = tdgchart.__internalFnCache[name][hash] = fn.apply(this, args);
            return cloneRes ? tdg.clone(res) : res
        }
    }
    ;
    tdgchart.util.loadCSSFile = function(id, url) {
        var link = document.createElement("link");
        link.rel = "stylesheet";
        link.type = "text/css";
        link.id = id;
        link.href = url;
        document.head.appendChild(link)
    }
    ;
    tdgchart.util.loadCSSString = function(id, cssString) {
        var node = document.createElement("style");
        node.type = "text/css";
        node.id = id;
        if (node.styleSheet)
            node.styleSheet.cssText = cssString;
        else
            node.appendChild(document.createTextNode(cssString));
        document.head.appendChild(node)
    }
    ;
    tdgchart.util.loadScriptFile = function(url, onLoad, onError, doc) {
        doc = doc || document;
        var s = doc.createElement("script");
        s.async = false;
        s.type = "text/javascript";
        s.src = url;
        s.charset = "UTF-8";
        if (onLoad)
            s.addEventListener("load", onLoad, false);
        if (onError)
            s.addEventListener("error", onError, false);
        doc.head.appendChild(s)
    }
    ;
    tdgchart.util.ajax = function(path, config) {
        var request;
        function onLoad() {
            if (request && request.status === 200 && request.readyState === 4) {
                var res = request.responseText;
                if (config.asJSON)
                    try {
                        res = JSON.parse(request.responseText)
                    } catch (e$1) {
                        try {
                            res = eval("(" + request.responseText + ")")
                        } catch (e$0) {
                            res = {}
                        }
                    }
                if (typeof config.onLoad === "function")
                    return config.onLoad(res);
                return res
            } else if (config.onError)
                config.onError(request);
            return undefined
        }
        var protocol = window.location.protocol;
        if (!window.tdgAllowFileRequests && (protocol === "file:" || protocol === "content:")) {
            tdg.logError("Could not dynamically load: " + path);
            if (config.onError)
                config.onError();
            return null
        }
        config = config || {};
        try {
            var postData = null;
            if (config.GETLimit >= 0) {
                var index = path.indexOf("?");
                if (index >= 0) {
                    var tempPath = path.substr(0, index);
                    var data = path.substr(index + 1);
                    if (data.length >= config.GETLimit) {
                        postData = data;
                        path = tempPath
                    }
                }
            }
            var method = typeof config.requestMethod === "string" ? config.requestMethod.toUpperCase() : postData ? "POST" : "GET";
            request = new XMLHttpRequest;
            request.open(method, path, config.async || false);
            if (config.hasOwnProperty("csrfName") !== undefined && method == "POST")
                request.setRequestHeader(config.csrfName, config.csrfValue);
            if (config.async && config.onLoad)
                request.onload = onLoad;
            request.send(postData)
        } catch (err) {
            request = null
        }
        if (request && !config.async)
            return onLoad();
        return null
    }
    ;
    tdgchart.util.getMouseInViewPort = function(svgNode, e) {
        var pt = svgNode.createSVGPoint();
        if (e.type.indexOf("touch") >= 0 && e.changedTouches && e.changedTouches.length > 0)
            e = e.changedTouches[0];
        pt.x = e.clientX;
        pt.y = e.clientY;
        pt = pt.matrixTransform(svgNode.getScreenCTM().inverse());
        return pt
    }
    ;
    tdgchart.util.getMousePosition = function(e) {
        if (e.type.indexOf("touch") >= 0 && e.changedTouches && e.changedTouches.length > 0)
            e = e.changedTouches[0];
        return {
            x: e.clientX,
            y: e.clientY
        }
    }
    ;
    tdgchart.util.bind = function(fn, context) {
        return function() {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(context, args)
        }
    }
    ;
    tdgchart.util.partial = function(fn, args, context) {
        return function() {
            var arg = 0
              , localArgs = Array.prototype.slice.call(args);
            for (var i = 0; i < localArgs.length && arg < arguments.length; i++)
                if (localArgs[i] == null)
                    localArgs[i] = arguments[arg++];
            return fn.apply(context || this, localArgs)
        }
    }
    ;
    tdgchart.util.isAbsolutePath = function(path) {
        return path.indexOf("://") >= 0 || path.charAt(0) === "/"
    }
    ;
    tdgchart.util.makePathAbsolute = function(path) {
        if (!tdg.isAbsolutePath(path)) {
            var url = document.location.pathname;
            path = url.substr(0, url.lastIndexOf("/") + 1) + path
        }
        return path
    }
    ;
    tdgchart.util.replaceAll = function(list, search, replace) {
        if (replace == null || tdgchart.util.isEmpty(list))
            return list;
        if (typeof list === "string")
            return list.split(search).join(replace);
        return list
    }
    ;
    tdgchart.util.textContainsHTML = function(text) {
        text = text + "";
        var idx = text.indexOf("<");
        return text && idx >= 0 && text.indexOf(">") > idx + 1
    }
    ;
    tdgchart.util.measureLabelWidth = function() {
        function canvasLabelWidth(label, font) {
            if (typeof label !== "string")
                label = label + "";
            if (label === "")
                label = ".";
            if (tdg.textContainsHTML(label))
                return tdgchart.measureLabel(label, font).width;
            font = font || "10px sans-serif";
            if (typeof font === "function")
                font = font(label);
            var cache = tdgchart.util.measureLabelWidth.cache;
            if (cache[font] && cache[font][label])
                return cache[font][label];
            var ctx = tdgchart.util.measureLabelWidth.canvasCtx;
            try {
                ctx.font = font;
                var width = Math.ceil(ctx.measureText(label).width);
                cache[font] = cache[font] || {};
                cache[font][label] = width;
                return width
            } catch (e$2) {
                return tdgchart.measureLabel(label, font).width
            }
        }
        function noCanvasLabelWidth(label, font) {
            return tdgchart.measureLabel(label, font).width
        }
        if (typeof document !== "undefined") {
            var canvas = document.createElement("canvas");
            if (canvas && canvas.getContext) {
                var docFragment = document.createDocumentFragment();
                docFragment.appendChild(canvas);
                canvasLabelWidth.canvasCtx = canvas.getContext("2d");
                canvasLabelWidth.cache = {};
                return canvasLabelWidth
            }
        }
        return noCanvasLabelWidth
    }();
    tdgchart.util.measureFont = function(font) {
        font = font || "10px sans-serif";
        if (typeof font === "function")
            font = font("W");
        if (tdgchart._measureLabelCache.fontSize[font])
            return tdgchart._measureLabelCache.fontSize[font];
        if (tdgchart._cachedLabelDiv == null)
            tdgchart.initLabelDiv();
        tdgchart._cachedLabelDiv.singleLineDiv.style.font = font;
        tdgchart._cachedLabelDiv.singleLineDiv.firstChild.textContent = "W";
        var bbox = tdgchart._cachedLabelDiv.singleLineDiv.getBBox();
        var res = tdgchart._measureLabelCache.fontSize[font] = {
            width: Math.round(bbox.width),
            height: Math.round(bbox.height)
        };
        return res
    }
    ;
    tdgchart.util.getAnchoredLabelAligns = function(side, rotation) {
        rotation = tdgchart.util.boundAngle(rotation, "degrees");
        var refAngle = 0;
        if (rotation < 0 + 10)
            refAngle = 0;
        else if (rotation < 90 - 20)
            refAngle = 45;
        else if (rotation <= 90 + 20)
            refAngle = 90;
        else if (rotation < 180 - 10)
            refAngle = 135;
        else if (rotation <= 180 + 10)
            refAngle = 180;
        else if (rotation < 270 - 20)
            refAngle = 225;
        else if (rotation <= 270 + 20)
            refAngle = 270;
        else if (rotation < 360 - 10)
            refAngle = 315;
        else
            refAngle = 0;
        var res = {};
        var invTable = {
            "top": "bottom",
            "bottom": "top",
            "left": "right",
            "right": "left"
        };
        var invert = function(cfg) {
            cfg.align = invTable[cfg.align] || cfg.align;
            cfg.valign = invTable[cfg.valign] || cfg.valign;
            return cfg
        };
        if (side == "top" || side == "bottom") {
            switch (refAngle) {
            case 0:
                res = {
                    align: "middle",
                    valign: "bottom"
                };
                break;
            case 45:
                res = {
                    align: "left",
                    valign: "bottom"
                };
                break;
            case 90:
                res = {
                    align: "left",
                    valign: "middle"
                };
                break;
            case 135:
                res = {
                    align: "left",
                    valign: "top"
                };
                break;
            case 180:
                res = {
                    align: "middle",
                    valign: "top"
                };
                break;
            case 225:
                res = {
                    align: "right",
                    valign: "top"
                };
                break;
            case 270:
                res = {
                    align: "right",
                    valign: "middle"
                };
                break;
            case 315:
                res = {
                    align: "right",
                    valign: "bottom"
                };
                break
            }
            if (side == "bottom")
                res = invert(res)
        } else if (side == "left" || side == "right") {
            switch (refAngle) {
            case 0:
                res = {
                    align: "right",
                    valign: "middle"
                };
                break;
            case 45:
                res = {
                    align: "right",
                    valign: "bottom"
                };
                break;
            case 90:
                res = {
                    align: "middle",
                    valign: "bottom"
                };
                break;
            case 135:
                res = {
                    align: "left",
                    valign: "bottom"
                };
                break;
            case 180:
                res = {
                    align: "left",
                    valign: "middle"
                };
                break;
            case 225:
                res = {
                    align: "left",
                    valign: "top"
                };
                break;
            case 270:
                res = {
                    align: "middle",
                    valign: "top"
                };
                break;
            case 315:
                res = {
                    align: "right",
                    valign: "top"
                };
                break
            }
            if (side == "right")
                res = invert(res)
        }
        return res
    }
    ;
    tdgchart.util.prettyPrintXML = function(xml) {
        xml = (xml || "") + "";
        var i, sliceIdx = 0, quoteCount = 0, bracketCount = 0, lines = [];
        for (i = 0; i < xml.length; i++) {
            if (xml.charAt(i) === "<" && !quoteCount)
                bracketCount = 1;
            if (xml.charAt(i) === ">" && !quoteCount) {
                bracketCount = 0;
                lines.push(xml.substring(sliceIdx, i + 1).trim());
                sliceIdx = i + 1
            } else if (xml.charAt(i) === '"' && bracketCount)
                quoteCount = (quoteCount + 1) % 2
        }
        var res = ""
          , indent = 0
          , prevType = "other";
        var transitions = {
            single: {
                single: 0,
                close: -1,
                open: 0,
                other: 0
            },
            close: {
                single: 0,
                close: -1,
                open: 0,
                other: 0
            },
            open: {
                single: 1,
                close: 0,
                open: 1,
                other: 1
            },
            other: {
                single: 0,
                close: -1,
                open: 0,
                other: 0
            }
        };
        for (i = 0; i < lines.length; i++) {
            var type = "other"
              , line = lines[i];
            if (line.match(/^<.+\/>$/))
                type = "single";
            else if (line.match(/^[^<]*<\/.+>$/))
                type = "close";
            else if (line.match(/^<[^!].*>$/))
                type = "open";
            indent += transitions[prevType][type];
            if (prevType === "open" && type === "close")
                res = res.slice(0, -1) + line + "\n";
            else
                res += "\t".repeat(Math.max(indent, 0)) + line + "\n";
            prevType = type
        }
        return res
    }
    ;
    tdgchart.util.flattenNestedLabels = function(originalLabels, concatSymbol) {
        var labelList = [];
        originalLabels = originalLabels || [];
        concatSymbol = concatSymbol || " > ";
        function traverse(labels, currentLabel) {
            if (!Array.isArray(labels))
                labels = [labels || ""];
            if (labels[0] && typeof labels[0] === "object")
                for (var i = 0; i < labels.length; i++) {
                    var v = labels[i];
                    for (var key in v)
                        if (v.hasOwnProperty(key))
                            traverse(v[key], currentLabel ? currentLabel + concatSymbol + key : key)
                }
            else
                for (var j = 0; j < labels.length; j++)
                    labelList.push(currentLabel + concatSymbol + (labels[j] || ""))
        }
        traverse(originalLabels, "");
        return labelList
    }
    ;
    tdgchart.util.isNestedLabels = function(labels) {
        return Array.isArray(labels) && !Array.isArray(labels[0]) && typeof labels[0] === "object" && !(labels[0]instanceof String)
    }
    ;
    tdgchart.util.nestedArrayDepth = function(a) {
        var depth = 0;
        while (a && Array.isArray(a)) {
            a = a[0];
            depth += 1
        }
        return depth
    }
    ;
    tdgchart.util.isPercentString = function(v) {
        return typeof v === "string" && v.endsWith("%")
    }
    ;
    tdgchart.util.parsePercent = function(val, min, max) {
        min = min == null ? 0 : min;
        max = max == null ? 1 : max;
        return Math.max(Math.min(parseFloat(val) / 100, max), min)
    }
    ;
    tdgchart.util.applyNumOrPercent = function(numberOrPercent, relativeSize, min, max) {
        if (tdg.isPercentString(numberOrPercent))
            return tdg.parsePercent(numberOrPercent, min, max) * relativeSize;
        return numberOrPercent || 0
    }
    ;
    tdgchart.util.toNum = function(value, defaultValue) {
        if (typeof value === "string")
            return parseFloat(value);
        else if (typeof value === "number")
            return value;
        return defaultValue
    }
    ;
    tdgchart.util.bound = function(value, min, max) {
        if (Array.isArray(min) && max == null) {
            max = min[1];
            min = min[0]
        }
        return Math.min(Math.max(value, min), max)
    }
    ;
    tdgchart.util.eq = function(a, b, dt) {
        return Math.abs(a - (b || 0)) < (dt || 1E-5)
    }
    ;
    tdgchart.util.same = function(a, b) {
        if (typeof a !== typeof b)
            return false;
        else if (Array.isArray(a) && Array.isArray(b)) {
            if (a.length !== b.length)
                return false;
            for (var i = 0; i < a.length; i++) {
                var resA = tdgchart.util.same(a[i], b[i]);
                if (!resA)
                    return false
            }
            return true
        } else if (typeof a !== "object")
            return a === b;
        else {
            for (var k in a) {
                if (a.hasOwnProperty(k) && !b.hasOwnProperty(k))
                    return false;
                var resO = tdgchart.util.same(a[k], b[k]);
                if (!resO)
                    return false
            }
            return true
        }
    }
    ;
    tdgchart.util.boundAngle = function(a, angleType) {
        angleType = angleType || "radians";
        var incr = angleType === "degrees" ? 360 : Math.PI * 2;
        while (a < 0)
            a += incr;
        while (a >= incr)
            a -= incr;
        return a
    }
    ;
    tdgchart.util.transpose = function(arrays) {
        var res = [];
        var len = arrays.length;
        var m = tdg.max(arrays, "length");
        for (var i = 0; i < m; i++) {
            res.push([]);
            for (var j = 0; j < len; j++)
                res[i].push((arrays[j] || [])[i])
        }
        return res
    }
    ;
    tdgchart.util.reverse = function(a) {
        return [].concat(a).reverse()
    }
    ;
    tdgchart.util.formatString = function() {
        var args = Array.prototype.slice.call(arguments, 1);
        return arguments[0].replace(/\{(\d+)\}/g, function(match, number) {
            return args[number] == null ? match : args[number]
        })
    }
    ;
    tdgchart.util.logError = function() {
        if (window.console && typeof window.console.log === "function") {
            var args = arguments.length > 1 ? Array.prototype.join.call(arguments, " ") : arguments[0];
            window.console.log(args)
        }
    }
    ;
    function arrayLookup(array, f, i) {
        var key = array[i];
        if (key == null)
            return null;
        if (typeof f === "function")
            return {
                value: f(key),
                key: key,
                index: i
            };
        else if (typeof f === "string" && key != null) {
            if (f.includes("."))
                return {
                    value: tdg.get(f, key),
                    key: key,
                    index: i
                };
            return {
                value: key[f],
                key: key,
                index: i
            }
        }
        return {
            value: key,
            key: key,
            index: i
        }
    }
    tdgchart.util.sum = function(array, f) {
        if (!Array.isArray(array))
            return array;
        if (!array.length)
            return 0;
        var sum = 0;
        for (var i = 0; i < array.length; i++) {
            var tmp = arrayLookup(array, f, i);
            if (tmp)
                sum += tmp.value || 0
        }
        return sum
    }
    ;
    tdgchart.util.accumulate = function(array) {
        if (!Array.isArray(array) || !array.length)
            return array;
        var newArray = [];
        for (var i = 0; i < array.length; i++)
            newArray[i] = (newArray[i - 1] || 0) + array[i];
        return newArray
    }
    ;
    function _min(array, f, resultType, recurse) {
        if (!Array.isArray(array))
            return array;
        if (!array.length)
            return undefined;
        resultType = resultType || "value";
        var tmp, res, min = Infinity;
        for (var i = 0; i < array.length; i++) {
            if (recurse && Array.isArray(array[i]))
                tmp = _min(array[i], f, "all", true);
            else {
                tmp = arrayLookup(array, f, i);
                if (tmp)
                    tmp.value = tmp.value || 0
            }
            if (tmp && (tmp.value < min || tmp.value === Infinity && min === Infinity)) {
                min = tmp.value;
                res = tmp
            }
        }
        if (res == null)
            return undefined;
        return resultType === "all" ? res : res[resultType]
    }
    function _max(array, f, resultType, recurse) {
        if (!Array.isArray(array))
            return array;
        if (!array.length)
            return undefined;
        resultType = resultType || "value";
        var tmp, res, max = -Infinity;
        for (var i = 0; i < array.length; i++) {
            if (recurse && Array.isArray(array[i]))
                tmp = _max(array[i], f, "all", true);
            else {
                tmp = arrayLookup(array, f, i);
                if (tmp)
                    tmp.value = tmp.value || 0
            }
            if (tmp && (tmp.value > max || tmp.value === -Infinity && max === -Infinity)) {
                max = tmp.value;
                res = tmp
            }
        }
        if (res == null)
            return undefined;
        return resultType === "all" ? res : res[resultType]
    }
    tdgchart.util.min = function(array, f, resultType) {
        return _min(array, f, resultType, false)
    }
    ;
    tdgchart.util.minR = function(array, f, resultType) {
        return _min(array, f, resultType, true)
    }
    ;
    tdgchart.util.max = function(array, f, resultType) {
        return _max(array, f, resultType, false)
    }
    ;
    tdgchart.util.maxR = function(array, f, resultType) {
        return _max(array, f, resultType, true)
    }
    ;
    tdgchart.util.minMax = function(array, fmin, fmax, resultType) {
        return {
            min: _min(array, fmin, resultType, false),
            max: _max(array, fmax || fmin, resultType, false)
        }
    }
    ;
    tdgchart.util.minMaxR = function(array, fmin, fmax, resultType) {
        return {
            min: _min(array, fmin, resultType, true),
            max: _max(array, fmax || fmin, resultType, true)
        }
    }
    ;
    tdgchart.util.median = function(array, f, preSorted) {
        if (!Array.isArray(array) || !array.length)
            return NaN;
        var newArray = [];
        if (f)
            for (var i = 0; i < array.length; i++)
                newArray[i] = arrayLookup(array, f, i).value;
        else
            newArray = array;
        if (!preSorted)
            newArray = newArray.sort(function(a, b) {
                return a - b
            });
        if (newArray.length % 2 === 1)
            return newArray[(newArray.length - 1) / 2];
        var a = newArray[newArray.length / 2];
        var b = newArray[newArray.length / 2 - 1];
        return (a + b) / 2
    }
    ;
    tdgchart.util.mean = function(array, f) {
        if (!Array.isArray(array) || !array.length)
            return 0;
        var sum = 0
          , count = 0;
        for (var i = 0; i < array.length; i++) {
            var tmp = arrayLookup(array, f, i);
            if (tmp && tmp.value != null) {
                sum += tmp.value;
                count++
            }
        }
        return sum / count
    }
    ;
    tdgchart.util.variance = function(array, f) {
        if (array.length < 1)
            return NaN;
        if (array.length === 1)
            return 0;
        var mean = tdg.mean(array, f)
          , sum = 0;
        for (var i = 0; i < array.length; i++) {
            var tmp = arrayLookup(array, f, i);
            if (tmp) {
                var d = (tmp.value || 0) - mean;
                sum += d * d
            }
        }
        return sum
    }
    ;
    tdgchart.util.deviation = function(array, f) {
        return Math.sqrt(tdg.variance(array, f) / array.length)
    }
    ;
    tdgchart.util.map = function(array, f) {
        var i, l = array ? array.length : 0, res = [];
        if (typeof f === "string")
            for (i = 0; i < l; i++) {
                var v = array[i];
                if (v && typeof v[f] === "function")
                    res.push(v[f]());
                else if (v)
                    res.push(v[f]);
                else
                    res.push(v)
            }
        else if (typeof f === "function")
            for (i = 0; i < l; i++)
                res.push(f(array[i], i, array));
        return res
    }
    ;
    tdgchart.util.filter = function(array, f) {
        var i, l = array ? array.length : 0, res = [];
        if (typeof f === "string")
            for (i = 0; i < l; i++) {
                var v = array[i];
                if (v && !!v[f])
                    res.push(v)
            }
        else if (typeof f === "function")
            for (i = 0; i < l; i++)
                if (f(array[i], i, array))
                    res.push(array[i]);
        return res
    }
    ;
    tdgchart.util.repeat = function(v, n, noClone) {
        n = n || 0;
        var i, res = [];
        if (typeof v === "object" && !noClone)
            for (i = 0; i < n; i++)
                res.push(tdgchart.util.cloneObject(v));
        else
            for (i = 0; i < n; i++)
                res.push(v);
        return res
    }
    ;
    tdgchart.util.dict = function(array, f) {
        var res = {}
          , l = array ? array.length : 0;
        for (var i = 0; i < l; i++)
            if (i in array) {
                var k = array[i];
                res[k] = f(k, i)
            }
        return res
    }
    ;
    tdgchart.util.range = function(start, stop, step) {
        if (stop == null && step == null) {
            stop = start;
            start = 0
        }
        if (step == null)
            step = 1;
        if ((stop - start) / step === Infinity)
            return undefined;
        var array = [], i = 0, j;
        if (step < 0)
            while ((j = start + step * i++) > stop)
                array.push(j);
        else
            while ((j = start + step * i++) < stop)
                array.push(j);
        return array
    }
    ;
    tdgchart.util.rangeCount = function(start, stop, count) {
        var gap = (stop - start) / (count - 1);
        var stops = tdg.range(start, stop, gap);
        stops.push(stop);
        return stops
    }
    ;
    tdgchart.util.isANumber = function(a) {
        return a != null && !isNaN(a) && typeof a === "number"
    }
    ;
    tdgchart.util.xor = function(a, b) {
        return (a || b) && !(a && b)
    }
    ;
    var radianRatio = Math.PI / 180
      , degreeRatio = 180 / Math.PI;
    tdgchart.util.degrees = function(radians) {
        return degreeRatio * radians
    }
    ;
    tdgchart.util.radians = function(degrees) {
        return radianRatio * degrees
    }
    ;
    tdgchart.util.toPolar = function(x, y, config) {
        config = config || {};
        var r = Math.sqrt(x * x + y * y);
        var angle = Math.atan2(y, x);
        if (y < 0)
            angle += Math.PI * 2;
        if (config.clockwise)
            angle = 2 * Math.PI - angle;
        if (config.angleType === "degrees")
            angle = tdgchart.util.degrees(angle);
        if (config.base)
            angle += config.clockwise ? config.base : -config.base;
        angle = tdgchart.util.boundAngle(angle, config.angleType);
        return {
            angle: angle,
            r: r
        }
    }
    ;
    tdgchart.util.scaleFontToBox = function(text, font, maxSize) {
        var fontParts = tdg.fontToFontParts(font);
        fontParts.fontSize = "10px";
        var textSize = tdgchart.measureLabel(text, fontParts.toString());
        var size = Math.max(textSize.width, textSize.height);
        var fontSize = 10 / size * maxSize;
        fontParts.fontSize = fontSize.toFixed(3) + "px";
        return fontParts.toString()
    }
    ;
    var boldList = ["bold", "bolder", "lighter", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
    var sizeList = ["medium", "xx-small", "x-small", "small", "large", "x-large", "xx-large", "smaller", "larger"];
    var stretchList = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"];
    tdgchart.util.fontToFontParts = tdgchart.util.memoize("fontToFontParts", true, function(font) {
        var fullFontParts = {
            fontStyle: "",
            fontVariant: "",
            fontWeight: "",
            fontStretch: "",
            fontSize: "",
            fontFamily: ""
        };
        var haveFontSize = false;
        font = (font || "") + "";
        var fontParts = font.split(/ (?=(?:[^'"]|'[^']*'|"[^"]*")*$)/);
        for (var i = 0; i < fontParts.length; i++) {
            var el = fontParts[i]
              , elLower = el.toLowerCase();
            if (elLower === "italic" || elLower === "oblique")
                fullFontParts.fontStyle = elLower;
            else if (elLower === "small-caps")
                fullFontParts.fontVariant = elLower;
            else if (boldList.includes(elLower))
                fullFontParts.fontWeight = elLower;
            else if (stretchList.includes(elLower))
                fullFontParts.fontStretch = elLower;
            else if (sizeList.includes(elLower)) {
                fullFontParts.fontSize = elLower;
                haveFontSize = true
            } else if (el)
                if (!haveFontSize) {
                    fullFontParts.fontSize = el;
                    haveFontSize = true
                } else
                    fullFontParts.fontFamily = el
        }
        fullFontParts.toString = function() {
            var family = this.fontFamily.trim();
            if (family.indexOf(" ") >= 0 && family[0] !== '"' && family[0] !== "'")
                family = '"' + family + '"';
            return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, family].join(" ").trim()
        }
        ;
        fullFontParts.toKebabCase = function() {
            var res = {};
            for (var k in this)
                if (this.hasOwnProperty(k) && this[k] && k.startsWith("font")) {
                    var kebab = k.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
                    res[kebab] = this[k]
                }
            return res
        }
        ;
        return fullFontParts
    });
    tdgchart.util.getScaleTicks = function(config) {
        var min = config.min || 0
          , max = config.max || 0;
        var fakeChart = {};
        var fakeSize = {
            width: 1E4,
            height: 1E4
        };
        var fakeAxis = {
            side: "bottom",
            name: "none",
            properties: {
                labels: {}
            }
        };
        var scale = tdgchart.prototype.getNumericScale.call(fakeChart, fakeSize, fakeAxis, {
            min: min,
            max: max
        });
        if (config.asSpan && scale.grid.length > 1)
            return scale.grid[1] - scale.grid[0];
        return scale.grid
    }
    ;
    tdgchart.util.geom = {};
    tdgchart.util.geom.quadrant = function(angle) {
        var pi = Math.PI;
        while (angle > 2 * pi)
            angle -= 2 * pi;
        while (angle < 0)
            angle += 2 * pi;
        if (angle < pi / 2)
            return 1;
        else if (angle >= pi / 2 && angle < pi)
            return 2;
        else if (angle >= pi && angle < 3 * pi / 2)
            return 3;
        return 4
    }
    ;
    tdgchart.util.geom.equal = function(s1, s2) {
        if (!isRect(s1) || !isRect(s2))
            return tdg.eq(s1.x, s2.x) && tdg.eq(s1.y, s2.y);
        s1 = tdg.geom.normalizeRect(s1);
        s2 = tdg.geom.normalizeRect(s2);
        return tdg.eq(s1.left, s2.left) && tdg.eq(s1.right, s2.right) && tdg.eq(s1.top, s2.top) && tdg.eq(s1.bottom, s2.bottom)
    }
    ;
    tdgchart.util.geom.ptInBox = function(pt, b1, b2) {
        return pt.x >= Math.min(b1.x, b2.x) && pt.x <= Math.max(b1.x, b2.x) && pt.y >= Math.min(b1.y, b2.y) && pt.y <= Math.max(b1.y, b2.y)
    }
    ;
    function ptRectIntersect(pt, rect) {
        rect = tdg.geom.normalizeRect(rect);
        return pt.x > rect.left && pt.x <= rect.right && pt.y > rect.top && pt.y <= rect.bottom
    }
    function rectIntersect(r1, r2) {
        r1 = tdg.geom.normalizeRect(r1);
        r2 = tdg.geom.normalizeRect(r2);
        return r1.left < r2.right && r2.left < r1.right && r1.top < r2.bottom && r2.top < r1.bottom
    }
    tdgchart.util.geom.intersect = function(s1, s2) {
        if (isRect(s1) && isRect(s2))
            return rectIntersect(s1, s2);
        else if (!isRect(s1) && !isRect(s2))
            return tdg.geom.equal(s1, s2);
        else if (isRect(s1))
            return ptRectIntersect(s2, s1);
        else if (isRect(s2))
            return ptRectIntersect(s1, s2);
        return null
    }
    ;
    tdgchart.util.geom.segmentsIntersects = function(s, r) {
        var triangles = [[s[0], s[1], r[0]], [s[0], s[1], r[1]], [r[0], r[1], s[0]], [r[0], r[1], s[1]]];
        var clockwise = triangles.map(polygonOrientation);
        if (clockwise[0] == 0 && clockwise[1] == 0)
            return colinearIntersectsSegment(s[0], r) || colinearIntersectsSegment(s[1], r) || colinearIntersectsSegment(r[0], s);
        return clockwise[0] != clockwise[1] && clockwise[2] != clockwise[3]
    }
    ;
    function colinearIntersectsSegment(pt, seg) {
        return pt.x >= seg[0].x && pt.x <= seg[0].x || pt.x >= seg[1].x && pt.x <= seg[1].x && (pt.y >= seg[0].y && pt.y <= seg[0].y) || pt.y >= seg[1].y && pt.y <= seg[1].y
    }
    tdgchart.util.geom.polygonArea = function(pts, oriented) {
        var sum = 0;
        for (var i = 0; i < pts.length; i++) {
            var j = (i + 1) % pts.length;
            sum += pts[i].x * pts[j].y - pts[j].x * pts[i].y
        }
        sum *= .5;
        return oriented ? -sum : Math.abs(sum)
    }
    ;
    function polygonOrientation(pts) {
        var area = tdg.geom.polygonArea(pts, true);
        return tdg.eq(area, 0) ? 0 : area < 0 ? -1 : 1
    }
    tdgchart.util.geom.union = function() {
        var res = {
            left: Infinity,
            right: -Infinity,
            top: Infinity,
            bottom: -Infinity
        };
        for (var i = 0; i < arguments.length; i++) {
            var s = tdg.geom.normalizeRect(arguments[i]);
            res = {
                left: Math.min(res.left, s.left),
                right: Math.max(res.right, s.right),
                top: Math.min(res.top, s.top),
                bottom: Math.max(res.bottom, s.bottom)
            }
        }
        return tdg.geom.normalizeRect(res)
    }
    ;
    tdgchart.util.geom.rectCenter = function(rect) {
        rect = tdg.geom.normalizeRect(rect);
        return {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
        }
    }
    ;
    tdgchart.util.geom.distance = function(s1, s2) {
        s1 = isRect(s1) ? tdg.geom.rectCenter(s1) : s1;
        s2 = isRect(s2) ? tdg.geom.rectCenter(s2) : s2;
        return Math.sqrt(Math.pow(s1.x - s2.x, 2) + Math.pow(s1.y - s2.y, 2))
    }
    ;
    tdgchart.util.geom.normalizeRect = function(s) {
        if (!isRect(s))
            return {
                left: s.x,
                x: s.x,
                right: s.x,
                top: s.y,
                y: s.y,
                bottom: s.y,
                width: 0,
                height: 0
            };
        var left = s.left != null ? s.left : s.x || 0;
        var top = s.top != null ? s.top : s.y || 0;
        var right = s.right != null ? s.right : left + s.width || 0;
        var bottom = s.bottom != null ? s.bottom : top + s.height || 0;
        return {
            left: left,
            top: top,
            right: right,
            bottom: bottom,
            x: left,
            y: top,
            width: right - left,
            height: bottom - top
        }
    }
    ;
    tdgchart.util.geom.isValidRect = function(rect) {
        rect = tdg.geom.normalizeRect(rect);
        return tdg.isANumber(rect.top) && tdg.isANumber(rect.y) && tdg.isANumber(rect.right) && tdg.isANumber(rect.bottom) && tdg.isANumber(rect.left) && tdg.isANumber(rect.x) && rect.width > 0 && rect.height > 0
    }
    ;
    tdgchart.util.geom.grow = function(rect, grow) {
        rect = tdg.geom.normalizeRect(rect);
        grow /= 2;
        return {
            width: grow + rect.width + grow,
            height: grow + rect.height + grow,
            top: rect.top - grow,
            y: rect.y - grow,
            right: rect.right + grow,
            bottom: rect.bottom + grow,
            left: rect.left - grow,
            x: rect.x - grow
        }
    }
    ;
    tdgchart.util.geom.shapeToString = function(s) {
        if (isRect(s)) {
            s = tdg.geom.normalizeRect(s);
            return tdg.formatString("x: {0}, y: {1}, w: {2}, h: {3}", s.left, s.top, s.width, s.height)
        }
        return tdg.formatString("x: {0}, y: {1}", s.x, s.y)
    }
    ;
    function isRect(s) {
        return s.width != null || s.right != null
    }
    tdgchart.util.transform = {};
    tdgchart.util.transform.setXY = function(transform, newX, newY) {
        if (transform instanceof Element && typeof transform.getAttribute === "function")
            transform = transform.getAttribute("transform");
        transform = tdgchart.translateStrToObject(transform);
        newX = newX == null ? transform.x : newX;
        newY = newY == null ? transform.y : newY;
        return "translate(" + newX + "," + newY + (transform.remainder ? "," + transform.remainder : "") + ")"
    }
    ;
    tdgchart.util.transform.appendXY = function(transform, dx, dy) {
        if (transform instanceof Element && typeof transform.getAttribute === "function")
            transform = transform.getAttribute("transform");
        var newTransform = "translate(" + (dx || 0) + "," + (dy || 0) + ")";
        return transform ? transform + ", " + newTransform : newTransform
    }
    ;
    tdgchart.util.dom = {};
    function ensureVisible(node, fn) {
        var res, dsp = node.getAttribute("display");
        if (dsp === "none" || dsp == null)
            node.setAttribute("display", "inline");
        try {
            res = node[fn]()
        } catch (e$3) {
            res = null
        } finally {
            if (dsp === "none")
                node.setAttribute("display", "none");
            else if (dsp == null)
                node.removeAttribute("display")
        }
        return res
    }
    tdgchart.util.dom.bbox = function(node) {
        var res = ensureVisible(node, "getBBox");
        return res == null ? {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        } : res
    }
    ;
    tdgchart.util.dom.ctm = function(node) {
        var res = ensureVisible(node, "getCTM");
        return res == null ? {
            e: 0,
            f: 0
        } : res
    }
    ;
    tdgchart.util.dom.empty = function(node) {
        while (node && node.firstChild)
            node.removeChild(node.firstChild)
    }
    ;
    tdgchart.util.dom.insertIFrame = function(parent, content, w, h) {
        var iframe = document.createElement("iframe");
        iframe.setAttribute("width", w);
        iframe.setAttribute("height", h);
        iframe.setAttribute("style", "border: 0px");
        parent.appendChild(iframe);
        var doc = iframe.contentWindow.document;
        doc.open();
        doc.write(content);
        doc.close();
        return iframe
    }
    ;
    tdgchart.util.dom.ancestor = function(a, e) {
        while (e) {
            if (e === a)
                return true;
            e = e.parentNode
        }
        return false
    }
    ;
    tdgchart.util.dom.walk = function(node, preFn, postFn) {
        if (preFn)
            preFn(node);
        node = node ? node.firstChild : null;
        while (node) {
            tdgchart.util.dom.walk(node, preFn, postFn);
            node = node.nextSibling
        }
        if (postFn)
            postFn(node)
    }
    ;
    tdgchart.util.traceDebug = function traceDebug(traceLine) {
        return traceit("DEBUG", "Moonbeam", traceLine)
    }
    ;
    tdgchart.util.traceInfo = function traceInfo(traceLine) {
        return traceit("INFO", "Moonbeam", traceLine)
    }
    ;
    tdgchart.util.traceWarn = function traceWarn(traceLine) {
        return traceit("WARN", "Moonbeam", traceLine)
    }
    ;
    tdgchart.util.getQueryParam = function getQueryParam(key, defaultValue, type) {
        var params;
        if (!type) {
            if (document && document.location && document.location.hash.length > 1)
                type = "hash";
            if (document && document.location && document.location.search.length > 1)
                type = "search"
        }
        if (type == "search")
            params = document && document.location && document.location.search.slice(1).split("&");
        else if (type == "hash")
            params = document && document.location && document.location.hash.slice(1).split("#");
        else if (typeof type == "string")
            params = type.split("&");
        else if (Array.isArray(type))
            params = type;
        if (!params)
            return defaultValue;
        for (var i = 0; i < params.length; i++) {
            var p = params[i].split("=");
            if (p[0] == key) {
                var val = p[1];
                if (val === undefined)
                    return defaultValue != undefined ? defaultValue : true;
                if (!isNaN(val) && !isNaN(parseFloat(val)))
                    return parseFloat(val);
                return p[1]
            }
        }
        return defaultValue
    }
    ;
    tdgchart.util.traceError = function traceError(traceLine) {
        return traceit("ERROR", "Moonbeam", traceLine)
    }
    ;
    tdgchart.util.arrayFlat = function(arr) {
        if (Array.prototype.flat)
            return arr.flat();
        else
            return arr.reduce(function(acc, val) {
                return Array.isArray(val) ? acc.concat(tdgchart.util.arrayFlat(val)) : acc.concat(val)
            }, [])
    }
    ;
    function traceit(traceLevel, traceArea, traceLine) {
        if (!window.ibiLog || !window.ibiLog.url || !window.ibiLog.urlId || !window.ibiLog.monId || !window.ibiLog.timeout || window.ibiLog.timeout < stop)
            return;
        if (!isLogLevel(traceLevel))
            return;
        var url = window.ibiLog.url + "?" + "IBIMON_area=" + traceArea + "&" + "IBIMON_level=" + traceLevel + "&" + "IBIMON_monId=" + window.ibiLog.monId + "&" + "IBIMON_urlId=" + window.ibiLog.urlId + "&" + "IBIMON_trace=" + traceLine;
        var req = new XMLHttpRequest;
        req.open("POST", url, true);
        req.send(null)
    }
    function isLogLevel(traceLevel) {
        var levels = [];
        levels.push(levels.FATAL = "FATAL");
        levels.push(levels.ERROR = ["ERROR", levels.FATAL]);
        levels.push(levels.WARN = ["WARN", levels.ERROR]);
        levels.push(levels.INFO = ["INFO", levels.WARN]);
        levels.push(levels.DEBUG = ["DEBUG", levels.INFO]);
        levels.push(levels.TRACE = ["TRACE", levels.DEBUG]);
        var acceptedLevel = [];
        function translateLogLevel(obj) {
            if (obj instanceof Array) {
                acceptedLevel.push(obj[0]);
                translateLogLevel(obj[1])
            } else if (typeof obj === "string" || obj instanceof String)
                acceptedLevel.push(obj)
        }
        var ibiLevel = window.ibiLog.level;
        levels[ibiLevel].forEach(function(lvl) {
            translateLogLevel(lvl)
        });
        return acceptedLevel.includes(traceLevel)
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.util.color = function(c) {
        return parseColor(c)
    }
    ;
    tdgchart.util.color.isVisible = function(c) {
        if (tdg.isEmpty(c))
            return false;
        c = parseColor(c);
        return c ? c.isVisible() : false
    }
    ;
    tdgchart.util.color.isLineVisible = function(props) {
        if (tdg.isEmpty(props))
            return false;
        return props.width > 0 && tdg.color.isVisible(props.color)
    }
    ;
    tdgchart.util.color.isRectVisible = function(r) {
        r = r || {};
        return tdg.color.isVisible(r.fill) || tdg.color.isVisible(r.color) || tdg.color.isLineVisible(r.border)
    }
    ;
    tdgchart.util.color.isGradient = function(c) {
        c = parseColor(c);
        return c.isComplexFill && (c instanceof LinearGradient || c instanceof RadialGradient)
    }
    ;
    tdgchart.util.color.isOpaque = function(c) {
        c = parseColor(c);
        return c.a === 1 || c.a == null
    }
    ;
    tdgchart.util.color.toColor = function(c) {
        var newC = parseColor(c);
        return newC.isComplexFill ? newC.rgb() : c
    }
    ;
    tdgchart.util.color.toColorString = function(c) {
        var newC = parseColor(c);
        return newC.isComplexFill ? newC.rgb().toString() : c
    }
    ;
    function isFillObject(o) {
        return typeof o === "object" && typeof o.type === "string" && ["linear", "radial", "pattern"].includes(o.type.toLowerCase())
    }
    function parseColorChannel(c) {
        var f = parseFloat(c);
        return c.endsWith("%") ? Math.round(f * 2.55) : f
    }
    tdgchart.__colorCache = {};
    function parseColor(format) {
        if (tdg.isEmpty(format))
            return new RGBColor(0,0,0,1);
        else if (format === "transparent")
            return new RGBColor(0,0,0,0);
        else if (isFillObject(format))
            return parseFill(format);
        else if (format instanceof Color || format instanceof LinearGradient || format instanceof RadialGradient || format instanceof Pattern)
            return format;
        format = (format + "").toLowerCase();
        var cacheLookup = tdgchart.__colorCache[format];
        if (cacheLookup)
            return tdg.color[cacheLookup[0]].apply({}, cacheLookup[1]);
        var r, g, b;
        var m1 = format.match(/([a-z]+)\((.*)\)/i);
        if (m1) {
            var m2 = m1[2].split(",")
              , a = 1;
            if (m1[1] === "rgba" || m1[1] === "hsla") {
                a = parseFloat(m2[3]);
                if (!a)
                    return new RGBColor(0,0,0,0)
            }
            if (m1[1].startsWith("hsl")) {
                var h = parseFloat(m2[0])
                  , s = parseFloat(m2[1]) / 100
                  , l = parseFloat(m2[2]) / 100;
                tdgchart.__colorCache[format] = ["HSLColor", [h, s, l, a]];
                return new HSLColor(h,s,l,a)
            } else if (m1[1].startsWith("rgb")) {
                r = parseColorChannel(m2[0]);
                g = parseColorChannel(m2[1]);
                b = parseColorChannel(m2[2]);
                tdgchart.__colorCache[format] = ["RGBColor", [r, g, b, a]];
                return new RGBColor(r,g,b,a)
            }
        }
        var newFormat = format;
        var named = tdg.color.names[format];
        if (named)
            newFormat = named;
        if (newFormat.startsWith("#")) {
            if (newFormat.length === 4) {
                r = newFormat.charAt(1);
                r += r;
                g = newFormat.charAt(2);
                g += g;
                b = newFormat.charAt(3);
                b += b
            } else if (newFormat.length === 7) {
                r = newFormat.substring(1, 3);
                g = newFormat.substring(3, 5);
                b = newFormat.substring(5, 7)
            }
            var args = [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1];
            tdgchart.__colorCache[format] = ["RGBColor", args];
            return RGBColor.apply({}, args)
        }
        if (newFormat.includes("gradient") && !newFormat.includes("url"))
            return parseFill(newFormat);
        var c = new RGBColor(0,0,0);
        c.isInvalid = true;
        return c
    }
    function parseFill(format) {
        function makeStop(offset, color_format) {
            var c = tdgchart.util.color(color_format);
            return [offset, c.toOpaqueColorString(), c.a]
        }
        function makeStopArray(stops) {
            var res = [];
            stops = ((stops || "") + "").split(/,(?=[^)]*(?:\(|$))/);
            for (var i = 0; i < stops.length; i++) {
                var match = (stops[i] || "").match(/^\s*(\S+)\s*(.*)$/);
                if (match && match.length > 2)
                    res.push(makeStop(match[1], match[2]))
            }
            return res
        }
        if (format instanceof tdgchart.util.color.Color)
            return format;
        var stops = [];
        var types = ["linear", "radial", "pattern"];
        if (typeof format === "object" && format.hasOwnProperty("type") && types.includes(format.type)) {
            if (format.type === "pattern")
                return new Pattern(format);
            var x1 = format.start ? format.start.x + "" : 0;
            var y1 = format.start ? format.start.y + "" : 0;
            var oldStops = format.stops || [];
            oldStops.map(function(el) {
                if (Array.isArray(el))
                    stops.push(makeStop(el[0], el[1]));
                else
                    stops.push(makeStop(el.offset, el.color))
            });
            switch (format.type) {
            case "linear":
                var x2 = format.end ? format.end.x + "" : 0;
                var y2 = format.end ? format.end.y + "" : 0;
                return new LinearGradient(x1,y1,x2,y2,stops,format.angle,format.gradientUnits);
            case "radial":
                var fx, fy, r = format.radius + "";
                if (format.focalPoint) {
                    fx = format.focalPoint.x + "";
                    fy = format.focalPoint.y + ""
                }
                return new RadialGradient(x1,y1,r,stops,fx,fy,format.gradientUnits)
            }
        }
        if (format.type)
            return format;
        var m2, m1 = format.match(/^([a-z-]+)\((.*)\)$/i);
        if (m1)
            switch (m1[1].toLowerCase()) {
            case "solid":
                return parseColor(m1[2]);
            case "linear-gradient":
                m2 = /^\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(.*)$/i.exec(m1[2]) || [0, 0, 0, 0, 0];
                stops = makeStopArray(m2[5]);
                return new LinearGradient(m2[1],m2[2],m2[3],m2[4],stops);
            case "radial-gradient":
                m2 = /^\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(.*)$/i.exec(m1[2]) || [0, 0, 0, 0, 0];
                stops = makeStopArray(m2[4]);
                return new RadialGradient(m2[1],m2[2],m2[3],stops)
            }
        return parseColor(format).rgb()
    }
    var Color = function() {
        this.isComplexFill = false
    };
    Color.prototype.isVisible = function() {
        return this.a == null || this.a > 0
    }
    ;
    Color.prototype.brighter = function(k) {
        var c = this.rgb();
        k = Math.pow(.7, arguments.length ? k : 1);
        var r = c.r
          , g = c.g
          , b = c.b
          , i = 30;
        if (!r && !g && !b)
            return new RGBColor(i,i,i,c.a);
        r = r && r < i ? i : r;
        g = g && g < i ? i : g;
        b = b && b < i ? i : b;
        return new RGBColor(Math.min(255, Math.floor(r / k)),Math.min(255, Math.floor(g / k)),Math.min(255, Math.floor(b / k)),c.a)
    }
    ;
    Color.prototype.darker = function(k) {
        var c = this.rgb();
        k = Math.pow(.7, arguments.length ? k : 1);
        return new RGBColor(Math.max(0, Math.floor(k * c.r)),Math.max(0, Math.floor(k * c.g)),Math.max(0, Math.floor(k * c.b)),c.a)
    }
    ;
    Color.prototype.lighter = function(k) {
        var c = this.rgb();
        var r = c.r
          , g = c.g
          , b = c.b;
        k = 255 * tdg.bound(k, -1, 1);
        return new RGBColor(tdg.bound(Math.floor(r + k), 0, 255),tdg.bound(Math.floor(g + k), 0, 255),tdg.bound(Math.floor(b + k), 0, 255),c.a)
    }
    ;
    function cToH(c) {
        var hex = c.toString(16);
        return hex.length === 1 ? "0" + hex : hex
    }
    Color.prototype.toHex = function() {
        var c = this.rgb();
        return "#" + cToH(c.r) + cToH(c.g) + cToH(c.b)
    }
    ;
    Color.prototype.toGreyScale = function() {
        var c = this.rgb();
        var avg = Math.round((c.r + c.g + c.b) / 3);
        return new RGBColor(avg,avg,avg,c.a)
    }
    ;
    Color.prototype.luma = function() {
        var c = this.rgb();
        return .2126 * Math.pow(c.r / 255, 2.2) + .7151 * Math.pow(c.g / 255, 2.2) + .0721 * Math.pow(c.b / 255, 2.2)
    }
    ;
    Color.prototype.toOpaqueColorString = function() {
        return this.alpha(null).toString()
    }
    ;
    var RGBColor = function(r, g, b, a) {
        if (this instanceof RGBColor) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
            this.opacity = a;
            if (!tdg.isANumber(this.r) || !tdg.isANumber(this.g) || !tdg.isANumber(this.b))
                this.color = "none";
            else
                this.color = this.a == null ? this.toString() : this.a === 0 ? "none" : this.alpha(null).toString();
            return this
        }
        return new RGBColor(r,g,b,a)
    };
    RGBColor.prototype = new Color;
    RGBColor.prototype.toString = function() {
        if (this.a != null && this.a < 1)
            return "rgba(" + this.r + "," + this.g + "," + this.b + "," + this.a + ")";
        return "rgb(" + this.r + "," + this.g + "," + this.b + ")"
    }
    ;
    RGBColor.prototype.alpha = function(a) {
        return new RGBColor(this.r,this.g,this.b,a)
    }
    ;
    RGBColor.prototype.rgb = function() {
        return this
    }
    ;
    RGBColor.prototype.hsl = function() {
        var r = this.r
          , g = this.g
          , b = this.b;
        var min = Math.min(r /= 255, g /= 255, b /= 255);
        var max = Math.max(r, g, b);
        var d = max - min;
        var h, s, l = (max + min) / 2;
        if (d) {
            s = l < .5 ? d / (max + min) : d / (2 - max - min);
            if (r === max)
                h = (g - b) / d + (g < b ? 6 : 0);
            else if (g === max)
                h = (b - r) / d + 2;
            else
                h = (r - g) / d + 4;
            h *= 60
        } else
            s = h = 0;
        return new HSLColor(h,s,l,this.a)
    }
    ;
    var HSLColor = function(h, s, l, a) {
        if (this instanceof HSLColor) {
            this.h = h;
            this.s = s;
            this.l = l;
            this.a = a;
            this.opacity = a;
            this.color = this.a == null ? this.toString() : this.a === 0 ? "none" : this.alpha(null).toString();
            return this
        }
        return new HSLColor(h,s,l,a)
    };
    HSLColor.prototype = new Color;
    HSLColor.prototype.toString = function() {
        if (this.a != null && this.a < 1)
            return "hsla(" + this.h + "," + this.s * 100 + "%," + this.l * 100 + "%," + this.a + ")";
        return "hsl(" + this.h + "," + this.s * 100 + "%," + this.l * 100 + "%)"
    }
    ;
    HSLColor.prototype.alpha = function(a) {
        return new HSLColor(this.h,this.s,this.l,a)
    }
    ;
    HSLColor.prototype.hsl = function() {
        return this
    }
    ;
    HSLColor.prototype.rgb = function() {
        var h = this.h
          , s = this.s
          , l = this.l;
        h = h % 360;
        if (h < 0)
            h += 360;
        s = Math.max(0, Math.min(s, 1));
        l = Math.max(0, Math.min(l, 1));
        var m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
        var m1 = 2 * l - m2;
        function v(h) {
            if (h > 360)
                h -= 360;
            else if (h < 0)
                h += 360;
            if (h < 60)
                return m1 + (m2 - m1) * h / 60;
            if (h < 180)
                return m2;
            if (h < 240)
                return m1 + (m2 - m1) * (240 - h) / 60;
            return m1
        }
        function vv(h) {
            return Math.round(v(h) * 255)
        }
        return new RGBColor(vv(h + 120),vv(h),vv(h - 120),this.a)
    }
    ;
    var Gradient = function() {
        this.isComplexFill = true;
        this.opacity = this.a = 1;
        this.color = "url(#tbd)"
    };
    Gradient.prototype = new Color;
    Gradient.prototype.darker = function() {
        return this
    }
    ;
    Gradient.prototype.lighter = function() {
        return this
    }
    ;
    Gradient.prototype.rgb = function() {
        return parseColor((this.stops[0] || [0, "black"])[1] || "black")
    }
    ;
    Gradient.prototype.hsl = function() {
        return parseColor((this.stops[0] || [0, "black"])[1] || "black").hsl()
    }
    ;
    Gradient.prototype.isVisible = function() {
        return true
    }
    ;
    Gradient.prototype.alpha = function(a) {
        this.stops.forEach(function(el) {
            el[2] = a
        });
        return this
    }
    ;
    var LinearGradient = function(x1, y1, x2, y2, stops, angle, units) {
        this.type = "lineargradient";
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        this.stops = stops;
        this.angle = angle;
        this.gradientUnits = units
    };
    LinearGradient.prototype = new Gradient;
    var RadialGradient = function(cx, cy, r, stops, fx, fy, units) {
        this.type = "radialgradient";
        this.cx = cx;
        this.cy = cy;
        if (fx != null && fy != null) {
            this.fx = fx;
            this.fy = fy
        }
        this.r = r;
        this.stops = stops;
        this.gradientUnits = units
    };
    RadialGradient.prototype = new Gradient;
    var Pattern = function(obj) {
        this.type = "pattern";
        this.isComplexFill = true;
        this.opacity = this.a = 1;
        this.foregroundColor = obj.color;
        this.backgroundColor = obj.backgroundColor;
        this.lineWidth = obj.lineWidth == null ? 1 : obj.lineWidth;
        this.antialias = obj.antialias;
        this.shape = obj.shape;
        this.size = obj.size;
        this.pad = obj.pad;
        this.darker = function() {
            return this
        }
        ;
        this.lighter = function() {
            return this
        }
        ;
        this.rgb = function() {
            return parseColor(this.foregroundColor)
        }
        ;
        this.hsl = function() {
            return parseColor(this.foregroundColor).hsl()
        }
        ;
        this.alpha = function() {
            return this
        }
        ;
        this.isVisible = function() {
            return true
        }
    };
    tdgchart.util.color.Color = Color;
    tdgchart.util.color.RGBColor = RGBColor;
    tdgchart.util.color.HSLColor = HSLColor;
    tdgchart.util.color.LinearGradient = LinearGradient;
    tdgchart.util.color.RadialGradient = RadialGradient;
    tdgchart.util.color.Pattern = Pattern;
    tdgchart.util.color.transparent = new RGBColor(0,0,0,0);
    tdgchart.util.color.palettes = {
        category10: ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"],
        category19: ["#9c9ede", "#7375b5", "#4a5584", "#cedb9c", "#b5cf6b", "#8ca252", "#637939", "#e7cb94", "#e7ba52", "#bd9e39", "#8c6d31", "#e7969c", "#d6616b", "#ad494a", "#843c39", "#de9ed6", "#ce6dbd", "#a55194", "#7b4173"],
        category20: ["#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5"]
    };
    tdgchart.util.color.names = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavender: "#e6e6fa",
        lavenderblush: "#fff0f5",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32",
        transparent: "rgba(0,0,0,0)"
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.util.tree = function(data) {
        function recurse(map) {
            var n = new TreeNode;
            for (var k in map) {
                if (!map.hasOwnProperty(k))
                    continue;
                var v = map[k];
                var isLeaf = Array.isArray(v) || typeof v !== "object";
                n.appendChild(isLeaf ? new TreeNode(v) : recurse(v)).nodeName = k
            }
            return n
        }
        if (Array.isArray(data))
            return arrayToTree(data);
        else if (data instanceof TreeNode)
            return data;
        return recurse(data)
    }
    ;
    function findNode(node, nodeName) {
        if (node && node.nodeName === nodeName)
            return node;
        for (var c = node.firstChild; c; c = c.nextSibling) {
            var res = findNode(c, nodeName);
            if (res)
                return res
        }
        return null
    }
    function arrayToTree(data) {
        var lastNode, root = new TreeNode;
        for (var i = 0; i < data.length; i++) {
            var d = data[i];
            if (!d || !Array.isArray(d))
                continue;
            var parentName = d[1];
            var node = new TreeNode(d[2],d[0]);
            if (parentName == null)
                root.appendChild(node);
            else {
                var tmp = lastNode;
                while (tmp && tmp.nodeName !== parentName)
                    tmp = tmp.parentNode;
                var parent = tmp || findNode(root, parentName) || root;
                parent.appendChild(node)
            }
            lastNode = node
        }
        return root
    }
    var TreeNode = function(value, name) {
        this.nodeValue = value;
        this.nodeName = name;
        this.childNodes = [];
        this.parentNode = null;
        this.firstChild = this.lastChild = null;
        this.previousSibling = this.nextSibling = null
    };
    TreeNode.prototype.getChild = function(s) {
        for (var i = 0; i < this.childNodes.length; i++)
            if (this.childNodes[i].nodeName === s)
                return this.childNodes[i];
        return null
    }
    ;
    TreeNode.prototype.appendChild = function(n) {
        if (n.parentNode)
            n.parentNode.removeChild(n);
        n.parentNode = this;
        n.previousSibling = this.lastChild;
        if (this.lastChild)
            this.lastChild.nextSibling = n;
        else
            this.firstChild = n;
        this.lastChild = n;
        this.childNodes.push(n);
        return n
    }
    ;
    TreeNode.prototype.removeChild = function(n) {
        var i = this.childNodes.indexOf(n);
        if (i < 0)
            return null;
        this.childNodes.splice(i, 1);
        if (n.previousSibling)
            n.previousSibling.nextSibling = n.nextSibling;
        else
            this.firstChild = n.nextSibling;
        if (n.nextSibling)
            n.nextSibling.previousSibling = n.previousSibling;
        else
            this.lastChild = n.previousSibling;
        n.nextSibling = n.previousSibling = n.parentNode = null;
        return n
    }
    ;
    TreeNode.prototype.visitBefore = function(f) {
        function visit(n, i) {
            f(n, i);
            for (var c = n.firstChild; c; c = c.nextSibling)
                visit(c, i + 1)
        }
        visit(this, 0)
    }
    ;
    TreeNode.prototype.visitAfter = function(f) {
        function visit(n, i) {
            for (var c = n.firstChild; c; c = c.nextSibling)
                visit(c, i + 1);
            f(n, i)
        }
        visit(this, 0)
    }
    ;
    TreeNode.prototype.search = function(f) {
        function visit(n, i) {
            var res = f(n, i);
            if (res)
                return true;
            for (var c = n.firstChild; c; c = c.nextSibling) {
                res = visit(c, i + 1);
                if (res)
                    return true
            }
            return false
        }
        return visit(this, 0)
    }
    ;
    function hasValue(v) {
        if (!v)
            return false;
        else if (Array.isArray(v))
            return v.some(hasValue);
        return true
    }
    TreeNode.prototype.pruneEmptyChildren = function() {
        this.visitAfter(function(node) {
            if (!node || !node.parentNode)
                return;
            if (tdg.isEmpty(node.childNodes) && !hasValue(node.nodeValue)) {
                var nextSibling = node.nextSibling;
                node.parentNode.removeChild(node);
                node.nextSibling = nextSibling
            }
        })
    }
    ;
    tdgchart.util.tree.TreeNode = TreeNode
}
)();
(function() {
    var tdg = tdgchart.util;
    var errorTemplate = '<div style="text-decoration: underline; margin-bottom: 10px">{0}</div>{1} ';
    tdgchart.UserError = function(msg) {
        this.name = "UserError";
        this.message = tdg.formatString(errorTemplate, tdgchart.translations.USERERROR, msg)
    }
    ;
    tdgchart.UserError.prototype = new Error;
    tdgchart.InternalError = function(msg) {
        this.name = "InternalError";
        this.message = tdg.formatString(errorTemplate, tdgchart.translations.ERROR, msg)
    }
    ;
    tdgchart.InternalError.prototype = new Error;
    tdgchart.prototype.errorHandlerWrapper = function(fn, args) {
        var chart = this;
        if (chart.catchErrors && chart.documentRoot)
            try {
                fn.apply(chart, args)
            } catch (e$4) {
                chart.drawError(chart.documentRoot, e$4)
            }
        else
            fn.apply(chart, args)
    }
    ;
    tdgchart.prototype.drawError = function(where, error, omitHeader) {
        var chart = this;
        var w = chart.width > 0 ? chart.width - 2 + "px" : "100%";
        var h = chart.height > 0 ? chart.height - 2 + "px" : "100%";
        var container = document.getElementById(where);
        if (!container) {
            container = document.createElement("div");
            document.body.appendChild(container)
        }
        tdg.dom.empty(container);
        var outerDiv = document.createElement("div");
        outerDiv.style.position = "relative";
        outerDiv.style.width = w;
        outerDiv.style.height = h;
        outerDiv.style.border = "1px solid black";
        outerDiv.style.overflow = "hidden";
        outerDiv.className = "error-message-container";
        var innerDiv = document.createElement("div");
        if (error instanceof tdgchart.UserError || error instanceof tdgchart.InternalError)
            innerDiv.innerHTML = error.message;
        else if (omitHeader)
            innerDiv.innerHTML = error;
        else {
            innerDiv.innerHTML = tdg.formatString(errorTemplate, tdgchart.translations.ERROR, error);
            if (error.stack) {
                var details = document.createElement("div");
                details.innerHTML = error.stack;
                details.style.font = "10pt Sans-Serif";
                details.style.margin = "12px";
                details.style["text-align"] = "left";
                var toggle = false;
                var detailLink = document.createElement("span");
                detailLink.innerHTML = '(<span style="text-decoration: underline">details</span>)';
                detailLink.style.font = "10pt Sans-Serif";
                detailLink.style.cursor = "pointer";
                detailLink.onclick = function() {
                    innerDiv[toggle ? "removeChild" : "appendChild"](details);
                    toggle = !toggle
                }
                ;
                innerDiv.appendChild(detailLink)
            }
        }
        innerDiv.style.width = w;
        innerDiv.style.height = h;
        innerDiv.style["text-align"] = "center";
        innerDiv.style["vertical-align"] = "middle";
        innerDiv.style.display = "table-cell";
        innerDiv.style.font = "bold 16pt Sans-Serif";
        innerDiv.style.color = "rgb(90, 90, 90)";
        innerDiv.className = "error-message";
        outerDiv.appendChild(innerDiv);
        container.appendChild(outerDiv)
    }
}
)();
var pv = {};
pv.color = tdgchart.util.color;
pv.range = tdgchart.util.range;
pv.version = {
    major: 3,
    minor: 2
};
pv.extend = function(f) {
    function g() {}
    g.prototype = f.prototype || f;
    return new g
}
;
pv.functor = function(v) {
    return typeof v === "function" ? v : function() {
        return v
    }
}
;
pv.id = function() {
    var id = 1;
    return function() {
        return id++
    }
}();
pv.index = function() {
    return this.index
}
;
pv.listen = function(target, type, listener) {
    listener = pv.listener(listener);
    return target.addEventListener ? target.addEventListener(type, listener, false) : target.attachEvent("on" + type, listener)
}
;
pv.listener = function(f) {
    return f.$listener || (f.$listener = function(e) {
        try {
            pv.event = e || window.event;
            if (e != null && e.type != null && (e.type === "touchstart" || e.type === "touchmove")) {
                pv.event.convertedPageX = pv.event.touches[0].pageX;
                pv.event.convertedPageY = pv.event.touches[0].pageY
            } else {
                pv.event.convertedPageX = pv.event.pageX;
                pv.event.convertedPageY = pv.event.pageY
            }
            return f.call(this, pv.event)
        } catch (e$5) {} finally {
            delete pv.event
        }
    }
    )
}
;
pv.blend = function(arrays) {
    return Array.prototype.concat.apply([], arrays)
}
;
pv.search = function(array, value) {
    var low = 0
      , high = array.length - 1;
    while (low <= high) {
        var mid = low + high >> 1
          , midValue = array[mid];
        if (midValue < value)
            low = mid + 1;
        else if (midValue > value)
            high = mid - 1;
        else
            return mid
    }
    return -low - 1
}
;
pv.search.index = function(array, value) {
    var i = pv.search(array, value);
    return i < 0 ? -i - 1 : i
}
;
pv.random = function(start, stop, step) {
    if (arguments.length === 1) {
        stop = start;
        start = 0
    }
    if (step == null)
        step = 1;
    return step ? Math.floor(Math.random() * (stop - start) / step) * step + start : Math.random() * (stop - start) + start
}
;
pv.vector = function(x, y) {
    return new pv.VectorClass(x,y)
}
;
pv.VectorClass = function(x, y) {
    this.x = x;
    this.y = y
}
;
pv.VectorClass.prototype.perp = function() {
    return new pv.VectorClass(-this.y,this.x)
}
;
pv.VectorClass.prototype.norm = function() {
    var l = this.length();
    return this.times(l ? 1 / l : 1)
}
;
pv.VectorClass.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y)
}
;
pv.VectorClass.prototype.times = function(k) {
    return new pv.VectorClass(this.x * k,this.y * k)
}
;
pv.VectorClass.prototype.plus = function(x, y) {
    return arguments.length === 1 ? new pv.VectorClass(this.x + x.x,this.y + x.y) : new pv.VectorClass(this.x + x,this.y + y)
}
;
pv.VectorClass.prototype.minus = function(x, y) {
    return arguments.length === 1 ? new pv.VectorClass(this.x - x.x,this.y - x.y) : new pv.VectorClass(this.x - x,this.y - y)
}
;
pv.VectorClass.prototype.dot = function(x, y) {
    return arguments.length === 1 ? this.x * x.x + this.y * x.y : this.x * x + this.y * y
}
;
pv.Transform = function() {}
;
pv.Transform.prototype = {
    k: 1,
    x: 0,
    y: 0
};
pv.Transform.identity = new pv.Transform;
pv.Transform.prototype.translate = function(x, y) {
    var v = new pv.Transform;
    v.k = this.k;
    v.x = this.k * x + this.x;
    v.y = this.k * y + this.y;
    return v
}
;
pv.Transform.prototype.scale = function(k) {
    var v = new pv.Transform;
    v.k = this.k * k;
    v.x = this.x;
    v.y = this.y;
    return v
}
;
pv.Transform.prototype.scaleXY = function(k) {
    var v = new pv.Transform;
    v.k = this.k;
    v.x = this.x * k;
    v.y = this.y * k;
    return v
}
;
pv.Transform.prototype.invert = function() {
    var v = new pv.Transform
      , k = 1 / this.k;
    v.k = k;
    v.x = -this.x * k;
    v.y = -this.y * k;
    return v
}
;
pv.Transform.prototype.times = function(m) {
    var v = new pv.Transform;
    v.k = this.k * m.k;
    v.x = this.k * m.x + this.x;
    v.y = this.k * m.y + this.y;
    return v
}
;
pv.Scale = function() {}
;
pv.Scale.interpolator = function(start, end) {
    if (typeof start == "number")
        return function(t) {
            return t * (end - start) + start
        }
        ;
    if (start === end) {
        start = tdgchart.util.color(start).rgb();
        return function() {
            return start
        }
    }
    start = tdgchart.util.color(start).rgb();
    end = tdgchart.util.color(end).rgb();
    return function(t) {
        var a = start.a * (1 - t) + end.a * t;
        if (a < 1E-5)
            a = 0;
        return start.a == 0 ? tdgchart.util.color.RGBColor(end.r, end.g, end.b, a) : end.a == 0 ? tdgchart.util.color.RGBColor(start.r, start.g, start.b, a) : tdgchart.util.color.RGBColor(Math.min(255, Math.round(start.r * (1 - t) + end.r * t)), Math.min(255, Math.round(start.g * (1 - t) + end.g * t)), Math.min(255, Math.round(start.b * (1 - t) + end.b * t)), a)
    }
}
;
pv.Scale.quantitative = function() {
    var d = [0, 1]
      , l = [0, 1]
      , r = [0, 1]
      , i = [tdgchart.util.identity]
      , type = Number
      , n = false
      , f = tdgchart.util.identity
      , g = tdgchart.util.identity;
    this.stepSize = undefined;
    function newDate(x) {
        return new Date(x)
    }
    function scale(x) {
        var j = pv.search(d, x);
        if (j < 0)
            j = -j - 2;
        j = Math.max(0, Math.min(i.length - 1, j));
        return i[j]((f(x) - l[j]) / (l[j + 1] - l[j]))
    }
    scale.transform = function(forward, inverse) {
        f = function(x) {
            return n ? -forward(-x) : forward(x)
        }
        ;
        g = function(y) {
            return n ? -inverse(-y) : inverse(y)
        }
        ;
        l = d.map(f);
        return this
    }
    ;
    scale.domain = function(array, min, max) {
        if (arguments.length) {
            var o;
            if (Array.isArray(array)) {
                if (arguments.length < 2)
                    min = tdgchart.util.identity;
                if (arguments.length < 3)
                    max = min;
                o = array.length && min(array[0]);
                d = array.length ? [tdgchart.util.min(array, min), tdgchart.util.max(array, max)] : []
            } else {
                o = array;
                d = Array.prototype.slice.call(arguments).map(Number)
            }
            if (!d.length)
                d = [-Infinity, Infinity];
            else if (d.length == 1)
                d = [d[0], d[0]];
            n = (d[0] || d[d.length - 1]) < 0;
            l = d.map(f);
            type = o instanceof Date ? newDate : Number;
            return this
        }
        return d.map(type)
    }
    ;
    scale.range = function() {
        if (arguments.length) {
            if (arguments.length === 1 && Array.isArray(arguments[0]))
                r = arguments[0].slice(0);
            else
                r = Array.prototype.slice.call(arguments);
            if (!r.length)
                r = [-Infinity, Infinity];
            else if (r.length == 1)
                r = [r[0], r[0]];
            i = [];
            for (var j = 0; j < r.length - 1; j++)
                i.push(pv.Scale.interpolator(r[j], r[j + 1]));
            return this
        }
        return r
    }
    ;
    scale.invert = function(y) {
        var j = pv.search(r, y);
        if (j < 0)
            j = -j - 2;
        j = Math.max(0, Math.min(i.length - 1, j));
        return type(g(l[j] + (y - r[j]) / (r[j + 1] - r[j]) * (l[j + 1] - l[j])))
    }
    ;
    scale.ticks = function(preserveMinMax) {
        var start = d[0]
          , end = d[d.length - 1]
          , reverse = end < start
          , min = reverse ? end : start
          , max = reverse ? start : end
          , span = max - min
          , step = 1;
        if (!span || !isFinite(span))
            return [type(min)];
        if (this.stepSize != null)
            step = this.stepSize;
        else if (preserveMinMax)
            step = getNiceMinMaxSpan(min, max);
        else {
            step = pv.logFloor(span / 5, 10);
            var err = 5 / (span / step);
            if (err <= .15)
                step *= 10;
            else if (err <= .35)
                step *= 5;
            else if (err <= .7)
                step *= 2;
            min = Math.floor(min / step) * step;
            max = Math.ceil(max / step) * step
        }
        var ticks = tdgchart.util.range(min, max + step, step);
        return reverse ? ticks.reverse() : ticks
    }
    ;
    function getNiceMinMaxSpan(min, max) {
        var span = max - min;
        if (!span || !isFinite(span))
            return 1;
        var multiplier = 1;
        var intervalsToTest = [4, 5, 3, 6, 7, 8];
        var testValues = intervalsToTest.map(function(el) {
            return span / el
        });
        for (var j = 0; j < 10; j++) {
            for (var i = 0; i < testValues.length; i++) {
                var testValue = testValues[i];
                if (Math.floor(testValue) / testValue === 1)
                    return testValue * multiplier;
                testValues[i] *= 10
            }
            multiplier /= 10
        }
        return testValues[0] * multiplier
    }
    scale.nice = function() {
        if (d.length != 2)
            return this;
        var start = d[0]
          , end = d[d.length - 1]
          , reverse = end < start
          , min = reverse ? end : start
          , max = reverse ? start : end
          , span = max - min;
        if (!span || !isFinite(span))
            return this;
        var step = Math.pow(10, Math.round(Math.log(span) / Math.log(10)) - 1);
        d = [Math.floor(min / step) * step, Math.ceil(max / step) * step];
        if (reverse)
            d.reverse();
        l = d.map(f);
        return this
    }
    ;
    scale.by = function(f) {
        function by() {
            return scale(f.apply(this, arguments))
        }
        for (var method in scale)
            by[method] = scale[method];
        return by
    }
    ;
    scale.domain.apply(scale, arguments);
    return scale
}
;
pv.Scale.linear = function() {
    var scale = pv.Scale.quantitative();
    scale.domain.apply(scale, arguments);
    return scale
}
;
pv.Scale.log = function() {
    var scale = pv.Scale.quantitative(1, 10), b, p, log = function(x) {
        return Math.log(x) / p
    }, pow = function(y) {
        return Math.pow(b, y)
    };
    scale.ticks = function() {
        var d = scale.domain()
          , ticks = [];
        if (d[0] > 0 && d[1] > 0) {
            var i = Math.floor(log(d[0])), j = Math.ceil(log(d[1])), k;
            for (; i < j; i++)
                for (k = 1; k < b; k++)
                    ticks.push(pow(i) * k);
            ticks.push(pow(i))
        } else {
            var i = Math.floor(log(1)), j = Math.ceil(log(10)), k;
            for (; i < j; i++)
                for (k = 1; k < b; k++)
                    ticks.push(pow(i) * k);
            ticks.push(pow(i))
        }
        for (i = 0; ticks[i] < d[0]; i++)
            ;
        for (j = ticks.length; ticks[j - 1] > d[1]; j--)
            ;
        return ticks.slice(i, j)
    }
    ;
    scale.nice = function() {
        var d = scale.domain();
        return scale.domain(pv.logFloor(d[0], b), pv.logCeil(d[1], b))
    }
    ;
    scale.base = function(v) {
        if (arguments.length) {
            b = Number(v);
            p = Math.log(b);
            scale.transform(log, pow);
            return this
        }
        return b
    }
    ;
    scale.domain.apply(scale, arguments);
    return scale.base(10)
}
;
pv.Scale.ordinal = function() {
    var d = []
      , i = {}
      , r = []
      , band = 0;
    function scale(x) {
        if (!(x in i))
            i[x] = d.push(x) - 1;
        return r[i[x] % r.length]
    }
    scale.domain = function(array, f) {
        if (arguments.length) {
            array = Array.isArray(array) ? arguments.length > 1 ? tdgchart.util.map(array, f) : array : Array.prototype.slice.call(arguments);
            i = {};
            d = [];
            var seen = {};
            for (var j = 0; j < array.length; j++) {
                var o = array[j];
                if (!(o in seen)) {
                    seen[o] = true;
                    d.push(o);
                    i[o] = j
                }
            }
            return this
        }
        return d
    }
    ;
    scale.range = function(array, f) {
        if (arguments.length) {
            r = Array.isArray(array) ? arguments.length > 1 ? tdgchart.util.map(array, f) : array : Array.prototype.slice.call(arguments);
            if (typeof r[0] == "string")
                r = r.map(tdgchart.util.color);
            return this
        }
        return r
    }
    ;
    scale.split = function(min, max) {
        var step = (max - min) / this.domain().length;
        r = tdgchart.util.range(min + step / 2, max, step);
        return this
    }
    ;
    scale.splitFlush = function(min, max) {
        var n = this.domain().length
          , step = (max - min) / (n - 1);
        r = n == 1 ? [(min + max) / 2] : tdgchart.util.range(min, max + step / 2, step);
        return this
    }
    ;
    scale.splitBanded = function(min, max, band) {
        if (arguments.length < 3)
            band = 1;
        if (band < 0) {
            var n = this.domain().length
              , total = -band * n
              , remaining = max - min - total
              , padding = remaining / (n + 1);
            r = tdgchart.util.range(min + padding, max, padding - band);
            r.band = -band
        } else {
            var step = (max - min) / (this.domain().length + (1 - band));
            r = tdgchart.util.range(min + step * (1 - band), max - .99 * step, step);
            r.band = step * band
        }
        return this
    }
    ;
    scale.splitBandedHalfInset = function(min, max, band) {
        if (arguments.length < 3)
            band = 1;
        if (band < 0) {
            var n = this.domain().length
              , total = -band * n
              , remaining = max - min - total
              , padding = remaining / (n + 1);
            r = tdgchart.util.range(min + padding, max, padding - band);
            r.band = -band
        } else {
            var step = (max - min) / (this.domain().length + (1 - band));
            var inset = step * (1 - band) / 2;
            step += inset * 2 / this.domain().length;
            r = tdgchart.util.range(min + inset, max, step);
            r.band = step * band
        }
        return this
    }
    ;
    scale.by = function(f) {
        function by() {
            return scale(f.apply(this, arguments))
        }
        for (var method in scale)
            by[method] = scale[method];
        return by
    }
    ;
    scale.splitProportional = function(min, max, sums, total) {
        var array = [0];
        var current = 0;
        var range = max - min;
        for (var i = 0; i < sums.length - 1; i++) {
            current += range * sums[i] / total;
            array.push(current)
        }
        r = array;
        r.band = band = 1;
        return this
    }
    ;
    scale.domain.apply(scale, arguments);
    return scale
}
;
pv.log = function(x, b) {
    return Math.log(x) / Math.log(b)
}
;
pv.logCeil = function(x, b) {
    return x > 0 ? Math.pow(b, Math.ceil(pv.log(x, b))) : -Math.pow(b, -Math.ceil(-pv.log(-x, b)))
}
;
pv.logFloor = function(x, b) {
    return x > 0 ? Math.pow(b, Math.floor(pv.log(x, b))) : -Math.pow(b, -Math.floor(-pv.log(-x, b)))
}
;
(function() {
    var tdg = tdgchart.util;
    pv.SvgScene = {
        svg: "http://www.w3.org/2000/svg",
        xmlns: "http://www.w3.org/2000/xmlns",
        xlink: "http://www.w3.org/1999/xlink",
        xhtml: "http://www.w3.org/1999/xhtml",
        scale: 1,
        events: ["DOMMouseScroll", "mousewheel", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "click", "dblclick", "touchstart", "touchmove", "touchend"],
        implicit: {
            svg: {
                "shape-rendering": "auto",
                "pointer-events": "painted",
                dy: 0,
                "text-anchor": "start",
                transform: "translate(0,0)",
                fill: "none",
                "fill-opacity": 1,
                stroke: "none",
                "stroke-opacity": 1,
                "stroke-width": 1.5,
                "stroke-linejoin": "miter"
            },
            css: {
                font: "10px sans-serif"
            }
        }
    };
    var strokePaths = ["bar", "cross", "circleplus", "circleminus", "tick", "pin", "dollar"];
    pv.SvgScene.pathRequiresStroke = function(pathName) {
        return strokePaths.includes((pathName + "").toLowerCase())
    }
    ;
    var crispEdgePaths = ["hline", "vline", "hatch", "dots", "diagonaldots", "solid"];
    pv.SvgScene.pathRequiresAntiAlias = function(pathName) {
        return !crispEdgePaths.includes((pathName + "").toLowerCase())
    }
    ;
    var crispEdgeShapes = ["plus", "rectangle", "rectanglethin", "square", "thinplus", "bar"];
    pv.SvgScene.shapeRequiresAntiAlias = function(shapeName) {
        return !crispEdgeShapes.includes((shapeName + "").toLowerCase())
    }
    ;
    pv.SvgScene.getPattern = function(shape, pad, lineWidth) {
        var hp = pad / 2
          , hw = lineWidth / 2;
        var path = ""
          , size = lineWidth + pad;
        switch ((shape + "").toLowerCase()) {
        case "hline":
            path = tdg.formatString("M{0},0h{1}", -size, size * 2);
            break;
        case "vline":
            path = tdg.formatString("M0,{0}v{1}", -size, size * 2);
            break;
        case "hatch":
            path = tdg.formatString("M0,{0}v{1}M{0},0h{1}", -size, size * 2);
            break;
        case "slash":
            size = (lineWidth + pad + lineWidth + pad) / Math.SQRT2;
            path = tdg.formatString("M-{0},{0}L{0},-{0}M0,{0}L{0},0M-{0},0L0,-{0}", size);
            break;
        case "backslash":
            size = (lineWidth + pad + lineWidth + pad) / Math.SQRT2;
            path = tdg.formatString("M-{0},-{0}L{0},{0}M-{0},0L0,{0}M0,-{0}L{0},0", size);
            break;
        case "diagonalhatch":
            size = (lineWidth + pad + lineWidth + pad) / Math.SQRT2;
            path = tdg.formatString("M-{0},{0}L{0},-{0}M0,{0}L{0},0M-{0},0L0,-{0}M-{0},-{0}L{0},{0}", size);
            break;
        case "dots":
            path = tdg.formatString("M0,-{0}v{1}", hw, lineWidth);
            break;
        case "diagonaldots":
            size = lineWidth + pad + lineWidth + pad;
            path = tdg.formatString("M-{0},-{1}h-{2}M{0},{1}h{2}", hp, hp + hw, lineWidth);
            break;
        case "solid":
            size = 1;
            path = "M0,0h1";
            break;
        case "empty":
            size = 50;
            path = "M0,0";
            break
        }
        return {
            path: path,
            size: size
        }
    }
    ;
    pv.SvgScene.getPath = function(s) {
        var path = null;
        var r = s.radius, rh = r / 2, r2 = r * 2, rs, rss, x, y;
        var sAng = s.startAngle, eAng = s.endAngle, rDif, theta;
        switch ((s.shape + "").toLowerCase()) {
        case "quartercircle":
            {
                path = "M " + -r + " " + 0 + "A" + r + "," + r + ",0,0,1,0 " + -r;
                break
            }
        case "ring":
            {
                var ri = Math.min(r * .85, r - 2.5);
                path = " M" + -r + ",0" + " A" + r + "," + r + ",0,0,0," + r + ",0" + " A" + r + "," + r + ",0,0,0," + -r + ",0" + " Z" + " M" + -ri + ",0" + " A" + ri + "," + ri + ",0,0,1," + ri + ",0" + " A" + ri + "," + ri + ",0,0,1," + -ri + ",0" + " Z";
                break
            }
        case "gaugeborder":
            {
                r = s.innerRadius;
                r2 = s.outerRadius;
                rDif = r2 - r;
                rs = (s.baseSize / r + .1) * r;
                var obr = rs + rDif;
                theta = Math.acos((2 * Math.pow(r2, 2) - Math.pow(rDif, 2)) / (2 * Math.pow(r2, 2)));
                var soAng = sAng - theta;
                var eoAng = eAng + theta;
                var theta2 = Math.acos((2 * Math.pow(obr, 2) - Math.pow(rDif, 2)) / (2 * Math.pow(obr, 2)));
                var sobAng = sAng - theta2;
                var eobAng = eAng + theta2;
                path = "M" + Math.cos(sAng + theta / 2) * r + " " + Math.sin(sAng + theta / 2) * r + " A " + r + " " + r + ", 0, " + (Math.abs(eAng - sAng) > Math.PI ? 1 : 0) + ", 1, " + Math.cos(eAng - theta / 2) * r + " " + Math.sin(eAng - theta / 2) * r + " A " + rDif / 2 + " " + rDif / 2 + ", 0, 0, 1, " + Math.cos(eAng) * (r - rDif / 2) + " " + Math.sin(eAng) * (r - rDif / 2) + " L " + Math.cos(eAng) * rs + " " + Math.sin(eAng) * rs + " A " + rs + " " + rs + ", 0, " + (Math.abs(eAng - sAng) > Math.PI ? 0 : 1) + ", 1, " + Math.cos(sAng) * rs + " " + Math.sin(sAng) * rs + " L " + Math.cos(sAng) * (r - rDif / 2) + " " + Math.sin(sAng) * (r - rDif / 2) + " A " + rDif / 2 + " " + rDif / 2 + ", 0, 0, 1, " + Math.cos(sAng + theta / 2) * r + " " + Math.sin(sAng + theta / 2) * r + " Z" + "M" + Math.cos(soAng + theta) * r2 + " " + Math.sin(soAng + theta) * r2 + " A " + r2 + " " + r2 + ", 0, " + (Math.abs(eAng - sAng) > Math.PI ? 1 : 0) + ", 1, " + Math.cos(eoAng - theta) * r2 + " " + Math.sin(eoAng - theta) * r2 + " A " + rDif + " " + rDif + ", 0, 0, 1, " + Math.cos(eoAng) * (r2 - rDif) + " " + Math.sin(eoAng) * (r2 - rDif) + " L " + Math.cos(eobAng) * obr + " " + Math.sin(eobAng) * obr + " A " + obr + " " + obr + ", 0, " + (Math.abs(eobAng - sobAng) < Math.PI ? 1 : 0) + ", 1, " + Math.cos(sobAng) * obr + " " + Math.sin(sobAng) * obr + " L " + Math.cos(soAng) * (r2 - rDif) + " " + Math.sin(soAng) * (r2 - rDif) + " A " + rDif + " " + rDif + ", 0, 0, 1, " + Math.cos(soAng + theta) * r2 + " " + Math.sin(soAng + theta) * r2 + " Z";
                break
            }
        case "gaugefill":
            {
                r = s.innerRadius;
                r2 = s.outerRadius;
                rDif = r2 - r;
                rs = (s.baseSize / r + .1) * r;
                theta = Math.acos((2 * Math.pow(r2, 2) - Math.pow(rDif, 2)) / (2 * Math.pow(r2, 2)));
                path = "M" + Math.cos(sAng + theta / 2) * r + " " + Math.sin(sAng + theta / 2) * r + " A " + r + " " + r + ", 0, " + (Math.abs(eAng - sAng) > Math.PI ? 1 : 0) + ", 1, " + Math.cos(eAng - theta / 2) * r + " " + Math.sin(eAng - theta / 2) * r + " A " + rDif / 2 + " " + rDif / 2 + ", 0, 0, 1, " + Math.cos(eAng) * (r - rDif / 2) + " " + Math.sin(eAng) * (r - rDif / 2) + " L " + Math.cos(eAng) * rs + " " + Math.sin(eAng) * rs + " A " + rs + " " + rs + ", 0, " + (Math.abs(eAng - sAng) > Math.PI ? 0 : 1) + ", 1, " + Math.cos(sAng) * rs + " " + Math.sin(sAng) * rs + " L " + Math.cos(sAng) * (r - rDif / 2) + " " + Math.sin(sAng) * (r - rDif / 2) + " A " + rDif / 2 + " " + rDif / 2 + ", 0, 0, 1, " + Math.cos(sAng + theta / 2) * r + " " + Math.sin(sAng + theta / 2) * r + " Z";
                break
            }
        case "arrow":
            {
                var h3 = r / 3
                  , h23 = h3 * 2
                  , h43 = h23 * 2;
                path = "M" + -h23 + "," + -h3 + "l" + h23 + "," + -h23 + "l" + h23 + "," + h23 + "l" + -h3 + ",0" + "l0," + h43 + "l" + -h23 + ",0" + "l0" + -h43 + "Z";
                break
            }
        case "bar":
            {
                path = "M0," + s.size / 2 + "L0," + -(s.size / 2);
                break
            }
        case "cross":
            {
                path = "M" + -r + "," + -r + "L" + r + "," + r + "M" + r + "," + -r + "L" + -r + "," + r;
                break
            }
        case "diamond":
            {
                path = "M0," + -r + "L" + r + ",0" + " 0," + r + " " + -r + ",0" + "Z";
                break
            }
        case "fivestar":
            {
                var t36 = .7265
                  , t72 = 3.0777
                  , c72 = .309
                  , s72 = .951
                  , c36 = .809
                  , s36 = .588;
                rs = r / 3.236;
                var hp = rs / c36;
                path = "M0," + -r + "L" + rs * t36 + "," + -rs + "L" + rs * t72 + "," + -rs + "L" + hp * s72 + "," + hp * c72 + "L" + r * s36 + "," + r * c36 + "L0," + hp + "L" + -(r * s36) + "," + r * c36 + "L" + -(hp * s72) + "," + hp * c72 + "L" + -(rs * t72) + "," + -rs + "L" + -(rs * t36) + "," + -rs + "Z";
                break
            }
        case "hexagon":
            {
                x = r * .5;
                y = r * .866;
                path = "M" + -x + "," + -y + "h" + r + "L" + r + ",0" + "L" + x + "," + y + "h" + -r + "L" + -r + ",0" + "Z";
                break
            }
        case "hourglass":
            {
                path = "M" + -r + "," + -r + "h" + r2 + "L" + -r + "," + r + "h" + r2 + "Z";
                break
            }
        case "house":
            {
                path = "M0," + -r + "L" + r + ",0v" + r + "h" + -(r * 2) + "v" + -r + "Z";
                break
            }
        case "piratecross":
            {
                rs = r / 1.6;
                rss = rs * 2;
                path = "M0,0" + "L" + -rs + "," + -r + "h" + rss + "L0,0" + "L" + r + "," + -rs + "v" + rss + "L0,0" + "L" + -rs + "," + r + "h" + rss + "L0,0" + "L" + -r + "," + -rs + "v" + rss + "L0,0";
                break
            }
        case "plus":
            {
                x = 2 / 3 * r;
                path = "M" + -(x / 2) + "," + -r + "h" + x + "v" + x + "h" + x + "v" + x + "h" + -x + "v" + x + "h" + -x + "v" + -x + "h" + -x + "v" + -x + "h" + x + "v" + -x;
                break
            }
        case "circleplus":
            {
                rs = r + " " + r;
                path = "m -" + r + " 0 a " + rs + " 0 1 0 " + r2 + " 0 a " + rs + " 0 1 0 -" + r2 + " 0";
                path += " M-" + rh + ",0 h" + r + " M0,-" + rh + " v" + r;
                break
            }
        case "circleminus":
            {
                rs = r + " " + r;
                path = "m -" + r + " 0 a " + rs + " 0 1 0 " + r2 + " 0 a " + rs + " 0 1 0 -" + r2 + " 0";
                path += " M-" + rh + ",0 h" + r;
                break
            }
        case "rectangle":
            {
                path = "M" + -r + "," + r / 4 + "h" + r2 + "v" + rh + "h" + -r2 + "Z";
                break
            }
        case "rectanglethin":
            {
                path = "M" + -r + "," + r / 10 + "h" + r2 + "v" + r / 5 + "h" + -r2 + "Z";
                break
            }
        case "sixstar":
            {
                rs = rh / .866;
                x = rh * .577;
                path = "M0," + -r + "L" + x + "," + -rh + "h" + rs + "L" + rs + ",0" + "L" + (rs + x) + "," + rh + "h" + -rs + "L0," + r + "L" + -x + "," + rh + "h" + -rs + "L" + -rs + ",0" + "L" + -(rs + x) + "," + -rh + "L" + -x + "," + -rh + "Z";
                break
            }
        case "fill":
        case "square":
            {
                path = "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
                break
            }
        case "thinplus":
            {
                x = r / 4;
                y = r - x;
                path = "M" + -(x / 2) + "," + -r + "h" + x + "v" + y + "h" + y + "v" + x + "h" + -y + "v" + y + "h" + -x + "v" + -y + "h" + -y + "v" + -x + "h" + y + "v" + -y;
                break
            }
        case "tick":
            {
                path = "M0,0L0," + -s.size;
                break
            }
        case "triangle":
            {
                rs = r * .866;
                path = "M0," + rs + "L" + r + "," + -rs + " " + -r + "," + -rs + "Z";
                break
            }
        case "needle2":
            {
                x = s.needleBaseRadius != undefined ? s.needleBaseRadius : 4;
                var br = s.needleBaseRadius;
                var mr = br / 8;
                path = "M" + -mr + "," + (r - mr) + "A" + mr + "," + mr + ",0,0,0," + mr + "," + (r - mr) + "L" + x + ",0" + "A" + br + "," + br + ",0,0,0," + -x + "," + 0 + "Z";
                break
            }
        case "needle":
            {
                x = s.needleBaseRadius != undefined ? s.needleBaseRadius : 4;
                path = "M0," + r + "L" + x + ",0" + " " + -x + ",0" + "Z";
                break
            }
        case "dollar":
            {
                rs = rh * .375;
                r2 = rs * 2;
                path = "M 0 -" + rh + "V" + rh + "M -" + rs + " " + rs + "C -" + rs + " " + r2 + ", " + rs + " " + r2 + ", " + rs + ", " + rs + " " + "S " + rs * .2666 + " " + rs * .1333 + ", 0 0S -" + rs + " -" + rs / 3 + ", -" + rs + " -" + rs + "C -" + rs + " -" + r2 + ", " + rs + " -" + r2 + ", " + rs + ", -" + rs;
                break
            }
        case "pin":
            {
                rs = (r - 1) / 2;
                r2 = rs / 1.6;
                y = tdg.radians(15);
                x = Math.sin(y) * rs;
                y = Math.cos(y) * rs;
                path = "M-" + x + ",-" + y + " A " + r2 + "," + r2 + ",0,1,1," + x + ",-" + y + " L 0,0 Z";
                break
            }
        case "labelcalloutlefthack":
            {
                x = 75;
                y = 20;
                var calloutH = y * .7;
                var calloutW = calloutH * .5;
                var cr = 5;
                var cr2 = cr / 2;
                path = "M" + (-x / 2 - cr) + "," + (y / 2 + calloutH + cr2) + " v" + -(y + calloutH) + " c" + 0 + "," + -cr2 + " " + cr2 + "," + -cr + " " + cr + "," + -cr + " h" + x + " c" + cr2 + "," + 0 + " " + cr + "," + cr2 + " " + cr + "," + cr + " v" + (y - cr) + " c" + 0 + "," + cr2 + " " + -cr2 + "," + cr + " " + -cr + "," + cr + " h" + -(x - calloutW) + " Z";
                break
            }
        case "roundedsquare":
            {
                var rm = r * .92;
                var cr = rm / 1.5;
                path = "M" + -rm + "," + (-rm + cr);
                path += "A" + cr + "," + cr + "," + 0 + "," + 0 + "," + 1 + "," + (-rm + cr) + "," + -rm;
                path += "L" + (rm - cr) + "," + -rm;
                path += "A" + cr + "," + cr + "," + 0 + "," + 0 + "," + 1 + "," + rm + "," + (-rm + cr);
                path += "L" + rm + "," + (rm - cr);
                path += "A" + cr + "," + cr + "," + 0 + "," + 0 + "," + 1 + "," + (rm - cr) + "," + rm;
                path += "L" + (-rm + cr) + "," + rm;
                path += "A" + cr + "," + cr + "," + 0 + "," + 0 + "," + 1 + "," + -rm + "," + (rm - cr);
                path += "Z";
                break
            }
        }
        return path
    }
    ;
    pv.SvgScene.dashPresets = {
        dash: "5 4",
        dash_dot: "5 4 2 4",
        dash_dot_dot: "10 4 2 4 2 4",
        dot: "2 4",
        long_dash: "10 4",
        long_dash_dot: "10 4 2 4",
        short_dash: "5 2",
        short_dash_dot: "5 2 2 2",
        short_dash_dot_dot: "5 2 2 2 2 2",
        short_dot: "2 2",
        solid: null
    };
    function dashLookup(dash) {
        if (!dash || typeof dash !== "string")
            return null;
        dash = dash.toLowerCase();
        return pv.SvgScene.dashPresets.hasOwnProperty(dash) ? pv.SvgScene.dashPresets[dash] : dash
    }
    pv.SvgScene.dashLookup = dashLookup;
    pv.SvgScene.updateAll = function(scenes) {
        if (scenes.length && scenes[0].reverse && scenes.type !== "line" && scenes.type !== "area") {
            var reversed = pv.extend(scenes);
            for (var i = 0, j = scenes.length - 1; j >= 0; i++,
            j--)
                reversed[i] = scenes[j];
            scenes = reversed
        }
        this.removeSiblings(this[scenes.type](scenes))
    }
    ;
    pv.SvgScene.create = function(type) {
        return document.createElementNS(this.svg, type)
    }
    ;
    pv.SvgScene.expect = function(e, type, attributes, style) {
        var name, value;
        if (e) {
            if (e.tagName === "a")
                e = e.firstChild;
            if (e.tagName === "defs")
                e = e.nextSibling;
            if (e.tagName !== type) {
                var n = this.create(type);
                e.parentNode.replaceChild(n, e);
                e = n
            }
        } else
            e = this.create(type);
        for (name in attributes) {
            value = attributes[name];
            if (value === this.implicit.svg[name])
                value = null;
            if (value == null)
                e.removeAttribute(name);
            else
                e.setAttribute(name, value)
        }
        if (e && e.style)
            for (name in style) {
                value = style[name];
                if (value === this.implicit.css[name])
                    value = null;
                if (value == null)
                    e.style.removeProperty(name);
                else
                    e.style[name] = value
            }
        return e
    }
    ;
    pv.SvgScene.append = function(e, scenes, index) {
        e.$scene = {
            scenes: scenes,
            index: index
        };
        e = this.title(e, scenes[index]);
        if (!e.parentNode)
            scenes.$g.appendChild(e);
        return e.nextSibling
    }
    ;
    pv.SvgScene.title = function(e, s) {
        if (s.title)
            if (pv._useHTMLtooltips) {
                e.setAttribute("tdgtitle", "placeholder");
                e.tdgtitle_dom = s.title
            } else {
                var a;
                if (e.firstChild && e.firstChild.nodeName === "title")
                    a = e.firstChild;
                else {
                    a = this.create("title");
                    e.appendChild(a)
                }
                a.setAttribute("tdgtitle", "placeholder");
                a.tdgtitle_dom = s.title
            }
        return e
    }
    ;
    pv.SvgScene.dispatch = pv.listener(function(e) {
        var t = e.target.$scene;
        if (t) {
            var type = e.type;
            switch (type) {
            case "DOMMouseScroll":
                {
                    type = "mousewheel";
                    e.wheel = -480 * e.detail;
                    break
                }
            case "mousewheel":
                {
                    e.wheel = (window.opera ? 12 : 1) * e.wheelDelta;
                    break
                }
            }
            if (pv.Mark.dispatch(type, t.scenes, t.index))
                e.preventDefault()
        }
    });
    pv.SvgScene.removeSiblings = function(e) {
        while (e) {
            var n = e.nextSibling;
            if (e.nodeName !== "defs")
                e.parentNode.removeChild(e);
            e = n
        }
    }
    ;
    pv.SvgScene.undefined = function() {}
    ;
    pv.SvgScene.addFillStyleDefinition = function(scenes, fill) {
        if (fill.color && fill.color.indexOf("#tbd") < 0)
            return;
        var root = pv.SvgScene.getSceneRoot(scenes);
        var defNode = pv.SvgScene.getDefsElement(scenes, root);
        pv.SvgScene.addFillStyleDefinitionDirect(root[0].canvas.id, defNode, fill)
    }
    ;
    pv.SvgScene.addFillStyleDefinitionDirect = function(documentRootID, defNode, fill) {
        if (fill.color && fill.color.indexOf("#tbd") < 0)
            return;
        function getPatternID(pattern, canvasID) {
            var shape = typeof pattern.shape === "function" ? pattern.shape() : pattern.shape;
            var p = [pattern.type, shape, pattern.size, pattern.pad, pattern.foregroundColor, pattern.backgroundColor];
            var s = canvasID + "__" + p.join("_");
            s = s.replace(/rgb\(/g, "").replace(/[ ;({}'"#:.,)]/g, "");
            return s
        }
        function getFillID(fill, canvasID) {
            var p;
            if (fill.type === "pattern")
                return getPatternID(fill, canvasID);
            else if (fill.type === "lineargradient")
                p = [fill.type, fill.x1, fill.y1, fill.x2, fill.y2];
            else
                p = [fill.type, fill.type, fill.cx, fill.cy, fill.r];
            var s = canvasID + "__" + p.join("_") + "_";
            s += fill.stops.map(function(el) {
                return el.join("_")
            }).join("_");
            s = s.replace(/~/g, "t").replace(/%/g, "p");
            s = s.replace(/rgb\(/g, "").replace(/[ #:.,)]/g, "");
            return s
        }
        var i, haveFillDef = false;
        var domid = getFillID(fill, documentRootID);
        for (i = 0; i < defNode.childNodes.length; i++)
            if (defNode.childNodes[i].id === domid) {
                haveFillDef = true;
                break
            }
        if (!haveFillDef) {
            var lg;
            if (fill.type === "lineargradient") {
                lg = defNode.appendChild(this.create("linearGradient"));
                if (fill.x1[fill.x1.length - 1] === "~") {
                    lg.setAttribute("gradientUnits", "userSpaceOnUse");
                    fill.x1 = fill.x1.slice(0, -1)
                }
                lg.setAttribute("id", domid);
                lg.setAttribute("x1", fill.x1);
                lg.setAttribute("y1", fill.y1);
                lg.setAttribute("x2", fill.x2);
                lg.setAttribute("y2", fill.y2)
            } else if (fill.type === "radialgradient") {
                lg = defNode.appendChild(this.create("radialGradient"));
                lg.setAttribute("id", domid);
                lg.setAttribute("cx", fill.cx);
                lg.setAttribute("cy", fill.cy);
                if (typeof fill.fx !== "undefined" && typeof fill.fy !== "undefined") {
                    lg.setAttribute("fx", fill.fx);
                    lg.setAttribute("fy", fill.fy)
                }
                lg.setAttribute("r", fill.r);
                if (fill.cx[fill.cx.length - 1] !== "%")
                    lg.setAttribute("gradientUnits", "userSpaceOnUse")
            } else if (fill.type === "pattern") {
                var shape = typeof fill.shape === "function" ? fill.shape() : fill.shape;
                lg = this.expect(null, "pattern", {
                    id: domid,
                    x: 1,
                    y: 1,
                    width: fill.size,
                    height: fill.size,
                    patternUnits: "userSpaceOnUse"
                });
                lg.appendChild(this.expect(null, "rect", {
                    width: fill.size,
                    height: fill.size,
                    fill: fill.backgroundColor
                }));
                var g = lg.appendChild(this.expect(null, "g", {
                    transform: "translate(" + fill.size / 2 + ", " + fill.size / 2 + ")"
                }));
                var r = fill.size / 2 - fill.pad;
                var isStroke = this.pathRequiresStroke(shape);
                var path = this.getPath({
                    radius: r,
                    size: r,
                    shape: shape
                });
                if (path)
                    g.appendChild(this.expect(null, "path", {
                        d: path,
                        fill: isStroke ? null : fill.foregroundColor,
                        stroke: isStroke ? fill.foregroundColor : null
                    }));
                else if (typeof shape === "string" && shape.indexOf(",") >= 0)
                    g.appendChild(this.expect(null, "path", {
                        d: shape,
                        fill: fill.foregroundColor,
                        stroke: fill.foregroundColor
                    }));
                else
                    g.appendChild(this.expect(null, "circle", {
                        cx: 0,
                        cy: 0,
                        r: r,
                        fill: fill.foregroundColor
                    }));
                defNode.appendChild(lg)
            }
            if (fill.type !== "pattern")
                for (i = 0; i < fill.stops.length; i += 1) {
                    var stop = lg.appendChild(this.create("stop"));
                    stop.setAttribute("offset", fill.stops[i][0]);
                    stop.setAttribute("stop-color", fill.stops[i][1]);
                    stop.setAttribute("stop-opacity", fill.stops[i][2])
                }
        }
        var base = document.getElementsByTagName("base").length ? location.href : "";
        base = navigator.userAgent.indexOf("MSIE") >= 0 ? "" : base;
        fill.color = "url(" + base + "#" + domid + ")"
    }
    ;
    pv.SvgScene.pathBasis = function() {
        var basis = [[1 / 6, 2 / 3, 1 / 6, 0], [0, 2 / 3, 1 / 3, 0], [0, 1 / 3, 2 / 3, 0], [0, 1 / 6, 2 / 3, 1 / 6]];
        function weight(w, p0, p1, p2, p3) {
            return {
                x: w[0] * p0.left + w[1] * p1.left + w[2] * p2.left + w[3] * p3.left,
                y: w[0] * p0.top + w[1] * p1.top + w[2] * p2.top + w[3] * p3.top
            }
        }
        var convert = function(p0, p1, p2, p3) {
            var b1 = weight(basis[1], p0, p1, p2, p3)
              , b2 = weight(basis[2], p0, p1, p2, p3)
              , b3 = weight(basis[3], p0, p1, p2, p3);
            return "C" + b1.x + "," + b1.y + "," + b2.x + "," + b2.y + "," + b3.x + "," + b3.y
        };
        convert.segment = function(p0, p1, p2, p3) {
            var b0 = weight(basis[0], p0, p1, p2, p3)
              , b1 = weight(basis[1], p0, p1, p2, p3)
              , b2 = weight(basis[2], p0, p1, p2, p3)
              , b3 = weight(basis[3], p0, p1, p2, p3);
            return "M" + b0.x + "," + b0.y + "C" + b1.x + "," + b1.y + "," + b2.x + "," + b2.y + "," + b3.x + "," + b3.y
        }
        ;
        return convert
    }();
    pv.SvgScene.curveBasis = function(points) {
        if (points.length <= 2)
            return "";
        var path = ""
          , p0 = points[0]
          , p1 = p0
          , p2 = p0
          , p3 = points[1];
        path += this.pathBasis(p0, p1, p2, p3);
        for (var i = 2; i < points.length; i++) {
            p0 = p1;
            p1 = p2;
            p2 = p3;
            p3 = points[i];
            path += this.pathBasis(p0, p1, p2, p3)
        }
        path += this.pathBasis(p1, p2, p3, p3);
        path += this.pathBasis(p2, p3, p3, p3);
        return path
    }
    ;
    pv.SvgScene.curveBasisSegments = function(points) {
        if (points.length <= 2)
            return "";
        var paths = []
          , p0 = points[0]
          , p1 = p0
          , p2 = p0
          , p3 = points[1]
          , firstPath = this.pathBasis.segment(p0, p1, p2, p3);
        p0 = p1;
        p1 = p2;
        p2 = p3;
        p3 = points[2];
        paths.push(firstPath + this.pathBasis(p0, p1, p2, p3));
        for (var i = 3; i < points.length; i++) {
            p0 = p1;
            p1 = p2;
            p2 = p3;
            p3 = points[i];
            paths.push(this.pathBasis.segment(p0, p1, p2, p3))
        }
        paths.push(this.pathBasis.segment(p1, p2, p3, p3) + this.pathBasis(p2, p3, p3, p3));
        return paths
    }
    ;
    pv.SvgScene.curveHermite = function(points, tangents) {
        if (tangents.length < 1 || points.length !== tangents.length && points.length !== tangents.length + 2)
            return "";
        var quad = points.length !== tangents.length
          , path = ""
          , p0 = points[0]
          , p = points[1]
          , t0 = tangents[0]
          , t = t0
          , pi = 1;
        if (quad) {
            path += "Q" + (p.left - t0.x * 2 / 3) + "," + (p.top - t0.y * 2 / 3) + "," + p.left + "," + p.top;
            p0 = points[1];
            pi = 2
        }
        if (tangents.length > 1) {
            t = tangents[1];
            p = points[pi];
            pi++;
            path += "C" + (p0.left + t0.x) + "," + (p0.top + t0.y) + "," + (p.left - t.x) + "," + (p.top - t.y) + "," + p.left + "," + p.top;
            for (var i = 2; i < tangents.length; i++,
            pi++) {
                p = points[pi];
                t = tangents[i];
                path += "S" + (p.left - t.x) + "," + (p.top - t.y) + "," + p.left + "," + p.top
            }
        }
        if (quad) {
            var lp = points[pi];
            path += "Q" + (p.left + t.x * 2 / 3) + "," + (p.top + t.y * 2 / 3) + "," + lp.left + "," + lp.top
        }
        return path
    }
    ;
    pv.SvgScene.curveHermiteSegments = function(points, tangents) {
        if (tangents.length < 1 || points.length !== tangents.length && points.length !== tangents.length + 2)
            return [];
        var quad = points.length !== tangents.length
          , paths = []
          , p0 = points[0]
          , p = p0
          , t0 = tangents[0]
          , t = t0
          , pi = 1;
        if (quad) {
            p = points[1];
            paths.push("M" + p0.left + "," + p0.top + "Q" + (p.left - t.x * 2 / 3) + "," + (p.top - t.y * 2 / 3) + "," + p.left + "," + p.top);
            pi = 2
        }
        for (var i = 1; i < tangents.length; i++,
        pi++) {
            p0 = p;
            t0 = t;
            p = points[pi];
            t = tangents[i];
            paths.push("M" + p0.left + "," + p0.top + "C" + (p0.left + t0.x) + "," + (p0.top + t0.y) + "," + (p.left - t.x) + "," + (p.top - t.y) + "," + p.left + "," + p.top)
        }
        if (quad) {
            var lp = points[pi];
            paths.push("M" + p.left + "," + p.top + "Q" + (p.left + t.x * 2 / 3) + "," + (p.top + t.y * 2 / 3) + "," + lp.left + "," + lp.top)
        }
        return paths
    }
    ;
    pv.SvgScene.cardinalTangents = function(points, tension) {
        var tangents = []
          , a = (1 - tension) / 2
          , p0 = points[0]
          , p1 = points[1]
          , p2 = points[2];
        for (var i = 3; i < points.length; i++) {
            tangents.push({
                x: a * (p2.left - p0.left),
                y: a * (p2.top - p0.top)
            });
            p0 = p1;
            p1 = p2;
            p2 = points[i]
        }
        tangents.push({
            x: a * (p2.left - p0.left),
            y: a * (p2.top - p0.top)
        });
        return tangents
    }
    ;
    pv.SvgScene.curveCardinal = function(points, tension) {
        if (points.length <= 2)
            return "";
        return this.curveHermite(points, this.cardinalTangents(points, tension))
    }
    ;
    pv.SvgScene.curveCardinalSegments = function(points, tension) {
        if (points.length <= 2)
            return "";
        return this.curveHermiteSegments(points, this.cardinalTangents(points, tension))
    }
    ;
    pv.SvgScene.monotoneTangents = function(points) {
        var tangents = []
          , d = []
          , m = []
          , dx = []
          , k = 0;
        for (k = 0; k < points.length - 1; k++)
            d[k] = (points[k + 1].top - points[k].top) / (points[k + 1].left - points[k].left);
        m[0] = d[0];
        dx[0] = points[1].left - points[0].left;
        for (k = 1; k < points.length - 1; k++) {
            m[k] = (d[k - 1] + d[k]) / 2;
            dx[k] = (points[k + 1].left - points[k - 1].left) / 2
        }
        m[k] = d[k - 1];
        dx[k] = points[k].left - points[k - 1].left;
        for (k = 0; k < points.length - 1; k++)
            if (d[k] === 0) {
                m[k] = 0;
                m[k + 1] = 0
            }
        for (k = 0; k < points.length - 1; k++) {
            if (Math.abs(m[k]) < 1E-5 || Math.abs(m[k + 1]) < 1E-5)
                continue;
            var ak = m[k] / d[k]
              , bk = m[k + 1] / d[k]
              , s = ak * ak + bk * bk;
            if (s > 9) {
                var tk = 3 / Math.sqrt(s);
                m[k] = tk * ak * d[k];
                m[k + 1] = tk * bk * d[k]
            }
        }
        var len;
        for (var i = 0; i < points.length; i++) {
            len = 1 + m[i] * m[i];
            tangents.push({
                x: dx[i] / 3 / len,
                y: m[i] * dx[i] / 3 / len
            })
        }
        return tangents
    }
    ;
    pv.SvgScene.curveMonotone = function(points) {
        if (points.length <= 2)
            return "";
        return this.curveHermite(points, this.monotoneTangents(points))
    }
    ;
    function drawAreaWithNaNs(scenes) {
        var segments = []
          , segment = [];
        segment.$g = scenes.$g;
        scenes.reduce(function(prev, cur, idx, arr) {
            if (cur.isNaN !== true)
                segment.push(cur);
            if ((cur.isNaN === true || idx === arr.length - 1) && segment.length > 0) {
                segments.push(segment);
                segment = [];
                segment.$g = scenes.$g
            }
            return cur
        }, {});
        var nodes = [];
        segments.forEach(tdg.bind(function(arr) {
            if (arr.length === 1) {
                arr[0].width = 1;
                this.bar(arr);
                nodes = nodes.concat(Array.prototype.slice.call(arr.$g.childNodes))
            }
            if (arr.length > 1) {
                this.areaSegment(arr);
                nodes = nodes.concat(Array.prototype.slice.call(arr.$g.childNodes))
            }
            nodes.forEach(function(node) {
                if (arr.$g === node.parentNode)
                    arr.$g.removeChild(node)
            })
        }, this));
        var groupNodes = Array.prototype.slice.call(scenes.$g.childNodes);
        nodes.forEach(function(node) {
            if (groupNodes.indexOf(node) < 0)
                scenes.$g.appendChild(node)
        })
    }
    pv.SvgScene.curveMonotoneSegments = function(points) {
        if (points.length <= 2)
            return "";
        return this.curveHermiteSegments(points, this.monotoneTangents(points))
    }
    ;
    pv.SvgScene.area = function(scenes) {
        var e = scenes.$g.firstChild;
        if (!scenes.length)
            return e;
        var s = scenes[0];
        if (s.segmented)
            return this.areaSegment(scenes);
        if (!s.visible)
            return e;
        var fill = s.fillStyle
          , stroke = s.strokeStyle;
        if (!fill.opacity && !stroke.opacity)
            return e;
        if (fill.type && fill.type !== "solid")
            pv.SvgScene.addFillStyleDefinition(scenes, fill);
        if (stroke.type && stroke.type !== "solid")
            pv.SvgScene.addFillStyleDefinition(scenes, stroke);
        if (scenes.some(function(el) {
            return el.isNaN === true
        }))
            return drawAreaWithNaNs.call(this, scenes);
        function path(i, j) {
            var p1 = []
              , p2 = [];
            for (var k = j; i <= k; i++,
            j--) {
                var si = scenes[i]
                  , sj = scenes[j]
                  , pi = si.left + "," + si.top
                  , pj = sj.left + sj.width + "," + (sj.top + sj.height);
                if (i < k) {
                    var sk = scenes[i + 1]
                      , sl = scenes[j - 1];
                    switch (s.interpolate) {
                    case "step-before":
                        {
                            pi += "V" + sk.top;
                            pj += "H" + (sl.left + sl.width);
                            break
                        }
                    case "step-after":
                        {
                            pi += "H" + sk.left;
                            pj += "V" + (sl.top + sl.height);
                            break
                        }
                    }
                }
                p1.push(pi);
                p2.push(pj)
            }
            return p1.concat(p2).join("L")
        }
        function pathCurve(i, j) {
            var pointsT = [], pointsB = [], pathT, pathB;
            for (var k = j; i <= k; i++,
            j--) {
                var sj = scenes[j];
                pointsT.push(scenes[i]);
                pointsB.push({
                    left: sj.left + sj.width,
                    top: sj.top + sj.height
                })
            }
            if (s.interpolate === "basis") {
                pathT = pv.SvgScene.curveBasis(pointsT);
                pathB = pv.SvgScene.curveBasis(pointsB)
            } else if (s.interpolate === "cardinal") {
                pathT = pv.SvgScene.curveCardinal(pointsT, s.tension);
                pathB = pv.SvgScene.curveCardinal(pointsB, s.tension)
            } else {
                pathT = pv.SvgScene.curveMonotone(pointsT);
                pathB = pv.SvgScene.curveMonotone(pointsB)
            }
            return pointsT[0].left + "," + pointsT[0].top + pathT + "L" + pointsB[0].left + "," + pointsB[0].top + pathB
        }
        var i, j, d = [], si, sj;
        for (i = 0; i < scenes.length; i++) {
            si = scenes[i];
            if (!si.width && !si.height)
                continue;
            for (j = i + 1; j < scenes.length; j++) {
                sj = scenes[j];
                if (!sj.width && !sj.height)
                    break
            }
            if (i && s.interpolate !== "step-after")
                i--;
            if (j < scenes.length && s.interpolate !== "step-before")
                j++;
            d.push((j - i > 2 && (s.interpolate === "basis" || s.interpolate === "cardinal" || s.interpolate === "monotone") ? pathCurve : path)(i, j - 1));
            i = j - 1
        }
        if (!d.length)
            return e;
        e = this.expect(e, "path", {
            "class": s.className || null,
            display: s.display || null,
            "shape-rendering": s.antialias ? null : "crispEdges",
            "pointer-events": s.events,
            cursor: s.cursor,
            d: "M" + d.join("ZM") + "Z",
            fill: fill.color,
            "fill-opacity": fill.opacity || null,
            stroke: stroke.color,
            "stroke-opacity": stroke.opacity || null,
            "stroke-width": stroke.opacity ? s.lineWidth / this.scale : null,
            "stroke-dasharray": dashLookup(s.dashStyle) || null
        });
        return this.append(e, scenes, 0)
    }
    ;
    pv.SvgScene.areaSegment = function(scenes) {
        var i, n, si, sj;
        var e = scenes.$g.firstChild, s = scenes[0], pathsT, pathsB;
        if (s.interpolate === "basis" || s.interpolate === "cardinal" || s.interpolate === "monotone") {
            var pointsT = []
              , pointsB = [];
            for (i = 0,
            n = scenes.length; i < n; i++) {
                sj = scenes[n - i - 1];
                pointsT.push(scenes[i]);
                pointsB.push({
                    left: sj.left + sj.width,
                    top: sj.top + sj.height
                })
            }
            if (s.interpolate === "basis") {
                pathsT = this.curveBasisSegments(pointsT);
                pathsB = this.curveBasisSegments(pointsB)
            } else if (s.interpolate === "cardinal") {
                pathsT = this.curveCardinalSegments(pointsT, s.tension);
                pathsB = this.curveCardinalSegments(pointsB, s.tension)
            } else {
                pathsT = this.curveMonotoneSegments(pointsT);
                pathsB = this.curveMonotoneSegments(pointsB)
            }
        }
        for (i = 0,
        n = scenes.length - 1; i < n; i++) {
            var s1 = scenes[i]
              , s2 = scenes[i + 1];
            if (!s1.visible || !s2.visible)
                continue;
            var fill = s1.fillStyle
              , stroke = s1.strokeStyle;
            if (!fill.opacity && !stroke.opacity)
                continue;
            var d;
            if (pathsT) {
                var pathT = pathsT[i]
                  , pathB = "L" + pathsB[n - i - 1].substr(1);
                d = pathT + pathB + "Z"
            } else {
                si = s1;
                sj = s2;
                switch (s1.interpolate) {
                case "step-before":
                    si = s2;
                    break;
                case "step-after":
                    sj = s1;
                    break
                }
                d = "M" + s1.left + "," + si.top + "L" + s2.left + "," + sj.top + "L" + (s2.left + s2.width) + "," + (sj.top + sj.height) + "L" + (s1.left + s1.width) + "," + (si.top + si.height) + "Z"
            }
            e = this.expect(e, "path", {
                "class": s1.className || null,
                "shape-rendering": s1.antialias ? null : "crispEdges",
                "pointer-events": s1.events,
                cursor: s1.cursor,
                d: d,
                fill: fill.color,
                "fill-opacity": fill.opacity || null,
                stroke: stroke.color,
                "stroke-opacity": stroke.opacity || null,
                "stroke-width": stroke.opacity ? s1.lineWidth / this.scale : null
            });
            e = this.append(e, scenes, i)
        }
        return e
    }
    ;
    pv.SvgScene.bar = function(scenes) {
        var e = scenes.$g.firstChild;
        function appendShadowPass(obj, c, s, shadowClsname, xOffset, yOffset, rx, ry, color, opacity, extraWidth, extraHeight) {
            var shadowPass = obj.expect(null, "rect", {
                "class": shadowClsname || null,
                "shape-rendering": null,
                "pointer-events": s.events,
                cursor: s.cursor,
                x: s.left + xOffset,
                y: s.top + yOffset,
                width: Math.max(1E-10, s.width + extraWidth),
                height: Math.max(1E-10, s.height + extraHeight),
                fill: color,
                "fill-opacity": opacity
            });
            c.appendChild(shadowPass);
            return shadowPass
        }
        var i, s, fill, stroke;
        var xRound = 0
          , yRound = 0
          , xOffset = 2
          , yOffset = 2;
        for (i = 0; i < scenes.length; i++) {
            s = scenes[i];
            if (!s.shadow)
                continue;
            if (!s.visible)
                continue;
            fill = s.fillStyle;
            stroke = s.strokeStyle;
            if (!fill.opacity && !stroke.opacity)
                continue;
            var shadowClsname;
            var clsname = s.className;
            if (clsname) {
                var pos = clsname.indexOf("!m");
                shadowClsname = clsname.substring(0, pos) + "!mshadow"
            }
            var c = this.expect(null, "g", {
                "class": "shadows"
            });
            if (s.shadow === "parent")
                scenes.parent.$g.insertBefore(c, scenes.parent.$g.firstChild);
            else
                scenes.$g.insertBefore(c, scenes.$g.firstChild);
            var darkWidth = 0;
            appendShadowPass(this, c, s, shadowClsname, xOffset - 2, yOffset - 2, xRound, yRound, "black", .1, darkWidth + 4, 4);
            appendShadowPass(this, c, s, shadowClsname, xOffset - 1, yOffset - 1, xRound, yRound, "black", .1, darkWidth + 2, 2);
            appendShadowPass(this, c, s, shadowClsname, xOffset, yOffset, xRound, yRound, "black", .08, darkWidth, 0)
        }
        for (i = 0; i < scenes.length; i++) {
            s = scenes[i];
            if (!s.visible)
                continue;
            fill = s.fillStyle;
            stroke = s.strokeStyle;
            if (!fill.opacity && !stroke.opacity)
                continue;
            if (fill.type && fill.type !== "solid")
                pv.SvgScene.addFillStyleDefinition(scenes, fill);
            if (stroke.type && stroke.type !== "solid")
                pv.SvgScene.addFillStyleDefinition(scenes, stroke);
            e = this.expect(e, "rect", {
                "class": s.className || null,
                display: s.display || null,
                "shape-rendering": s.antialias ? null : "crispEdges",
                "pointer-events": s.events,
                cursor: s.cursor,
                x: s.left,
                y: s.top,
                rx: s.cornerRadius || null,
                ry: s.cornerRadius || null,
                width: Math.max(1E-10, s.width),
                height: Math.max(1E-10, s.height),
                fill: fill.color,
                "fill-opacity": fill.opacity || null,
                stroke: stroke.color,
                "stroke-opacity": stroke.opacity || null,
                "stroke-width": stroke.opacity ? s.lineWidth / this.scale : null,
                "stroke-dasharray": dashLookup(s.dashStyle) || null
            });
            e = this.append(e, scenes, i)
        }
        return e
    }
    ;
    pv.SvgScene.trapezoid = function(scenes) {
        var e = scenes.$g.firstChild;
        for (var i = 0; i < scenes.length; i++) {
            var s = scenes[i];
            if (!s.visible)
                continue;
            var fill = s.fillStyle
              , stroke = s.strokeStyle;
            if (!fill.opacity && !stroke.opacity)
                continue;
            if (fill.type && fill.type !== "solid")
                pv.SvgScene.addFillStyleDefinition(scenes, fill);
            if (stroke.type && stroke.type !== "solid")
                pv.SvgScene.addFillStyleDefinition(scenes, stroke);
            var path = "M" + s.left + "," + s.top + "h" + s.width + "l" + -s.inset + "," + s.height + "h" + -(s.width - s.inset - s.inset) + "Z";
            e = this.expect(e, "path", {
                d: path,
                "class": s.className || null,
                "shape-rendering": s.antialias ? null : "crispEdges",
                "pointer-events": s.events,
                cursor: s.cursor,
                fill: fill.color,
                "fill-opacity": fill.opacity || null,
                stroke: stroke.color,
                "stroke-opacity": stroke.opacity || null,
                "stroke-width": stroke.opacity ? s.lineWidth / this.scale : null,
                "stroke-dasharray": dashLookup(s.dashStyle) || null
            });
            e = this.append(e, scenes, i)
        }
        return e
    }
    ;
    pv.SvgScene.dot = function(scenes) {
        var e = scenes.$g.firstChild;
        function appendShadowPass(obj, c, s, shadowClsname, xOffset, yOffset, path, color, opacity, extraWidth) {
            var shadowPass = null;
            var svg1 = {
                "class": shadowClsname || null,
                "shape-rendering": null,
                "pointer-events": s.events,
                cursor: s.cursor,
                transform: "translate(" + (s.left + xOffset + extraWidth) + "," + (s.top + yOffset + extraWidth) + ")",
                "tdg:radius": s.includeRadius ? s.innerRadius : null,
                fill: color,
                "fill-opacity": opacity,
                stroke: null,
                "stroke-opacity": null,
                "stroke-width": null,
                "stroke-dasharray": null
            };
            if (path) {
                if (s.angle)
                    svg1.transform += " rotate(" + 180 * s.angle / Math.PI + ")";
                svg1.d = path;
                shadowPass = obj.expect(null, "path", svg1)
            } else {
                svg1.cx = 0;
                svg1.cy = 0;
                svg1.r = s.radius;
                shadowPass = obj.expect(null, "circle", svg1)
            }
            c.appendChild(shadowPass);
            return shadowPass
        }
        var i, s, fill, stroke;
        var xOffset = 0
          , yOffset = 0;
        for (i = 0; i < scenes.length; i++) {
            s = scenes[i];
            if (!s.shadow)
                continue;
            if (!s.visible)
                continue;
            fill = s.fillStyle;
            stroke = s.strokeStyle;
            if (!fill.opacity && !stroke.opacity)
                continue;
            var shadowClsname;
            var clsname = s.className;
            if (clsname) {
                var pos = clsname.indexOf("!m");
                shadowClsname = clsname.substring(0, pos) + "!mshadow"
            }
            var c = this.expect(null, "g", {
                "class": "shadows"
            });
            if (s.shadow === "parent")
                scenes.parent.$g.insertBefore(c, scenes.parent.$g.firstChild);
            else
                scenes.$g.insertBefore(c, scenes.$g.firstChild);
            var path1 = pv.SvgScene.getPath(s);
            var darkWidth = 1;
            appendShadowPass(this, c, s, shadowClsname, xOffset, yOffset, path1, "black", .05, darkWidth + 2);
            appendShadowPass(this, c, s, shadowClsname, xOffset, yOffset, path1, "black", .1, darkWidth + 1);
            appendShadowPass(this, c, s, shadowClsname, xOffset, yOffset, path1, "black", .15, darkWidth)
        }
        for (i = 0; i < scenes.length; i++) {
            s = scenes[i];
            if (!s.visible)
                continue;
            fill = s.fillStyle;
            stroke = s.strokeStyle;
            if (!fill.opacity && !stroke.opacity)
                continue;
            if (fill.type && fill.type !== "solid")
                pv.SvgScene.addFillStyleDefinition(scenes, fill);
            if (stroke.type && stroke.type !== "solid")
                pv.SvgScene.addFillStyleDefinition(scenes, stroke);
            var path = pv.SvgScene.getPath(s);
            var isStraightEdged = !pv.SvgScene.shapeRequiresAntiAlias(s.shape) && (isNaN(s.angle) || s.angle === 0);
            var lineWidth = s.lineWidth / this.scale;
            var svg = {
                display: s.display || null,
                "class": s.className || null,
                "shape-rendering": isStraightEdged ? "crispEdges" : s.antialias ? null : "crispEdges",
                "pointer-events": s.events,
                cursor: s.cursor,
                "tdg:radius": s.includeRadius ? s.radius : null,
                fill: fill.color,
                "fill-opacity": fill.opacity || null,
                stroke: lineWidth ? stroke.color : null,
                "stroke-opacity": stroke.opacity || null,
                "stroke-width": stroke.opacity && lineWidth ? lineWidth : null,
                "stroke-dasharray": dashLookup(s.dashStyle) || null
            };
            if (s.shape === "gaugeBorder") {
                svg["fill-rule"] = "evenodd";
                svg["stroke-linejoin"] = "round"
            }
            svg.transform = "translate(" + s.left + "," + s.top + ")";
            if (path) {
                if (s.angle)
                    svg.transform += " rotate(" + 180 * s.angle / Math.PI + ")";
                svg.d = path;
                e = this.expect(e, "path", svg)
            } else {
                svg.cx = 0;
                svg.cy = 0;
                svg.r = s.radius;
                e = this.expect(e, "circle", svg)
            }
            e = this.append(e, scenes, i)
        }
        return e
    }
    ;
    pv.SvgScene.image = function(scenes) {
        var e = scenes.$g.firstChild;
        for (var i = 0; i < scenes.length; i++) {
            var s = scenes[i];
            if (!s.visible)
                continue;
            e = this.fill(e, scenes, i);
            if (s.image) {
                e = this.expect(e, "foreignObject", {
                    cursor: s.cursor,
                    x: s.left,
                    y: s.top,
                    width: s.width,
                    height: s.height
                });
                var c = e.firstChild || e.appendChild(document.createElementNS(this.xhtml, "canvas"));
                c.$scene = {
                    scenes: scenes,
                    index: i
                };
                c.style.width = s.width;
                c.style.height = s.height;
                c.width = s.imageWidth;
                c.height = s.imageHeight;
                c.getContext("2d").putImageData(s.image, 0, 0)
            } else {
                e = this.expect(e, "image", {
                    preserveAspectRatio: "none",
                    cursor: s.cursor,
                    x: s.left,
                    y: s.top,
                    width: s.width,
                    height: s.height
                });
                e.setAttributeNS(this.xlink, "href", s.url)
            }
            e = this.append(e, scenes, i);
            e = this.stroke(e, scenes, i)
        }
        return e
    }
    ;
    function getSVGContainer(scenes) {
        var parent = scenes;
        while (parent.parent)
            parent = parent.parent;
        return parent.$g
    }
    function createHTMLLabelContainer(scenes) {
        var svg = getSVGContainer(scenes);
        var rootContainer = svg.parentNode;
        var div = document.createElement("div");
        div.style.display = "block";
        div.style.position = "relative";
        div.style.border = "none";
        div.style.fontSize = "10px";
        div.style.fontFamily = "sans-serif";
        div.style.zIndex = 10;
        div.setAttribute("class", "htmlLabelHolder");
        rootContainer.insertBefore(div, svg);
        return div
    }
    function transformToElement(el, target) {
        var transform = {
            x: 0,
            y: 0
        };
        while (el && el !== target) {
            if (el.transform.baseVal.numberOfItems > 0) {
                transform.x += el.transform.baseVal.getItem(0).matrix.e;
                transform.y += el.transform.baseVal.getItem(0).matrix.f
            }
            el = el.parentNode
        }
        return transform
    }
    pv.SvgScene.labelHTML = function(scenes, s) {
        var useForeignObject = document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Extensibility", "1.1");
        if (!s.visible)
            return;
        var fill = s.textStyle;
        if (!fill.opacity || !s.text)
            return;
        var lblSize = tdgchart.measureLabel(s.text, s.font || null);
        var x = 0
          , y = 0;
        switch (s.textBaseline) {
        case "middle":
            y = s.textMargin - lblSize.height / 2 - 3;
            break;
        case "top":
            y = s.textMargin - 3.5;
            break;
        case "bottom":
            y = s.textMargin - lblSize.height - 3;
            break
        }
        switch (s.textAlign) {
        case "right":
            x = s.textMargin * -1 - lblSize.width;
            break;
        case "center":
            x = s.textMargin - lblSize.width / 2 - 3;
            break;
        case "left":
            x = s.textMargin;
            break
        }
        if (useForeignObject) {
            var e = this.expect(e, "foreignObject", {
                "pointer-events": s.events,
                cursor: s.cursor,
                "class": s.className || null,
                display: s.display || null,
                x: s.textAngle ? x : x + s.left,
                y: s.textAngle ? y : y + s.top,
                width: lblSize.width + 1,
                height: lblSize.height + 1,
                transform: (s.textAngle ? "translate(" + s.left + "," + s.top + ")" : "") + (s.textAngle ? " rotate(" + 180 * s.textAngle / Math.PI + ")" : "") + (this.scale !== 1 ? " scale(" + 1 / this.scale + ")" : "")
            }, {
                font: s.font,
                color: fill.color,
                opacity: fill.opacity || null,
                "text-shadow": s.textShadow,
                "text-decoration": s.textDecoration
            });
            var objectBody = document.createElementNS(this.xhtml, "body");
            objectBody.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
            objectBody.setAttribute("marginWidth", "0");
            objectBody.setAttribute("marginHeight", "0");
            objectBody.innerHTML = s.text;
            e.appendChild(objectBody);
            this.append(e, scenes, 0)
        } else {
            var svg = getSVGContainer(scenes);
            var localTransform = transformToElement(scenes.$g, svg);
            var container = svg.parentNode.getElementsByClassName("htmlLabelHolder")[0];
            if (!container)
                container = createHTMLLabelContainer(scenes);
            var lbl = document.createElement("div");
            lbl.setAttribute("class", s.className || null);
            if (s.title && typeof pv._useHTMLtooltips !== "undefined" && pv._useHTMLtooltips)
                lbl.setAttribute("tdgtitle", s.title);
            if (s.textAngle)
                lbl.style.transform = "rotate(" + tdg.degrees(s.textAngle) + "deg)";
            lbl.style.cursor = s.cursor || null;
            lbl.style.display = "inline-block";
            lbl.style.position = "absolute";
            lbl.style.left = x + s.left + localTransform.x + "px";
            lbl.style.top = y + s.top + localTransform.y + "px";
            lbl.style.font = s.font;
            lbl.style.color = fill.color;
            lbl.innerHTML = s.text;
            container.appendChild(lbl)
        }
    }
    ;
    pv.SvgScene.multilineLabel = function(scenes, s) {
        var fill = s.textStyle;
        if (!fill.opacity || !s.text)
            return;
        var x = 0
          , y = 0
          , dy = 0
          , anchor = "start";
        var labelHeight = tdgchart.measureLabel(s.text, s.font || null).height;
        var splitLabel = s.text.split("\n");
        var lineSize = labelHeight / splitLabel.length;
        switch (s.textBaseline) {
        case "middle":
            dy = "1em";
            y = -labelHeight / 2;
            break;
        case "top":
            dy = ".71em";
            y = s.textMargin;
            break;
        case "bottom":
            y = lineSize - labelHeight - s.textMargin;
            break
        }
        switch (s.textAlign) {
        case "right":
            anchor = "end";
            x = s.textMargin * -1;
            break;
        case "center":
            anchor = "middle";
            break;
        case "left":
            x = s.textMargin;
            break
        }
        var e = this.expect(null, "text", {
            "pointer-events": s.events,
            cursor: s.cursor,
            "class": s.className || null,
            display: s.display || null,
            x: x,
            y: y,
            dy: dy,
            transform: "translate(" + s.left + "," + s.top + ")" + (s.textAngle ? " rotate(" + 180 * s.textAngle / Math.PI + ")" : "") + (this.scale !== 1 ? " scale(" + 1 / this.scale + ")" : ""),
            fill: fill.color,
            "fill-opacity": fill.opacity || null,
            "text-anchor": anchor
        }, {
            font: s.font,
            "text-shadow": s.textShadow,
            "text-decoration": s.textDecoration
        });
        for (var i = 0; i < splitLabel.length; i++) {
            var lbl = this.expect(null, "tspan", {
                x: x,
                y: y + lineSize * i,
                dy: dy
            });
            lbl.appendChild(document.createTextNode(splitLabel[i]));
            e.appendChild(lbl)
        }
        e = this.append(e, scenes, 0)
    }
    ;
    function minus(d) {
        return typeof d !== "string" ? -d : d.charAt(0) === "-" ? d.slice(1) : "-" + d
    }
    pv.SvgScene.label = function(scenes) {
        var e = scenes.$g.firstChild;
        for (var i = 0; i < scenes.length; i++) {
            var s = scenes[i];
            if (!s.visible)
                continue;
            var fill = s.textStyle;
            if (!fill.opacity || !s.text)
                continue;
            if (tdg.textContainsHTML(s.text)) {
                pv.SvgScene.labelHTML(scenes, s);
                continue
            }
            if (s.text.indexOf("\n") >= 0) {
                pv.SvgScene.multilineLabel(scenes, s);
                continue
            }
            var x = 0
              , y = 0
              , dy = 0
              , anchor = "start";
            var text = s.text.replace(/\n/gi, " ");
            switch (s.textBaseline) {
            case "middle":
                dy = ".35em";
                break;
            case "top":
                dy = ".71em";
                y = s.textMargin;
                break;
            case "bottom":
                y = minus(s.textMargin);
                break
            }
            switch (s.textAlign) {
            case "right":
                anchor = "end";
                x = s.textMargin * -1;
                break;
            case "center":
                anchor = "middle";
                break;
            case "left":
                x = s.textMargin;
                break
            }
            e = this.expect(e, "text", {
                "pointer-events": s.events,
                cursor: s.cursor,
                "class": s.className || null,
                display: s.display || null,
                x: x,
                y: y,
                dy: dy,
                transform: "translate(" + s.left + "," + s.top + ")" + (s.textAngle ? " rotate(" + 180 * s.textAngle / Math.PI + ")" : "") + (this.scale !== 1 ? " scale(" + 1 / this.scale + ")" : ""),
                fill: fill.color,
                "fill-opacity": fill.opacity || null,
                "text-anchor": anchor
            }, {
                font: s.font,
                "text-shadow": s.textShadow,
                "text-decoration": s.textDecoration
            });
            if (e.firstChild)
                e.firstChild.nodeValue = text;
            else
                e.appendChild(document.createTextNode(text));
            e = this.append(e, scenes, i)
        }
        return e
    }
    ;
    pv.SvgScene.line = function(scenes) {
        var e = scenes.$g.firstChild;
        if (scenes.length < 2)
            return e;
        var s = scenes[0];
        if (s.segmented)
            return this.lineSegment(scenes);
        function appendShadowPass(obj, c, s, shadowClsname, xOffset, yOffset, path, color, opacity, width) {
            var shadowPass = obj.expect(e, "path", {
                "class": shadowClsname || null,
                "shape-rendering": null,
                "pointer-events": s.events,
                cursor: s.cursor,
                transform: "translate(" + xOffset + "," + yOffset + ")",
                d: path,
                stroke: color,
                "stroke-opacity": opacity,
                "stroke-width": width,
                "stroke-linejoin": s.lineJoin,
                "stroke-dasharray": dashLookup(s.dashStyle) || null
            });
            c.appendChild(shadowPass);
            return shadowPass
        }
        if (!s.visible)
            return e;
        var d, i;
        var fill = s.fillStyle
          , stroke = s.strokeStyle;
        if (!fill.opacity && !stroke.opacity)
            return e;
        if (s.shadow && s.shadow != null) {
            d = "M" + s.left + "," + s.top;
            var shadowClsname;
            var clsname = s.className;
            if (clsname) {
                var pos = clsname.indexOf("!m");
                shadowClsname = clsname.substring(0, pos) + "!mshadow"
            }
            var c = this.expect(null, "g", {
                "class": "shadows"
            });
            if (s.shadow === "parent")
                scenes.parent.$g.insertBefore(c, scenes.parent.$g.firstChild);
            else
                scenes.$g.insertBefore(c, scenes.$g.firstChild);
            if (scenes.length > 2 && (s.interpolate === "basis" || s.interpolate === "cardinal" || s.interpolate === "monotone"))
                switch (s.interpolate) {
                case "basis":
                    d += this.curveBasis(scenes);
                    break;
                case "cardinal":
                    d += this.curveCardinal(scenes, s.tension);
                    break;
                case "monotone":
                    d += this.curveMonotone(scenes);
                    break
                }
            else {
                for (i = 1; i < scenes.length; i++)
                    d += this.pathSegment(scenes[i - 1], scenes[i]);
                if (s.interpolate === "baselineDescender")
                    if (scenes[0].tension === Number.POSITIVE_INFINITY)
                        d += "H0";
                    else
                        d += (scenes[0].tension >= 0 ? "V" : "H") + Math.abs(scenes[0].tension)
            }
            var xoffset = 2;
            var yoffset = 2;
            var darkWidth = 0;
            appendShadowPass(this, c, s, shadowClsname, xoffset, yoffset, d, "black", .1, s.lineWidth + darkWidth + 4);
            appendShadowPass(this, c, s, shadowClsname, xoffset, yoffset, d, "black", .1, s.lineWidth + darkWidth + 2);
            appendShadowPass(this, c, s, shadowClsname, xoffset, yoffset, d, "black", .08, s.lineWidth + darkWidth)
        }
        if (!s.visible)
            return e;
        fill = s.fillStyle;
        stroke = s.strokeStyle;
        if (!fill.opacity && !stroke.opacity)
            return e;
        if (fill.type && fill.type !== "solid")
            pv.SvgScene.addFillStyleDefinition(scenes, fill);
        if (stroke.type && stroke.type !== "solid")
            pv.SvgScene.addFillStyleDefinition(scenes, stroke);
        d = "M" + s.left + "," + s.top;
        if (scenes.length > 2 && (s.interpolate === "basis" || s.interpolate === "cardinal" || s.interpolate === "monotone"))
            switch (s.interpolate) {
            case "basis":
                d += this.curveBasis(scenes);
                break;
            case "cardinal":
                d += this.curveCardinal(scenes, s.tension);
                break;
            case "monotone":
                d += this.curveMonotone(scenes);
                break
            }
        else {
            for (i = 1; i < scenes.length; i++)
                d += this.pathSegment(scenes[i - 1], scenes[i]);
            if (s.interpolate === "baselineDescender")
                if (scenes[0].tension === Number.POSITIVE_INFINITY)
                    d += "H0";
                else
                    d += (scenes[0].tension >= 0 ? "V" : "H") + Math.abs(scenes[0].tension)
        }
        e = this.expect(e, "path", {
            "class": s.className || null,
            "shape-rendering": s.antialias ? null : "crispEdges",
            "pointer-events": s.events,
            cursor: s.cursor,
            d: d,
            fill: fill.color,
            "fill-opacity": fill.opacity || null,
            stroke: stroke.color,
            "stroke-opacity": stroke.opacity || null,
            "stroke-width": stroke.opacity ? s.lineWidth / this.scale : null,
            "stroke-linejoin": s.lineJoin,
            "stroke-dasharray": dashLookup(s.dashStyle) || null
        });
        return this.append(e, scenes, 0)
    }
    ;
    pv.SvgScene.lineSegment = function(scenes) {
        var e = scenes.$g.firstChild;
        function appendShadowPass(obj, c, s, shadowClsname, xOffset, yOffset, path, color, opacity, width) {
            var shadowPass = obj.expect(e, "path", {
                "class": shadowClsname || null,
                "shape-rendering": null,
                "pointer-events": s.events,
                cursor: s.cursor,
                transform: "translate(" + xOffset + "," + yOffset + ")",
                d: path,
                stroke: color,
                "stroke-opacity": opacity,
                "stroke-width": width,
                "stroke-linejoin": s.lineJoin,
                "stroke-dasharray": dashLookup(s.dashStyle) || null
            });
            c.appendChild(shadowPass);
            return shadowPass
        }
        var s = scenes[0];
        var paths;
        switch (s.interpolate) {
        case "basis":
            paths = this.curveBasisSegments(scenes);
            break;
        case "cardinal":
            paths = this.curveCardinalSegments(scenes, s.tension);
            break;
        case "monotone":
            paths = this.curveMonotoneSegments(scenes);
            break
        }
        var i, d, s1, s2, fill, stroke;
        var xoffset = 1
          , yoffset = 1;
        var n = scenes.length - 1;
        for (i = 0; i < n; i++) {
            s1 = scenes[i];
            s2 = scenes[i + 1];
            if (!s1.visible || !s2.visible)
                continue;
            if (!s1.shadow || !s2.shadow)
                continue;
            fill = s1.fillStyle;
            stroke = s1.strokeStyle;
            if (!fill.opacity && !stroke.opacity)
                continue;
            var shadowClsname;
            var clsname = s1.className;
            if (clsname) {
                var pos = clsname.indexOf("!m");
                shadowClsname = clsname.substring(0, pos) + "!mshadow"
            }
            d = "M" + s1.left + "," + s1.top + this.pathSegment(s1, s2);
            if (s1.interpolate === "baselineDescender" && i === scenes.length - 2)
                d += "M" + s2.left + "," + s2.top + (s2.tension >= 0 ? "V" : "H") + Math.abs(s2.tension);
            var c = this.expect(null, "g", {
                "class": "shadows"
            });
            if (s1.shadow === "parent")
                scenes.parent.$g.insertBefore(c, scenes.parent.$g.firstChild);
            else
                scenes.$g.insertBefore(c, scenes.$g.firstChild);
            var darkWidth = 0;
            appendShadowPass(this, c, s1, shadowClsname, xoffset, yoffset, d, "black", .05, s1.lineWidth + darkWidth + 2);
            appendShadowPass(this, c, s1, shadowClsname, xoffset, yoffset, d, "black", .1, s1.lineWidth + darkWidth + 1);
            appendShadowPass(this, c, s1, shadowClsname, xoffset, yoffset, d, "black", .15, s1.lineWidth + darkWidth)
        }
        var totallength = 0;
        for (i = 0,
        n = scenes.length - 1; i < n; i++) {
            s1 = scenes[i];
            s2 = scenes[i + 1];
            if (!s1.visible || !s2.visible)
                continue;
            fill = tdg.color.transparent;
            stroke = s1.strokeStyle;
            if (!stroke.opacity)
                continue;
            if (fill.type && fill.type !== "solid")
                pv.SvgScene.addFillStyleDefinition(scenes, fill);
            if (stroke.type && stroke.type !== "solid")
                pv.SvgScene.addFillStyleDefinition(scenes, stroke);
            if (paths)
                d = paths[i];
            else
                d = "M" + s1.left + "," + s1.top + this.pathSegment(s1, s2);
            if (s1.interpolate === "baselineDescender" && i === scenes.length - 2)
                if (scenes[0].tension === Number.POSITIVE_INFINITY)
                    d += "H0";
                else
                    d += "M" + s2.left + "," + s2.top + (s2.tension >= 0 ? "V" : "H") + Math.abs(s2.tension);
            e = this.expect(e, "path", {
                "class": s1.className || null,
                "shape-rendering": s1.antialias ? null : "crispEdges",
                "pointer-events": s1.events,
                cursor: s1.cursor,
                d: d,
                fill: fill.color,
                "fill-opacity": fill.opacity || null,
                stroke: stroke.color,
                "stroke-opacity": stroke.opacity || null,
                "stroke-width": stroke.opacity ? s1.lineWidth / this.scale : null,
                "stroke-dasharray": dashLookup(s1.dashStyle) || null,
                "stroke-dashoffset": s1.dashStyle ? totallength : null,
                "stroke-linejoin": s1.lineJoin
            });
            e = this.append(e, scenes, i);
            if (s1.dashStyle)
                totallength += s1.top === s2.top || s1.left === s2.left ? Math.abs(s2.top - s1.top + s2.left - s1.left) : Math.sqrt((s2.top - s1.top) * (s2.top - s1.top) + (s2.left - s1.left) * (s2.left - s1.left))
        }
        return e
    }
    ;
    pv.SvgScene.pathSegment = function(s1, s2) {
        var l = 1;
        switch (s1.interpolate) {
        case "polar-reverse":
            l = 0;
        case "polar":
            {
                var dx = s2.left - s1.left
                  , dy = s2.top - s1.top
                  , e = 1 - s1.eccentricity
                  , r = Math.sqrt(dx * dx + dy * dy) / (2 * e);
                if (e <= 0 || e > 1)
                    break;
                return "A" + r + "," + r + " 0 0," + l + " " + s2.left + "," + s2.top
            }
        case "step-before":
            return "V" + s2.top + "H" + s2.left;
        case "step-after":
            return "H" + s2.left + "V" + s2.top;
        case "step-between":
            return "H" + (s1.left + s2.left) / 2 + "V" + s2.top + "H" + s2.left;
        case "baselineDescender":
            if (s1.tension === Number.POSITIVE_INFINITY)
                return "H0 M" + s2.left + "," + s2.top;
            return (s1.tension >= 0 ? "V" : "H") + Math.abs(s1.tension) + "M" + s2.left + "," + s2.top
        }
        return "L" + s2.left + "," + s2.top
    }
    ;
    pv.SvgScene.lineIntersect = function(o1, d1, o2, d2) {
        return o1.plus(d1.times(o2.minus(o1).dot(d2.perp()) / d1.dot(d2.perp())))
    }
    ;
    pv.SvgScene.pathJoin = function(s0, s1, s2, s3) {
        var p1 = pv.vector(s1.left, s1.top)
          , p2 = pv.vector(s2.left, s2.top)
          , p = p2.minus(p1)
          , v = p.perp().norm()
          , w = v.times(s1.lineWidth / (2 * this.scale))
          , a = p1.plus(w)
          , b = p2.plus(w)
          , c = p2.minus(w)
          , d = p1.minus(w);
        if (s0 && s0.visible) {
            var v1 = p1.minus(s0.left, s0.top).perp().norm().plus(v);
            d = this.lineIntersect(p1, v1, d, p);
            a = this.lineIntersect(p1, v1, a, p)
        }
        if (s3 && s3.visible) {
            var v2 = pv.vector(s3.left, s3.top).minus(p2).perp().norm().plus(v);
            c = this.lineIntersect(p2, v2, c, p);
            b = this.lineIntersect(p2, v2, b, p)
        }
        return "M" + a.x + "," + a.y + "L" + b.x + "," + b.y + " " + c.x + "," + c.y + " " + d.x + "," + d.y
    }
    ;
    pv.SvgScene.panel = function(scenes) {
        function addShadowFilter(scenes, shadow) {
            var newShadow = {};
            newShadow.angle = typeof shadow.angle === "undefined" ? 225 : Math.round(shadow.angle);
            newShadow.distance = typeof shadow.distance === "undefined" ? 8 : Math.round(shadow.distance);
            newShadow.blur = typeof shadow.blur === "undefined" ? 5 : Math.round(shadow.blur * 30);
            var shadowID = "shadow_" + newShadow.angle + "_" + newShadow.distance + "_" + newShadow.blur;
            while (scenes.hasOwnProperty("parent"))
                scenes = scenes.parent;
            var defs = scenes.$g.getElementsByTagName("defs")[0];
            if (defs.querySelector("#" + shadowID))
                return shadowID;
            var shadowFilter = defs.appendChild(this.expect(null, "filter", {
                id: shadowID
            }));
            var blurFilter = this.expect(null, "feGaussianBlur", {
                "in": "SourceAlpha",
                stdDeviation: newShadow.blur + "",
                result: "blur"
            });
            var angle = tdg.radians(newShadow.angle) + Math.PI / 2;
            var offsetFilter = this.expect(null, "feOffset", {
                "in": "blur",
                dx: newShadow.distance * Math.cos(angle) + "",
                dy: newShadow.distance * Math.sin(angle) + "",
                result: "offsetBlur"
            });
            shadowFilter.appendChild(blurFilter);
            shadowFilter.appendChild(offsetFilter);
            var merge = shadowFilter.appendChild(this.create("feMerge"));
            merge.appendChild(this.expect(null, "feMergeNode", {
                "in": "offsetBlur"
            }));
            merge.appendChild(this.expect(null, "feMergeNode", {
                "in": "SourceGraphic"
            }));
            return shadowID
        }
        var g = scenes.$g
          , e = g && g.firstChild;
        for (var i = 0; i < scenes.length; i++) {
            var j, s = scenes[i];
            if (!s.visible)
                continue;
            if (!scenes.parent) {
                if (g && g.parentNode !== s.canvas) {
                    g = s.canvas.firstChild;
                    e = g && g.firstChild
                }
                if (!g) {
                    g = this.create("svg");
                    g.setAttribute("xmlns", pv.SvgScene.svg);
                    g.setAttribute("font-size", "10px");
                    g.setAttribute("font-family", "sans-serif");
                    g.setAttribute("fill", "none");
                    g.setAttribute("stroke", "none");
                    g.setAttribute("stroke-width", 1.5);
                    g.setAttribute("style", "display: block");
                    g.setAttribute("overflow", "hidden");
                    for (j = 0; j < this.events.length; j++)
                        g.addEventListener(this.events[j], this.dispatch, false);
                    e = g.firstChild;
                    var titleID, descID;
                    if (s.title) {
                        titleID = s.canvas.id + "_aria_title";
                        var title = this.expect(null, "title", {
                            id: titleID
                        });
                        title.textContent = s.title;
                        title.setAttribute("aria-hidden", "true");
                        g.setAttribute("aria-labelledby", titleID);
                        g.appendChild(title)
                    }
                    if (s.desc) {
                        descID = s.canvas.id + "_aria_desc";
                        var desc = this.expect(null, "desc", {
                            id: descID
                        });
                        desc.textContent = s.desc;
                        desc.setAttribute("aria-hidden", "true");
                        g.setAttribute("aria-describedby", descID);
                        g.appendChild(desc)
                    }
                    g.appendChild(this.create("defs"));
                    g.appendChild(this.expect(null, "rect", {
                        "pointer-events": "all",
                        "class": "eventCatcher",
                        width: s.width + s.left + s.right,
                        height: s.height + s.top + s.bottom
                    }));
                    s.canvas.appendChild(g)
                }
                scenes.$g = g;
                var w = s.width + s.left + s.right;
                var h = s.height + s.top + s.bottom;
                if (s.viewBox && s.viewBox.scale != null) {
                    var scale = s.viewBox.scale || 1;
                    g.setAttribute("viewBox", "0 0 " + w + " " + h);
                    w = w * scale;
                    h = h * scale
                }
                g.setAttribute("width", w);
                g.setAttribute("height", h);
                g.setAttribute("class", s.className || null)
            }
            if (s.overflow === "hidden") {
                var id = pv.id().toString(36);
                var base = document.getElementsByTagName("base").length ? location.href : "";
                base = navigator.userAgent.indexOf("MSIE") >= 0 ? "" : base;
                var url = "url(" + base + "#" + id + ")";
                var c = this.expect(e, "g", {
                    "clip-path": url
                });
                if (!c.parentNode)
                    g.appendChild(c);
                scenes.$g = g = c;
                e = c.firstChild;
                var clip = this.expect(null, "clipPath", {
                    id: id
                });
                var r = clip.appendChild(this.create("rect"));
                r.setAttribute("x", s.left);
                r.setAttribute("y", s.top);
                r.setAttribute("width", s.width);
                r.setAttribute("height", s.height);
                var defs = pv.SvgScene.getDefsElement(scenes);
                defs.appendChild(clip)
            }
            e = this.fill(e, scenes, i);
            var k = this.scale
              , t = s.transform
              , x = s.left + t.x
              , y = s.top + t.y;
            this.scale *= t.k;
            for (j = 0; j < s.children.length; j++) {
                var shadow = (s.children[j].type === "panel" || s.children[j].type === "bar") && s.children[j][0] && s.children[j][0].shadow;
                if (shadow)
                    shadow = null;
                s.children[j].$g = s.children[j].mark.$dom = e = this.expect(e, "g", {
                    "class": s.children[j].type === "panel" ? (s.children[j][0] ? s.children[j][0].className : null) || null : null,
                    filter: shadow ? "url(#" + shadow + ")" : null,
                    transform: "translate(" + x + "," + y + ")" + (t.k !== 1 ? " scale(" + t.k + ")" : "")
                });
                this.updateAll(s.children[j]);
                if (!e.parentNode)
                    g.appendChild(e);
                e = e.nextSibling
            }
            this.scale = k;
            e = this.stroke(e, scenes, i);
            if (g && s && s.attributes)
                for (var a in s.attributes)
                    if (s.attributes.hasOwnProperty(a))
                        g.setAttribute(a, s.attributes[a])
        }
        return e
    }
    ;
    pv.SvgScene.fill = function(e, scenes, i) {
        var s = scenes[i]
          , fill = s.fillStyle;
        if (fill.opacity || s.events === "all") {
            if (fill.type && fill.type !== "solid")
                pv.SvgScene.addFillStyleDefinition(scenes, fill);
            e = this.expect(e, "rect", {
                "shape-rendering": s.antialias ? null : "crispEdges",
                "pointer-events": s.events,
                cursor: s.cursor,
                x: s.left,
                y: s.top,
                rx: s.cornerRadius || null,
                ry: s.cornerRadius || null,
                width: s.width,
                height: s.height,
                fill: fill.color,
                "fill-opacity": fill.opacity,
                stroke: null
            });
            e = this.append(e, scenes, i)
        }
        return e
    }
    ;
    pv.SvgScene.stroke = function(e, scenes, i) {
        var s = scenes[i]
          , stroke = s.strokeStyle;
        if (stroke.opacity || s.events === "all") {
            if (stroke.type && stroke.type !== "solid")
                pv.SvgScene.addFillStyleDefinition(scenes, stroke);
            e = this.expect(e, "rect", {
                "shape-rendering": s.antialias ? null : "crispEdges",
                "pointer-events": s.events === "all" ? "stroke" : s.events,
                cursor: s.cursor,
                x: s.left,
                y: s.top,
                rx: s.cornerRadius || null,
                ry: s.cornerRadius || null,
                width: Math.max(1E-10, s.width),
                height: Math.max(1E-10, s.height),
                fill: null,
                stroke: stroke.color,
                "stroke-opacity": stroke.opacity,
                "stroke-width": s.lineWidth / this.scale,
                "stroke-dasharray": dashLookup(s.dashStyle) || null
            });
            e = this.append(e, scenes, i)
        }
        return e
    }
    ;
    pv.SvgScene.rule = function(scenes) {
        var e = scenes.$g.firstChild;
        for (var i = 0; i < scenes.length; i++) {
            var s = scenes[i];
            if (!s.visible)
                continue;
            var stroke = s.strokeStyle;
            if (!stroke.opacity)
                continue;
            if (stroke.type && stroke.type !== "solid")
                pv.SvgScene.addFillStyleDefinition(scenes, stroke);
            e = this.expect(e, "line", {
                "class": s.className || null,
                "shape-rendering": s.antialias ? null : "crispEdges",
                "pointer-events": s.events,
                display: s.display || null,
                cursor: s.cursor,
                x1: s.left,
                y1: s.top,
                x2: s.left + s.width,
                y2: s.top + s.height,
                stroke: stroke.color,
                "stroke-opacity": stroke.opacity,
                "stroke-width": s.lineWidth / this.scale,
                "stroke-dasharray": dashLookup(s.dashStyle) || null
            });
            e = this.append(e, scenes, i)
        }
        return e
    }
    ;
    pv.SvgScene.wedge = function(scenes) {
        var e = scenes.$g.firstChild;
        function getPoints(s) {
            var r1 = s.innerRadius, r2 = s.outerRadius, a = Math.abs(s.angle), p;
            if (a >= 2 * Math.PI)
                if (r1)
                    p = "M0," + r2 + "A" + r2 + "," + r2 + " 0 1,1 0," + -r2 + "A" + r2 + "," + r2 + " 0 1,1 0," + r2 + "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z";
                else
                    p = "M0," + r2 + "A" + r2 + "," + r2 + " 0 1,1 0," + -r2 + "A" + r2 + "," + r2 + " 0 1,1 0," + r2 + "Z";
            else {
                var sa = Math.min(s.startAngle, s.endAngle)
                  , ea = Math.max(s.startAngle, s.endAngle)
                  , c1 = Math.cos(sa)
                  , c2 = Math.cos(ea)
                  , s1 = Math.sin(sa)
                  , s2 = Math.sin(ea);
                if (Math.abs(c1) < 1E-6)
                    c1 = 0;
                if (Math.abs(c2) < 1E-6)
                    c2 = 0;
                if (Math.abs(s1) < 1E-6)
                    s1 = 0;
                if (Math.abs(s2) < 1E-6)
                    s2 = 0;
                if (r1)
                    p = "M" + r2 * c1 + "," + r2 * s1 + "A" + r2 + "," + r2 + " 0 " + (a < Math.PI ? "0" : "1") + ",1 " + r2 * c2 + "," + r2 * s2 + "L" + r1 * c2 + "," + r1 * s2 + "A" + r1 + "," + r1 + " 0 " + (a < Math.PI ? "0" : "1") + ",0 " + r1 * c1 + "," + r1 * s1 + "Z";
                else
                    p = "M" + r2 * c1 + "," + r2 * s1 + "A" + r2 + "," + r2 + " 0 " + (a < Math.PI ? "0" : "1") + ",1 " + r2 * c2 + "," + r2 * s2 + "L0,0Z"
            }
            return p
        }
        function appendShadowPass(obj, c, s, shadowClsname, xoffset, yoffset, points, color, opacity, extraWidth) {
            var shadowPass = null;
            var svg1 = {
                "class": shadowClsname || null,
                "shape-rendering": null,
                "pointer-events": s.events,
                cursor: s.cursor,
                transform: "translate(" + (s.left + xoffset + extraWidth) + "," + (s.top + yoffset + extraWidth) + ")",
                d: points,
                "tdg:angle": s.includeAngles ? (s.endAngle + s.startAngle) / 2 : null,
                "tdg:inner-radius": s.includeRadius ? s.innerRadius : null,
                "tdg:outer-radius": s.includeRadius ? s.outerRadius : null,
                fill: color,
                "fill-rule": "evenodd",
                "fill-opacity": opacity,
                stroke: null,
                "stroke-opacity": null,
                "stroke-width": null,
                "stroke-dasharray": null
            };
            shadowPass = obj.expect(null, "path", svg1);
            c.appendChild(shadowPass);
            return shadowPass
        }
        var i, s, p, fill, stroke;
        var xoffset = 0
          , yoffset = 0;
        for (i = 0; i < scenes.length; i++) {
            s = scenes[i];
            if (!s.shadow)
                continue;
            if (!s.visible)
                continue;
            fill = s.fillStyle;
            stroke = s.strokeStyle;
            if (!fill.opacity && !stroke.opacity)
                continue;
            var shadowClsname;
            var clsname = s.className;
            if (clsname) {
                var pos = clsname.indexOf("!m");
                shadowClsname = clsname.substring(0, pos) + "!mshadow"
            }
            p = getPoints(s);
            var c = this.expect(null, "g", {
                "class": "shadows"
            });
            if (s.shadow === "parent") {
                if (scenes.$g.hasAttribute("transform"))
                    c.setAttribute("transform", scenes.$g.getAttribute("transform"));
                scenes.parent.$g.insertBefore(c, scenes.parent.$g.firstChild)
            } else
                scenes.$g.insertBefore(c, scenes.$g.firstChild);
            var darkWidth = 1;
            appendShadowPass(this, c, s, shadowClsname, xoffset, yoffset, p, "black", .05, darkWidth + 2);
            appendShadowPass(this, c, s, shadowClsname, xoffset, yoffset, p, "black", .1, darkWidth + 1);
            appendShadowPass(this, c, s, shadowClsname, xoffset, yoffset, p, "black", .15, darkWidth)
        }
        for (i = 0; i < scenes.length; i++) {
            s = scenes[i];
            if (!s.visible)
                continue;
            fill = s.fillStyle;
            stroke = s.strokeStyle;
            if (!fill.opacity && !stroke.opacity)
                continue;
            p = getPoints(s);
            if (fill.type && fill.type !== "solid")
                pv.SvgScene.addFillStyleDefinition(scenes, fill);
            if (stroke.type && stroke.type !== "solid")
                pv.SvgScene.addFillStyleDefinition(scenes, stroke);
            e = this.expect(e, "path", {
                "class": s.className || null,
                display: s.display || null,
                "shape-rendering": s.antialias ? null : "crispEdges",
                "pointer-events": s.events,
                cursor: s.cursor,
                transform: "translate(" + s.left + "," + s.top + ")",
                d: p,
                "tdg:angle": s.includeAngles ? (s.endAngle + s.startAngle) / 2 : null,
                "tdg:inner-radius": s.includeRadius ? s.innerRadius : null,
                "tdg:outer-radius": s.includeRadius ? s.outerRadius : null,
                fill: fill.color,
                "fill-rule": "evenodd",
                "fill-opacity": fill.opacity || null,
                stroke: stroke.color,
                "stroke-opacity": stroke.opacity || null,
                "stroke-width": stroke.opacity ? s.lineWidth / this.scale : null,
                "stroke-dasharray": dashLookup(s.dashStyle) || null
            });
            e = this.append(e, scenes, i)
        }
        return e
    }
    ;
    pv.SvgScene.wedge25d = function(scenes) {
        var e = scenes.$g.firstChild;
        function angle_in(a, f, t, include) {
            f = tdg.boundAngle(f);
            t = tdg.boundAngle(t);
            a = tdg.boundAngle(a);
            if (include === false)
                if (t >= f)
                    return a >= f && a <= t;
                else
                    return a >= f || a <= t;
            else if (t >= f)
                return a > f && a < t;
            else
                return a > f || a < t
        }
        function middle_angle(sa, ea) {
            while (ea < sa)
                ea += 2 * Math.PI;
            while (ea > sa + 2 * Math.PI)
                ea -= 2 * Math.PI;
            return tdg.boundAngle((sa + ea) / 2)
        }
        function add_max(max, val) {
            if (typeof val === "object")
                for (var i = 0; i < val.length; i++) {
                    if (max == null || val[i] > max)
                        max = val[i]
                }
            else if (max == null || val > max)
                max = val;
            return max
        }
        function side_do(scenes, g, s, fill, stroke, sa, ea, c1, s1, c2, s2, part) {
            var a = tdg.boundAngle(ea - sa);
            var r1 = s.innerRadius
              , r2 = s.outerRadius;
            if (a === 0)
                return;
            var inner_seq, outer_seq;
            if (angle_in(middle_angle(sa, ea), 0, Math.PI)) {
                outer_seq = 7;
                inner_seq = 5
            } else {
                inner_seq = 4;
                outer_seq = 2
            }
            var outer_side = "M" + r2 * c1 + "," + r2 * s1 + "A" + r2 + "," + r2 + " 0 " + (a < Math.PI ? "0" : "1") + ",1 " + r2 * c2 + "," + r2 * s2 + "L" + r2 * c2 + "," + (r2 * s2 + yoffset) + "A" + r2 + "," + r2 + " 0 " + (a < Math.PI ? "0" : "1") + ",0 " + r2 * c1 + "," + (r2 * s1 + yoffset) + "Z";
            var p1b = add_max(null, [r2 * s1, r2 * s2, r2 * s2 + yoffset, r2 * s1 + yoffset]);
            if (angle_in(Math.PI / 2, sa, ea))
                p1b = r2 + yoffset;
            pv.SvgScene.append_poly(scenes, g, s, fill, stroke, outer_side, .7, s.left, s.top, {
                "tdg:seq": outer_seq,
                "tdg:seq2": 40,
                "tdg:part": "os" + (part ? part : ""),
                "tdg:ymax": p1b,
                "fill-rule": "evenodd"
            });
            if (r1) {
                var inner_side = "M" + r1 * c1 + "," + r1 * s1 + "A" + r1 + "," + r1 + " 0 " + (a < Math.PI ? "0" : "1") + ",1 " + r1 * c2 + "," + r1 * s2 + "L" + r1 * c2 + "," + (r1 * s2 + yoffset) + "A" + r1 + "," + r1 + " 0 " + (a < Math.PI ? "0" : "1") + ",0 " + r1 * c1 + "," + (r1 * s1 + yoffset) + "Z";
                var p4b = add_max(null, [r1 * s1, r1 * s2 + yoffset, r1 * s1 + yoffset]);
                if (angle_in(Math.PI / 2, sa, ea))
                    p4b = r1 + yoffset;
                pv.SvgScene.append_poly(scenes, g, s, fill, stroke, inner_side, .7, s.left, s.top, {
                    "tdg:seq": inner_seq,
                    "tdg:seq2": 60,
                    "tdg:part": "is" + (part ? part : ""),
                    "tdg:ymax": p4b,
                    "fill-rule": "evenodd"
                })
            }
        }
        if (!scenes.length)
            return e;
        var rot = 1 - Math.min(90, Math.max(0, scenes[0].skew ? scenes[0].skew : 0)) / 100;
        var yoffset, yshift = scenes[0].outerRadius * (1 - rot);
        var pie_g = this.appendContainer(e, scenes.$g, "pie25d", {
            transform: "translate(0," + yshift + ") scale(1," + rot + ")",
            "tdg:center": scenes[0].outerRadius,
            "tdg:skew": 1 - rot
        });
        for (var i = 0; i < scenes.length; i++) {
            var s = scenes[i];
            var g = this.appendContainer(e, pie_g, "wedge25d");
            yoffset = s.depth / rot;
            if (!s.visible || !isFinite(s.angle))
                continue;
            var fill = s.fillStyle
              , stroke = s.strokeStyle;
            if (!fill.opacity && !stroke.opacity)
                continue;
            var r1 = s.innerRadius
              , r2 = s.outerRadius
              , a = Math.abs(s.angle);
            var outer_side_back, outer_side_front, inner_side_back, inner_side_front, top, slice_start, slice_end;
            if (a >= 2 * Math.PI) {
                top = "M0," + r2 + "A" + r2 + "," + r2 + " 0 1,1 0," + -r2 + "A" + r2 + "," + r2 + " 0 1,1 0," + r2;
                if (r1)
                    top += "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1;
                top += "Z";
                outer_side_front = "M" + r2 + "," + 0 + "A" + r2 + "," + r2 + " 0 1,1 " + -r2 + ",0" + "l 0," + yoffset + "A" + r2 + "," + r2 + " 0 1,0 " + r2 + "," + yoffset + "l 0," + -yoffset + "Z";
                outer_side_back = "M" + r2 + "," + 0 + "A" + r2 + "," + r2 + " 0 1,0 " + -r2 + ",0" + "l 0," + yoffset + "A" + r2 + "," + r2 + " 0 1,1 " + r2 + "," + yoffset + "l 0," + -yoffset + "Z";
                if (r1) {
                    inner_side_front = "M" + r1 + ",0" + "A" + r1 + "," + r1 + " 0 1,1 " + -r1 + ",0" + "l 0," + yoffset + "A" + r1 + "," + r1 + " 0 1,0 " + r1 + "," + yoffset + "l 0," + -yoffset + "Z";
                    inner_side_back = "M" + r1 + ",0" + "A" + r1 + "," + r1 + " 0 1,0 " + -r1 + ",0" + "l 0," + yoffset + "A" + r1 + "," + r1 + " 0 1,1 " + r1 + "," + yoffset + "l 0," + -yoffset + "Z"
                }
                pv.SvgScene.append_poly(scenes, g, s, fill, stroke, top, 0, s.left, s.top + yoffset, {
                    "tdg:seq": 0,
                    "tdg:seq2": 0,
                    "fill-rule": "evenodd"
                });
                pv.SvgScene.append_poly(scenes, g, s, fill, stroke, outer_side_back, .7, s.left, s.top, {
                    "tdg:seq": 2,
                    "tdg:seq2": 0,
                    "fill-rule": "evenodd"
                });
                if (r1)
                    pv.SvgScene.append_poly(scenes, g, s, fill, stroke, inner_side_back, .7, s.left, s.top, {
                        "tdg:seq": 2,
                        "tdg:seq2": 0,
                        "fill-rule": "evenodd"
                    });
                if (r1)
                    pv.SvgScene.append_poly(scenes, g, s, fill, stroke, inner_side_front, .7, s.left, s.top, {
                        "tdg:seq": 2,
                        "tdg:seq2": 0,
                        "fill-rule": "evenodd"
                    });
                pv.SvgScene.append_poly(scenes, g, s, fill, stroke, outer_side_front, .7, s.left, s.top, {
                    "tdg:seq": 2,
                    "tdg:seq2": 0,
                    "fill-rule": "evenodd"
                });
                pv.SvgScene.append_poly(scenes, g, s, fill, stroke, top, 0, s.left, s.top, {
                    "tdg:seq": 4,
                    "tdg:seq2": 0,
                    "fill-rule": "evenodd"
                })
            } else {
                var sa = Math.min(s.startAngle, s.endAngle)
                  , ea = Math.max(s.startAngle, s.endAngle)
                  , c1 = Math.cos(sa)
                  , c2 = Math.cos(ea)
                  , s1 = Math.sin(sa)
                  , s2 = Math.sin(ea);
                if (Math.abs(c1) < 1E-6)
                    c1 = 0;
                if (Math.abs(c2) < 1E-6)
                    c2 = 0;
                if (Math.abs(s1) < 1E-6)
                    s1 = 0;
                if (Math.abs(s2) < 1E-6)
                    s2 = 0;
                top = "M" + r2 * c1 + "," + r2 * s1 + "A" + r2 + "," + r2 + " 0 " + (a < Math.PI ? "0" : "1") + ",1 " + r2 * c2 + "," + r2 * s2;
                if (r1)
                    top += "L" + r1 * c2 + "," + r1 * s2 + "A" + r1 + "," + r1 + " 0 " + (a < Math.PI ? "0" : "1") + ",0 " + r1 * c1 + "," + r1 * s1 + "Z";
                else
                    top += "L0,0Z";
                var pb = add_max(null, r1 ? [r2 * s1, r2 * s2, r1 * s2, r1 * s1] : [r2 * s1, r2 * s2]);
                pv.SvgScene.append_poly(scenes, g, s, fill, stroke, top, 0, s.left, s.top + yoffset, {
                    "tdg:seq": 0,
                    "tdg:seq2": 0,
                    "tdg:part": "bot",
                    "tdg:ymax": pb + yoffset,
                    "fill-rule": "evenodd"
                });
                if (angle_in(0, sa, ea) && angle_in(Math.PI, sa, ea))
                    if (angle_in(sa, 0, Math.PI)) {
                        side_do(scenes, g, s, fill, stroke, sa, Math.PI, c1, s1, -1, 0, "br");
                        side_do(scenes, g, s, fill, stroke, 0, ea, 1, 0, c2, s2, "bl");
                        side_do(scenes, g, s, fill, stroke, Math.PI, 2 * Math.PI, -1, 0, 1, 0, "f")
                    } else {
                        side_do(scenes, g, s, fill, stroke, sa, 0, c1, s1, 1, 0, "br");
                        side_do(scenes, g, s, fill, stroke, Math.PI, ea, -1, 0, c2, s2, "bl");
                        side_do(scenes, g, s, fill, stroke, 0, Math.PI, 1, 0, -1, 0, "f")
                    }
                else if (angle_in(0, sa, ea)) {
                    side_do(scenes, g, s, fill, stroke, sa, 0, c1, s1, 1, 0, "f");
                    side_do(scenes, g, s, fill, stroke, 0, ea, 1, 0, c2, s2, "b")
                } else if (angle_in(Math.PI, sa, ea)) {
                    side_do(scenes, g, s, fill, stroke, sa, Math.PI, c1, s1, -1, 0, "f");
                    side_do(scenes, g, s, fill, stroke, Math.PI, ea, -1, 0, c2, s2, "b")
                } else
                    side_do(scenes, g, s, fill, stroke, sa, ea, c1, s1, c2, s2);
                slice_start = "M" + r2 * c1 + "," + r2 * s1 + "l" + 0 + "," + yoffset + "L " + r1 * c1 + "," + (r1 * s1 + yoffset) + "l" + 0 + "," + -yoffset + "Z";
                var p2b = add_max(null, [r2 * s1 + yoffset, r1 * s1 + yoffset]);
                pv.SvgScene.append_poly(scenes, g, s, fill, stroke, slice_start, 1.2, s.left, s.top, {
                    "tdg:seq": angle_in(sa, 0, Math.PI) ? 6 : 3,
                    "tdg:seq2": 0,
                    "tdg:part": "st",
                    "tdg:ymax": p2b,
                    "fill-rule": "evenodd"
                });
                slice_end = "M" + r2 * c2 + "," + r2 * s2 + "l" + 0 + "," + yoffset + "L " + r1 * c2 + "," + (r1 * s2 + yoffset) + "l" + 0 + "," + -yoffset + "Z";
                var p3b = add_max(null, [r2 * s2 + yoffset, r1 * s2 + yoffset]);
                pv.SvgScene.append_poly(scenes, g, s, fill, stroke, slice_end, 1.2, s.left, s.top, {
                    "tdg:seq": 2,
                    "tdg:seq2": 0,
                    "tdg:part": "en",
                    "tdg:ymax": p3b,
                    "fill-rule": "evenodd"
                });
                pv.SvgScene.append_poly(scenes, g, s, fill, stroke, top, 0, s.left, s.top, {
                    "tdg:seq": 8,
                    "tdg:seq2": 0,
                    "tdg:part": "top",
                    "tdg:ymax": pb,
                    "fill-rule": "evenodd"
                })
            }
            e = this.append(g, scenes, i)
        }
        return e
    }
    ;
    pv.SvgScene.area3d = function(scenes) {
        var width, height, depth, front, up, dn, i, sj;
        var e = scenes.$g.firstChild;
        if (!scenes.length)
            return e;
        var s = scenes[0];
        if (!s.visible)
            return e;
        var fill = s.fillStyle
          , stroke = s.strokeStyle;
        if (!fill.opacity && !stroke.opacity)
            return e;
        width = scenes.parent[0].width;
        height = scenes.parent[0].height;
        depth = scenes.parent[0].depth;
        front = (scenes.parent[scenes.parentIndex].front || 0) + s.front;
        up = [];
        dn = [];
        for (i = 0,
        sj = null; i < scenes.length; i++) {
            var si = scenes[i];
            var sih = isFinite(si.height) ? si.height : 0;
            var sjh;
            if (i > 0 && (sjh > 0 && sih < 0 || sjh < 0 && sih > 0)) {
                var wp = sj.left + (si.left - sj.left) * sjh / (-sih + sjh);
                up.push({
                    x: wp,
                    y: si.bottom
                });
                up.push({
                    x: si.left,
                    y: si.bottom + Math.max(sih, 0)
                });
                dn.push({
                    x: wp,
                    y: si.bottom
                });
                dn.push({
                    x: si.left,
                    y: si.bottom + Math.min(sih, 0)
                })
            } else {
                up.push({
                    x: si.left,
                    y: si.bottom + Math.max(sih, 0)
                });
                dn.push({
                    x: si.left,
                    y: si.bottom + Math.min(sih, 0)
                })
            }
            sj = si;
            sjh = sih
        }
        up.reverse();
        dn.reverse();
        var riser = [];
        var poly = -1;
        function mkpoint(x, y, z) {
            return [x / width, y / height, z / depth]
        }
        function side_part(p1, p2) {
            var pts = [];
            pts.push(mkpoint(p1.x, p1.y, front));
            pts.push(mkpoint(p2.x, p2.y, front));
            pts.push(mkpoint(p2.x, p2.y, front + s.depth));
            pts.push(mkpoint(p1.x, p1.y, front + s.depth));
            return pts
        }
        var p;
        riser[++poly] = [];
        for (p = 0; p < up.length; p++)
            riser[poly].push(mkpoint(up[p].x, up[p].y, front));
        for (p = dn.length - 1; p >= 0; p--)
            riser[poly].push(mkpoint(dn[p].x, dn[p].y, front));
        if (up[0].y !== dn[0].y)
            riser[++poly] = side_part(up[0], dn[0]);
        for (p = 0; p < up.length - 1; p++)
            riser[++poly] = side_part(up[p], up[p + 1]);
        for (p = 0; p < dn.length - 1; p++)
            riser[++poly] = side_part(dn[p], dn[p + 1]);
        if (up[up.length - 1].y !== dn[dn.length - 1].y)
            riser[++poly] = side_part(up[up.length - 1], dn[dn.length - 1]);
        riser[++poly] = [];
        for (p = 0; p < up.length; p++)
            riser[poly].push(mkpoint(up[p].x, up[p].y, front + s.depth));
        for (p = dn.length - 1; p >= 0; p--)
            riser[poly].push(mkpoint(dn[p].x, dn[p].y, front + s.depth));
        if (s.fillEffect === "shadeSides")
            e = this.append_3d_object(e, scenes, 0, riser, undefined, [0, 1.3]);
        else
            e = this.append_3d_object(e, scenes, 0, riser);
        return e
    }
    ;
    pv.SvgScene.area3dSegment = function(scenes) {
        var e = scenes.$g.firstChild, s = scenes[0], pathsT, pathsB;
        var i, n;
        if (s.interpolate === "basis" || s.interpolate === "cardinal" || s.interpolate === "monotone") {
            var pointsT = []
              , pointsB = [];
            for (i = 0,
            n = scenes.length; i < n; i++) {
                var sn = scenes[n - i - 1];
                pointsT.push(scenes[i]);
                pointsB.push({
                    left: sn.left + sn.width,
                    top: sn.top + sn.height
                })
            }
            if (s.interpolate === "basis") {
                pathsT = this.curveBasisSegments(pointsT);
                pathsB = this.curveBasisSegments(pointsB)
            } else if (s.interpolate === "cardinal") {
                pathsT = this.curveCardinalSegments(pointsT, s.tension);
                pathsB = this.curveCardinalSegments(pointsB, s.tension)
            } else {
                pathsT = this.curveMonotoneSegments(pointsT);
                pathsB = this.curveMonotoneSegments(pointsB)
            }
        }
        for (i = 0,
        n = scenes.length - 1; i < n; i++) {
            var s1 = scenes[i]
              , s2 = scenes[i + 1];
            if (!s1.visible || !s2.visible)
                continue;
            var fill = s1.fillStyle
              , stroke = s1.strokeStyle;
            if (!fill.opacity && !stroke.opacity)
                continue;
            var d;
            if (pathsT) {
                var pathT = pathsT[i]
                  , pathB = "L" + pathsB[n - i - 1].substr(1);
                d = pathT + pathB + "Z"
            } else {
                var si = s1
                  , sj = s2;
                switch (s1.interpolate) {
                case "step-before":
                    si = s2;
                    break;
                case "step-after":
                    sj = s1;
                    break
                }
                d = "M" + s1.left + "," + si.top + "L" + s2.left + "," + sj.top + "L" + (s2.left + s2.width) + "," + (sj.top + sj.height) + "L" + (s1.left + s1.width) + "," + (si.top + si.height) + "Z"
            }
            e = this.expect(e, "path", {
                "shape-rendering": s1.antialias ? null : "crispEdges",
                "pointer-events": s1.events,
                cursor: s1.cursor,
                d: d,
                fill: fill.color,
                "fill-opacity": fill.opacity || null,
                stroke: stroke.color,
                "stroke-opacity": stroke.opacity || null,
                "stroke-width": stroke.opacity ? s1.lineWidth / this.scale : null
            });
            e = this.append(e, scenes, i)
        }
        return e
    }
    ;
    pv.SvgScene.bar3d = function(scenes) {
        function polygons(left, w, top, h, front, d) {
            var pps = [];
            pps.push([[0, h, 0], [w, h, 0], [w, h, d], [0, h, d]]);
            pps.push([[0, 0, 0], [w, 0, 0], [w, h, 0], [0, h, 0]]);
            pps.push([[w, 0, 0], [w, 0, d], [w, h, d], [w, h, 0]]);
            pps.push([[0, 0, d], [w, 0, d], [w, h, d], [0, h, d]]);
            pps.push([[0, 0, 0], [0, 0, d], [0, h, d], [0, h, 0]]);
            pps.push([[0, 0, 0], [w, 0, 0], [w, 0, d], [0, 0, d]]);
            for (var p = 0; p < pps.length; p++)
                for (var i = 0; i < pps[p].length; i++) {
                    pps[p][i][0] += left;
                    pps[p][i][1] += top;
                    pps[p][i][2] += front
                }
            return pps
        }
        var e = scenes.$g.firstChild;
        var width = scenes.parent[0].width;
        var height = scenes.parent[0].height;
        var depth = scenes.parent[0].depth;
        for (var sn = 0; sn < scenes.length; sn++) {
            var s = scenes[sn];
            var front = (scenes.parent[scenes.parentIndex].front || 0) + s.front;
            if (!s.visible)
                continue;
            if (!s.fillStyle.opacity && !s.strokeStyle.opacity)
                continue;
            var sh = isFinite(s.height) ? s.height : 0;
            var b = sh >= 0 ? s.bottom : s.bottom + sh;
            var h = sh >= 0 ? sh : -sh;
            var object = polygons(s.left / width, s.width / width, b / height, h / height, front / depth, s.depth / depth);
            if (scenes[sn].fillEffect === "shadeSides")
                e = this.append_3d_object(e, scenes, sn, object, undefined, [.8, 0, 1.5]);
            else
                e = this.append_3d_object(e, scenes, sn, object)
        }
        return e
    }
    ;
    pv.SvgScene.bar25d = function(scenes) {
        var e = scenes.$g.firstChild;
        function side25d(originx, originy, x, y, dx, dy) {
            return "m" + originx + " " + originy + "l" + dx + " " + dy + "l" + x + " " + y + "l" + -dx + " " + -dy + "l" + -x + " " + -y + "z" + "m" + x + " " + y
        }
        for (var i = 0; i < scenes.length; i++) {
            var s = scenes[i];
            if (!s.visible || !isFinite(s.top))
                continue;
            var fill = s.fillStyle
              , stroke = s.strokeStyle;
            if (!fill.opacity && !stroke.opacity)
                continue;
            var dx = Math.ceil(s.depth * (1 - s.dmargin) / Math.sqrt(2));
            var dy = -dx;
            var mx = Math.ceil(s.depth * s.dmargin / 2 / Math.sqrt(2));
            var my = -mx;
            var lx = mx + dx;
            if (!s.backtext)
                lx = mx;
            var ly = -lx;
            var g = this.appendContainer(e, scenes.$g, "bar25d", {
                "tdg:zx": Math.floor(s.left),
                "tdg:zy": Math.floor(s.top),
                "tdg:dx": lx,
                "tdg:dy": ly
            });
            var sh = isFinite(s.height) ? s.height : 0;
            pv.SvgScene.append_poly(scenes, g, s, fill, stroke, "m" + (s.left + mx + dx) + " " + (s.top + my + dy) + "l" + s.width + " " + 0 + "l" + 0 + " " + sh + "l" + -s.width + " " + 0 + "z", 0, 0, 0);
            pv.SvgScene.append_poly(scenes, g, s, fill, stroke, side25d(s.left + mx, s.top + my + sh, s.width, 0, dx, dy), 0, 0, 0);
            pv.SvgScene.append_poly(scenes, g, s, fill, stroke, side25d(s.left + mx, s.top + my, 0, sh, dx, dy), 1.4, 0, 0);
            pv.SvgScene.append_poly(scenes, g, s, fill, stroke, side25d(s.left + mx + s.width, s.top + my, 0, sh, dx, dy), 1.5, 0, 0);
            pv.SvgScene.append_poly(scenes, g, s, fill, stroke, side25d(s.left + mx, s.top + my, s.width, 0, dx, dy), .8, 0, 0);
            pv.SvgScene.append_poly(scenes, g, s, fill, stroke, "m" + (s.left + mx) + " " + (s.top + my) + "l" + s.width + " " + 0 + "l" + 0 + " " + sh + "l" + -s.width + " " + 0 + "z", 0, 0, 0);
            e = this.append(g, scenes, i)
        }
        return e
    }
    ;
    pv.SvgScene.feelerline = function(scenes) {
        var e = scenes.$g.firstChild;
        if (scenes.length < 1)
            return e;
        for (var i = 0; i < scenes.length; i++) {
            var s = scenes[i];
            if (!s.visible)
                continue;
            var fill = s.fillStyle
              , stroke = s.strokeStyle;
            if (!fill.opacity && !stroke.opacity)
                continue;
            if (stroke.type && stroke.type !== "solid")
                pv.SvgScene.addFillStyleDefinition(scenes, stroke);
            var d = "M" + s.x0 + "," + s.y0 + "L" + s.x1 + "," + s.y1;
            if (s.x2 != null && s.y2 != null)
                d += "L" + s.x2 + "," + s.y2;
            e = this.expect(e, "path", {
                "class": s.className || null,
                "shape-rendering": s.antialias ? null : "crispEdges",
                "pointer-events": s.events,
                cursor: s.cursor,
                d: d,
                fill: fill.color,
                "fill-opacity": fill.opacity || null,
                stroke: stroke.color,
                "stroke-opacity": stroke.opacity || null,
                "stroke-width": stroke.opacity ? s.lineWidth / this.scale : null,
                "stroke-linejoin": s.lineJoin,
                "stroke-dasharray": dashLookup(s.dashStyle) || null
            });
            e = this.append(e, scenes, 0)
        }
        return e
    }
    ;
    pv.SvgScene.label3d = function(scenes) {
        var e = scenes.$g.firstChild;
        for (var i = 0; i < scenes.length; i++) {
            var s = scenes[i];
            if (!s.visible)
                continue;
            var fill = s.textStyle;
            if (!fill.opacity || !s.text)
                continue;
            var x = 0
              , y = 0
              , dy = 0
              , anchor = "start";
            switch (s.textBaseline) {
            case "middle":
                dy = ".35em";
                break;
            case "top":
                dy = ".71em";
                y = s.textMargin;
                break;
            case "bottom":
                y = minus(s.textMargin);
                break
            }
            switch (s.textAlign) {
            case "right":
                anchor = "end";
                x = s.textMargin * -1;
                break;
            case "center":
                anchor = "middle";
                break;
            case "left":
                x = s.textMargin;
                break
            }
            var width = scenes.parent[0].width;
            var height = scenes.parent[0].height;
            var depth = scenes.parent[0].depth;
            var front = (scenes.parent[scenes.parentIndex].front || 0) + s.front;
            var point = [s.left / width, s.bottom / height, front / depth];
            var p3d = this.get_3d_projection(scenes);
            var pt = p3d.get_2d_point(p3d.project2d([[point]])[0][0], width, height);
            e = this.expect(e, "text", {
                "pointer-events": s.events,
                cursor: s.cursor,
                "class": s.className || null,
                x: x,
                y: y,
                dy: dy,
                transform: "translate(" + pt.x + "," + pt.y + ")" + (s.textAngle ? " rotate(" + 180 * s.textAngle / Math.PI + ")" : "") + (this.scale !== 1 ? " scale(" + 1 / this.scale + ")" : ""),
                fill: fill.color,
                "fill-opacity": fill.opacity || null,
                "text-anchor": anchor
            }, {
                font: s.font,
                "text-shadow": s.textShadow,
                "text-decoration": s.textDecoration
            });
            if (e.firstChild)
                e.firstChild.nodeValue = s.text;
            else
                e.appendChild(document.createTextNode(s.text));
            e = this.append(e, scenes, i)
        }
        return e
    }
    ;
    pv.SvgScene.panel3d = function(scenes) {
        return pv.SvgScene.panel.call(this, scenes)
    }
    ;
    pv.SvgScene.rule3d = function(scenes) {
        var e = scenes.$g.firstChild;
        for (var i = 0; i < scenes.length; i++) {
            var s = scenes[i];
            if (!s.visible)
                continue;
            var stroke = s.strokeStyle;
            if (!stroke.opacity)
                continue;
            var width = scenes.parent[0].width;
            var height = scenes.parent[0].height;
            var depth = scenes.parent[0].depth;
            var pp = [[]];
            pp[0].push([s.left / width, s.bottom / height, s.front / depth]);
            pp[0].push([(s.left + s.width) / width, (s.bottom + s.height) / height, (s.front + s.depth) / depth]);
            e = this.append_3d_object(e, scenes, i, pp, false)
        }
        return e
    }
    ;
    pv.SvgScene.wall3d = function(scenes) {
        function polygons(left, w, top, h, front, d) {
            var pps = [];
            if (d === 0)
                pps.push([[0, 0, 0], [w, 0, 0], [w, h, 0], [0, h, 0]]);
            else if (h === 0)
                pps.push([[0, 0, 0], [w, 0, 0], [w, 0, d], [0, 0, d]]);
            else
                pps.push([[0, 0, 0], [0, 0, d], [0, h, d], [0, h, 0]]);
            for (var p = 0; p < pps.length; p++)
                for (var i = 0; i < pps[p].length; i++) {
                    pps[p][i][0] += left;
                    pps[p][i][1] += top;
                    pps[p][i][2] += front
                }
            return pps
        }
        var e = scenes.$g.firstChild;
        var width = scenes.parent[0].width;
        var height = scenes.parent[0].height;
        var depth = scenes.parent[0].depth;
        for (var sn = 0; sn < scenes.length; sn++) {
            var s = scenes[sn];
            var front = (scenes.parent[scenes.parentIndex].front || 0) + s.front;
            if (!s.visible)
                continue;
            if (!s.fillStyle.opacity && !s.strokeStyle.opacity)
                continue;
            var object = polygons(s.left / width, s.width / width, s.bottom / height, s.height / height, front / depth, s.depth / depth);
            e = this.append_3d_object(e, scenes, sn, object)
        }
        return e
    }
    ;
    pv.SvgScene.surface3d = function(scenes) {
        var e = scenes.$g.firstChild;
        if (!scenes.length)
            return e;
        var s = scenes[0];
        if (!s.visible)
            return e;
        var fill = s.fillStyle
          , stroke = s.strokeStyle;
        if (!fill.opacity && !stroke.opacity)
            return e;
        var width = scenes.parent[0].width;
        var height = scenes.parent[0].height;
        var depth = scenes.parent[0].depth;
        var front = (scenes.parent[scenes.parentIndex].front || 0) + s.front;
        if (scenes.parentIndex === 0)
            return e;
        var pps = [], i;
        for (i = 0; i < scenes.length - 1; i++) {
            pps[i] = [];
            var ppsn = -1;
            var f = scenes[i];
            var t = scenes[i + 1];
            if (scenes.parent[scenes.parentIndex - 1].children[0].length <= i + 1)
                continue;
            var fb = scenes.parent[scenes.parentIndex - 1].children[0][i];
            var tb = scenes.parent[scenes.parentIndex - 1].children[0][i + 1];
            pps[i][++ppsn] = [];
            pps[i][ppsn].push([(f.left + f.width) / width, (f.bottom + f.height) / height, front / depth]);
            pps[i][ppsn].push([(t.left + t.width) / width, (t.bottom + t.height) / height, front / depth]);
            pps[i][ppsn].push([(tb.left + tb.width) / width, (tb.bottom + tb.height) / height, (front + f.depth) / depth]);
            pps[i][ppsn].push([(fb.left + fb.width) / width, (fb.bottom + fb.height) / height, (front + f.depth) / depth])
        }
        for (i = 0; i < scenes.length - 1; i++) {
            s = scenes[i];
            e = this.append_3d_object(e, scenes, i, pps[i])
        }
        return e
    }
    ;
    pv.SvgScene.surface3dSegment = function(scenes) {
        var e = scenes.$g.firstChild, s = scenes[0], pathsT, pathsB;
        var i, n;
        if (s.interpolate === "basis" || s.interpolate === "cardinal" || s.interpolate === "monotone") {
            var pointsT = []
              , pointsB = [];
            for (i = 0,
            n = scenes.length; i < n; i++) {
                var sn = scenes[n - i - 1];
                pointsT.push(scenes[i]);
                pointsB.push({
                    left: sn.left + sn.width,
                    top: sn.top + sn.height
                })
            }
            if (s.interpolate === "basis") {
                pathsT = this.curveBasisSegments(pointsT);
                pathsB = this.curveBasisSegments(pointsB)
            } else if (s.interpolate === "cardinal") {
                pathsT = this.curveCardinalSegments(pointsT, s.tension);
                pathsB = this.curveCardinalSegments(pointsB, s.tension)
            } else {
                pathsT = this.curveMonotoneSegments(pointsT);
                pathsB = this.curveMonotoneSegments(pointsB)
            }
        }
        for (i = 0,
        n = scenes.length - 1; i < n; i++) {
            var s1 = scenes[i]
              , s2 = scenes[i + 1];
            if (!s1.visible || !s2.visible)
                continue;
            var fill = s1.fillStyle
              , stroke = s1.strokeStyle;
            if (!fill.opacity && !stroke.opacity)
                continue;
            var d;
            if (pathsT) {
                var pathT = pathsT[i]
                  , pathB = "L" + pathsB[n - i - 1].substr(1);
                d = pathT + pathB + "Z"
            } else {
                var si = s1
                  , sj = s2;
                switch (s1.interpolate) {
                case "step-before":
                    si = s2;
                    break;
                case "step-after":
                    sj = s1;
                    break
                }
                d = "M" + s1.left + "," + si.top + "L" + s2.left + "," + sj.top + "L" + (s2.left + s2.width) + "," + (sj.top + sj.height) + "L" + (s1.left + s1.width) + "," + (si.top + si.height) + "Z"
            }
            e = this.expect(e, "path", {
                "shape-rendering": s1.antialias ? null : "crispEdges",
                "pointer-events": s1.events,
                cursor: s1.cursor,
                d: d,
                fill: fill.color,
                "fill-opacity": fill.opacity || null,
                stroke: stroke.color,
                "stroke-opacity": stroke.opacity || null,
                "stroke-width": stroke.opacity ? s1.lineWidth / this.scale : null
            });
            e = this.append(e, scenes, i)
        }
        return e
    }
    ;
    pv.SvgScene.append_poly = function(scenes, g, s, fill, stroke, p, adj, tx, ty, attrs) {
        var w = pv.SvgScene.append_svg_path(null, scenes, s, pv.SvgScene.adjcolor(fill, adj), stroke, p, tx, ty, attrs);
        g.appendChild(w)
    }
    ;
    pv.SvgScene.appendContainer = function(e, parent_g, className, attrs) {
        var nattrs = {
            "class": className
        };
        for (var key in attrs)
            nattrs[key] = attrs[key];
        var g = this.expect(e, "g", nattrs);
        if (!g.parentNode)
            parent_g.appendChild(g);
        return g
    }
    ;
    pv.SvgScene.append_svg_path = function(e, scenes, s, fill, stroke, p, tx, ty, attrs) {
        var ox = 0
          , oy = 0;
        if (fill && fill.type && fill.type !== "solid")
            pv.SvgScene.addFillStyleDefinition(scenes, fill);
        if (stroke && stroke.type && stroke.type !== "solid")
            pv.SvgScene.addFillStyleDefinition(scenes, stroke);
        if (tx === undefined)
            tx = s.left + ox;
        if (ty === undefined)
            ty = s.top + oy;
        var svgattrs = {
            "class": s.className || null,
            display: s.display || null,
            "shape-rendering": s.antialias ? null : "crispEdges",
            "pointer-events": s.events,
            cursor: s.cursor,
            transform: tx === 0 && ty === 0 ? null : "translate(" + tx + "," + ty + ")",
            d: p,
            fill: fill ? fill.color : null,
            "fill-opacity": fill ? fill.opacity || null : null,
            "fill-rule": fill ? "nonzero" : null,
            stroke: stroke.color,
            "stroke-opacity": stroke.opacity || null,
            "stroke-width": stroke.opacity ? s.lineWidth / this.scale : null,
            "stroke-dasharray": dashLookup(s.dashStyle) || null
        };
        for (var key in attrs)
            svgattrs[key] = attrs[key];
        e = this.expect(e, "path", svgattrs);
        return e
    }
    ;
    pv.SvgScene.get_3d_projection = function(scenes) {
        var p3 = scenes.parent[0].projection3d;
        var rotate, tilt;
        var parent = scenes;
        while (parent.hasOwnProperty("parent") && p3 == null) {
            parent = parent.parent;
            if (parent[0].hasOwnProperty("projection3d"))
                p3 = parent[0].projection3d;
            if (parent[0].hasOwnProperty("tilt"))
                tilt = parent[0].tilt;
            if (parent[0].hasOwnProperty("rotate"))
                rotate = parent[0].rotate
        }
        if (!isFinite(rotate) || rotate < 0 || rotate > Math.PI / 2)
            rotate = 30 / 180 * Math.PI;
        if (!isFinite(tilt) || tilt < 0 || tilt > Math.PI / 2)
            tilt = 20 / 180 * Math.PI;
        if (p3 == null || p3.rotation !== rotate || p3.tilt !== tilt)
            p3 = parent[0].projection3d = new pv.scene3d(rotate,tilt);
        return p3
    }
    ;
    pv.SvgScene.adjcolor = function(fill, adj) {
        var color, opacity = 1;
        if (!adj || fill === "transparent" || fill.color === "none")
            return fill;
        else if (fill.type && ["linear", "radial", "lineargradient", "radialgradient"].indexOf(fill.type) >= 0)
            return fill;
        if (fill.color) {
            color = tdg.color(fill.color);
            opacity = fill.opacity
        } else {
            color = tdg.color(fill);
            opacity = color.opacity
        }
        if (color.rgb && color.color !== "none" && !color.hasOwnProperty("stops"))
            if (adj > 0)
                return color.darker(adj).alpha(opacity);
            else if (adj < 0)
                return color.brighter(-adj).alpha(opacity);
        return fill
    }
    ;
    pv.SvgScene.append_3d_object = function(e, scenes, sn, objects, close, coloradj) {
        var p3d = this.get_3d_projection(scenes);
        var width = scenes.parent[0].width;
        var height = scenes.parent[0].height;
        var s = scenes[sn];
        var projectedobjects = p3d.project2d(objects);
        for (var w = projectedobjects.length - 1; w >= 0; w--) {
            var poly = p3d.create_svg_path(projectedobjects[w], width, height, close);
            var fill = s.fillStyle;
            if (coloradj !== undefined)
                fill = pv.SvgScene.adjcolor(s.fillStyle, w < coloradj.length ? coloradj[w] : coloradj[coloradj.length - 1]);
            e = pv.SvgScene.append_svg_path(e, scenes, s, fill, s.strokeStyle, poly, 0, 0);
            e = this.append(e, scenes, sn)
        }
        return e
    }
    ;
    pv.SvgScene.getSceneRoot = function(scenes) {
        var parent = scenes;
        while (parent.hasOwnProperty("parent"))
            parent = parent.parent;
        return parent
    }
    ;
    pv.SvgScene.getDefsElement = function(scenes, parent) {
        parent = parent || pv.SvgScene.getSceneRoot(scenes);
        var results = parent.$g.getElementsByTagName("defs");
        if (results.length === 1)
            return results[0];
        else
            return parent.$g.appendChild(this.create("defs"))
    }
}
)();
pv.Scene = pv.SvgScene;
pv.Scene.updateAll = function(scenes) {
    if (scenes.length && scenes[0].reverse && scenes.type !== "line" && scenes.type !== "area") {
        var reversed = pv.extend(scenes);
        for (var i = 0, j = scenes.length - 1; j >= 0; i++,
        j--)
            reversed[i] = scenes[j];
        scenes = reversed
    }
    if (this[scenes.type])
        this.removeSiblings(this[scenes.type](scenes))
}
;
pv.Scene.removeSiblings = function(e) {
    while (e) {
        var n = e.nextSibling;
        e.parentNode.removeChild(e);
        e = n
    }
}
;
pv.Mark = function() {
    this.$properties = [];
    this.$handlers = {}
}
;
pv.Mark.prototype.properties = {};
pv.Mark.cast = {};
pv.Mark.prototype.instance = function(defaultIndex) {
    var scene = this.scene || this.parent.instance(-1).children[this.childIndex]
      , index = !arguments.length || this.hasOwnProperty("index") ? this.index : defaultIndex;
    return scene[index < 0 ? scene.length - 1 : index]
}
;
pv.Mark.prototype.property = function(name, cast) {
    if (!this.hasOwnProperty("properties"))
        this.properties = pv.extend(this.properties);
    this.properties[name] = true;
    pv.Mark.prototype.propertyMethod(name, false, pv.Mark.cast[name] = cast);
    return this
}
;
pv.Mark.prototype.propertyMethod = function(name, def, cast) {
    if (!cast)
        cast = pv.Mark.cast[name];
    this[name] = function(v) {
        if (def && this.scene) {
            var defs = this.scene.defs;
            if (arguments.length) {
                defs[name] = {
                    id: v == null ? 0 : pv.id(),
                    value: v != null && cast ? cast(v) : v
                };
                return this
            }
            return defs[name] ? defs[name].value : null
        }
        if (arguments.length) {
            var type = !def << 1 | typeof v == "function";
            this.propertyValue(name, type & 1 && cast ? function() {
                var x = v.apply(this, arguments);
                return x != null ? cast(x) : null
            }
            : v != null && cast ? cast(v) : v).type = type;
            return this
        }
        return this.instance()[name]
    }
}
;
pv.Mark.prototype.propertyValue = function(name, v) {
    var properties = this.$properties
      , p = {
        name: name,
        id: pv.id(),
        value: v
    };
    for (var i = 0; i < properties.length; i++)
        if (properties[i].name == name) {
            properties.splice(i, 1);
            break
        }
    properties.push(p);
    return p
}
;
pv.Mark.prototype.property("data").property("visible", Boolean).property("left", Number).property("right", Number).property("top", Number).property("bottom", Number).property("cursor", String).property("title").property("reverse", Boolean).property("antialias", Boolean).property("events", String).property("className", String).property("display", String);
pv.Mark.prototype.childIndex = -1;
pv.Mark.prototype.index = -1;
pv.Mark.prototype.scale = 1;
pv.Mark.prototype.defaults = (new pv.Mark).data(function(d) {
    return [d]
}).visible(true).antialias(true).events("painted").className("");
pv.Mark.prototype.extend = function(proto) {
    this.proto = proto;
    return this
}
;
pv.Mark.prototype.add = function(type) {
    return this.parent.add(type).extend(this)
}
;
pv.Mark.prototype.def = function(name, v) {
    this.propertyMethod(name, true);
    return this[name](arguments.length > 1 ? v : null)
}
;
pv.Mark.prototype.anchor = function(name) {
    var target = this, scene;
    if (!name)
        name = "center";
    function instances(source) {
        var mark = target
          , index = [];
        while (!(scene = mark.scene)) {
            source = source.parent;
            index.push({
                index: source.index,
                childIndex: mark.childIndex
            });
            mark = mark.parent
        }
        while (index.length) {
            var i = index.pop();
            scene = scene[i.index].children[i.childIndex]
        }
        if (target.hasOwnProperty("index")) {
            var s = pv.extend(scene[target.index]);
            s.right = s.top = s.left = s.bottom = 0;
            return [s]
        }
        return scene
    }
    return (new pv.Anchor(this)).name(name).def("$mark.anchor", function() {
        scene = this.scene.target = instances(this)
    }).data(function() {
        return scene.map(function(s) {
            return s.data
        })
    }).visible(function() {
        return scene[this.index].visible
    }).left(function() {
        var s = scene[this.index]
          , w = s.width || 0;
        switch (this.name()) {
        case "bottom":
        case "top":
        case "center":
            return s.left + w / 2;
        case "left":
            return null
        }
        return s.left + w
    }).top(function() {
        var s = scene[this.index]
          , h = s.height || 0;
        switch (this.name()) {
        case "left":
        case "right":
        case "center":
            return s.top + h / 2;
        case "top":
            return null
        }
        return s.top + h
    }).right(function() {
        var s = scene[this.index];
        return this.name() == "left" ? s.right + (s.width || 0) : null
    }).bottom(function() {
        var s = scene[this.index];
        return this.name() == "top" ? s.bottom + (s.height || 0) : null
    }).textAlign(function() {
        switch (this.name()) {
        case "bottom":
        case "top":
        case "center":
            return "center";
        case "right":
            return "right"
        }
        return "left"
    }).textBaseline(function() {
        switch (this.name()) {
        case "right":
        case "left":
        case "center":
            return "middle";
        case "top":
            return "top"
        }
        return "bottom"
    })
}
;
pv.Mark.prototype.anchorTarget = function() {
    if (typeof this.proto === "undefined")
        return undefined;
    return this.proto.anchorTarget()
}
;
pv.Mark.prototype.margin = function(n) {
    return this.left(n).right(n).top(n).bottom(n)
}
;
pv.Mark.prototype.first = function() {
    return this.scene[0]
}
;
pv.Mark.prototype.last = function() {
    return this.scene[this.scene.length - 1]
}
;
pv.Mark.prototype.sibling = function() {
    return this.index == 0 ? null : this.scene[this.index - 1]
}
;
pv.Mark.prototype.cousin = function() {
    var p = this.parent
      , s = p && p.sibling();
    return s && s.children ? s.children[this.childIndex][this.index] : null
}
;
pv.Mark.prototype.render = function() {
    var parent = this.parent
      , stack = pv.Mark.stack;
    if (parent && !this.root.scene) {
        this.root.render();
        return
    }
    var indexes = [];
    for (var mark = this; mark.parent; mark = mark.parent)
        indexes.unshift(mark.childIndex);
    function render(mark, depth, scale) {
        mark.scale = scale;
        if (depth < indexes.length) {
            stack.unshift(null);
            if (mark.hasOwnProperty("index"))
                renderInstance(mark, depth, scale);
            else {
                for (var i = 0, n = mark.scene.length; i < n; i++) {
                    mark.index = i;
                    renderInstance(mark, depth, scale)
                }
                delete mark.index
            }
            stack.shift()
        } else {
            mark.build();
            pv.Scene.scale = scale;
            pv.Scene.updateAll(mark.scene)
        }
        delete mark.scale
    }
    function renderInstance(mark, depth, scale) {
        var s = mark.scene[mark.index], i;
        if (s.visible) {
            var childIndex = indexes[depth]
              , child = mark.children[childIndex];
            for (i = 0; i < childIndex; i++)
                mark.children[i].scene = s.children[i];
            stack[0] = s.data;
            if (child.scene)
                render(child, depth + 1, scale * s.transform.k);
            else {
                child.scene = s.children[childIndex];
                render(child, depth + 1, scale * s.transform.k);
                delete child.scene
            }
            for (i = 0; i < childIndex; i++)
                delete mark.children[i].scene
        }
    }
    this.bind();
    while (parent && !parent.hasOwnProperty("index"))
        parent = parent.parent;
    this.context(parent ? parent.scene : undefined, parent ? parent.index : -1, function() {
        render(this.root, 0, 1)
    })
}
;
pv.Mark.stack = [];
pv.Mark.prototype.bind = function() {
    var seen = {}, types = [[], [], [], []], data, visible;
    function bind(mark) {
        do {
            var properties = mark.$properties;
            for (var i = properties.length - 1; i >= 0; i--) {
                var p = properties[i];
                if (!(p.name in seen)) {
                    seen[p.name] = p;
                    switch (p.name) {
                    case "data":
                        data = p;
                        break;
                    case "visible":
                        visible = p;
                        break;
                    default:
                        types[p.type].push(p);
                        break
                    }
                }
            }
        } while (mark = mark.proto)
    }
    bind(this);
    bind(this.defaults);
    types[1].reverse();
    types[3].reverse();
    var mark = this;
    do
        for (var name in mark.properties)
            if (!(name in seen))
                types[2].push(seen[name] = {
                    name: name,
                    type: 2,
                    value: null
                });
    while (mark = mark.proto);
    var defs = types[0].concat(types[1]);
    for (var i = 0; i < defs.length; i++)
        this.propertyMethod(defs[i].name, true);
    this.binds = {
        properties: seen,
        data: data,
        defs: defs,
        required: [visible],
        optional: pv.blend(types)
    }
}
;
pv.Mark.prototype.build = function() {
    var scene = this.scene
      , stack = pv.Mark.stack;
    if (!scene) {
        scene = this.scene = [];
        scene.mark = this;
        scene.type = this.type;
        scene.childIndex = this.childIndex;
        if (this.parent) {
            scene.parent = this.parent.scene;
            scene.parentIndex = this.parent.index
        }
    }
    if (this.binds.defs.length) {
        var defs = scene.defs;
        if (!defs)
            scene.defs = defs = {};
        for (var i = 0; i < this.binds.defs.length; i++) {
            var p = this.binds.defs[i]
              , d = defs[p.name];
            if (!d || p.id > d.id)
                defs[p.name] = {
                    id: 0,
                    value: p.type & 1 ? p.value.apply(this, stack) : p.value
                }
        }
    }
    var data = this.binds.data;
    data = data.type & 1 ? data.value.apply(this, stack) : data.value;
    stack.unshift(null);
    scene.length = data.length;
    for (var i = 0; i < data.length; i++) {
        pv.Mark.prototype.index = this.index = i;
        var s = scene[i];
        if (!s)
            scene[i] = s = {};
        s.data = stack[0] = data[i];
        this.buildInstance(s)
    }
    pv.Mark.prototype.index = -1;
    delete this.index;
    stack.shift();
    return this
}
;
pv.Mark.prototype.buildProperties = function(s, properties) {
    for (var i = 0, n = properties.length; i < n; i++) {
        var p = properties[i]
          , v = p.value;
        switch (p.type) {
        case 0:
        case 1:
            v = this.scene.defs[p.name].value;
            break;
        case 3:
            v = v.apply(this, pv.Mark.stack);
            break
        }
        s[p.name] = v
    }
}
;
pv.Mark.prototype.buildInstance = function(s) {
    this.buildProperties(s, this.binds.required);
    if (s.visible) {
        this.buildProperties(s, this.binds.optional);
        this.buildImplied(s)
    }
}
;
pv.Mark.prototype.buildImplied = function(s) {
    var l = s.left;
    var r = s.right;
    var t = s.top;
    var b = s.bottom;
    var p = this.properties;
    var w = p.width ? s.width : 0;
    var h = p.height ? s.height : 0;
    var width = this.parent ? this.parent.width() : w + l + r;
    if (w == null)
        w = width - (r = r || 0) - (l = l || 0);
    else if (r == null)
        r = width - w - (l = l || 0);
    else if (l == null)
        l = width - w - (r = r || 0);
    var height = this.parent ? this.parent.height() : h + t + b;
    if (h == null)
        h = height - (t = t || 0) - (b = b || 0);
    else if (b == null)
        b = height - h - (t = t || 0);
    else if (t == null)
        t = height - h - (b = b || 0);
    s.left = l;
    s.right = r;
    s.top = t;
    s.bottom = b;
    if (p.width)
        s.width = w;
    if (p.height)
        s.height = h;
    if (p.textStyle && !s.textStyle)
        s.textStyle = tdgchart.util.color.transparent;
    if (p.fillStyle && !s.fillStyle)
        s.fillStyle = tdgchart.util.color.transparent;
    if (p.strokeStyle && !s.strokeStyle)
        s.strokeStyle = tdgchart.util.color.transparent
}
;
pv.Mark.prototype.mouse = function() {
    var x = pv.event.convertedPageX || 0
      , y = pv.event.convertedPageY || 0
      , n = this.root.canvas();
    if (x == undefined && pv.event.clientX != undefined) {
        var doc = document.documentElement
          , body = document.body;
        x = pv.event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
        y = pv.event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)
    }
    if (x === undefined)
        x = 0;
    if (y === undefined)
        y = 0;
    do {
        x -= n.offsetLeft;
        y -= n.offsetTop
    } while (n = n.offsetParent);
    var t = pv.Transform.identity
      , p = this.properties.transform ? this : this.parent
      , pz = [];
    do
        pz.push(p);
    while (p = p.parent);
    while (p = pz.pop())
        t = t.translate(p.left(), p.top()).times(p.transform());
    t = t.invert();
    return pv.vector(x * t.k + t.x, y * t.k + t.y)
}
;
pv.Mark.prototype.event = function(type, handler) {
    this.$handlers[type] = pv.functor(handler);
    return this
}
;
pv.Mark.prototype.context = function(scene, index, f) {
    var proto = pv.Mark.prototype
      , stack = pv.Mark.stack
      , oscene = pv.Mark.scene
      , oindex = proto.index;
    function apply(scene, index) {
        pv.Mark.scene = scene;
        proto.index = index;
        if (!scene)
            return;
        var that = scene.mark
          , mark = that
          , ancestors = [];
        do {
            ancestors.push(mark);
            stack.push(scene[index].data);
            mark.index = index;
            mark.scene = scene;
            index = scene.parentIndex;
            scene = scene.parent
        } while (mark = mark.parent);
        for (var i = ancestors.length - 1, k = 1; i > 0; i--) {
            mark = ancestors[i];
            mark.scale = k;
            k *= mark.scene[mark.index].transform.k
        }
        if (that.children)
            for (var i = 0, n = that.children.length; i < n; i++) {
                mark = that.children[i];
                mark.scene = that.scene[that.index].children[i];
                mark.scale = k
            }
    }
    function clear(scene, index) {
        if (!scene)
            return;
        var that = scene.mark, mark;
        if (that.children)
            for (var i = 0, n = that.children.length; i < n; i++) {
                mark = that.children[i];
                delete mark.scene;
                delete mark.scale
            }
        mark = that;
        do {
            stack.pop();
            if (mark.parent) {
                delete mark.scene;
                delete mark.scale
            }
            delete mark.index
        } while (mark = mark.parent)
    }
    clear(oscene, oindex);
    apply(scene, index);
    f.apply(this, stack);
    clear(scene, index);
    apply(oscene, oindex)
}
;
pv.Mark.dispatch = function(type, scene, index) {
    var m = scene.mark
      , p = scene.parent
      , l = m.$handlers[type];
    if (!l)
        return p && pv.Mark.dispatch(type, p, scene.parentIndex);
    m.context(scene, index, function() {
        m = l.apply(m, pv.Mark.stack);
        if (m && m.render)
            m.render()
    });
    return true
}
;
pv.Mark.prototype.lineStyle = function(line) {
    if (typeof line === "function") {
        var callback = line;
        line = {
            width: function(d) {
                return (callback.call(this, d) || {}).width
            },
            color: function(d) {
                return (callback.call(this, d) || {}).color
            },
            dash: function(d) {
                return (callback.call(this, d) || {}).dash
            }
        }
    }
    if (!line.width)
        this.strokeStyle(null);
    else
        this.strokeStyle(line.color).lineWidth(line.width).dashStyle(line.dash);
    return this
}
;
pv.Anchor = function(target) {
    pv.Mark.call(this);
    this.target = target;
    this.parent = target.parent
}
;
pv.Anchor.prototype = pv.extend(pv.Mark).property("name", String);
pv.Anchor.prototype.anchorTarget = function() {
    return this.target
}
;
pv.Area = function() {
    pv.Mark.call(this)
}
;
pv.Area.prototype = pv.extend(pv.Mark).property("width", Number).property("height", Number).property("lineWidth", Number).property("strokeStyle", tdgchart.util.color).property("fillStyle", tdgchart.util.color).property("dashStyle", String).property("segmented", Boolean).property("interpolate", String).property("tension", Number);
pv.Area.prototype.type = "area";
pv.Area.prototype.defaults = (new pv.Area).extend(pv.Mark.prototype.defaults).lineWidth(1.5).interpolate("linear").dashStyle("").tension(.7);
pv.Area.prototype.buildImplied = function(s) {
    if (s.height == null)
        s.height = 0;
    if (isNaN(s.height))
        s.isNaN = true;
    if (s.width == null)
        s.width = 0;
    pv.Mark.prototype.buildImplied.call(this, s)
}
;
pv.Area.fixed = {
    lineWidth: 1,
    lineJoin: 1,
    strokeStyle: 1,
    fillStyle: 1,
    segmented: 1,
    interpolate: 1,
    tension: 1
};
pv.Area.prototype.bind = function() {
    pv.Mark.prototype.bind.call(this);
    var binds = this.binds
      , required = binds.required
      , optional = binds.optional;
    for (var i = 0, n = optional.length; i < n; i++) {
        var p = optional[i];
        p.fixed = p.name in pv.Area.fixed;
        if (p.name === "segmented") {
            required.push(p);
            optional.splice(i, 1);
            i--;
            n--
        }
    }
    this.binds.$required = required;
    this.binds.$optional = optional
}
;
pv.Area.prototype.buildInstance = function(s) {
    var binds = this.binds;
    if (this.index) {
        var fixed = binds.fixed;
        if (!fixed) {
            fixed = binds.fixed = [];
            var f = function(p) {
                return !p.fixed || (fixed.push(p),
                false)
            };
            binds.required = binds.required.filter(f);
            if (!this.scene[0].segmented)
                binds.optional = binds.optional.filter(f)
        }
        for (var i = 0, n = fixed.length; i < n; i++) {
            var p = fixed[i].name;
            s[p] = this.scene[0][p]
        }
    } else {
        binds.required = binds.$required;
        binds.optional = binds.$optional;
        binds.fixed = null
    }
    pv.Mark.prototype.buildInstance.call(this, s)
}
;
pv.Area.prototype.anchor = function(name) {
    var scene;
    return pv.Mark.prototype.anchor.call(this, name).def("$area.anchor", function() {
        scene = this.scene.target
    }).interpolate(function() {
        return scene[this.index].interpolate
    }).eccentricity(function() {
        return scene[this.index].eccentricity
    }).tension(function() {
        return scene[this.index].tension
    })
}
;
pv.Bar = function() {
    pv.Mark.call(this)
}
;
pv.Bar.prototype = pv.extend(pv.Mark).property("width", Number).property("height", Number).property("lineWidth", Number).property("shadow").property("strokeStyle", tdgchart.util.color).property("fillStyle", tdgchart.util.color).property("dashStyle", String).property("cornerRadius", Number).property("attributes", Object);
pv.Bar.prototype.type = "bar";
pv.Bar.prototype.defaults = (new pv.Bar).extend(pv.Mark.prototype.defaults).lineWidth(1.5).dashStyle("").shadow(false);
pv.Trapezoid = function() {
    pv.Bar.call(this)
}
;
pv.Trapezoid.prototype = pv.extend(pv.Bar).property("inset", Number);
pv.Trapezoid.prototype.type = "trapezoid";
pv.Trapezoid.prototype.defaults = (new pv.Trapezoid).extend(pv.Bar.prototype.defaults).inset(20);
pv.Dot = function() {
    pv.Mark.call(this)
}
;
pv.Dot.prototype = pv.extend(pv.Mark).property("size", Number).property("radius", Number).property("shape", String).property("angle", Number).property("lineWidth", Number).property("dashStyle", String).property("strokeStyle", tdgchart.util.color).property("fillStyle", tdgchart.util.color).property("includeRadius", Boolean);
pv.Dot.prototype.type = "dot";
pv.Dot.prototype.defaults = (new pv.Dot).extend(pv.Mark.prototype.defaults).size(20).shape("circle").lineWidth(1.5).dashStyle("").includeRadius(false);
pv.Dot.prototype.anchor = function(name) {
    var scene;
    return pv.Mark.prototype.anchor.call(this, name).def("$wedge.anchor", function() {
        scene = this.scene.target
    }).left(function() {
        var s = scene[this.index];
        switch (this.name()) {
        case "bottom":
        case "top":
        case "center":
            return s.left;
        case "left":
            return null
        }
        return s.left + s.radius
    }).right(function() {
        var s = scene[this.index];
        return this.name() == "left" ? s.right + s.radius : null
    }).top(function() {
        var s = scene[this.index];
        switch (this.name()) {
        case "left":
        case "right":
        case "center":
            return s.top;
        case "top":
            return null
        }
        return s.top + s.radius
    }).bottom(function() {
        var s = scene[this.index];
        return this.name() == "top" ? s.bottom + s.radius : null
    }).textAlign(function() {
        switch (this.name()) {
        case "left":
            return "right";
        case "bottom":
        case "top":
        case "center":
            return "center"
        }
        return "left"
    }).textBaseline(function() {
        switch (this.name()) {
        case "right":
        case "left":
        case "center":
            return "middle";
        case "bottom":
            return "top"
        }
        return "bottom"
    })
}
;
pv.Dot.prototype.buildImplied = function(s) {
    if (s.radius == null)
        s.radius = Math.sqrt(s.size);
    else if (s.size == null)
        s.size = s.radius * s.radius;
    pv.Mark.prototype.buildImplied.call(this, s)
}
;
pv.Label = function() {
    pv.Mark.call(this)
}
;
pv.Label.prototype = pv.extend(pv.Mark).property("text", String).property("font", String).property("textAngle", Number).property("textStyle", tdgchart.util.color).property("textAlign", String).property("textBaseline", String).property("textMargin", Number).property("textDecoration", String).property("textShadow", String);
pv.Label.prototype.type = "label";
pv.Label.prototype.defaults = (new pv.Label).extend(pv.Mark.prototype.defaults).text(tdgchart.util.identity).font("10px sans-serif").cursor("default").textAngle(0).textStyle("black").textAlign("left").textBaseline("bottom").textMargin(3);
pv.Line = function() {
    pv.Mark.call(this)
}
;
pv.Line.prototype = pv.extend(pv.Mark).property("lineWidth", Number).property("lineJoin", String).property("strokeStyle", tdgchart.util.color).property("fillStyle", tdgchart.util.color).property("dashStyle", String).property("segmented", Boolean).property("interpolate", String).property("eccentricity", Number).property("tension", Number);
pv.Line.prototype.type = "line";
pv.Line.prototype.defaults = (new pv.Line).extend(pv.Mark.prototype.defaults).lineJoin("miter").lineWidth(1.5).dashStyle("").interpolate("linear").eccentricity(0).tension(.7);
pv.Line.prototype.bind = pv.Area.prototype.bind;
pv.Line.prototype.buildInstance = pv.Area.prototype.buildInstance;
pv.Line.prototype.anchor = function(name) {
    return pv.Area.prototype.anchor.call(this, name).textAlign(function() {
        switch (this.name()) {
        case "left":
            return "right";
        case "bottom":
        case "top":
        case "center":
            return "center";
        case "right":
            return "left"
        }
    }).textBaseline(function() {
        switch (this.name()) {
        case "right":
        case "left":
        case "center":
            return "middle";
        case "top":
            return "bottom";
        case "bottom":
            return "top"
        }
    })
}
;
pv.Rule = function() {
    pv.Mark.call(this)
}
;
pv.Rule.prototype = pv.extend(pv.Mark).property("width", Number).property("height", Number).property("lineWidth", Number).property("dashStyle", String).property("strokeStyle", tdgchart.util.color);
pv.Rule.prototype.type = "rule";
pv.Rule.prototype.defaults = (new pv.Rule).extend(pv.Mark.prototype.defaults).lineWidth(1).dashStyle("").antialias(false);
pv.Rule.prototype.anchor = pv.Line.prototype.anchor;
pv.Rule.prototype.buildImplied = function(s) {
    var l = s.left
      , r = s.right;
    if (s.width != null || l == null && r == null || r != null && l != null)
        s.height = 0;
    else
        s.width = 0;
    pv.Mark.prototype.buildImplied.call(this, s)
}
;
pv.Panel = function() {
    pv.Bar.call(this);
    this.children = [];
    this.root = this;
    this.$dom = pv.$ && pv.$.s
}
;
pv.Panel.prototype = pv.extend(pv.Bar).property("transform").property("viewBox").property("overflow", String).property("desc", String).property("canvas", function(c) {
    return typeof c == "string" ? document.getElementById(c) : c
});
pv.Panel.prototype.type = "panel";
pv.Panel.prototype.defaults = (new pv.Panel).extend(pv.Bar.prototype.defaults).fillStyle(null).overflow("visible");
pv.Panel.prototype.anchor = function(name) {
    var anchor = pv.Bar.prototype.anchor.call(this, name);
    anchor.parent = this;
    return anchor
}
;
pv.Panel.prototype.add = function(type) {
    var child = new type;
    child.constructor = type;
    child.parent = this;
    child.root = this.root;
    child.childIndex = this.children.length;
    this.children.push(child);
    return child
}
;
pv.Panel.prototype.bind = function() {
    pv.Mark.prototype.bind.call(this);
    for (var i = 0; i < this.children.length; i++)
        this.children[i].bind()
}
;
pv.Panel.prototype.buildInstance = function(s) {
    pv.Bar.prototype.buildInstance.call(this, s);
    if (!s.visible)
        return;
    if (!s.children)
        s.children = [];
    var scale = this.scale * s.transform.k, child, n = this.children.length;
    pv.Mark.prototype.index = -1;
    for (var i = 0; i < n; i++) {
        child = this.children[i];
        child.scene = s.children[i];
        child.scale = scale;
        child.build()
    }
    for (var i = 0; i < n; i++) {
        child = this.children[i];
        s.children[i] = child.scene;
        delete child.scene;
        delete child.scale
    }
    s.children.length = n
}
;
pv.Panel.prototype.buildImplied = function(s) {
    if (!this.parent) {
        var c = s.canvas;
        if (c) {
            if (c.$panel != this) {
                c.$panel = this;
                while (c.lastChild)
                    c.removeChild(c.lastChild)
            }
        } else {
            var cache = this.$canvas || (this.$canvas = []);
            if (!(c = cache[this.index])) {
                c = cache[this.index] = document.createElement("span");
                if (this.$dom)
                    this.$dom.parentNode.insertBefore(c, this.$dom);
                else {
                    var n = document.body;
                    while (n.lastChild && n.lastChild.tagName)
                        n = n.lastChild;
                    if (n != document.body)
                        n = n.parentNode;
                    n.appendChild(c)
                }
            }
        }
        s.canvas = c
    }
    if (!s.transform)
        s.transform = pv.Transform.identity.translate(0, 0);
    pv.Mark.prototype.buildImplied.call(this, s)
}
;
pv.Wedge = function() {
    pv.Mark.call(this)
}
;
pv.Wedge.prototype = pv.extend(pv.Mark).property("startAngle", Number).property("endAngle", Number).property("angle", Number).property("innerRadius", Number).property("outerRadius", Number).property("lineWidth", Number).property("dashStyle", String).property("strokeStyle", tdgchart.util.color).property("fillStyle", tdgchart.util.color).property("includeAngles", Boolean).property("includeRadius", Boolean);
pv.Wedge.prototype.type = "wedge";
pv.Wedge.prototype.defaults = (new pv.Wedge).extend(pv.Mark.prototype.defaults).startAngle(function() {
    var s = this.sibling();
    return s ? s.endAngle : -Math.PI / 2
}).innerRadius(0).lineWidth(1.5).strokeStyle(null).dashStyle("").includeAngles(false).includeRadius(false);
pv.Wedge.prototype.midRadius = function() {
    return (this.innerRadius() + this.outerRadius()) / 2
}
;
pv.Wedge.prototype.midAngle = function() {
    return (this.startAngle() + this.endAngle()) / 2
}
;
pv.Wedge.prototype.anchor = function(name) {
    function partial(s) {
        return s.innerRadius || s.angle < 2 * Math.PI
    }
    function midRadius(s) {
        return (s.innerRadius + s.outerRadius) / 2
    }
    function midAngle(s) {
        return (s.startAngle + s.endAngle) / 2
    }
    var scene;
    return pv.Mark.prototype.anchor.call(this, name).def("$wedge.anchor", function() {
        scene = this.scene.target
    }).left(function() {
        var s = scene[this.index];
        if (partial(s))
            switch (this.name()) {
            case "outer":
                return s.left + s.outerRadius * Math.cos(midAngle(s));
            case "inner":
                return s.left + s.innerRadius * Math.cos(midAngle(s));
            case "start":
                return s.left + midRadius(s) * Math.cos(s.startAngle);
            case "center":
                return s.left + midRadius(s) * Math.cos(midAngle(s));
            case "end":
                return s.left + midRadius(s) * Math.cos(s.endAngle)
            }
        return s.left
    }).top(function() {
        var s = scene[this.index];
        if (partial(s))
            switch (this.name()) {
            case "outer":
                return s.top + s.outerRadius * Math.sin(midAngle(s));
            case "inner":
                return s.top + s.innerRadius * Math.sin(midAngle(s));
            case "start":
                return s.top + midRadius(s) * Math.sin(s.startAngle);
            case "center":
                return s.top + midRadius(s) * Math.sin(midAngle(s));
            case "end":
                return s.top + midRadius(s) * Math.sin(s.endAngle)
            }
        return s.top
    }).textAlign(function() {
        var s = scene[this.index];
        if (partial(s))
            switch (this.name()) {
            case "outer":
                return pv.Wedge.upright(midAngle(s)) ? "right" : "left";
            case "inner":
                return pv.Wedge.upright(midAngle(s)) ? "left" : "right"
            }
        return "center"
    }).textBaseline(function() {
        var s = scene[this.index];
        if (partial(s))
            switch (this.name()) {
            case "start":
                return pv.Wedge.upright(s.startAngle) ? "top" : "bottom";
            case "end":
                return pv.Wedge.upright(s.endAngle) ? "bottom" : "top"
            }
        return "middle"
    }).textAngle(function() {
        var s = scene[this.index]
          , a = 0;
        if (partial(s))
            switch (this.name()) {
            case "center":
            case "inner":
            case "outer":
                a = midAngle(s);
                break;
            case "start":
                a = s.startAngle;
                break;
            case "end":
                a = s.endAngle;
                break
            }
        return pv.Wedge.upright(a) ? a : a + Math.PI
    })
}
;
pv.Wedge.upright = function(angle) {
    angle = angle % (2 * Math.PI);
    angle = angle < 0 ? 2 * Math.PI + angle : angle;
    return angle < Math.PI / 2 || angle >= 3 * Math.PI / 2
}
;
pv.Wedge.prototype.buildImplied = function(s) {
    if (s.angle == null)
        s.angle = s.endAngle - s.startAngle;
    else if (s.endAngle == null)
        s.endAngle = s.startAngle + s.angle;
    pv.Mark.prototype.buildImplied.call(this, s)
}
;
/*
 Copyright (c) 2011, Nick Rabinowitz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
pv.Layout = function() {
    pv.Panel.call(this)
}
;
pv.Layout.prototype = pv.extend(pv.Panel);
pv.Layout.prototype.property = function(name, cast) {
    if (!this.hasOwnProperty("properties"))
        this.properties = pv.extend(this.properties);
    this.properties[name] = true;
    this.propertyMethod(name, false, pv.Mark.cast[name] = cast);
    return this
}
;
pv.Layout.Stack = function() {
    pv.Layout.call(this);
    var that = this, none = function() {
        return null
    }, prop = {
        t: none,
        l: none,
        r: none,
        b: none,
        w: none,
        h: none
    }, values, buildImplied = that.buildImplied;
    function proxy(name) {
        return function() {
            return prop[name](this.parent.index, this.index)
        }
    }
    this.buildImplied = function(s) {
        buildImplied.call(this, s);
        var data = s.layers, n = data.length, m, orient = s.orient, horizontal = /^(top|bottom)\b/.test(orient), h = this.parent[horizontal ? "height" : "width"](), x = [], y = [], dy = [];
        var stack = pv.Mark.stack
          , o = {
            parent: {
                parent: this
            }
        };
        stack.unshift(null);
        values = [];
        for (var i = 0; i < n; i++) {
            dy[i] = [];
            y[i] = [];
            o.parent.index = i;
            stack[0] = data[i];
            values[i] = this.$values.apply(o.parent, stack);
            if (!i)
                m = values[i].length;
            stack.unshift(null);
            for (var j = 0; j < m; j++) {
                stack[0] = values[i][j];
                o.index = j;
                if (!i)
                    x[j] = this.$x.apply(o, stack);
                dy[i][j] = this.$y.apply(o, stack)
            }
            stack.shift()
        }
        stack.shift();
        var index;
        switch (s.order) {
        case "reverse":
            index = tdgchart.util.range(n - 1, -1, -1);
            break;
        default:
            index = tdgchart.util.range(n);
            break
        }
        switch (s.offset) {
        case "silohouette":
            {
                for (var j = 0; j < m; j++) {
                    var o = 0;
                    for (var i = 0; i < n; i++)
                        o += dy[i][j];
                    y[index[0]][j] = (h - o) / 2
                }
                break
            }
        case "wiggle":
            {
                var o = 0;
                for (var i = 0; i < n; i++)
                    o += dy[i][0];
                y[index[0]][0] = o = (h - o) / 2;
                for (var j = 1; j < m; j++) {
                    var s1 = 0
                      , s2 = 0
                      , dx = x[j] - x[j - 1];
                    for (var i = 0; i < n; i++)
                        s1 += dy[i][j];
                    for (var i = 0; i < n; i++) {
                        var s3 = (dy[index[i]][j] - dy[index[i]][j - 1]) / (2 * dx);
                        for (var k = 0; k < i; k++)
                            s3 += (dy[index[k]][j] - dy[index[k]][j - 1]) / dx;
                        s2 += s3 * dy[index[i]][j]
                    }
                    y[index[0]][j] = o -= s1 ? s2 / s1 * dx : 0
                }
                break
            }
        case "expand":
            {
                for (var j = 0; j < m; j++) {
                    y[index[0]][j] = 0;
                    var k = 0;
                    for (var i = 0; i < n; i++)
                        k += dy[i][j];
                    if (k) {
                        k = h / k;
                        for (var i = 0; i < n; i++)
                            dy[i][j] *= k
                    } else {
                        k = h / n;
                        for (var i = 0; i < n; i++)
                            dy[i][j] = k
                    }
                }
                break
            }
        default:
            {
                for (var j = 0; j < m; j++)
                    y[index[0]][j] = 0;
                break
            }
        }
        for (var j = 0; j < m; j++) {
            var o = y[index[0]][j];
            for (var i = 1; i < n; i++) {
                o += dy[index[i - 1]][j] || 0;
                y[index[i]][j] = o
            }
        }
        var i = orient.indexOf("-")
          , pdy = horizontal ? "h" : "w"
          , px = i < 0 ? horizontal ? "l" : "b" : orient.charAt(i + 1)
          , py = orient.charAt(0);
        for (var p in prop)
            prop[p] = none;
        prop[px] = function(i, j) {
            return x[j]
        }
        ;
        prop[py] = function(i, j) {
            return y[i][j]
        }
        ;
        prop[pdy] = function(i, j) {
            return dy[i][j]
        }
    }
    ;
    this.layer = (new pv.Mark).data(function() {
        return values[this.parent.index]
    }).top(proxy("t")).left(proxy("l")).right(proxy("r")).bottom(proxy("b")).width(proxy("w")).height(proxy("h"));
    this.layer.add = function(type) {
        return that.add(pv.Panel).data(function() {
            return that.layers()
        }).add(type).extend(this)
    }
}
;
pv.Layout.Stack.prototype = pv.extend(pv.Layout).property("orient", String).property("offset", String).property("order", String).property("layers");
pv.Layout.Stack.prototype.defaults = (new pv.Layout.Stack).extend(pv.Layout.prototype.defaults).orient("bottom-left").offset("zero").layers([[]]);
pv.Layout.Stack.prototype.$x = pv.Layout.Stack.prototype.$y = function() {
    return 0
}
;
pv.Layout.Stack.prototype.x = function(f) {
    this.$x = pv.functor(f);
    return this
}
;
pv.Layout.Stack.prototype.y = function(f) {
    this.$y = pv.functor(f);
    return this
}
;
pv.Layout.Stack.prototype.$values = tdgchart.util.identity;
pv.Layout.Stack.prototype.values = function(f) {
    this.$values = pv.functor(f);
    return this
}
;
pv.Layout.Cloud = function() {
    pv.Layout.call(this);
    var that = this
      , notImplemented = function() {
        throw new Exception("Not implemented");
    };
    (this.node = (new pv.Mark).data(function() {
        return that.nodes()
    }).top(function(d) {
        return d.y
    }).left(function(d) {
        return d.x
    })).parent = this;
    this.$setSize = this.$collide = this.$getBox = notImplemented
}
;
pv.Layout.Cloud.prototype = pv.extend(pv.Layout).property("nodes", function(v) {
    return v.map(function(d, i) {
        if (typeof d != "object")
            d = {
                nodeValue: d
            };
        return d
    })
}).property("padding", Number).property("maxTagCount", Number).property("spiralTightness", Number).property("spiralDistance", Number).property("gridRows", Number).property("gridCols", Number).property("verticalSkew", Number).property("horizontalSkew", Number);
pv.Layout.Cloud.prototype.defaults = (new pv.Layout.Cloud).extend(pv.Layout.prototype.defaults).nodes([]).padding(2).spiralTightness(.1).spiralDistance(2).gridRows(16).gridCols(16).verticalSkew(0).horizontalSkew(0);
pv.Layout.Cloud.prototype.buildImplied = function(s) {
    pv.Layout.prototype.buildImplied.call(this, s);
    var that = this
      , collide = that.$collide(s.padding)
      , setSize = that.$setSize
      , getBox = that.$getBox
      , vskew = that.verticalSkew()
      , hskew = that.horizontalSkew()
      , nodes = s.nodes;
    var CollisionGrid = function(rows, cols) {
        var g = this
          , table = {}
          , cw = s.width / cols
          , ch = s.height / rows
          , keys = function(n) {
            var bb = getBox(n), minx = Math.floor(bb.x1 / cw), maxx = Math.floor(bb.x2 / cw), miny = Math.floor(bb.y1 / ch), maxy = Math.floor(bb.y2 / ch), x, y, ks = [];
            for (x = minx; x <= maxx; x++)
                for (y = miny; y <= maxy; y++)
                    ks.push([x, y]);
            return ks
        };
        g.add = function(n) {
            keys(n).forEach(function(k) {
                var sk = k[0] + "," + k[1];
                if (!(sk in table))
                    table[sk] = [];
                table[sk].push(n)
            })
        }
        ;
        g.getPool = function(n) {
            return pv.blend(keys(n).map(function(k) {
                var sk = k[0] + "," + k[1];
                if (sk in table)
                    return table[sk]
            }).filter(function(el) {
                return typeof el !== "undefined"
            }))
        }
    }, cg = new CollisionGrid(16,16), lastHit;
    function testCollision(n, d) {
        if (!d)
            lastHit = null;
        if (lastHit)
            if (collide(n, lastHit))
                return true;
            else
                lastHit = null;
        var pool = cg.getPool(n), i;
        for (i = 0; i < pool.length; i++)
            if (collide(n, pool[i])) {
                lastHit = pool[i];
                return true
            }
        return false
    }
    function placeNode(n, d) {
        var d = d || 0, b = n.size * s.spiralTightness, dist = n.size * s.spiralDistance, w = s.width, h = s.height, t, theta = function(d) {
            return d * Math.PI / Math.sqrt(Math.PI * Math.PI * b * d / dist)
        }, x = function(d, hs) {
            return w / 2 + hs + b * t * Math.cos(t)
        }, y = function(d, vs) {
            return h / 2 + vs + b * t * Math.sin(t)
        };
        if (d) {
            if (vskew && !n.vs || hskew && !n.hs) {
                if (vskew)
                    n.vs = pv.random(-1 * vskew / 2, vskew / 2);
                if (hskew)
                    n.hs = pv.random(-1 * hskew / 2, hskew / 2)
            }
            if (n.vs === undefined)
                n.vs = 0;
            if (n.hs === undefined)
                n.hs = 0;
            t = theta(d);
            n.x = x(d, n.hs);
            n.y = y(d, n.vs)
        }
        return testCollision(n, d)
    }
    nodes.forEach(setSize);
    nodes.sort(function(a, b) {
        return b.size < a.size ? -1 : b.size > a.size ? 1 : 0
    });
    nodes.length = s.maxTagCount;
    nodes.forEach(function(n) {
        var d = 0;
        while (placeNode(n, ++d))
            ;
        cg.add(n)
    })
}
;
pv.Layout.Cloud.Box = function() {
    pv.Layout.Cloud.call(this);
    var that = this;
    this.node.top(function(d) {
        return d.y - d.h / 2
    }).left(function(d) {
        return d.x - d.w / 2
    }).width(function(d) {
        return d.w
    }).height(function(d) {
        return d.h
    });
    this.$nodeWidth = this.$nodeHeight = function() {
        return 10
    }
    ;
    var count = 0;
    this.$setSize = function(n) {
        var w = that.$nodeWidth(n)
          , h = that.$nodeHeight(n);
        n.size = Math.sqrt(w * h);
        if (that.alternate() && count++ % 2) {
            n.w = h;
            n.h = w;
            n.rotated = true
        } else {
            n.w = w;
            n.h = h
        }
    }
    ;
    this.$collide = function(padding) {
        return function(n1, n2) {
            var nb1 = that.$getBox(n1)
              , nb2 = that.$getBox(n2);
            return n1 != n2 && ((nb1.x1 - padding < nb2.x1 && nb2.x1 < nb1.x2 + padding || nb1.x1 - padding < nb2.x2 && nb2.x2 < nb1.x2 + padding || nb2.x1 < nb1.x1 && nb2.x2 > nb1.x2) && (nb1.y1 - padding < nb2.y1 && nb2.y1 < nb1.y2 + padding || nb1.y1 - padding < nb2.y2 && nb2.y2 < nb1.y2 + padding) || nb2.y1 < nb1.y1 && nb2.y2 > nb1.y2)
        }
    }
    ;
    this.$getBox = function(n) {
        return {
            x1: n.x - n.w / 2,
            y1: n.y - n.h / 2,
            x2: n.x + n.w / 2,
            y2: n.y + n.h / 2
        }
    }
}
;
pv.Layout.Cloud.Box.prototype = pv.extend(pv.Layout.Cloud).property("alternate", Boolean);
pv.Layout.Cloud.Box.prototype.nodeWidth = function(f) {
    this.$nodeWidth = pv.functor(f);
    return this
}
;
pv.Layout.Cloud.Box.prototype.nodeHeight = function(f) {
    this.$nodeHeight = pv.functor(f);
    return this
}
;
pv.Layout.Cloud.Box.prototype.defaults = (new pv.Layout.Cloud.Box).extend(pv.Layout.Cloud.prototype.defaults).alternate(false);
pv.Layout.Cloud.Text = function() {
    pv.Layout.Cloud.Box.call(this);
    var that = this;
    (this.label = (new pv.Mark).extend(this.node).top(function(n) {
        return n.y
    }).left(function(n) {
        return n.x
    }).font(function(n) {
        return that.$font(n)
    }).text(function(n) {
        return that.$text(n)
    }).textBaseline("middle").textAlign("center").textAngle(function(n) {
        return n.rotated ? Math.PI / -2 : 0
    })).parent = this;
    this.$font = function() {
        return "bold 14px Arial"
    }
    ;
    this.$text = function(n) {
        return n.nodeName || n.nodeValue
    }
    ;
    this.node.fillStyle(null);
    var setBoxSize = that.$setSize;
    this.$setSize = function(n) {
        var res = tdgchart.measureLabel(that.$text(n), that.$font(n));
        that.$nodeWidth = pv.functor(res.width);
        that.$nodeHeight = pv.functor(res.height);
        setBoxSize(n)
    }
    ;
    delete this.nodeWidth;
    delete this.nodeHeight
}
;
pv.Layout.Cloud.Text.prototype = pv.extend(pv.Layout.Cloud.Box);
pv.Layout.Cloud.Text.prototype.font = function(f) {
    this.$font = pv.functor(f);
    return this
}
;
pv.Layout.Cloud.Text.prototype.text = function(f) {
    this.$text = pv.functor(f);
    return this
}
;
pv.Behavior = {};
pv.Behavior.drag = function() {
    var scene, index, p, v1, max;
    function mousedown(d) {
        index = this.index;
        scene = this.scene;
        var m = this.mouse();
        v1 = ((p = d).fix = pv.vector(d.x, d.y)).minus(m);
        max = {
            x: this.parent.width() - (d.dx || 0),
            y: this.parent.height() - (d.dy || 0)
        };
        scene.mark.context(scene, index, function() {
            this.render()
        });
        pv.Mark.dispatch("dragstart", scene, index)
    }
    function mousemove() {
        if (!scene)
            return;
        scene.mark.context(scene, index, function() {
            var m = this.mouse();
            p.x = p.fix.x = Math.max(0, Math.min(v1.x + m.x, max.x));
            p.y = p.fix.y = Math.max(0, Math.min(v1.y + m.y, max.y));
            this.render()
        });
        pv.Mark.dispatch("drag", scene, index)
    }
    function mouseup() {
        if (!scene)
            return;
        p.fix = null;
        scene.mark.context(scene, index, function() {
            this.render()
        });
        pv.Mark.dispatch("dragend", scene, index);
        scene = null
    }
    pv.listen(window.document, "mousemove", mousemove);
    pv.listen(window.document, "mouseup", mouseup);
    return mousedown
}
;
pv.Behavior.select = function() {
    var scene, index, r, m1;
    function mousedown(d) {
        index = this.index;
        scene = this.scene;
        m1 = this.mouse();
        r = d;
        r.x = m1.x;
        r.y = m1.y;
        r.dx = r.dy = 0;
        pv.Mark.dispatch("selectstart", scene, index)
    }
    function mousemove() {
        if (!scene)
            return;
        scene.mark.context(scene, index, function() {
            var m2 = this.mouse();
            r.x = Math.max(0, Math.min(m1.x, m2.x));
            r.y = Math.max(0, Math.min(m1.y, m2.y));
            r.dx = Math.min(this.width(), Math.max(m2.x, m1.x)) - r.x;
            r.dy = Math.min(this.height(), Math.max(m2.y, m1.y)) - r.y;
            this.render()
        });
        pv.Mark.dispatch("select", scene, index)
    }
    function mouseup() {
        if (!scene)
            return;
        pv.Mark.dispatch("selectend", scene, index);
        scene = null
    }
    pv.listen(window.document, "mousemove", mousemove);
    pv.listen(window.document, "mouseup", mouseup);
    return mousedown
}
;
pv.Behavior.pan = function() {
    var scene, index, m1, v1, k, bound;
    var mousedown = function() {
        index = this.index;
        scene = this.scene;
        v1 = pv.vector(pv.event.convertedPageX, pv.event.convertedPageY);
        m1 = this.transform();
        k = 1 / (m1.k * this.scale);
        if (bound)
            bound = {
                x: (1 - m1.k) * this.width(),
                y: (1 - m1.k) * this.height()
            }
    };
    var mousemove = function() {
        if (!scene)
            return;
        scene.mark.context(scene, index, function() {
            var x = (pv.event.convertedPageX - v1.x) * k;
            var y = (pv.event.convertedPageY - v1.y) * k;
            var m = m1.translate(x, y);
            if (bound) {
                m.x = Math.max(bound.x, Math.min(0, m.x));
                m.y = Math.max(bound.y, Math.min(0, m.y))
            }
            this.transform(m).render()
        });
        pv.Mark.dispatch("pan", scene, index)
    };
    var mouseup = function() {
        scene = null
    };
    mousedown.bound = function(x) {
        if (arguments.length) {
            bound = Boolean(x);
            return this
        }
        return Boolean(bound)
    }
    ;
    pv.listen(window.document, "mousemove", mousemove);
    pv.listen(window.document, "mouseup", mouseup);
    pv.listen(window.document, "touchmove", mousemove);
    pv.listen(window.document, "touchend", mouseup);
    return mousedown
}
;
pv.Behavior.delta = function() {
    var scene, index, r = {}, m1;
    var mousedown = function() {
        index = this.index;
        scene = this.scene;
        m1 = this.mouse();
        r.dx = r.dy = 0;
        pv.Mark.dispatch("deltastart", scene, index)
    };
    var mousemove = function() {
        if (!scene)
            return;
        scene.mark.context(scene, index, function() {
            var m2 = this.mouse();
            r.dx = m2.x - m1.x;
            r.dy = m2.y - m1.y;
            this.delta = r;
            m1 = m2
        });
        pv.Mark.dispatch("delta", scene, index)
    };
    var mouseup = function() {
        if (!scene)
            return;
        pv.Mark.dispatch("deltaend", scene, index);
        scene = null
    };
    pv.listen(window, "mousemove", mousemove);
    pv.listen(window, "mouseup", mouseup);
    pv.listen(window, "touchmove", mousemove);
    pv.listen(window, "touchend", mouseup);
    return mousedown
}
;
pv.Geo = function() {}
;
pv.Geo.projections = {
    mercator: {
        project: function(latlng) {
            return {
                x: latlng.lng / 180,
                y: latlng.lat > 85 ? 1 : latlng.lat < -85 ? -1 : Math.log(Math.tan(Math.PI / 4 + tdgchart.util.radians(latlng.lat) / 2)) / Math.PI
            }
        },
        invert: function(xy) {
            return {
                lng: xy.x * 180,
                lat: tdgchart.util.degrees(2 * Math.atan(Math.exp(xy.y * Math.PI)) - Math.PI / 2)
            }
        }
    },
    "gall-peters": {
        project: function(latlng) {
            return {
                x: latlng.lng / 180,
                y: Math.sin(tdgchart.util.radians(latlng.lat))
            }
        },
        invert: function(xy) {
            return {
                lng: xy.x * 180,
                lat: tdgchart.util.degrees(Math.asin(xy.y))
            }
        }
    },
    sinusoidal: {
        project: function(latlng) {
            return {
                x: tdgchart.util.radians(latlng.lng) * Math.cos(tdgchart.util.radians(latlng.lat)) / Math.PI,
                y: latlng.lat / 90
            }
        },
        invert: function(xy) {
            return {
                lng: tdgchart.util.degrees(xy.x * Math.PI / Math.cos(xy.y * Math.PI / 2)),
                lat: xy.y * 90
            }
        }
    },
    aitoff: {
        project: function(latlng) {
            var l = tdgchart.util.radians(latlng.lng)
              , f = tdgchart.util.radians(latlng.lat)
              , a = Math.acos(Math.cos(f) * Math.cos(l / 2));
            return {
                x: 2 * (a ? Math.cos(f) * Math.sin(l / 2) * a / Math.sin(a) : 0) / Math.PI,
                y: 2 * (a ? Math.sin(f) * a / Math.sin(a) : 0) / Math.PI
            }
        },
        invert: function(xy) {
            var x = xy.x * Math.PI / 2
              , y = xy.y * Math.PI / 2;
            return {
                lng: tdgchart.util.degrees(x / Math.cos(y)),
                lat: tdgchart.util.degrees(y)
            }
        }
    },
    hammer: {
        project: function(latlng) {
            var l = tdgchart.util.radians(latlng.lng)
              , f = tdgchart.util.radians(latlng.lat)
              , c = Math.sqrt(1 + Math.cos(f) * Math.cos(l / 2));
            return {
                x: 2 * Math.SQRT2 * Math.cos(f) * Math.sin(l / 2) / c / 3,
                y: Math.SQRT2 * Math.sin(f) / c / 1.5
            }
        },
        invert: function(xy) {
            var x = xy.x * 3
              , y = xy.y * 1.5
              , z = Math.sqrt(1 - x * x / 16 - y * y / 4);
            return {
                lng: tdgchart.util.degrees(2 * Math.atan2(z * x, 2 * (2 * z * z - 1))),
                lat: tdgchart.util.degrees(Math.asin(z * y))
            }
        }
    },
    identity: {
        project: function(latlng) {
            return {
                x: latlng.lng / 180,
                y: latlng.lat / 90
            }
        },
        invert: function(xy) {
            return {
                lng: xy.x * 180,
                lat: xy.y * 90
            }
        }
    }
};
pv.Geo.scale = function(p) {
    var rmin = {
        x: 0,
        y: 0
    }, rmax = {
        x: 1,
        y: 1
    }, d = [], j = pv.Geo.projections.identity, x = pv.Scale.linear(-1, 1).range(0, 1), y = pv.Scale.linear(-1, 1).range(1, 0), c = {
        lng: 0,
        lat: 0
    }, lastLatLng, lastPoint;
    function scale(latlng) {
        if (!lastLatLng || latlng.lng != lastLatLng.lng || latlng.lat != lastLatLng.lat) {
            lastLatLng = latlng;
            var p = project(latlng);
            lastPoint = {
                x: x(p.x),
                y: y(p.y)
            }
        }
        return lastPoint
    }
    function project(latlng) {
        var offset = {
            lng: latlng.lng - c.lng,
            lat: latlng.lat
        };
        return j.project(offset)
    }
    function invert(xy) {
        var latlng = j.invert(xy);
        latlng.lng += c.lng;
        return latlng
    }
    scale.x = function(latlng) {
        return scale(latlng).x
    }
    ;
    scale.y = function(latlng) {
        return scale(latlng).y
    }
    ;
    scale.ticks = {
        lng: function() {
            var lat, lng;
            if (d.length > 1) {
                var s = pv.Scale.linear();
                lat = s.domain(d, function(d) {
                    return d.lat
                }).ticks();
                lng = s.domain(d, function(d) {
                    return d.lng
                }).ticks()
            } else {
                lat = tdgchart.util.range(-80, 81, 10);
                lng = tdgchart.util.range(-180, 181, 10)
            }
            return lng.map(function(lng) {
                return lat.map(function(lat) {
                    return {
                        lat: lat,
                        lng: lng
                    }
                })
            })
        },
        lat: function() {
            return tdgchart.util.transpose(scale.ticks.lng())
        }
    };
    scale.invert = function(p) {
        return invert({
            x: x.invert(p.x),
            y: y.invert(p.y)
        })
    }
    ;
    scale.domain = function(array, f) {
        if (arguments.length) {
            d = array instanceof Array ? arguments.length > 1 ? tdgchart.util.map(array, f) : array : Array.prototype.slice.call(arguments);
            if (d.length > 1) {
                var lngs = d.map(function(c) {
                    return c.lng
                });
                var lats = d.map(function(c) {
                    return c.lat
                });
                c = {
                    lng: (tdgchart.util.max(lngs) + tdgchart.util.min(lngs)) / 2,
                    lat: (tdgchart.util.max(lats) + tdgchart.util.min(lats)) / 2
                };
                var n = d.map(project);
                x.domain(n, function(p) {
                    return p.x
                });
                y.domain(n, function(p) {
                    return p.y
                })
            } else {
                c = {
                    lng: 0,
                    lat: 0
                };
                x.domain(-1, 1);
                y.domain(-1, 1)
            }
            lastLatLng = null;
            return this
        }
        return d
    }
    ;
    scale.range = function(min, max) {
        if (arguments.length) {
            if (typeof min == "object") {
                rmin = {
                    x: Number(min.x),
                    y: Number(min.y)
                };
                rmax = {
                    x: Number(max.x),
                    y: Number(max.y)
                }
            } else {
                rmin = {
                    x: 0,
                    y: 0
                };
                rmax = {
                    x: Number(min),
                    y: Number(max)
                }
            }
            x.range(rmin.x, rmax.x);
            y.range(rmax.y, rmin.y);
            lastLatLng = null;
            return this
        }
        return [rmin, rmax]
    }
    ;
    scale.projection = function(p) {
        if (arguments.length) {
            j = typeof p == "string" ? pv.Geo.projections[p] || pv.Geo.projections.identity : p;
            return this.domain(d)
        }
        return p
    }
    ;
    scale.by = function(f) {
        function by() {
            return scale(f.apply(this, arguments))
        }
        for (var method in scale)
            by[method] = scale[method];
        return by
    }
    ;
    if (arguments.length)
        scale.projection(p);
    return scale
}
;
pv.Wedge25d = function() {
    pv.Wedge.call(this)
}
;
pv.Wedge25d.prototype = pv.extend(pv.Wedge).property("fillEffect", String).property("depth", Number).property("skew", Number);
pv.Wedge25d.prototype.type = "wedge25d";
pv.Wedge25d.prototype.defaults = (new pv.Wedge25d).extend(pv.Wedge.prototype.defaults).depth(25).skew(0);
pv.Area3d = function() {
    pv.Area.call(this)
}
;
pv.Area3d.prototype = pv.extend(pv.Area).property("fillEffect", String).property("depth", Number).property("front", Number).property("back", Number);
pv.Area3d.prototype.type = "area3d";
pv.Bar3d = function() {
    pv.Bar.call(this)
}
;
pv.Bar3d.prototype = pv.extend(pv.Bar).property("fillEffect", String).property("depth", Number).property("front", Number).property("back", Number);
pv.Bar3d.prototype.type = "bar3d";
pv.Bar3d.prototype.defaults = (new pv.Bar3d).extend(pv.Bar.prototype.defaults).front(0).depth(20);
pv.Bar25d = function() {
    pv.Bar.call(this)
}
;
pv.Bar25d.prototype = pv.extend(pv.Bar).property("fillEffect", String).property("backtext", Boolean).property("depth", Number).property("dmargin", Number);
pv.Bar25d.prototype.type = "bar25d";
pv.Bar25d.prototype.defaults = (new pv.Bar25d).extend(pv.Bar.prototype.defaults).depth(25).backtext(false).dmargin(.6);
pv.FeelerLine = function() {
    pv.Line.call(this)
}
;
pv.FeelerLine.prototype = pv.extend(pv.Line).property("x0", Number).property("y0", Number).property("x1", Number).property("y1", Number).property("x2", Number).property("y2", Number);
pv.FeelerLine.prototype.type = "feelerline";
pv.FeelerLine.prototype.defaults = (new pv.FeelerLine).extend(pv.Line.prototype.defaults).segmented(true).fillStyle(null).lineWidth(1);
pv.Label3d = function() {
    pv.Label.call(this)
}
;
pv.Label3d.prototype = pv.extend(pv.Label).property("depth", Number).property("front", Number).property("back", Number);
pv.Label3d.prototype.type = "label3d";
pv.Label3d.prototype.buildImplied = function(s) {
    var fr = s.front
      , ba = s.back;
    if (s.depth != null || fr != null && ba != null)
        s.height = s.width = 0;
    else
        s.depth = 0;
    pv.Label.prototype.buildImplied.call(this, s)
}
;
pv.Panel3d = function() {
    pv.Panel.call(this);
    this.root3d = this
}
;
pv.Panel3d.prototype = pv.extend(pv.Panel).property("rotate", Number).property("tilt", Number).property("projection3d", Object).property("depth", Number).property("front", Number).property("back", Number);
pv.Panel3d.prototype.type = "panel3d";
pv.Panel3d.prototype.defaults = (new pv.Panel3d).extend(pv.Panel.prototype.defaults);
pv.Panel3d.prototype.buildInstance = function(s) {
    pv.Panel.prototype.buildInstance.call(this, s);
    this.rotate(function() {
        return this.root3d.rotate()
    });
    this.tilt(function() {
        return this.root3d.tilt()
    });
    this.projection3d(function() {
        return this.root3d.projection3d()
    })
}
;
pv.Panel3d.prototype.add = function(type) {
    var child = pv.Panel.prototype.add.call(this, type);
    child.root3d = this.root3d;
    return child
}
;
pv.Rule3d = function() {
    pv.Rule.call(this)
}
;
pv.Rule3d.prototype = pv.extend(pv.Rule).property("depth", Number).property("front", Number).property("back", Number);
pv.Rule3d.prototype.type = "rule3d";
pv.Rule3d.prototype.defaults = (new pv.Rule3d).extend(pv.Rule.prototype.defaults).antialias(true);
pv.Rule3d.prototype.buildImplied = function(s) {
    var fr = s.front
      , ba = s.back;
    if (s.depth != null && s.depth !== 0 || fr == null && ba == null || fr != null && ba != null)
        s.height = s.width = 0;
    else
        s.depth = 0;
    pv.Rule.prototype.buildImplied.call(this, s)
}
;
pv.Wall3d = function() {
    pv.Rule.call(this)
}
;
pv.Wall3d.prototype = pv.extend(pv.Rule).property("fillStyle", tdgchart.util.color).property("depth", Number).property("front", Number).property("back", Number);
pv.Wall3d.prototype.type = "wall3d";
pv.Wall3d.prototype.defaults = (new pv.Wall3d).extend(pv.Rule.prototype.defaults).antialias(true);
pv.Wall3d.prototype.buildImplied = function(s) {
    var fr = s.front
      , ba = s.back;
    if (s.depth != null || fr != null && ba != null)
        pv.Rule.prototype.buildImplied.call(this, s);
    else {
        s.depth = 0;
        pv.Mark.prototype.buildImplied.call(this, s)
    }
}
;
pv.Surface3d = function() {
    pv.Area3d.call(this)
}
;
pv.Surface3d.prototype = pv.extend(pv.Area3d);
pv.Surface3d.prototype.type = "surface3d";
pv.tdgScene = pv.extend(pv.SvgScene);
pv.scene3d = function(rotation, tilt) {
    this.rotation = rotation;
    this.tilt = tilt;
    this.viewer = [];
    this.camera = [];
    this.cameraangle = [];
    this.compute_position();
    this.projection = new this.projection(this.viewer,this.camera,this.cameraangle)
}
;
pv.scene3d.prototype.projection = function(viewer, camera, camera_angle) {
    this.sinx = Math.sin(camera_angle[0]);
    this.siny = Math.sin(camera_angle[1]);
    this.sinz = Math.sin(camera_angle[2]);
    this.cosx = Math.cos(camera_angle[0]);
    this.cosy = Math.cos(camera_angle[1]);
    this.cosz = Math.cos(camera_angle[2]);
    this.camera = camera;
    this.viewer = viewer;
    this.pos2D = function(point) {
        var px = point[0] - this.camera[0];
        var py = point[1] - this.camera[1];
        var pz = point[2] - this.camera[2];
        var dx = this.cosy * (this.sinz * py + this.cosz * px) - this.siny * pz;
        var dy = this.sinx * (this.cosy * pz + this.siny * (this.sinz * py + this.cosz * px)) + this.cosx * (this.cosz * py - this.sinz * px);
        var dz = this.cosz * (this.cosy * pz + this.siny * (this.sinz * py + this.cosz * px)) - this.sinx * (this.cosz * py - this.sinz * px);
        var b = [];
        b[0] = -(dx - this.viewer[0]) * (this.viewer[2] / dz);
        b[1] = (dy - this.viewer[1]) * (this.viewer[2] / dz);
        return b
    }
}
;
pv.scene3d.prototype.set_rotation = function(angle) {
    this.rotation = angle;
    this.compute_position();
    this.projection = new this.projection(this.viewer,this.camera,this.cameraangle)
}
;
pv.scene3d.prototype.set_tilt = function(angle) {
    this.tilt = angle;
    this.compute_position();
    this.projection = new this.projection(this.viewer,this.camera,this.cameraangle)
}
;
pv.scene3d.prototype.compute_position = function() {
    var xf = Math.sin(this.rotation) * Math.sin(Math.PI / 2 + this.tilt);
    var yf = Math.cos(Math.PI / 2 + this.tilt);
    var zf = Math.cos(this.rotation) * Math.sin(Math.PI / 2 + this.tilt);
    var r;
    r = 2;
    this.viewer[0] = xf * r;
    this.viewer[1] = -yf * r;
    this.viewer[2] = -zf * r;
    this.viewer[0] += .5;
    this.viewer[1] += .5;
    this.viewer[2] += -2;
    this.camera[0] = 0;
    this.camera[1] = 0;
    this.camera[2] = -2;
    this.cameraangle[0] = this.tilt;
    this.cameraangle[1] = -this.rotation;
    this.cameraangle[2] = 0;
    r = 5;
    this.viewer[0] = xf * r;
    this.viewer[1] = yf * r;
    this.viewer[2] = zf * r;
    this.viewer[0] += 0;
    this.viewer[1] += 0;
    this.viewer[2] += 0;
    this.camera[0] = .5;
    this.camera[1] = .5;
    this.camera[2] = 2;
    this.cameraangle[0] = this.tilt;
    this.cameraangle[1] = this.rotation;
    this.cameraangle[2] = 0;
    r = 3;
    this.camera[0] = xf * r;
    this.camera[1] = -yf * r;
    this.camera[2] = -zf * r;
    this.camera[0] += 0;
    this.camera[1] += 0;
    this.camera[2] += 0;
    this.viewer[0] = .5;
    this.viewer[1] = .5;
    this.viewer[2] = -4;
    this.cameraangle[0] = this.tilt;
    this.cameraangle[1] = -this.rotation;
    this.cameraangle[2] = 0
}
;
pv.scene3d.prototype.project2d = function(objects) {
    var pp = [];
    for (var w = 0; w < objects.length; w++) {
        pp[w] = [];
        for (var i = 0; i < objects[w].length; i++)
            pp[w][i] = this.projection.pos2D(objects[w][i])
    }
    return pp
}
;
pv.scene3d.prototype.get_2d_point = function(p, width, height) {
    var shift = 2;
    var scale = 4;
    return {
        x: (p[0] + shift) * width / scale,
        y: (p[1] + shift) * height / scale
    }
}
;
pv.scene3d.prototype.create_svg_path = function(poly, width, height, close) {
    function moveto(x, y) {
        return "M" + x + " " + y
    }
    function lineto(x, y) {
        return "L" + x + " " + y
    }
    function closepath() {
        return "z"
    }
    var path = "";
    var p = this.get_2d_point(poly[0], width, height);
    if (isNaN(p.x))
        return undefined;
    path += moveto(p.x, p.y);
    for (var i = 1; i < poly.length; i++) {
        p = this.get_2d_point(poly[i], width, height);
        path += lineto(p.x, p.y)
    }
    if (close === undefined || close)
        path += closepath();
    return path
}
;
pv.scene3d.prototype.draw_to_canvas = function(canvas, pps) {
    var context = canvas.getContext("2d");
    var pp = this.project2d(pps);
    var x, y;
    context.clearRect(0, 0, canvas.width, canvas.height);
    for (var w = pp.length - 1; w >= 0; w--) {
        x = (pp[w][0][0] + 5) * canvas.width / 10;
        y = (pp[w][0][1] + 5) * canvas.height / 10;
        if (w === 0) {
            context.beginPath();
            context.arc(x, y, 4, 0, 2 * Math.PI, false);
            context.fillStyle = "#0f0";
            context.fill()
        }
        context.beginPath();
        context.moveTo(x, y);
        for (var i = 1; i < pp[w].length; i++) {
            x = (pp[w][i][0] + 5) * canvas.width / 10;
            y = (pp[w][i][1] + 5) * canvas.height / 10;
            context.lineTo(x, y)
        }
        context.closePath();
        context.fillStyle = this.colors[w];
        context.strokeStyle = "#f00";
        context.lineWidth = 1;
        context.fill();
        context.stroke()
    }
}
;
pv.Mark.prototype.buildImplied2d = pv.Mark.prototype.buildImplied;
pv.Mark.prototype.buildImplied = function(s) {
    pv.Mark.prototype.buildImplied2d.call(this, s);
    var p = this.properties;
    if (!(p.front && p.back))
        return;
    var fr = s.front;
    var ba = s.back;
    var d = p.depth ? s.depth : 0;
    var depth = this.parent ? this.parent.depth() : d + fr + ba;
    if (d == null)
        d = depth - (ba = ba || 0) - (fr = fr || 0);
    else if (ba == null)
        ba = depth - d - (fr = fr || 0);
    else if (fr == null)
        fr = depth - d - (ba = ba || 0);
    s.front = fr;
    s.back = ba;
    if (p.depth)
        s.depth = d
}
;
if (pv.Scene === pv.SvgScene)
    pv.Scene = pv.tdgScene;
(function() {
    var d3 = {
        version: "1.15.0"
    };
    tdgchart.d3 = d3;
    if (!Date.now)
        Date.now = function() {
            return +new Date
        }
        ;
    var d3_array = d3_arraySlice;
    function d3_arrayCopy(psuedoarray) {
        var i = -1
          , n = psuedoarray.length
          , array = [];
        while (++i < n)
            array.push(psuedoarray[i]);
        return array
    }
    function d3_arraySlice(psuedoarray) {
        return Array.prototype.slice.call(psuedoarray)
    }
    try {
        var unused = d3_array(document.documentElement.childNodes)[0].nodeType
    } catch (e$6) {
        d3_array = d3_arrayCopy
    }
    d3.functor = function(v) {
        return typeof v === "function" ? v : function() {
            return v
        }
    }
    ;
    d3.ascending = function(a, b) {
        return a < b ? -1 : a > b ? 1 : 0
    }
    ;
    function d3_collapse(s) {
        return s.replace(/(^\s+)|(\s+$)/g, "").replace(/\s+/g, " ")
    }
    function d3_call(callback) {
        callback.apply(this, (arguments[0] = this,
        arguments));
        return this
    }
    d3.requote = function(s) {
        return s.replace(d3_requote_re, "\\$&")
    }
    ;
    var d3_requote_re = /[\\\^\$\*\+\?\[\]\(\)\.\{\}]/g;
    d3.ns = {
        prefix: {
            svg: "http://www.w3.org/2000/svg",
            xhtml: "http://www.w3.org/1999/xhtml",
            xlink: "http://www.w3.org/1999/xlink",
            xml: "http://www.w3.org/XML/1998/namespace",
            xmlns: "http://www.w3.org/2000/xmlns/"
        },
        qualify: function(name) {
            var i = name.indexOf(":");
            return i < 0 ? name : {
                space: d3.ns.prefix[name.substring(0, i)],
                local: name.substring(i + 1)
            }
        }
    };
    d3.dispatch = function(types) {
        var dispatch = {}, type;
        for (var i = 0, n = arguments.length; i < n; i++) {
            type = arguments[i];
            dispatch[type] = d3_dispatch(type)
        }
        return dispatch
    }
    ;
    function d3_dispatch(type) {
        var dispatch = {}
          , listeners = [];
        dispatch.add = function(listener) {
            for (var i = 0; i < listeners.length; i++)
                if (listeners[i].listener == listener)
                    return dispatch;
            listeners.push({
                listener: listener,
                on: true
            });
            return dispatch
        }
        ;
        dispatch.remove = function(listener) {
            for (var i = 0; i < listeners.length; i++) {
                var l = listeners[i];
                if (l.listener == listener) {
                    l.on = false;
                    listeners = listeners.slice(0, i).concat(listeners.slice(i + 1));
                    break
                }
            }
            return dispatch
        }
        ;
        dispatch.dispatch = function() {
            var ls = listeners;
            for (var i = 0, n = ls.length; i < n; i++) {
                var l = ls[i];
                if (l.on)
                    l.listener.apply(this, arguments)
            }
        }
        ;
        return dispatch
    }
    var d3_ease_quad = d3_ease_poly(2)
      , d3_ease_cubic = d3_ease_poly(3);
    var d3_ease = {
        linear: function() {
            return d3_ease_linear
        },
        poly: d3_ease_poly,
        quad: function() {
            return d3_ease_quad
        },
        cubic: function() {
            return d3_ease_cubic
        },
        sin: function() {
            return d3_ease_sin
        },
        exp: function() {
            return d3_ease_exp
        },
        circle: function() {
            return d3_ease_circle
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function() {
            return d3_ease_bounce
        }
    };
    var d3_ease_mode = {
        "in": function(f) {
            return f
        },
        "out": d3_ease_reverse,
        "in-out": d3_ease_reflect,
        "out-in": function(f) {
            return d3_ease_reflect(d3_ease_reverse(f))
        }
    };
    d3.ease = function(name) {
        var i = name.indexOf("-")
          , t = i >= 0 ? name.substring(0, i) : name
          , m = i >= 0 ? name.substring(i + 1) : "in";
        return d3_ease_mode[m](d3_ease[t].apply(null, Array.prototype.slice.call(arguments, 1)))
    }
    ;
    function d3_ease_reverse(f) {
        return function(t) {
            return 1 - f(1 - t)
        }
    }
    function d3_ease_reflect(f) {
        return function(t) {
            return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t))
        }
    }
    function d3_ease_linear(t) {
        return t
    }
    function d3_ease_poly(e) {
        return function(t) {
            return Math.pow(t, e)
        }
    }
    function d3_ease_sin(t) {
        return 1 - Math.cos(t * Math.PI / 2)
    }
    function d3_ease_exp(t) {
        return t ? Math.pow(2, 10 * (t - 1)) - .001 : 0
    }
    function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t)
    }
    function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2)
            p = .45;
        if (arguments.length < 1) {
            a = 1;
            s = p / 4
        } else
            s = p / (2 * Math.PI) * Math.asin(1 / a);
        return function(t) {
            return 1 + a * Math.pow(2, 10 * -t) * Math.sin((t - s) * 2 * Math.PI / p)
        }
    }
    function d3_ease_back(s) {
        if (!s)
            s = 1.70158;
        return function(t) {
            return t * t * ((s + 1) * t - s)
        }
    }
    function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
    }
    d3.event = null;
    d3.interpolate = function(a, b) {
        if (typeof b === "number")
            return d3.interpolateNumber(+a, b);
        if (typeof b === "string")
            return d3.interpolateString(String(a), b)
    }
    ;
    d3.interpolateNumber = function(a, b) {
        b -= a;
        return function(t) {
            return a + b * t
        }
    }
    ;
    d3.interpolateString = function(a, b) {
        var m, i, j, s0 = 0, s1 = 0, s = [], q = [], n, o;
        d3_interpolate_number.lastIndex = 0;
        for (i = 0; m = d3_interpolate_number.exec(b); ++i) {
            if (m.index)
                s.push(b.substring(s0, s1 = m.index));
            q.push({
                i: s.length,
                x: m[0]
            });
            s.push(null);
            s0 = d3_interpolate_number.lastIndex
        }
        if (s0 < b.length)
            s.push(b.substring(s0));
        for (i = 0,
        n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {
            o = q[i];
            if (o.x == m[0]) {
                if (o.i)
                    if (s[o.i + 1] == null) {
                        s[o.i - 1] += o.x;
                        s.splice(o.i, 1);
                        for (j = i + 1; j < n; ++j)
                            q[j].i--
                    } else {
                        s[o.i - 1] += o.x + s[o.i + 1];
                        s.splice(o.i, 2);
                        for (j = i + 1; j < n; ++j)
                            q[j].i -= 2
                    }
                else if (s[o.i + 1] == null)
                    s[o.i] = o.x;
                else {
                    s[o.i] = o.x + s[o.i + 1];
                    s.splice(o.i + 1, 1);
                    for (j = i + 1; j < n; ++j)
                        q[j].i--
                }
                q.splice(i, 1);
                n--;
                i--
            } else
                o.x = d3.interpolateNumber(parseFloat(m[0]), parseFloat(o.x))
        }
        while (i < n) {
            o = q.pop();
            if (s[o.i + 1] == null)
                s[o.i] = o.x;
            else {
                s[o.i] = o.x + s[o.i + 1];
                s.splice(o.i + 1, 1)
            }
            n--
        }
        if (s.length === 1)
            return s[0] == null ? q[0].x : function() {
                return b
            }
            ;
        return function(t) {
            for (i = 0; i < n; ++i)
                s[(o = q[i]).i] = o.x(t);
            return s.join("")
        }
    }
    ;
    d3.interpolateRgb = d3_interpolateRgb;
    function d3_interpolateRgb(a, b) {
        a = tdgchart.util.color(a);
        b = tdgchart.util.color(b);
        var ar = a.r
          , ag = a.g
          , ab = a.b
          , br = b.r - ar
          , bg = b.g - ag
          , bb = b.b - ab;
        return function(t) {
            return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t))
        }
    }
    function d3_rgb_hex(v) {
        return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16)
    }
    var d3_interpolate_number = /[-+]?(?:\d+\.\d+|\d+\.|\.\d+|\d+)(?:[eE][-]?\d+)?/g;
    var d3_select = function(s, n) {
        return n.querySelector(s)
    }
      , d3_selectAll = function(s, n) {
        return d3_array(n.querySelectorAll(s))
    };
    var d3_root = {};
    if (typeof document !== "undefined") {
        d3_root = d3_selection([[document]]);
        d3_root[0].parentNode = document.documentElement
    }
    d3.select = function(selector) {
        return typeof selector === "string" ? d3_root.select(selector) : d3_selection([[selector]])
    }
    ;
    d3.selectAll = function(selector) {
        return typeof selector === "string" ? d3_root.selectAll(selector) : d3_selection([d3_array(selector)])
    }
    ;
    function d3_selection(groups) {
        function select(select) {
            var subgroups = [], subgroup, subnode, group, node;
            for (var j = 0, m = groups.length; j < m; j++) {
                group = groups[j];
                subgroups.push(subgroup = []);
                subgroup.parentNode = group.parentNode;
                for (var i = 0, n = group.length; i < n; i++)
                    if (node = group[i]) {
                        subgroup.push(subnode = select(node));
                        if (subnode && "__data__"in node)
                            subnode.__data__ = node.__data__
                    } else
                        subgroup.push(null)
            }
            return d3_selection(subgroups)
        }
        function selectAll(selectAll) {
            var subgroups = [], subgroup, group, node;
            for (var j = 0, m = groups.length; j < m; j++) {
                group = groups[j];
                for (var i = 0, n = group.length; i < n; i++)
                    if (node = group[i]) {
                        subgroups.push(subgroup = selectAll(node));
                        subgroup.parentNode = node
                    }
            }
            return d3_selection(subgroups)
        }
        groups.select = function(selector) {
            return select(function(node) {
                return d3_select(selector, node)
            })
        }
        ;
        groups.selectAll = function(selector) {
            return selectAll(function(node) {
                return d3_selectAll(selector, node)
            })
        }
        ;
        groups.filter = function(filter) {
            var subgroups = [], subgroup, group, node;
            for (var j = 0, m = groups.length; j < m; j++) {
                group = groups[j];
                subgroups.push(subgroup = []);
                subgroup.parentNode = group.parentNode;
                for (var i = 0, n = group.length; i < n; i++)
                    if ((node = group[i]) && filter.call(node, node.__data__, i))
                        subgroup.push(node)
            }
            return d3_selection(subgroups)
        }
        ;
        groups.map = function(map) {
            var group, node;
            for (var j = 0, m = groups.length; j < m; j++) {
                group = groups[j];
                for (var i = 0, n = group.length; i < n; i++)
                    if (node = group[i])
                        node.__data__ = map.call(node, node.__data__, i)
            }
            return groups
        }
        ;
        groups.data = function(data, join) {
            var enter = []
              , update = []
              , exit = [];
            function bind(group, groupData) {
                var i = 0, n = group.length, m = groupData.length, n0 = Math.min(n, m), n1 = Math.max(n, m), updateNodes = [], enterNodes = [], exitNodes = [], node, nodeData;
                if (join) {
                    var nodeByKey = {}, keys = [], key, j = groupData.length;
                    for (i = 0; i < n; i++) {
                        key = join.call(node = group[i], node.__data__, i);
                        if (key in nodeByKey)
                            exitNodes[j++] = group[i];
                        else
                            nodeByKey[key] = node;
                        keys.push(key)
                    }
                    for (i = 0; i < m; i++) {
                        node = nodeByKey[key = join.call(groupData, nodeData = groupData[i], i)];
                        if (node) {
                            node.__data__ = nodeData;
                            updateNodes[i] = node;
                            enterNodes[i] = exitNodes[i] = null
                        } else {
                            enterNodes[i] = d3_selection_enterNode(nodeData);
                            updateNodes[i] = exitNodes[i] = null
                        }
                        delete nodeByKey[key]
                    }
                    for (i = 0; i < n; i++)
                        if (keys[i]in nodeByKey)
                            exitNodes[i] = group[i]
                } else {
                    for (; i < n0; i++) {
                        node = group[i];
                        nodeData = groupData[i];
                        if (node) {
                            node.__data__ = nodeData;
                            updateNodes[i] = node;
                            enterNodes[i] = exitNodes[i] = null
                        } else {
                            enterNodes[i] = d3_selection_enterNode(nodeData);
                            updateNodes[i] = exitNodes[i] = null
                        }
                    }
                    for (; i < m; i++) {
                        enterNodes[i] = d3_selection_enterNode(groupData[i]);
                        updateNodes[i] = exitNodes[i] = null
                    }
                    for (; i < n1; i++) {
                        exitNodes[i] = group[i];
                        enterNodes[i] = updateNodes[i] = null
                    }
                }
                enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
                enter.push(enterNodes);
                update.push(updateNodes);
                exit.push(exitNodes)
            }
            var i = -1, n = groups.length, group;
            if (typeof data === "function")
                while (++i < n)
                    bind(group = groups[i], data.call(group, group.parentNode.__data__, i));
            else
                while (++i < n)
                    bind(group = groups[i], data);
            var selection = d3_selection(update);
            selection.enter = function() {
                return d3_selectionEnter(enter)
            }
            ;
            selection.exit = function() {
                return d3_selection(exit)
            }
            ;
            return selection
        }
        ;
        groups.each = function(callback) {
            for (var j = 0, m = groups.length; j < m; j++) {
                var group = groups[j];
                for (var i = 0, n = group.length; i < n; i++) {
                    var node = group[i];
                    if (node)
                        callback.call(node, node.__data__, i)
                }
            }
            return groups
        }
        ;
        function first(callback) {
            for (var j = 0, m = groups.length; j < m; j++) {
                var group = groups[j];
                for (var i = 0, n = group.length; i < n; i++) {
                    var node = group[i];
                    if (node)
                        return callback.call(node, node.__data__, i)
                }
            }
            return null
        }
        groups.empty = function() {
            return !first(function() {
                return true
            })
        }
        ;
        groups.node = function() {
            return first(function() {
                return this
            })
        }
        ;
        groups.attr = function(name, value) {
            name = d3.ns.qualify(name);
            if (arguments.length < 2)
                return first(name.local ? function() {
                    return this.getAttributeNS(name.space, name.local)
                }
                : function() {
                    return this.getAttribute(name)
                }
                );
            function attrNull() {
                this.removeAttribute(name)
            }
            function attrNullNS() {
                this.removeAttributeNS(name.space, name.local)
            }
            function attrConstant() {
                this.setAttribute(name, value)
            }
            function attrConstantNS() {
                this.setAttributeNS(name.space, name.local, value)
            }
            function attrFunction() {
                var x = value.apply(this, arguments);
                if (x == null)
                    this.removeAttribute(name);
                else
                    this.setAttribute(name, x)
            }
            function attrFunctionNS() {
                var x = value.apply(this, arguments);
                if (x == null)
                    this.removeAttributeNS(name.space, name.local);
                else
                    this.setAttributeNS(name.space, name.local, x)
            }
            return groups.each(value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant)
        }
        ;
        groups.classed = function(name, value) {
            var re = new RegExp("(^|\\s+)" + d3.requote(name) + "(\\s+|$)","g");
            if (arguments.length < 2)
                return first(function() {
                    if (c = this.classList)
                        return c.contains(name);
                    var c = this.className;
                    re.lastIndex = 0;
                    return re.test(c.baseVal != null ? c.baseVal : c)
                });
            function classedAdd() {
                if (c = this.classList)
                    return c.add(name);
                var c = this.className
                  , cb = c.baseVal != null
                  , cv = cb ? c.baseVal : c;
                re.lastIndex = 0;
                if (!re.test(cv)) {
                    cv = d3_collapse(cv + " " + name);
                    if (cb)
                        c.baseVal = cv;
                    else
                        this.className = cv
                }
                return undefined
            }
            function classedRemove() {
                if (c = this.classList)
                    return c.remove(name);
                var c = this.className
                  , cb = c.baseVal != null
                  , cv = cb ? c.baseVal : c;
                cv = d3_collapse(cv.replace(re, " "));
                if (cb)
                    c.baseVal = cv;
                else
                    this.className = cv;
                return undefined
            }
            function classedFunction() {
                (value.apply(this, arguments) ? classedAdd : classedRemove).call(this)
            }
            return groups.each(typeof value === "function" ? classedFunction : value ? classedAdd : classedRemove)
        }
        ;
        groups.style = function(name, value, priority) {
            if (arguments.length < 3)
                priority = "";
            if (arguments.length < 2)
                return first(function() {
                    return window.getComputedStyle(this, null).getPropertyValue(name)
                });
            function styleNull() {
                this.style.removeProperty(name)
            }
            function styleConstant() {
                this.style.setProperty(name, value + "", priority)
            }
            function styleFunction() {
                var x = value.apply(this, arguments);
                if (x == null)
                    this.style.removeProperty(name);
                else
                    this.style.setProperty(name, x + "", priority)
            }
            return groups.each(value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant)
        }
        ;
        groups.property = function(name, value) {
            name = d3.ns.qualify(name);
            if (arguments.length < 2)
                return first(function() {
                    return this[name]
                });
            function propertyNull() {
                delete this[name]
            }
            function propertyConstant() {
                this[name] = value
            }
            function propertyFunction() {
                var x = value.apply(this, arguments);
                if (x == null)
                    delete this[name];
                else
                    this[name] = x
            }
            return groups.each(value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant)
        }
        ;
        groups.text = function(value) {
            if (arguments.length < 1)
                return first(function() {
                    return this.textContent
                });
            function textConstant() {
                this.textContent = value
            }
            function textFunction() {
                this.textContent = value.apply(this, arguments)
            }
            return groups.each(typeof value === "function" ? textFunction : textConstant)
        }
        ;
        groups.html = function(value) {
            if (arguments.length < 1)
                return first(function() {
                    return this.innerHTML
                });
            function htmlConstant() {
                this.innerHTML = value
            }
            function htmlFunction() {
                this.innerHTML = value.apply(this, arguments)
            }
            return groups.each(typeof value === "function" ? htmlFunction : htmlConstant)
        }
        ;
        groups.append = function(name) {
            name = d3.ns.qualify(name);
            function append(node) {
                return node.appendChild(document.createElement(name))
            }
            function appendNS(node) {
                return node.appendChild(document.createElementNS(name.space, name.local))
            }
            return select(name.local ? appendNS : append)
        }
        ;
        groups.insert = function(name, before) {
            name = d3.ns.qualify(name);
            function insert(node) {
                return node.insertBefore(document.createElement(name), d3_select(before, node))
            }
            function insertNS(node) {
                return node.insertBefore(document.createElementNS(name.space, name.local), d3_select(before, node))
            }
            return select(name.local ? insertNS : insert)
        }
        ;
        groups.remove = function() {
            return groups.each(function() {
                var parent = this.parentNode;
                if (parent)
                    parent.removeChild(this)
            })
        }
        ;
        groups.sort = function(comparator) {
            comparator = d3_selection_comparator.apply(this, arguments);
            for (var j = 0, m = groups.length; j < m; j++) {
                var group = groups[j];
                group.sort(comparator);
                for (var i = 1, n = group.length, prev = group[0]; i < n; i++) {
                    var node = group[i];
                    if (node) {
                        if (prev)
                            prev.parentNode.insertBefore(node, prev.nextSibling);
                        prev = node
                    }
                }
            }
            return groups
        }
        ;
        groups.on = function(type, listener, capture) {
            if (arguments.length < 3)
                capture = false;
            var i = type.indexOf(".")
              , typo = i === -1 ? type : type.substring(0, i)
              , name = "__on" + type;
            return groups.each(function(d, i) {
                if (this[name])
                    this.removeEventListener ? this.removeEventListener(typo, this[name], capture) : this.detachEvent("on" + typo, this[name]);
                if (listener)
                    this.addEventListener ? this.addEventListener(typo, this[name] = l, capture) : this.attachEvent("on" + typo, this[name] = l);
                var node = this;
                function l(e) {
                    var o = d3.event;
                    d3.event = e;
                    listener.call(node, node.__data__, i, e);
                    if (type !== "click")
                        d3.event = o
                }
            })
        }
        ;
        groups.transition = function() {
            return d3_transition(groups)
        }
        ;
        groups.call = d3_call;
        return groups
    }
    function d3_selectionEnter(groups) {
        function select(select) {
            var subgroups = [], subgroup, subnode, group, node;
            for (var j = 0, m = groups.length; j < m; j++) {
                group = groups[j];
                subgroups.push(subgroup = []);
                subgroup.parentNode = group.parentNode;
                for (var i = 0, n = group.length; i < n; i++)
                    if (node = group[i]) {
                        subgroup.push(subnode = select(group.parentNode));
                        subnode.__data__ = node.__data__
                    } else
                        subgroup.push(null)
            }
            return d3_selection(subgroups)
        }
        groups.append = function(name) {
            name = d3.ns.qualify(name);
            function append(node) {
                return node.appendChild(document.createElement(name))
            }
            function appendNS(node) {
                return node.appendChild(document.createElementNS(name.space, name.local))
            }
            return select(name.local ? appendNS : append)
        }
        ;
        groups.insert = function(name, before) {
            name = d3.ns.qualify(name);
            function insert(node) {
                return node.insertBefore(document.createElement(name), d3_select(before, node))
            }
            function insertNS(node) {
                return node.insertBefore(document.createElementNS(name.space, name.local), d3_select(before, node))
            }
            return select(name.local ? insertNS : insert)
        }
        ;
        return groups
    }
    function d3_selection_comparator(comparator) {
        if (!arguments.length)
            comparator = d3.ascending;
        return function(a, b) {
            return comparator(a && a.__data__, b && b.__data__)
        }
    }
    function d3_selection_enterNode(data) {
        return {
            __data__: data
        }
    }
    d3.transition = d3_root.transition;
    var d3_transitionId = 0
      , d3_transitionInheritId = 0;
    function d3_transition(groups) {
        var transition = {}, transitionId = d3_transitionInheritId || ++d3_transitionId, tweens = {}, interpolators = [], remove = false, event = d3.dispatch("start", "end"), stage = [], delay = [], duration = [], durationMax, ease = d3.ease("cubic-in-out");
        groups.each(function() {
            (this.__transition__ || (this.__transition__ = {})).owner = transitionId
        });
        function step(elapsed) {
            var clear = true
              , k = -1;
            groups.each(function() {
                if (stage[++k] === 2)
                    return;
                var t = (elapsed - delay[k]) / duration[k], tx = this.__transition__, te, tk, ik = interpolators[k];
                if (t < 1) {
                    clear = false;
                    if (t < 0)
                        return
                } else
                    t = 1;
                if (stage[k]) {
                    if (!tx || tx.active !== transitionId) {
                        stage[k] = 2;
                        return
                    }
                } else if (!tx || tx.active > transitionId) {
                    stage[k] = 2;
                    return
                } else {
                    stage[k] = 1;
                    event.start.dispatch.apply(this, arguments);
                    ik = interpolators[k] = {};
                    tx.active = transitionId;
                    for (tk in tweens)
                        if (te = tweens[tk].apply(this, arguments))
                            ik[tk] = te
                }
                te = ease(t);
                for (tk in ik)
                    ik[tk].call(this, te);
                if (t === 1) {
                    stage[k] = 2;
                    if (tx.active === transitionId) {
                        var owner = tx.owner;
                        if (owner === transitionId) {
                            delete this.__transition__;
                            if (remove)
                                this.parentNode.removeChild(this)
                        }
                        d3_transitionInheritId = transitionId;
                        event.end.dispatch.apply(this, arguments);
                        d3_transitionInheritId = 0;
                        tx.owner = owner
                    }
                }
            });
            return clear
        }
        transition.delay = function(value) {
            var delayMin = Infinity
              , k = -1;
            if (typeof value === "function")
                groups.each(function(d, i) {
                    var x = delay[++k] = +value.apply(this, arguments);
                    if (x < delayMin)
                        delayMin = x
                });
            else {
                delayMin = +value;
                groups.each(function(d, i) {
                    delay[++k] = delayMin
                })
            }
            d3_timer(step, delayMin);
            return transition
        }
        ;
        transition.duration = function(value) {
            var k = -1;
            if (typeof value === "function") {
                durationMax = 0;
                groups.each(function(d, i) {
                    var x = duration[++k] = +value.apply(this, arguments);
                    if (x > durationMax)
                        durationMax = x
                })
            } else {
                durationMax = +value;
                groups.each(function(d, i) {
                    duration[++k] = durationMax
                })
            }
            return transition
        }
        ;
        transition.ease = function(value) {
            ease = typeof value === "function" ? value : d3.ease.apply(d3, arguments);
            return transition
        }
        ;
        transition.attrTween = function(name, tween) {
            function attrTween(d, i) {
                var f = tween.call(this, d, i, this.getAttribute(name));
                return function(t) {
                    this.setAttribute(name, f(t))
                }
            }
            function attrTweenNS(d, i) {
                var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
                return function(t) {
                    this.setAttributeNS(name.space, name.local, f(t))
                }
            }
            tweens["attr." + name] = name.local ? attrTweenNS : attrTween;
            return transition
        }
        ;
        transition.attr = function(name, value, reversed) {
            if (typeof reversed != "undefined" && reversed)
                return transition.attrTween(name, d3_transitionTweenReversed(value));
            return transition.attrTween(name, d3_transitionTween(value))
        }
        ;
        transition.styleTween = function(name, tween, priority) {
            if (arguments.length < 3)
                priority = null;
            function styleTween(d, i) {
                var f = tween.call(this, d, i, window.getComputedStyle(this, null).getPropertyValue(name));
                return function(t) {
                    this.style.setProperty(name, f(t) + "", priority)
                }
            }
            tweens["style." + name] = styleTween;
            return transition
        }
        ;
        transition.style = function(name, value, priority) {
            if (arguments.length < 3)
                priority = null;
            return transition.styleTween(name, d3_transitionTween(value), priority)
        }
        ;
        transition.text = function(value) {
            tweens.text = function(d, i) {
                this.textContent = typeof value === "function" ? value.call(this, d, i) : value
            }
            ;
            return transition
        }
        ;
        transition.select = function(query) {
            var k, t = d3_transition(groups.select(query)).ease(ease);
            k = -1;
            t.delay(function(d, i) {
                return delay[++k]
            });
            k = -1;
            t.duration(function(d, i) {
                return duration[++k]
            });
            return t
        }
        ;
        transition.selectAll = function(query) {
            var k, t = d3_transition(groups.selectAll(query)).ease(ease);
            k = -1;
            t.delay(function(d, i) {
                return delay[i ? k : ++k]
            });
            k = -1;
            t.duration(function(d, i) {
                return duration[i ? k : ++k]
            });
            return t
        }
        ;
        transition.remove = function() {
            remove = true;
            return transition
        }
        ;
        transition.each = function(type, listener) {
            event[type].add(listener);
            return transition
        }
        ;
        transition.call = d3_call;
        return transition.delay(0).duration(250)
    }
    function d3_transitionTweenReversed(b) {
        return typeof b === "function" ? function(d, i, a) {
            return d3.interpolate(String(b.call(this, d, i)), a)
        }
        : function(d, i, a) {
            a = String(a);
            return d3.interpolate(b, a)
        }
    }
    function d3_transitionTween(b) {
        return typeof b === "function" ? function(d, i, a) {
            return d3.interpolate(a, String(b.call(this, d, i)))
        }
        : (b = String(b),
        function(d, i, a) {
            return d3.interpolate(a, b)
        }
        )
    }
    var d3_timer_queue = null, d3_timer_interval, d3_timer_timeout;
    d3.timer = function(callback) {
        d3_timer(callback, 0)
    }
    ;
    function d3_timer(callback, delay) {
        var now = Date.now(), found = false, t0, t1 = d3_timer_queue;
        if (!isFinite(delay))
            return;
        while (t1) {
            if (t1.callback === callback) {
                t1.then = now;
                t1.delay = delay;
                found = true;
                break
            }
            t0 = t1;
            t1 = t1.next
        }
        if (!found)
            d3_timer_queue = {
                callback: callback,
                then: now,
                delay: delay,
                next: d3_timer_queue
            };
        if (!d3_timer_interval) {
            d3_timer_timeout = clearTimeout(d3_timer_timeout);
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step)
        }
    }
    function d3_timer_step() {
        var elapsed, now = Date.now(), t1 = d3_timer_queue;
        while (t1) {
            elapsed = now - t1.then;
            if (elapsed > t1.delay)
                t1.flush = t1.callback(elapsed);
            t1 = t1.next
        }
        var delay = d3_timer_flush() - now;
        if (delay > 24) {
            if (isFinite(delay)) {
                clearTimeout(d3_timer_timeout);
                d3_timer_timeout = setTimeout(d3_timer_step, delay)
            }
            d3_timer_interval = 0
        } else {
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step)
        }
    }
    d3.timer.flush = function() {
        var elapsed, now = Date.now(), t1 = d3_timer_queue;
        while (t1) {
            elapsed = now - t1.then;
            if (!t1.delay)
                t1.flush = t1.callback(elapsed);
            t1 = t1.next
        }
        d3_timer_flush()
    }
    ;
    function d3_timer_flush() {
        var t0 = null
          , t1 = d3_timer_queue
          , then = Infinity;
        while (t1)
            if (t1.flush)
                t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next;
            else {
                then = Math.min(then, t1.then + t1.delay);
                t1 = (t0 = t1).next
            }
        return then
    }
    var d3_timer_frame;
    if (typeof window !== "undefined")
        d3_timer_frame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
            setTimeout(callback, 17)
        }
        ;
    if (typeof navigator !== "undefined" && navigator.userAgent.match(/OS 6_\d(_\d)? like Mac OS X/i))
        d3_timer_frame = function(callback) {
            setTimeout(callback, 17)
        }
        ;
    d3.svg = {};
    d3.svg.arc = function() {
        var innerRadius = d3_svg_arcInnerRadius
          , outerRadius = d3_svg_arcOuterRadius
          , startAngle = d3_svg_arcStartAngle
          , endAngle = d3_svg_arcEndAngle;
        function arc() {
            var r0 = innerRadius.apply(this, arguments)
              , r1 = outerRadius.apply(this, arguments)
              , a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset
              , a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset
              , da = a1 - a0
              , df = da < Math.PI ? "0" : "1"
              , c0 = Math.cos(a0)
              , s0 = Math.sin(a0)
              , c1 = Math.cos(a1)
              , s1 = Math.sin(a1);
            return da >= d3_svg_arcMax ? r0 ? "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,1 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,1 0," + r0 + "Z" : "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : r0 ? "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z" : "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0" + "Z"
        }
        arc.innerRadius = function(v) {
            if (!arguments.length)
                return innerRadius;
            innerRadius = d3.functor(v);
            return arc
        }
        ;
        arc.outerRadius = function(v) {
            if (!arguments.length)
                return outerRadius;
            outerRadius = d3.functor(v);
            return arc
        }
        ;
        arc.startAngle = function(v) {
            if (!arguments.length)
                return startAngle;
            startAngle = d3.functor(v);
            return arc
        }
        ;
        arc.endAngle = function(v) {
            if (!arguments.length)
                return endAngle;
            endAngle = d3.functor(v);
            return arc
        }
        ;
        arc.centroid = function() {
            var r = (innerRadius.apply(this, arguments) + outerRadius.apply(this, arguments)) / 2
              , a = (startAngle.apply(this, arguments) + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
            return [Math.cos(a) * r, Math.sin(a) * r]
        }
        ;
        return arc
    }
    ;
    var d3_svg_arcOffset = -Math.PI / 2
      , d3_svg_arcMax = 2 * Math.PI - 1E-6;
    function d3_svg_arcInnerRadius(d) {
        return d.innerRadius
    }
    function d3_svg_arcOuterRadius(d) {
        return d.outerRadius
    }
    function d3_svg_arcStartAngle(d) {
        return d.startAngle
    }
    function d3_svg_arcEndAngle(d) {
        return d.endAngle
    }
    d3.svg.mouse = function(container, event) {
        event = event || d3.event;
        var point = (container.ownerSVGElement || container).createSVGPoint();
        if (d3_mouse_bug44083 < 0 && (window.scrollX || window.scrollY)) {
            var svg = d3.select(document.body).append("svg:svg").style("position", "absolute").style("top", 0).style("left", 0);
            var ctm = svg[0][0].getScreenCTM();
            d3_mouse_bug44083 = !(ctm.f || ctm.e);
            svg.remove()
        }
        if (d3_mouse_bug44083) {
            point.x = event.pageX;
            point.y = event.pageY
        } else {
            point.x = event.clientX;
            point.y = event.clientY
        }
        point = point.matrixTransform(container.getScreenCTM().inverse());
        return [point.x, point.y]
    }
    ;
    var d3_mouse_bug44083 = typeof navigator !== "undefined" && /WebKit/.test(navigator.userAgent) ? -1 : 0;
    d3.merge = function(arrays) {
        var n = arrays.length, m, i = -1, j = 0, merged, array;
        while (++i < n)
            j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
            array = arrays[n];
            m = array.length;
            while (--m >= 0)
                merged[--j] = array[m]
        }
        return merged
    }
    ;
    d3.rebind = function(target, source) {
        var i = 1, n = arguments.length, method;
        while (++i < n)
            target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target
    }
    ;
    function d3_rebind(target, source, method) {
        return function() {
            var value = method.apply(source, arguments);
            return value === source ? target : value
        }
    }
    d3.layout = {};
    d3.layout.hierarchy = function() {
        var sort = d3_layout_hierarchySort
          , children = d3_layout_hierarchyChildren
          , value = d3_layout_hierarchyValue;
        function recurse(node, depth, nodes) {
            var childs = children.call(hierarchy, node, depth);
            node.depth = depth;
            nodes.push(node);
            if (childs && (n = childs.length)) {
                var i = -1, n, c = node.children = new Array(n), v = 0, j = depth + 1, d;
                while (++i < n) {
                    d = c[i] = recurse(childs[i], j, nodes);
                    d.parent = node;
                    v += d.value
                }
                if (sort)
                    c.sort(sort);
                if (value)
                    node.value = v
            } else {
                delete node.children;
                if (value)
                    node.value = +value.call(hierarchy, node, depth) || 0
            }
            return node
        }
        function revalue(node, depth) {
            var children = node.children
              , v = 0;
            if (children && (n = children.length)) {
                var i = -1, n, j = depth + 1;
                while (++i < n)
                    v += revalue(children[i], j)
            } else if (value)
                v = +value.call(hierarchy, node, depth) || 0;
            if (value)
                node.value = v;
            return v
        }
        function hierarchy(d) {
            var nodes = [];
            recurse(d, 0, nodes);
            return nodes
        }
        hierarchy.sort = function(x) {
            if (!arguments.length)
                return sort;
            sort = x;
            return hierarchy
        }
        ;
        hierarchy.children = function(x) {
            if (!arguments.length)
                return children;
            children = x;
            return hierarchy
        }
        ;
        hierarchy.value = function(x) {
            if (!arguments.length)
                return value;
            value = x;
            return hierarchy
        }
        ;
        hierarchy.revalue = function(root) {
            revalue(root, 0);
            return root
        }
        ;
        return hierarchy
    }
    ;
    function d3_layout_hierarchyRebind(object, hierarchy) {
        d3.rebind(object, hierarchy, "sort", "children", "value");
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object
    }
    function d3_layout_hierarchyChildren(d) {
        return d.children
    }
    function d3_layout_hierarchyValue(d) {
        return d.value
    }
    function d3_layout_hierarchySort(a, b) {
        return b.value - a.value
    }
    function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function(parent) {
            return (parent.children || []).map(function(child) {
                return {
                    source: parent,
                    target: child
                }
            })
        }))
    }
    d3.layout.tree = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null)
          , separation = d3_layout_treeSeparation
          , size = [1, 1]
          , nodeSize = false;
        function tree(d, i) {
            var nodes = hierarchy.call(this, d, i)
              , root = nodes[0];
            function firstWalk(node, previousSibling) {
                var children = node.children
                  , layout = node._tree;
                if (children && (n = children.length)) {
                    var n, firstChild = children[0], previousChild, ancestor = firstChild, child, i = -1;
                    while (++i < n) {
                        child = children[i];
                        firstWalk(child, previousChild);
                        ancestor = apportion(child, previousChild, ancestor);
                        previousChild = child
                    }
                    d3_layout_treeShift(node);
                    var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);
                    if (previousSibling) {
                        layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
                        layout.mod = layout.prelim - midpoint
                    } else
                        layout.prelim = midpoint
                } else if (previousSibling)
                    layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling)
            }
            function secondWalk(node, x) {
                node.x = node._tree.prelim + x;
                var children = node.children;
                if (children && (n = children.length)) {
                    var i = -1, n;
                    x += node._tree.mod;
                    while (++i < n)
                        secondWalk(children[i], x)
                }
            }
            function apportion(node, previousSibling, ancestor) {
                if (previousSibling) {
                    var vip = node, vop = node, vim = previousSibling, vom = node.parent.children[0], sip = vip._tree.mod, sop = vop._tree.mod, sim = vim._tree.mod, som = vom._tree.mod, shift;
                    while (vim = d3_layout_treeRight(vim),
                    vip = d3_layout_treeLeft(vip),
                    vim && vip) {
                        vom = d3_layout_treeLeft(vom);
                        vop = d3_layout_treeRight(vop);
                        vop._tree.ancestor = node;
                        shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);
                        if (shift > 0) {
                            d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);
                            sip += shift;
                            sop += shift
                        }
                        sim += vim._tree.mod;
                        sip += vip._tree.mod;
                        som += vom._tree.mod;
                        sop += vop._tree.mod
                    }
                    if (vim && !d3_layout_treeRight(vop)) {
                        vop._tree.thread = vim;
                        vop._tree.mod += sim - sop
                    }
                    if (vip && !d3_layout_treeLeft(vom)) {
                        vom._tree.thread = vip;
                        vom._tree.mod += sip - som;
                        ancestor = node
                    }
                }
                return ancestor
            }
            d3_layout_treeVisitAfter(root, function(node, previousSibling) {
                node._tree = {
                    ancestor: node,
                    prelim: 0,
                    mod: 0,
                    change: 0,
                    shift: 0,
                    number: previousSibling ? previousSibling._tree.number + 1 : 0
                }
            });
            firstWalk(root);
            secondWalk(root, -root._tree.prelim);
            var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost)
              , right = d3_layout_treeSearch(root, d3_layout_treeRightmost)
              , deep = d3_layout_treeSearch(root, d3_layout_treeDeepest)
              , x0 = left.x - separation(left, right) / 2
              , x1 = right.x + separation(right, left) / 2
              , y1 = deep.depth || 1;
            d3_layout_treeVisitAfter(root, nodeSize ? function(node) {
                node.x *= size[0];
                node.y = node.depth * size[1];
                delete node._tree
            }
            : function(node) {
                node.x = (node.x - x0) / (x1 - x0) * size[0];
                node.y = node.depth / y1 * size[1];
                delete node._tree
            }
            );
            return nodes
        }
        tree.separation = function(x) {
            if (!arguments.length)
                return separation;
            separation = x;
            return tree
        }
        ;
        tree.size = function(x) {
            if (!arguments.length)
                return nodeSize ? null : size;
            nodeSize = (size = x) == null;
            return tree
        }
        ;
        tree.nodeSize = function(x) {
            if (!arguments.length)
                return nodeSize ? size : null;
            nodeSize = (size = x) != null;
            return tree
        }
        ;
        return d3_layout_hierarchyRebind(tree, hierarchy)
    }
    ;
    function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2
    }
    function d3_layout_treeLeft(node) {
        var children = node.children;
        return children && children.length ? children[0] : node._tree.thread
    }
    function d3_layout_treeRight(node) {
        var children = node.children, n;
        return children && (n = children.length) ? children[n - 1] : node._tree.thread
    }
    function d3_layout_treeSearch(node, compare) {
        var children = node.children;
        if (children && (n = children.length)) {
            var child, n, i = -1;
            while (++i < n)
                if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0)
                    node = child
        }
        return node
    }
    function d3_layout_treeRightmost(a, b) {
        return a.x - b.x
    }
    function d3_layout_treeLeftmost(a, b) {
        return b.x - a.x
    }
    function d3_layout_treeDeepest(a, b) {
        return a.depth - b.depth
    }
    function d3_layout_treeVisitAfter(node, callback) {
        function visit(node, previousSibling) {
            var children = node.children;
            if (children && (n = children.length)) {
                var child, previousChild = null, i = -1, n;
                while (++i < n) {
                    child = children[i];
                    visit(child, previousChild);
                    previousChild = child
                }
            }
            callback(node, previousSibling)
        }
        visit(node, null)
    }
    function d3_layout_treeShift(node) {
        var shift = 0, change = 0, children = node.children, i = children.length, child;
        while (--i >= 0) {
            child = children[i]._tree;
            child.prelim += shift;
            child.mod += shift;
            shift += child.shift + (change += child.change)
        }
    }
    function d3_layout_treeMove(ancestor, node, shift) {
        ancestor = ancestor._tree;
        node = node._tree;
        var change = shift / (node.number - ancestor.number);
        ancestor.change += change;
        node.change -= change;
        node.shift += shift;
        node.prelim += shift;
        node.mod += shift
    }
    function d3_layout_treeAncestor(vim, node, ancestor) {
        return vim._tree.ancestor.parent == node.parent ? vim._tree.ancestor : ancestor
    }
    d3.layout.pack = function() {
        var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [1, 1], radius;
        function pack(d, i) {
            var nodes = hierarchy.call(this, d, i)
              , root = nodes[0]
              , w = size[0]
              , h = size[1]
              , r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
                return radius
            }
            ;
            root.x = root.y = 0;
            d3_layout_treeVisitAfter(root, function(d) {
                d.r = +r(d.value)
            });
            d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
            if (padding) {
                var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
                d3_layout_treeVisitAfter(root, function(d) {
                    d.r += dr
                });
                d3_layout_treeVisitAfter(root, d3_layout_packSiblings);
                d3_layout_treeVisitAfter(root, function(d) {
                    d.r -= dr
                })
            }
            d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
            return nodes
        }
        pack.size = function(_) {
            if (!arguments.length)
                return size;
            size = _;
            return pack
        }
        ;
        pack.radius = function(_) {
            if (!arguments.length)
                return radius;
            radius = _ == null || typeof _ === "function" ? _ : +_;
            return pack
        }
        ;
        pack.padding = function(_) {
            if (!arguments.length)
                return padding;
            padding = +_;
            return pack
        }
        ;
        return d3_layout_hierarchyRebind(pack, hierarchy)
    }
    ;
    function d3_layout_packSort(a, b) {
        return a.value - b.value
    }
    function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b;
        b._pack_prev = a;
        b._pack_next = c;
        c._pack_prev = b
    }
    function d3_layout_packSplice(a, b) {
        a._pack_next = b;
        b._pack_prev = a
    }
    function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x
          , dy = b.y - a.y
          , dr = a.r + b.r;
        return .999 * dr * dr > dx * dx + dy * dy
    }
    function d3_layout_packSiblings(node) {
        if (!(nodes = node.children) || !(n = nodes.length))
            return;
        var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
        function bound(node) {
            xMin = Math.min(node.x - node.r, xMin);
            xMax = Math.max(node.x + node.r, xMax);
            yMin = Math.min(node.y - node.r, yMin);
            yMax = Math.max(node.y + node.r, yMax)
        }
        nodes.forEach(d3_layout_packLink);
        a = nodes[0];
        a.x = -a.r;
        a.y = 0;
        bound(a);
        if (n > 1) {
            b = nodes[1];
            b.x = b.r;
            b.y = 0;
            bound(b);
            if (n > 2) {
                c = nodes[2];
                d3_layout_packPlace(a, b, c);
                bound(c);
                d3_layout_packInsert(a, c);
                a._pack_prev = c;
                d3_layout_packInsert(c, b);
                b = a._pack_next;
                for (i = 3; i < n; i++) {
                    d3_layout_packPlace(a, b, c = nodes[i]);
                    var isect = 0
                      , s1 = 1
                      , s2 = 1;
                    for (j = b._pack_next; j !== b; j = j._pack_next,
                    s1++)
                        if (d3_layout_packIntersects(j, c)) {
                            isect = 1;
                            break
                        }
                    if (isect == 1)
                        for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev,
                        s2++)
                            if (d3_layout_packIntersects(k, c))
                                break;
                    if (isect) {
                        if (s1 < s2 || s1 == s2 && b.r < a.r)
                            d3_layout_packSplice(a, b = j);
                        else
                            d3_layout_packSplice(a = k, b);
                        i--
                    } else {
                        d3_layout_packInsert(a, c);
                        b = c;
                        bound(c)
                    }
                }
            }
        }
        var cx = (xMin + xMax) / 2
          , cy = (yMin + yMax) / 2
          , cr = 0;
        for (i = 0; i < n; i++) {
            c = nodes[i];
            c.x -= cx;
            c.y -= cy;
            cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y))
        }
        node.r = cr;
        nodes.forEach(d3_layout_packUnlink)
    }
    function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node
    }
    function d3_layout_packUnlink(node) {
        delete node._pack_next;
        delete node._pack_prev
    }
    function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        node.x = x += k * node.x;
        node.y = y += k * node.y;
        node.r *= k;
        if (children) {
            var i = -1
              , n = children.length;
            while (++i < n)
                d3_layout_packTransform(children[i], x, y, k)
        }
    }
    function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r
          , dx = b.x - a.x
          , dy = b.y - a.y;
        if (db && (dx || dy)) {
            var da = b.r + c.r
              , dc = dx * dx + dy * dy;
            da *= da;
            db *= db;
            var x = .5 + (db - da) / (2 * dc)
              , y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
            c.x = a.x + x * dx + y * dy;
            c.y = a.y + x * dy - y * dx
        } else {
            c.x = a.x + db;
            c.y = a.y
        }
    }
}
)();
(function() {
    var exports = tdgchart.d3_time = {};
    function ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN
    }
    function bisector(compare) {
        if (compare.length === 1)
            compare = ascendingComparator(compare);
        return {
            left: function(a, x, lo, hi) {
                if (lo == null)
                    lo = 0;
                if (hi == null)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) < 0)
                        lo = mid + 1;
                    else
                        hi = mid
                }
                return lo
            },
            right: function(a, x, lo, hi) {
                if (lo == null)
                    lo = 0;
                if (hi == null)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) > 0)
                        hi = mid;
                    else
                        lo = mid + 1
                }
                return lo
            }
        }
    }
    function ascendingComparator(f) {
        return function(d, x) {
            return ascending(f(d), x)
        }
    }
    var ascendingBisect = bisector(ascending);
    var bisectRight = ascendingBisect.right;
    var e10 = Math.sqrt(50)
      , e5 = Math.sqrt(10)
      , e2 = Math.sqrt(2);
    function tickStep(start, stop, count) {
        var step0 = Math.abs(stop - start) / Math.max(0, count)
          , step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10))
          , error = step0 / step1;
        if (error >= e10)
            step1 *= 10;
        else if (error >= e5)
            step1 *= 5;
        else if (error >= e2)
            step1 *= 2;
        return stop < start ? -step1 : step1
    }
    function initRange(domain, range) {
        switch (arguments.length) {
        case 0:
            break;
        case 1:
            this.range(domain);
            break;
        default:
            this.range(range).domain(domain);
            break
        }
        return this
    }
    var array = Array.prototype;
    var map$1 = array.map;
    var slice = array.slice;
    function constant(x) {
        return function() {
            return x
        }
    }
    function array$1(a, b) {
        var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
        for (i = 0; i < na; ++i)
            x[i] = interpolateValue(a[i], b[i]);
        for (; i < nb; ++i)
            c[i] = b[i];
        return function(t) {
            for (i = 0; i < na; ++i)
                c[i] = x[i](t);
            return c
        }
    }
    function date(a, b) {
        var d = new Date;
        return a = +a,
        b -= a,
        function(t) {
            return d.setTime(a + b * t),
            d
        }
    }
    function interpolateNumber(a, b) {
        return a = +a,
        b -= a,
        function(t) {
            return a + b * t
        }
    }
    function object(a, b) {
        var i = {}, c = {}, k;
        if (a == null || typeof a !== "object")
            a = {};
        if (b == null || typeof b !== "object")
            b = {};
        for (k in b)
            if (k in a)
                i[k] = interpolateValue(a[k], b[k]);
            else
                c[k] = b[k];
        return function(t) {
            for (k in i)
                c[k] = i[k](t);
            return c
        }
    }
    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g
      , reB = new RegExp(reA.source,"g");
    function zero(b) {
        return function() {
            return b
        }
    }
    function one(b) {
        return function(t) {
            return b(t) + ""
        }
    }
    function string(a, b) {
        var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
        a = a + "",
        b = b + "";
        while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
            if ((bs = bm.index) > bi) {
                bs = b.slice(bi, bs);
                if (s[i])
                    s[i] += bs;
                else
                    s[++i] = bs
            }
            if ((am = am[0]) === (bm = bm[0]))
                if (s[i])
                    s[i] += bm;
                else
                    s[++i] = bm;
            else {
                s[++i] = null;
                q.push({
                    i: i,
                    x: interpolateNumber(am, bm)
                })
            }
            bi = reB.lastIndex
        }
        if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i])
                s[i] += bs;
            else
                s[++i] = bs
        }
        return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length,
        function(t) {
            for (var i = 0, o; i < b; ++i)
                s[(o = q[i]).i] = o.x(t);
            return s.join("")
        }
        )
    }
    function interpolateValue(a, b) {
        var t = typeof b;
        return b == null || t === "boolean" ? constant(b) : (t === "number" ? interpolateNumber : t === "string" ? string : b instanceof Date ? date : Array.isArray(b) ? array$1 : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a, b)
    }
    function interpolateRound(a, b) {
        return a = +a,
        b -= a,
        function(t) {
            return Math.round(a + b * t)
        }
    }
    function number$1(x) {
        return +x
    }
    var unit = [0, 1];
    function identity(x) {
        return x
    }
    function normalize(a, b) {
        return (b -= a = +a) ? function(x) {
            return (x - a) / b
        }
        : constant(isNaN(b) ? NaN : .5)
    }
    function clamper(domain) {
        var a = domain[0], b = domain[domain.length - 1], t;
        if (a > b)
            t = a,
            a = b,
            b = t;
        return function(x) {
            return Math.max(a, Math.min(b, x))
        }
    }
    function bimap(domain, range, interpolate) {
        var d0 = domain[0]
          , d1 = domain[1]
          , r0 = range[0]
          , r1 = range[1];
        if (d1 < d0)
            d0 = normalize(d1, d0),
            r0 = interpolate(r1, r0);
        else
            d0 = normalize(d0, d1),
            r0 = interpolate(r0, r1);
        return function(x) {
            return r0(d0(x))
        }
    }
    function polymap(domain, range, interpolate) {
        var j = Math.min(domain.length, range.length) - 1
          , d = new Array(j)
          , r = new Array(j)
          , i = -1;
        if (domain[j] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse()
        }
        while (++i < j) {
            d[i] = normalize(domain[i], domain[i + 1]);
            r[i] = interpolate(range[i], range[i + 1])
        }
        return function(x) {
            var i = bisectRight(domain, x, 1, j) - 1;
            return r[i](d[i](x))
        }
    }
    function copy(source, target) {
        return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown())
    }
    function transformer() {
        var domain = unit, range = unit, interpolate = interpolateValue, transform, untransform, unknown, clamp = identity, piecewise, output, input;
        function rescale() {
            piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
            output = input = null;
            return scale
        }
        function scale(x) {
            return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)))
        }
        scale.invert = function(y) {
            return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)))
        }
        ;
        scale.domain = function(_) {
            return arguments.length ? (domain = map$1.call(_, number$1),
            clamp === identity || (clamp = clamper(domain)),
            rescale()) : domain.slice()
        }
        ;
        scale.range = function(_) {
            return arguments.length ? (range = slice.call(_),
            rescale()) : range.slice()
        }
        ;
        scale.rangeRound = function(_) {
            return range = slice.call(_),
            interpolate = interpolateRound,
            rescale()
        }
        ;
        scale.clamp = function(_) {
            return arguments.length ? (clamp = _ ? clamper(domain) : identity,
            scale) : clamp !== identity
        }
        ;
        scale.interpolate = function(_) {
            return arguments.length ? (interpolate = _,
            rescale()) : interpolate
        }
        ;
        scale.unknown = function(_) {
            return arguments.length ? (unknown = _,
            scale) : unknown
        }
        ;
        return function(t, u) {
            transform = t,
            untransform = u;
            return rescale()
        }
    }
    function continuous(transform, untransform) {
        return transformer()(transform, untransform)
    }
    function formatDecimal(x, p) {
        var i;
        if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
            return null;
        var coefficient = x.slice(0, i);
        return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x.slice(i + 1)]
    }
    function exponent(x) {
        return x = formatDecimal(Math.abs(x)),
        x ? x[1] : NaN
    }
    function formatGroup(grouping, thousands) {
        return function(value, width) {
            var i = value.length
              , t = []
              , j = 0
              , g = grouping[0]
              , length = 0;
            while (i > 0 && g > 0) {
                if (length + g + 1 > width)
                    g = Math.max(1, width - length);
                t.push(value.substring(i -= g, i + g));
                if ((length += g + 1) > width)
                    break;
                g = grouping[j = (j + 1) % grouping.length]
            }
            return t.reverse().join(thousands)
        }
    }
    function formatNumerals(numerals) {
        return function(value) {
            return value.replace(/[0-9]/g, function(i) {
                return numerals[+i]
            })
        }
    }
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    function formatSpecifier(specifier) {
        return new FormatSpecifier(specifier)
    }
    formatSpecifier.prototype = FormatSpecifier.prototype;
    function FormatSpecifier(specifier) {
        var match;
        if (!(match = re.exec(specifier)))
            throw new Error("invalid format: " + specifier);
        this.fill = match[1] || " ";
        this.align = match[2] || ">";
        this.sign = match[3] || "-";
        this.symbol = match[4] || "";
        this.zero = !!match[5];
        this.width = match[6] && +match[6];
        this.comma = !!match[7];
        this.precision = match[8] && +match[8].slice(1);
        this.trim = !!match[9];
        this.type = match[10] || ""
    }
    FormatSpecifier.prototype.toString = function() {
        return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width == null ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type
    }
    ;
    function formatTrim(s) {
        out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i)
            switch (s[i]) {
            case ".":
                i0 = i1 = i;
                break;
            case "0":
                if (i0 === 0)
                    i0 = i;
                i1 = i;
                break;
            default:
                if (i0 > 0) {
                    if (!+s[i])
                        break out;
                    i0 = 0
                }
                break
            }
        return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s
    }
    var prefixExponent;
    function formatPrefixAuto(x, p) {
        var d = formatDecimal(x, p);
        if (!d)
            return x + "";
        var coefficient = d[0]
          , exponent = d[1]
          , i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1
          , n = coefficient.length;
        return i === n ? coefficient : i > n ? coefficient + (new Array(i - n + 1)).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + (new Array(1 - i)).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]
    }
    function formatRounded(x, p) {
        var d = formatDecimal(x, p);
        if (!d)
            return x + "";
        var coefficient = d[0]
          , exponent = d[1];
        return exponent < 0 ? "0." + (new Array(-exponent)).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + (new Array(exponent - coefficient.length + 2)).join("0")
    }
    var formatTypes = {
        "%": function(x, p) {
            return (x * 100).toFixed(p)
        },
        "b": function(x) {
            return Math.round(x).toString(2)
        },
        "c": function(x) {
            return x + ""
        },
        "d": function(x) {
            return Math.round(x).toString(10)
        },
        e: function(x, p) {
            return x.toExponential(p)
        },
        "f": function(x, p) {
            return x.toFixed(p)
        },
        g: function(x, p) {
            return x.toPrecision(p)
        },
        o: function(x) {
            return Math.round(x).toString(8)
        },
        p: function(x, p) {
            return formatRounded(x * 100, p)
        },
        "r": formatRounded,
        "s": formatPrefixAuto,
        "X": function(x) {
            return Math.round(x).toString(16).toUpperCase()
        },
        x: function(x) {
            return Math.round(x).toString(16)
        }
    };
    var prefixes = ["y", "z", "a", "f", "p", "n", "\u00b5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
    function formatLocale(locale) {
        var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity
          , currency = locale.currency
          , decimal = locale.decimal
          , numerals = locale.numerals ? formatNumerals(locale.numerals) : identity
          , percent = locale.percent || "%";
        function newFormat(specifier) {
            specifier = formatSpecifier(specifier);
            var fill = specifier.fill
              , align = specifier.align
              , sign = specifier.sign
              , symbol = specifier.symbol
              , zero = specifier.zero
              , width = specifier.width
              , comma = specifier.comma
              , precision = specifier.precision
              , trim = specifier.trim
              , type = specifier.type;
            if (type === "n")
                comma = true,
                type = "g";
            else if (!formatTypes[type])
                precision == null && (precision = 12),
                trim = true,
                type = "g";
            if (zero || fill === "0" && align === "=")
                zero = true,
                fill = "0",
                align = "=";
            var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : ""
              , suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";
            var formatType = formatTypes[type]
              , maybeSuffix = /[defgprs%]/.test(type);
            precision = precision == null ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
            function format(value) {
                var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
                if (type === "c") {
                    valueSuffix = formatType(value) + valueSuffix;
                    value = ""
                } else {
                    value = +value;
                    var valueNegative = value < 0;
                    value = formatType(Math.abs(value), precision);
                    if (trim)
                        value = formatTrim(value);
                    if (valueNegative && +value === 0)
                        valueNegative = false;
                    valuePrefix = (valueNegative ? sign === "(" ? sign : "-" : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
                    valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
                    if (maybeSuffix) {
                        i = -1,
                        n = value.length;
                        while (++i < n)
                            if (c = value.charCodeAt(i),
                            48 > c || c > 57) {
                                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                                value = value.slice(0, i);
                                break
                            }
                    }
                }
                if (comma && !zero)
                    value = group(value, Infinity);
                var length = valuePrefix.length + value.length + valueSuffix.length
                  , padding = length < width ? (new Array(width - length + 1)).join(fill) : "";
                if (comma && zero)
                    value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity),
                    padding = "";
                switch (align) {
                case "<":
                    value = valuePrefix + value + valueSuffix + padding;
                    break;
                case "=":
                    value = valuePrefix + padding + value + valueSuffix;
                    break;
                case "^":
                    value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
                    break;
                default:
                    value = padding + valuePrefix + value + valueSuffix;
                    break
                }
                return numerals(value)
            }
            format.toString = function() {
                return specifier + ""
            }
            ;
            return format
        }
        function formatPrefix(specifier, value) {
            var f = newFormat((specifier = formatSpecifier(specifier),
            specifier.type = "f",
            specifier))
              , e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3
              , k = Math.pow(10, -e)
              , prefix = prefixes[8 + e / 3];
            return function(value) {
                return f(k * value) + prefix
            }
        }
        return {
            format: newFormat,
            formatPrefix: formatPrefix
        }
    }
    var locale;
    var format;
    var formatPrefix;
    defaultLocale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["$", ""]
    });
    function defaultLocale(definition) {
        locale = formatLocale(definition);
        format = locale.format;
        formatPrefix = locale.formatPrefix;
        return locale
    }
    function precisionFixed(step) {
        return Math.max(0, -exponent(Math.abs(step)))
    }
    function precisionPrefix(step, value) {
        return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)))
    }
    function precisionRound(step, max) {
        step = Math.abs(step),
        max = Math.abs(max) - step;
        return Math.max(0, exponent(max) - exponent(step)) + 1
    }
    function tickFormat(start, stop, count, specifier) {
        var step = tickStep(start, stop, count), precision;
        specifier = formatSpecifier(specifier == null ? ",f" : specifier);
        switch (specifier.type) {
        case "s":
            {
                var value = Math.max(Math.abs(start), Math.abs(stop));
                if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value)))
                    specifier.precision = precision;
                return formatPrefix(specifier, value)
            }
        case "":
        case "e":
        case "g":
        case "p":
        case "r":
            {
                if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop)))))
                    specifier.precision = precision - (specifier.type === "e");
                break
            }
        case "f":
        case "%":
            {
                if (specifier.precision == null && !isNaN(precision = precisionFixed(step)))
                    specifier.precision = precision - (specifier.type === "%") * 2;
                break
            }
        }
        return format(specifier)
    }
    function nice(domain, interval) {
        domain = domain.slice();
        var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
        if (x1 < x0) {
            t = i0,
            i0 = i1,
            i1 = t;
            t = x0,
            x0 = x1,
            x1 = t
        }
        domain[i0] = interval.floor(x0);
        domain[i1] = interval.ceil(x1);
        return domain
    }
    var t0$1 = new Date
      , t1$1 = new Date;
    function newInterval(floori, offseti, count, field) {
        function interval(date) {
            return floori(date = new Date(+date)),
            date
        }
        interval.floor = interval;
        interval.ceil = function(date) {
            return floori(date = new Date(date - 1)),
            offseti(date, 1),
            floori(date),
            date
        }
        ;
        interval.round = function(date) {
            var d0 = interval(date)
              , d1 = interval.ceil(date);
            return date - d0 < d1 - date ? d0 : d1
        }
        ;
        interval.offset = function(date, step) {
            return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)),
            date
        }
        ;
        interval.range = function(start, stop, step) {
            var range = [], previous;
            start = interval.floor(start);
            step = step == null ? 1 : Math.floor(step);
            if (!(start < stop) || !(step > 0))
                return range;
            do {
                previous = new Date(+start);
                range.push(previous);
                offseti(start, step);
                floori(start)
            } while (previous < start && start < stop);
            if (+range[range.length - 1] < stop)
                range.push(start);
            return range
        }
        ;
        interval.filter = function(test) {
            return newInterval(function(date) {
                if (date >= date)
                    while (floori(date),
                    !test(date))
                        date.setTime(date - 1)
            }, function(date, step) {
                if (date >= date)
                    if (step < 0)
                        while (++step <= 0)
                            while (offseti(date, -1),
                            !test(date))
                                ;
                    else
                        while (--step >= 0)
                            while (offseti(date, +1),
                            !test(date))
                                ;
            })
        }
        ;
        if (count) {
            interval.count = function(start, end) {
                t0$1.setTime(+start),
                t1$1.setTime(+end);
                floori(t0$1),
                floori(t1$1);
                return Math.floor(count(t0$1, t1$1))
            }
            ;
            interval.every = function(step) {
                step = Math.floor(step);
                return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function(d) {
                    return field(d) % step === 0
                }
                : function(d) {
                    return interval.count(0, d) % step === 0
                }
                )
            }
        }
        return interval
    }
    var millisecond = newInterval(function() {}, function(date, step) {
        date.setTime(+date + step)
    }, function(start, end) {
        return end - start
    });
    millisecond.every = function(k) {
        k = Math.floor(k);
        if (!isFinite(k) || !(k > 0))
            return null;
        if (!(k > 1))
            return millisecond;
        return newInterval(function(date) {
            date.setTime(Math.floor(date / k) * k)
        }, function(date, step) {
            date.setTime(+date + step * k)
        }, function(start, end) {
            return (end - start) / k
        })
    }
    ;
    var durationSecond = 1E3;
    var durationMinute = durationSecond * 60;
    var durationHour = durationMinute * 60;
    var durationDay = durationHour * 24;
    var durationWeek = durationDay * 7;
    var durationMonth = durationDay * 30;
    var durationQuarter = durationMonth * 3;
    var durationYear = durationDay * 365;
    var second = newInterval(function(date) {
        date.setTime(date - date.getMilliseconds())
    }, function(date, step) {
        date.setTime(+date + step * durationSecond)
    }, function(start, end) {
        return (end - start) / durationSecond
    }, function(date) {
        return date.getUTCSeconds()
    });
    second.duration = durationSecond;
    var minute = newInterval(function(date) {
        date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond)
    }, function(date, step) {
        date.setTime(+date + step * durationMinute)
    }, function(start, end) {
        return (end - start) / durationMinute
    }, function(date) {
        return date.getMinutes()
    });
    minute.duration = durationMinute;
    var hour = newInterval(function(date) {
        date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute)
    }, function(date, step) {
        date.setTime(+date + step * durationHour)
    }, function(start, end) {
        return (end - start) / durationHour
    }, function(date) {
        return date.getHours()
    });
    hour.duration = durationHour;
    var day = newInterval(function(date) {
        date.setHours(0, 0, 0, 0)
    }, function(date, step) {
        date.setDate(date.getDate() + step)
    }, function(start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay
    }, function(date) {
        return date.getDate() - 1
    });
    day.duration = durationDay;
    function weekday(i) {
        var res = newInterval(function(date) {
            date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
            date.setHours(0, 0, 0, 0)
        }, function(date, step) {
            date.setDate(date.getDate() + step * 7)
        }, function(start, end) {
            return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek
        });
        res.duration = durationWeek;
        return res
    }
    var sunday = weekday(0);
    var monday = weekday(1);
    var tuesday = weekday(2);
    var wednesday = weekday(3);
    var thursday = weekday(4);
    var friday = weekday(5);
    var saturday = weekday(6);
    var month = newInterval(function(date) {
        date.setDate(1);
        date.setHours(0, 0, 0, 0)
    }, function(date, step) {
        date.setMonth(date.getMonth() + step)
    }, function(start, end) {
        return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12
    }, function(date) {
        return date.getMonth()
    });
    month.duration = durationMonth;
    var quarter = newInterval(function(date) {
        var month = date.getMonth();
        date.setMonth(month - month % 3);
        date.setDate(1);
        date.setHours(0, 0, 0, 0)
    }, function(date, step) {
        date.setQuarter(date.getQuarter() + step)
    }, function(start, end) {
        return end.getQuarter() - start.getQuarter() + (end.getFullYear() - start.getFullYear()) * 12
    }, function(date) {
        return date.getQuarter()
    });
    quarter.duration = durationQuarter;
    var year = newInterval(function(date) {
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0)
    }, function(date, step) {
        date.setFullYear(date.getFullYear() + step)
    }, function(start, end) {
        return end.getFullYear() - start.getFullYear()
    }, function(date) {
        return date.getFullYear()
    });
    year.duration = durationYear;
    year.every = function(k) {
        return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
            date.setFullYear(Math.floor(date.getFullYear() / k) * k);
            date.setMonth(0, 1);
            date.setHours(0, 0, 0, 0)
        }, function(date, step) {
            date.setFullYear(date.getFullYear() + step * k)
        })
    }
    ;
    var utcMinute = newInterval(function(date) {
        date.setUTCSeconds(0, 0)
    }, function(date, step) {
        date.setTime(+date + step * durationMinute)
    }, function(start, end) {
        return (end - start) / durationMinute
    }, function(date) {
        return date.getUTCMinutes()
    });
    var utcHour = newInterval(function(date) {
        date.setUTCMinutes(0, 0, 0)
    }, function(date, step) {
        date.setTime(+date + step * durationHour)
    }, function(start, end) {
        return (end - start) / durationHour
    }, function(date) {
        return date.getUTCHours()
    });
    var utcDay = newInterval(function(date) {
        date.setUTCHours(0, 0, 0, 0)
    }, function(date, step) {
        date.setUTCDate(date.getUTCDate() + step)
    }, function(start, end) {
        return (end - start) / durationDay
    }, function(date) {
        return date.getUTCDate() - 1
    });
    function utcWeekday(i) {
        return newInterval(function(date) {
            date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
            date.setUTCHours(0, 0, 0, 0)
        }, function(date, step) {
            date.setUTCDate(date.getUTCDate() + step * 7)
        }, function(start, end) {
            return (end - start) / durationWeek
        })
    }
    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    var utcThursday = utcWeekday(4);
    var utcMonth = newInterval(function(date) {
        date.setUTCDate(1);
        date.setUTCHours(0, 0, 0, 0)
    }, function(date, step) {
        date.setUTCMonth(date.getUTCMonth() + step)
    }, function(start, end) {
        return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12
    }, function(date) {
        return date.getUTCMonth()
    });
    var utcYear = newInterval(function(date) {
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0)
    }, function(date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step)
    }, function(start, end) {
        return end.getUTCFullYear() - start.getUTCFullYear()
    }, function(date) {
        return date.getUTCFullYear()
    });
    utcYear.every = function(k) {
        return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
            date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
            date.setUTCMonth(0, 1);
            date.setUTCHours(0, 0, 0, 0)
        }, function(date, step) {
            date.setUTCFullYear(date.getUTCFullYear() + step * k)
        })
    }
    ;
    function localDate(d) {
        if (0 <= d.y && d.y < 100) {
            var date = new Date(-1,d.m,d.d,d.H,d.M,d.S,d.L);
            date.setFullYear(d.y);
            return date
        }
        return new Date(d.y,d.m,d.d,d.H,d.M,d.S,d.L)
    }
    function utcDate(d) {
        if (0 <= d.y && d.y < 100) {
            var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
            date.setUTCFullYear(d.y);
            return date
        }
        return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L))
    }
    function newYear(y) {
        return {
            y: y,
            m: 0,
            d: 1,
            H: 0,
            M: 0,
            S: 0,
            L: 0
        }
    }
    var pads = {
        "-": "",
        _: " ",
        0: "0"
    }
      , numberRe = /^\s*\d+/
      , percentRe = /^%/
      , requoteRe = /[\\^$*+?|[\]().{}]/g;
    function formatLocale$1(locale) {
        var locale_dateTime = locale.dateTime
          , locale_date = locale.date
          , locale_time = locale.time
          , locale_periods = locale.periods
          , locale_weekdays = locale.days
          , locale_shortWeekdays = locale.shortDays
          , locale_months = locale.months
          , locale_shortMonths = locale.shortMonths;
        var periodRe = formatRe(locale_periods)
          , periodLookup = formatLookup(locale_periods)
          , weekdayRe = formatRe(locale_weekdays)
          , weekdayLookup = formatLookup(locale_weekdays)
          , shortWeekdayRe = formatRe(locale_shortWeekdays)
          , shortWeekdayLookup = formatLookup(locale_shortWeekdays)
          , monthRe = formatRe(locale_months)
          , monthLookup = formatLookup(locale_months)
          , shortMonthRe = formatRe(locale_shortMonths)
          , shortMonthLookup = formatLookup(locale_shortMonths);
        var formats = {
            "a": formatShortWeekday,
            "A": formatWeekday,
            "b": formatShortMonth,
            "B": formatMonth,
            "c": null,
            "d": formatDayOfMonth,
            e: formatDayOfMonth,
            "f": formatMicroseconds,
            H: formatHour24,
            I: formatHour12,
            "j": formatDayOfYear,
            "L": formatMilliseconds,
            m: formatMonthNumber,
            M: formatMinutes,
            p: formatPeriod,
            "Q": formatUnixTimestamp,
            "s": formatUnixTimestampSeconds,
            "S": formatSeconds,
            "u": formatWeekdayNumberMonday,
            "U": formatWeekNumberSunday,
            V: formatWeekNumberISO,
            "w": formatWeekdayNumberSunday,
            W: formatWeekNumberMonday,
            "x": null,
            "X": null,
            y: formatYear,
            Y: formatFullYear,
            "Z": formatZone,
            "%": formatLiteralPercent
        };
        var utcFormats = {
            "a": formatUTCShortWeekday,
            A: formatUTCWeekday,
            "b": formatUTCShortMonth,
            "B": formatUTCMonth,
            c: null,
            d: formatUTCDayOfMonth,
            "e": formatUTCDayOfMonth,
            f: formatUTCMicroseconds,
            "H": formatUTCHour24,
            I: formatUTCHour12,
            "j": formatUTCDayOfYear,
            L: formatUTCMilliseconds,
            m: formatUTCMonthNumber,
            M: formatUTCMinutes,
            "p": formatUTCPeriod,
            Q: formatUnixTimestamp,
            "s": formatUnixTimestampSeconds,
            "S": formatUTCSeconds,
            u: formatUTCWeekdayNumberMonday,
            U: formatUTCWeekNumberSunday,
            V: formatUTCWeekNumberISO,
            w: formatUTCWeekdayNumberSunday,
            W: formatUTCWeekNumberMonday,
            x: null,
            X: null,
            "y": formatUTCYear,
            Y: formatUTCFullYear,
            "Z": formatUTCZone,
            "%": formatLiteralPercent
        };
        var parses = {
            a: parseShortWeekday,
            "A": parseWeekday,
            "b": parseShortMonth,
            "B": parseMonth,
            "c": parseLocaleDateTime,
            d: parseDayOfMonth,
            e: parseDayOfMonth,
            "f": parseMicroseconds,
            "H": parseHour24,
            I: parseHour24,
            j: parseDayOfYear,
            L: parseMilliseconds,
            "m": parseMonthNumber,
            "M": parseMinutes,
            p: parsePeriod,
            Q: parseUnixTimestamp,
            "s": parseUnixTimestampSeconds,
            "S": parseSeconds,
            u: parseWeekdayNumberMonday,
            U: parseWeekNumberSunday,
            "V": parseWeekNumberISO,
            "w": parseWeekdayNumberSunday,
            "W": parseWeekNumberMonday,
            x: parseLocaleDate,
            X: parseLocaleTime,
            y: parseYear,
            "Y": parseFullYear,
            "Z": parseZone,
            "%": parseLiteralPercent
        };
        formats.x = newFormat(locale_date, formats);
        formats.X = newFormat(locale_time, formats);
        formats.c = newFormat(locale_dateTime, formats);
        utcFormats.x = newFormat(locale_date, utcFormats);
        utcFormats.X = newFormat(locale_time, utcFormats);
        utcFormats.c = newFormat(locale_dateTime, utcFormats);
        function newFormat(specifier, formats) {
            return function(date) {
                var string = [], i = -1, j = 0, n = specifier.length, c, pad, format;
                if (!(date instanceof Date))
                    date = new Date(+date);
                while (++i < n)
                    if (specifier.charCodeAt(i) === 37) {
                        string.push(specifier.slice(j, i));
                        if ((pad = pads[c = specifier.charAt(++i)]) != null)
                            c = specifier.charAt(++i);
                        else
                            pad = c === "e" ? " " : "0";
                        if (format = formats[c])
                            c = format(date, pad);
                        string.push(c);
                        j = i + 1
                    }
                string.push(specifier.slice(j, i));
                return string.join("")
            }
        }
        function newParse(specifier, newDate) {
            return function(string) {
                var d = newYear(1900), i = parseSpecifier(d, specifier, string += "", 0), week, day$1;
                if (i !== string.length)
                    return null;
                if ("Q"in d)
                    return new Date(d.Q);
                if ("p"in d)
                    d.H = d.H % 12 + d.p * 12;
                if ("V"in d) {
                    if (d.V < 1 || d.V > 53)
                        return null;
                    if (!("w"in d))
                        d.w = 1;
                    if ("Z"in d) {
                        week = utcDate(newYear(d.y)),
                        day$1 = week.getUTCDay();
                        week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
                        week = utcDay.offset(week, (d.V - 1) * 7);
                        d.y = week.getUTCFullYear();
                        d.m = week.getUTCMonth();
                        d.d = week.getUTCDate() + (d.w + 6) % 7
                    } else {
                        week = newDate(newYear(d.y)),
                        day$1 = week.getDay();
                        week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
                        week = day.offset(week, (d.V - 1) * 7);
                        d.y = week.getFullYear();
                        d.m = week.getMonth();
                        d.d = week.getDate() + (d.w + 6) % 7
                    }
                } else if ("W"in d || "U"in d) {
                    if (!("w"in d))
                        d.w = "u"in d ? d.u % 7 : "W"in d ? 1 : 0;
                    day$1 = "Z"in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
                    d.m = 0;
                    d.d = "W"in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7
                }
                if ("Z"in d) {
                    d.H += d.Z / 100 | 0;
                    d.M += d.Z % 100;
                    return utcDate(d)
                }
                return newDate(d)
            }
        }
        function parseSpecifier(d, specifier, string, j) {
            var i = 0, n = specifier.length, m = string.length, c, parse;
            while (i < n) {
                if (j >= m)
                    return -1;
                c = specifier.charCodeAt(i++);
                if (c === 37) {
                    c = specifier.charAt(i++);
                    parse = parses[c in pads ? specifier.charAt(i++) : c];
                    if (!parse || (j = parse(d, string, j)) < 0)
                        return -1
                } else if (c != string.charCodeAt(j++))
                    return -1
            }
            return j
        }
        function parsePeriod(d, string, i) {
            var n = periodRe.exec(string.slice(i));
            return n ? (d.p = periodLookup[n[0].toLowerCase()],
            i + n[0].length) : -1
        }
        function parseShortWeekday(d, string, i) {
            var n = shortWeekdayRe.exec(string.slice(i));
            return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()],
            i + n[0].length) : -1
        }
        function parseWeekday(d, string, i) {
            var n = weekdayRe.exec(string.slice(i));
            return n ? (d.w = weekdayLookup[n[0].toLowerCase()],
            i + n[0].length) : -1
        }
        function parseShortMonth(d, string, i) {
            var n = shortMonthRe.exec(string.slice(i));
            return n ? (d.m = shortMonthLookup[n[0].toLowerCase()],
            i + n[0].length) : -1
        }
        function parseMonth(d, string, i) {
            var n = monthRe.exec(string.slice(i));
            return n ? (d.m = monthLookup[n[0].toLowerCase()],
            i + n[0].length) : -1
        }
        function parseLocaleDateTime(d, string, i) {
            return parseSpecifier(d, locale_dateTime, string, i)
        }
        function parseLocaleDate(d, string, i) {
            return parseSpecifier(d, locale_date, string, i)
        }
        function parseLocaleTime(d, string, i) {
            return parseSpecifier(d, locale_time, string, i)
        }
        function formatShortWeekday(d) {
            return locale_shortWeekdays[d.getDay()]
        }
        function formatWeekday(d) {
            return locale_weekdays[d.getDay()]
        }
        function formatShortMonth(d) {
            return locale_shortMonths[d.getMonth()]
        }
        function formatMonth(d) {
            return locale_months[d.getMonth()]
        }
        function formatPeriod(d) {
            return locale_periods[+(d.getHours() >= 12)]
        }
        function formatUTCShortWeekday(d) {
            return locale_shortWeekdays[d.getUTCDay()]
        }
        function formatUTCWeekday(d) {
            return locale_weekdays[d.getUTCDay()]
        }
        function formatUTCShortMonth(d) {
            return locale_shortMonths[d.getUTCMonth()]
        }
        function formatUTCMonth(d) {
            return locale_months[d.getUTCMonth()]
        }
        function formatUTCPeriod(d) {
            return locale_periods[+(d.getUTCHours() >= 12)]
        }
        return {
            format: function(specifier) {
                var f = newFormat(specifier += "", formats);
                f.toString = function() {
                    return specifier
                }
                ;
                return f
            },
            parse: function(specifier) {
                var p = newParse(specifier += "", localDate);
                p.toString = function() {
                    return specifier
                }
                ;
                return p
            },
            utcFormat: function(specifier) {
                var f = newFormat(specifier += "", utcFormats);
                f.toString = function() {
                    return specifier
                }
                ;
                return f
            },
            utcParse: function(specifier) {
                var p = newParse(specifier, utcDate);
                p.toString = function() {
                    return specifier
                }
                ;
                return p
            }
        }
    }
    function pad(value, fill, width) {
        var sign = value < 0 ? "-" : ""
          , string = (sign ? -value : value) + ""
          , length = string.length;
        return sign + (length < width ? (new Array(width - length + 1)).join(fill) + string : string)
    }
    function requote(s) {
        return s.replace(requoteRe, "\\$&")
    }
    function formatRe(names) {
        return new RegExp("^(?:" + names.map(requote).join("|") + ")","i")
    }
    function formatLookup(names) {
        var map = {}
          , i = -1
          , n = names.length;
        while (++i < n)
            map[names[i].toLowerCase()] = i;
        return map
    }
    function parseWeekdayNumberSunday(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 1));
        return n ? (d.w = +n[0],
        i + n[0].length) : -1
    }
    function parseWeekdayNumberMonday(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 1));
        return n ? (d.u = +n[0],
        i + n[0].length) : -1
    }
    function parseWeekNumberSunday(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.U = +n[0],
        i + n[0].length) : -1
    }
    function parseWeekNumberISO(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.V = +n[0],
        i + n[0].length) : -1
    }
    function parseWeekNumberMonday(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.W = +n[0],
        i + n[0].length) : -1
    }
    function parseFullYear(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 4));
        return n ? (d.y = +n[0],
        i + n[0].length) : -1
    }
    function parseYear(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2E3),
        i + n[0].length) : -1
    }
    function parseZone(d, string, i) {
        var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
        return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")),
        i + n[0].length) : -1
    }
    function parseMonthNumber(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.m = n[0] - 1,
        i + n[0].length) : -1
    }
    function parseDayOfMonth(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.d = +n[0],
        i + n[0].length) : -1
    }
    function parseDayOfYear(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 3));
        return n ? (d.m = 0,
        d.d = +n[0],
        i + n[0].length) : -1
    }
    function parseHour24(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.H = +n[0],
        i + n[0].length) : -1
    }
    function parseMinutes(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.M = +n[0],
        i + n[0].length) : -1
    }
    function parseSeconds(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.S = +n[0],
        i + n[0].length) : -1
    }
    function parseMilliseconds(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 3));
        return n ? (d.L = +n[0],
        i + n[0].length) : -1
    }
    function parseMicroseconds(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 6));
        return n ? (d.L = Math.floor(n[0] / 1E3),
        i + n[0].length) : -1
    }
    function parseLiteralPercent(d, string, i) {
        var n = percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1
    }
    function parseUnixTimestamp(d, string, i) {
        var n = numberRe.exec(string.slice(i));
        return n ? (d.Q = +n[0],
        i + n[0].length) : -1
    }
    function parseUnixTimestampSeconds(d, string, i) {
        var n = numberRe.exec(string.slice(i));
        return n ? (d.Q = +n[0] * 1E3,
        i + n[0].length) : -1
    }
    function formatDayOfMonth(d, p) {
        return pad(d.getDate(), p, 2)
    }
    function formatHour24(d, p) {
        return pad(d.getHours(), p, 2)
    }
    function formatHour12(d, p) {
        return pad(d.getHours() % 12 || 12, p, 2)
    }
    function formatDayOfYear(d, p) {
        return pad(1 + day.count(year(d), d), p, 3)
    }
    function formatMilliseconds(d, p) {
        return pad(d.getMilliseconds(), p, 3)
    }
    function formatMicroseconds(d, p) {
        return formatMilliseconds(d, p) + "000"
    }
    function formatMonthNumber(d, p) {
        return pad(d.getMonth() + 1, p, 2)
    }
    function formatMinutes(d, p) {
        return pad(d.getMinutes(), p, 2)
    }
    function formatSeconds(d, p) {
        return pad(d.getSeconds(), p, 2)
    }
    function formatWeekdayNumberMonday(d) {
        var day = d.getDay();
        return day === 0 ? 7 : day
    }
    function formatWeekNumberSunday(d, p) {
        return pad(sunday.count(year(d), d), p, 2)
    }
    function formatWeekNumberISO(d, p) {
        var day = d.getDay();
        d = day >= 4 || day === 0 ? thursday(d) : thursday.ceil(d);
        return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2)
    }
    function formatWeekdayNumberSunday(d) {
        return d.getDay()
    }
    function formatWeekNumberMonday(d, p) {
        return pad(monday.count(year(d), d), p, 2)
    }
    function formatYear(d, p) {
        return pad(d.getFullYear() % 100, p, 2)
    }
    function formatFullYear(d, p) {
        return pad(d.getFullYear() % 1E4, p, 4)
    }
    function formatZone(d) {
        var z = d.getTimezoneOffset();
        return (z > 0 ? "-" : (z *= -1,
        "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2)
    }
    function formatUTCDayOfMonth(d, p) {
        return pad(d.getUTCDate(), p, 2)
    }
    function formatUTCHour24(d, p) {
        return pad(d.getUTCHours(), p, 2)
    }
    function formatUTCHour12(d, p) {
        return pad(d.getUTCHours() % 12 || 12, p, 2)
    }
    function formatUTCDayOfYear(d, p) {
        return pad(1 + utcDay.count(utcYear(d), d), p, 3)
    }
    function formatUTCMilliseconds(d, p) {
        return pad(d.getUTCMilliseconds(), p, 3)
    }
    function formatUTCMicroseconds(d, p) {
        return formatUTCMilliseconds(d, p) + "000"
    }
    function formatUTCMonthNumber(d, p) {
        return pad(d.getUTCMonth() + 1, p, 2)
    }
    function formatUTCMinutes(d, p) {
        return pad(d.getUTCMinutes(), p, 2)
    }
    function formatUTCSeconds(d, p) {
        return pad(d.getUTCSeconds(), p, 2)
    }
    function formatUTCWeekdayNumberMonday(d) {
        var dow = d.getUTCDay();
        return dow === 0 ? 7 : dow
    }
    function formatUTCWeekNumberSunday(d, p) {
        return pad(utcSunday.count(utcYear(d), d), p, 2)
    }
    function formatUTCWeekNumberISO(d, p) {
        var day = d.getUTCDay();
        d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
        return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2)
    }
    function formatUTCWeekdayNumberSunday(d) {
        return d.getUTCDay()
    }
    function formatUTCWeekNumberMonday(d, p) {
        return pad(utcMonday.count(utcYear(d), d), p, 2)
    }
    function formatUTCYear(d, p) {
        return pad(d.getUTCFullYear() % 100, p, 2)
    }
    function formatUTCFullYear(d, p) {
        return pad(d.getUTCFullYear() % 1E4, p, 4)
    }
    function formatUTCZone() {
        return "+0000"
    }
    function formatLiteralPercent() {
        return "%"
    }
    function formatUnixTimestamp(d) {
        return +d
    }
    function formatUnixTimestampSeconds(d) {
        return Math.floor(+d / 1E3)
    }
    var locale$1;
    var timeFormat;
    var timeParse;
    var utcFormat;
    defaultLocale$1({
        dateTime: "%x, %X",
        date: "%-m/%-d/%Y",
        time: "%-I:%M:%S %p",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
    function defaultLocale$1(definition) {
        locale$1 = formatLocale$1(definition);
        timeFormat = locale$1.format;
        timeParse = locale$1.parse;
        utcFormat = locale$1.utcFormat;
        return locale$1
    }
    function date$1(t) {
        return new Date(t)
    }
    function number$2(t) {
        return t instanceof Date ? +t : +new Date(+t)
    }
    function calendar(year, quarter, month, week, day, hour, minute, second, millisecond, format) {
        var scale = continuous(identity, identity)
          , invert = scale.invert
          , domain = scale.domain;
        var formatMillisecond = format(".%L")
          , formatSecond = format(":%S")
          , formatMinute = format("%I:%M")
          , formatHour = format("%I %p")
          , formatDay = format("%a %d")
          , formatWeek = format("%b %d")
          , formatMonth = format("%B")
          , formatQuarter = format("foo")
          , formatYear = format("%Y");
        var tickIntervals = [[second, 1, durationSecond], [second, 5, 5 * durationSecond], [second, 15, 15 * durationSecond], [second, 30, 30 * durationSecond], [minute, 1, durationMinute], [minute, 5, 5 * durationMinute], [minute, 10, 10 * durationMinute], [minute, 15, 15 * durationMinute], [minute, 30, 30 * durationMinute], [hour, 1, durationHour], [hour, 2, 2 * durationHour], [hour, 6, 6 * durationHour], [day, 1, durationDay], [day, 2, 2 * durationDay], [week, 1, durationWeek], [month, 1, durationMonth], [quarter, 1, durationQuarter], [year, 1, durationYear]];
        function tickFormat(date) {
            return (second(date) < date ? formatMillisecond : minute(date) < date ? formatSecond : hour(date) < date ? formatMinute : day(date) < date ? formatHour : month(date) < date ? week(date) < date ? formatDay : formatWeek : quarter(date) < date ? formatMonth : year(date) < date ? formatQuarter : formatYear)(date)
        }
        function tickInterval(interval, start, stop, step) {
            if (interval == null)
                interval = 10;
            if (typeof interval === "number") {
                var target = Math.abs(stop - start) / interval
                  , i = bisector(function(i) {
                    return i[2]
                }).right(tickIntervals, target);
                if (i === tickIntervals.length) {
                    step = tickStep(start / durationYear, stop / durationYear, interval);
                    interval = year
                } else if (i) {
                    i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
                    step = i[1];
                    interval = i[0]
                } else {
                    step = Math.max(tickStep(start, stop, interval), 1);
                    interval = millisecond
                }
            }
            return step == null ? interval : interval.every(step)
        }
        scale.invert = function(y) {
            return new Date(invert(y))
        }
        ;
        scale.domain = function(_) {
            return arguments.length ? domain(map$1.call(_, number$2)) : domain().map(date$1)
        }
        ;
        scale.ticks = function(interval, step) {
            var d = domain(), t0 = d[0], t1 = d[d.length - 1], r = t1 < t0, t;
            if (r)
                t = t0,
                t0 = t1,
                t1 = t;
            t = tickInterval(interval, t0, t1, step);
            t = t ? t.range(t0, t1) : [];
            return r ? t.reverse() : t
        }
        ;
        scale.tickFormat = function(count, specifier) {
            return specifier == null ? tickFormat : format(specifier)
        }
        ;
        scale.nice = function(interval, step) {
            var d = domain();
            return (interval = tickInterval(interval, d[0], d[d.length - 1], step)) ? domain(nice(d, interval)) : scale
        }
        ;
        scale.copy = function() {
            return copy(scale, calendar(year, quarter, month, week, day, hour, minute, second, millisecond, format))
        }
        ;
        return scale
    }
    function time() {
        return initRange.apply(calendar(year, quarter, month, sunday, day, hour, minute, second, millisecond, timeFormat).domain([new Date(2E3,0,1), new Date(2E3,0,2)]), arguments)
    }
    function utcTime() {
        return initRange.apply(calendar(utcYear, quarter, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, millisecond, utcFormat).domain([Date.UTC(2E3, 0, 1), Date.UTC(2E3, 0, 2)]), arguments)
    }
    exports.scaleTime = time;
    exports.scaleUtc = utcTime;
    exports.tickFormat = tickFormat;
    exports.timeFormat = timeFormat;
    exports.timeParse = timeParse;
    exports.timeCanonicalParse = timeParse("%Y%m%d %H:%M:%S.%L");
    exports.time = {
        year: year,
        quarter: quarter,
        month: month,
        week: sunday,
        sunday: sunday,
        monday: monday,
        tuesday: tuesday,
        wednesday: wednesday,
        thursday: thursday,
        friday: friday,
        saturday: saturday,
        day: day,
        hour: hour,
        minute: minute,
        second: second,
        millisecond: millisecond
    };
    Object.defineProperty(exports, "__esModule", {
        value: true
    })
}
)();
tdgchart.version = "3.1";
tdgchart.minorVersion = "12244";
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.cacheEngine = function() {
        function cacheEngine(chart) {
            this.__internalCache = {};
            this.__chart = chart;
            return this
        }
        return cacheEngine
    }();
    tdgchart.prototype.cacheEngine.prototype.clear = function() {
        if (Array.isArray(this.__preserve)) {
            for (var key in this.__internalCache)
                if (this.__internalCache.hasOwnProperty(key) && !this.__preserve.includes(key))
                    delete this.__internalCache[key];
            delete this.__preserve
        } else
            this.__internalCache = {}
    }
    ;
    tdgchart.prototype.cacheEngine.prototype.hasKey = function(key) {
        return key in this.__internalCache
    }
    ;
    tdgchart.prototype.cacheEngine.prototype.get_or_set = function(key, defaultValue) {
        if (key in this.__internalCache)
            return this.__internalCache[key];
        else {
            if (defaultValue != null)
                this.__internalCache[key] = defaultValue;
            return defaultValue
        }
    }
    ;
    tdgchart.prototype.cacheEngine.prototype.get = function(key, defaultValue) {
        if (key in this.__internalCache)
            return this.__internalCache[key];
        return defaultValue
    }
    ;
    tdgchart.prototype.cacheEngine.prototype.set = function(key, value) {
        this.__internalCache[key] = value;
        return value
    }
    ;
    tdgchart.prototype.cacheEngine.prototype.remove = function(key) {
        var value = this.__internalCache[key];
        delete this.__internalCache[key];
        return value
    }
    ;
    tdgchart.prototype.cacheEngine.prototype.preserve = function(key) {
        this.__preserve = this.__preserve || [];
        this.__preserve.push(key)
    }
    ;
    tdgchart.prototype.cacheEngine.prototype.setProperty = function(prop, newValue) {
        var cachedProps = this.__internalCache.originalProperties = this.__internalCache.originalProperties || [];
        var idx, chartObj = this.__chart;
        var innerProp = prop.split(".");
        for (var i = 0; i < innerProp.length - 1; i++) {
            var newProp = innerProp[i];
            var match = newProp.match(/(.*)\[(\d*)\]/);
            if (match && match.length > 2) {
                newProp = match[1];
                idx = parseInt(match[2], 10);
                if (!chartObj.hasOwnProperty(newProp) || !Array.isArray(chartObj[newProp]) || !chartObj[newProp][i])
                    return
            } else {
                if (!chartObj.hasOwnProperty(newProp))
                    return;
                idx = null
            }
            chartObj[newProp] = chartObj[newProp] || {};
            chartObj = idx == null ? chartObj[newProp] : chartObj[newProp][idx]
        }
        innerProp = innerProp[innerProp.length - 1];
        cachedProps.push({
            prop: prop,
            value: chartObj[innerProp]
        });
        chartObj[innerProp] = newValue
    }
    ;
    tdgchart.prototype.cacheEngine.prototype.restoreCachedProperties = function() {
        var chart = this.__chart;
        if (this.hasKey("originalGroupLabels"))
            chart.groupLabels = this.get("originalGroupLabels");
        chart.data = this.get("originalData");
        var propList = this.get("originalProperties");
        for (var i = propList.length - 1; i >= 0; i--)
            tdg.set(propList[i].prop, propList[i].value, chart)
    }
}
)();
(function() {
    tdgchart.prototype.applyAutoSettings = applyAutoSettings;
    tdgchart.prototype.applyAutoSettingsPostData = applyAutoSettingsPostData;
    var tdg = tdgchart.util;
    function applyAutoSettings() {
        var chart = this;
        var chartType = chart.chartType;
        var isStacked = chart.blaProperties.seriesLayout === "stacked" || chart.blaProperties.seriesLayout === "percent";
        var matrixType = chart.matrixProperties.chartType;
        var seriesCount = chart.swapData || chart.swapDataAndLabels ? chart.groupCount() : chart.seriesCount();
        function isAuto(prop, target) {
            return tdg.flattenProperty(prop, target || chart) === "auto"
        }
        if (isAuto("legend.position"))
            chart.legend.position = "right";
        if (isAuto("legend.reverseOrder"))
            chart.legend.reverseOrder = chart.isBLA() && isStacked;
        if (isAuto("accessibility.title"))
            if (tdg.isEmpty(chart.title.text)) {
                chart.accessibility.title = chartType.charAt(0).toUpperCase() + chartType.substr(1) + " Chart";
                if (chartType === "matrix")
                    chart.accessibility.title = "Matrix Of " + chart.accessibility.title
            } else
                chart.accessibility.title = chart.title.text;
        applyAxisAutoSettings(chart, "xaxis", isAuto);
        applyAxisAutoSettings(chart, "yaxis", isAuto);
        applyAxisAutoSettings(chart, "zaxis", isAuto);
        if (isAuto("gaugeProperties.outerBorder.fill.color"))
            chart.gaugeProperties.outerBorder.fill.color = chart.getSeriesAndGroupProperty(0, null, "color");
        if (isAuto("gaugeProperties.needleBase.color"))
            chart.gaugeProperties.needleBase.color = chart.getSeriesAndGroupProperty(0, null, "color");
        if (isAuto("pieProperties.totalLabel.visible")) {
            var holeSize = tdg.applyNumOrPercent(chart.pieProperties.holeSize, chart.width) || 0;
            chart.pieProperties.totalLabel.visible = holeSize > 20
        }
        if (isAuto("dataGridProperties.altRowFill")) {
            var bg = chart.get("chartFrame.fill.color");
            if (bg) {
                var color = tdg.color(bg);
                if (color.isVisible()) {
                    color = color.hsl();
                    color.l *= .7;
                    chart.dataGridProperties.altRowFill = color.toString()
                }
            }
        }
        function invertColor(propString, targetColor) {
            var prop = chart.get(propString);
            if (isAuto(propString + ".color"))
                if (tdg.color.isVisible(targetColor) && tdg.color(targetColor).luma() < .18)
                    prop.color = "white";
                else
                    prop.color = "black"
        }
        var backgroundColor = chart.get("chartFrame.fill.color");
        if (!tdg.color.isVisible(backgroundColor))
            backgroundColor = chart.get("fill.color");
        invertColor("dataSelection.selectedBorder", backgroundColor);
        invertColor("dataSelection.unselectedBorder", backgroundColor);
        invertColor("mouseOverIndicator.border", backgroundColor);
        chart.series.forEach(function(s) {
            if (isAuto("dataLabels.color", s)) {
                var pos = chart.getSeriesAndGroupProperty(s.series, null, "dataLabels.position");
                if (pos === "center" || chartType === "treemap" || chartType === "bar" && (pos === "insideTop" || pos === "insideBottom" || isStacked) || chartType === "pie" && pos === "top")
                    s.dataLabels.color = function(d, data, ids) {
                        var targetColor;
                        if (tdgchart.tdgscene.isTDGSceneMark(this)) {
                            targetColor = tdg.get("props.attrs.color", this);
                            if (targetColor == null)
                                targetColor = tdg.get("attrs.color", this.parent)
                        } else if (tdgchart.extensionManager.isExtension(chart.chartType))
                            targetColor = chart.seriesColorLookup()(d);
                        else if (this instanceof pv.Mark) {
                            var target = this.anchorTarget();
                            if (chartType === "treemap")
                                target = this.parent.children[0];
                            targetColor = target.fillStyle().color
                        }
                        if (!targetColor)
                            return "black";
                        else if (tdg.color(targetColor).luma() < .18)
                            return "white";
                        return "black"
                    }
                    ;
                else
                    s.dataLabels.color = "black"
            }
            if (isAuto("dataLabels.visible", s))
                if (chartType === "treemap" || chartType === "funnel")
                    s.dataLabels.visible = true;
                else
                    s.dataLabels.visible = false;
            if (isAuto("dataLabels.position", s))
                if (chart.isBLA() && seriesCount > 1 && (chart.blaProperties.seriesLayout === "stacked" || chart.blaProperties.seriesLayout === "percent"))
                    s.dataLabels.position = "center";
                else if (chartType === "matrix" && matrixType === "marker")
                    s.dataLabels.position = "center";
                else if (chartType === "heatmap")
                    s.dataLabels.position = "center";
                else if (chartType === "pie")
                    s.dataLabels.position = "outsideAuto";
                else if (chartType === "funnel")
                    s.dataLabels.position = "outside";
                else
                    s.dataLabels.position = "top"
        })
    }
    function applyAutoSettingsPostData() {
        function isAuto(prop, target) {
            return tdg.flattenProperty(prop, target || chart) === "auto"
        }
        var chart = this;
        var chartType = chart.chartType;
        var matrixType = chart.matrixProperties.chartType;
        var seriesCount = chart.seriesCount();
        var legendVisibility;
        if (isAuto("legend.visible")) {
            if (tdgchart.extensionManager.isExtension(chart.chartType))
                if (tdgchart.extensionManager.requiresModule(chart.chartType, "legend"))
                    if (tdgchart.extensionManager.getModuleProperty(chart, "legend", "sizeMode") === "size")
                        legendVisibility = true;
                    else if (tdgchart.extensionManager.getModuleProperty(chart, "legend", "colorMode") === "series" && seriesCount < 2)
                        legendVisibility = false;
                    else
                        legendVisibility = true;
                else
                    legendVisibility = false;
            else if (seriesCount < 2)
                if (chart.dataArrayMap)
                    if (chart.dataArrayMap.indexOf("color") >= 0)
                        legendVisibility = true;
                    else if (chart.dataArrayMap.indexOf("size") >= 0) {
                        chart.cache.set("legend_hide_labels", true);
                        legendVisibility = true
                    } else if (chartType === "matrix" && matrixType === "marker" && chart.dataArrayMap.indexOf("value") >= 0)
                        legendVisibility = true;
                    else if (chart.isLeaflet() && chart.dataArrayMap.indexOf("value") >= 0)
                        legendVisibility = true;
                    else
                        legendVisibility = false;
                else
                    legendVisibility = false;
            else
                legendVisibility = true;
            if (legendVisibility != null)
                chart.cache.setProperty("legend.visible", legendVisibility);
            if (chart.legend.title.visible && chart.legend.title.text != "")
                chart.legend.visible = true
        }
    }
    function applyAxisAutoSettings(chart, axisName, isAuto) {
        if (isAuto(axisName + ".labels.excludeMax")) {
            var chartType = chart.chartType;
            var matrixType = chart.matrixProperties.chartType;
            var axisModes = chart.cache.get("axisModes", {});
            var isOrdinal = axisModes[axisName] === "ordinal" || (axisName === "xaxis" && axisModes.x1 === "ordinal" || axisName === "yaxis" && axisModes.y1 === "ordinal") || axisName === "zaxis" && axisModes.z1 === "ordinal";
            if (chartType === "matrix" && !isOrdinal && (matrixType === "bubble" || matrixType === "scatter"))
                chart[axisName].labels.excludeMax = true;
            else
                chart[axisName].labels.excludeMax = false
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    var globalAnnotations;
    tdgchart.prototype.validateChartProperties = function() {
        var chart = this;
        if (tdgchart.extensionManager.isExtension(chart.chartType))
            validateExtension(chart);
        globalAnnotations = tdgchart.propertyAnnotations;
        validateAnnotationObject(chart, tdgchart.propertyAnnotations, "")
    }
    ;
    function validateExtension(chart) {
        var extList = tdgchart.extensionManager.__extensionList;
        for (var e in extList)
            if (extList.hasOwnProperty(e))
                tdgchart.propertyAnnotations.global.chartType.stringValues.push(e);
        var props = chart.extensions[chart.chartType];
        var annotations = extList[chart.chartType].propertyAnnotations;
        globalAnnotations = annotations;
        validateAnnotationObject(props, annotations, '.extensions["' + chart.chartType + '"]')
    }
    function validateColor(color) {
        if (!color || typeof color !== "string")
            return false;
        if (tdg.color.names[color] || color.match(/^#[0-9a-f]{3,6}$/i) != null || color.match(/rgba??\(\d{1,3},/i) != null || color.match(/hsla??\(\d{1,3},/i) != null)
            return true;
        return false
    }
    function validatePercentString(str) {
        return typeof str === "string" && str.endsWith("%")
    }
    function validateNumber(prop, annotation) {
        if (typeof prop !== "number")
            return false;
        if (annotation.numericRange && (prop < annotation.numericRange[0] || prop > annotation.numericRange[1]))
            return false;
        return true
    }
    function validateString(prop, annotation) {
        if (typeof prop !== "string")
            return false;
        if (annotation.stringValues && annotation.stringValues.indexOf(prop) < 0)
            return false;
        return true
    }
    function validateHexString(prop, annotation) {
        if (typeof prop !== "string")
            return false;
        if (!prop.match(/^[0-9a-f]*$/))
            return false;
        if (annotation.stringValues && annotation.stringValues.indexOf(prop) < 0)
            return false;
        return true
    }
    function validateAlphanumString(prop, annotation) {
        if (typeof prop !== "string")
            return false;
        if (!prop.match(/^[0-9a-z]*$/i))
            return false;
        if (annotation.stringValues && annotation.stringValues.indexOf(prop) < 0)
            return false;
        return true
    }
    function validateArray(prop, annotation, breadcrumb) {
        if (!Array.isArray(prop))
            throw format(breadcrumb, "an array of {0} and not a {1}", annotationToStr(annotation), typeof prop);
        if (!annotation.arrayTypes || !prop.length)
            return true;
        var newAnnotation = tdg.cloneObject(annotation);
        var types = Array.isArray(annotation.arrayTypes) ? annotation.arrayTypes : [annotation.arrayTypes];
        var bestError;
        for (var i = 0; i < prop.length; i++) {
            for (var j = 0; j < types.length; j++) {
                try {
                    newAnnotation.typeAnnotation = types[j];
                    checkTypeAnnotation(prop[i], newAnnotation, breadcrumb + "[" + i + "]")
                } catch (e$7) {
                    bestError = e$7;
                    continue
                }
                bestError = null;
                break
            }
            if (bestError)
                throw bestError;
        }
        return true
    }
    function validateType(prop, annotation, breadcrumb) {
        var newAnnotation = tdg.cloneObject(annotation);
        var bestError;
        for (var i = 0; i < annotation.typeValues.length; i++) {
            try {
                newAnnotation.typeAnnotation = annotation.typeValues[i];
                checkTypeAnnotation(prop, newAnnotation, breadcrumb)
            } catch (e$8) {
                if (typeof prop === "object" && isGlobalAnnotationType(newAnnotation.typeAnnotation))
                    bestError = e$8;
                continue
            }
            return true
        }
        if (bestError)
            throw bestError;
        return false
    }
    function validateGenericType(type) {
        return function(prop) {
            return typeof prop === type
        }
    }
    var validators = {
        str: validateString,
        number: validateNumber,
        hexstr: validateHexString,
        alphanum: validateAlphanumString,
        bool: validateGenericType("boolean"),
        array: validateArray,
        color: validateColor,
        percentString: validatePercentString,
        font: validateGenericType("string"),
        type: validateType,
        json: validateGenericType("object"),
        "function": validateGenericType("function")
    };
    function checkTypeAnnotation(prop, annotation, breadcrumb) {
        var type = annotation.typeAnnotation;
        if (prop == null || type === "object")
            return;
        if (isGlobalAnnotationType(type)) {
            var isDefault = !!annotation.defaultType;
            annotation = getGlobalAnnotation(type);
            if (typeof annotation === "object" && !annotation.typeAnnotation)
                return validateAnnotationObject(prop, annotation, breadcrumb, isDefault)
        }
        var validator = validators[type];
        if (validator && validator(prop, annotation, breadcrumb))
            return;
        throw format(breadcrumb, "a {0} and not {1}", annotationToStr(annotation), niceStr(prop));
    }
    function validateAnnotationObject(propTree, annotationTree, breadcrumb, isDefault) {
        if (propTree == null || typeof propTree !== "object") {
            if (isDefault)
                return;
            if (breadcrumb === ".locale")
                return;
            throw format(breadcrumb, "an object with additional properties and not {0}", niceStr(propTree));
        }
        for (var annotationKey in annotationTree) {
            if (!annotationTree.hasOwnProperty(annotationKey) || annotationKey === "global")
                continue;
            var newBreadcrumb = breadcrumb + "." + annotationKey;
            var annotation = annotationTree[annotationKey];
            if (isGlobalAnnotationType(annotation))
                annotation = getGlobalAnnotation(annotation);
            if (typeof annotation === "string")
                checkTypeAnnotation(propTree[annotationKey], {
                    typeAnnotation: annotation
                }, newBreadcrumb);
            else if (typeof annotation === "object")
                if (annotation.typeAnnotation)
                    checkTypeAnnotation(propTree[annotationKey], annotation, newBreadcrumb);
                else
                    validateAnnotationObject(propTree[annotationKey], annotation, newBreadcrumb, isDefault)
        }
    }
    function format(breadcrumb, str) {
        str = "Property Validation Fail: chart{0} must be " + str.replace(/\{(\d)\}/gi, function(s, d) {
            return "{" + (parseInt(d, 10) + 1) + "}"
        });
        return tdg.formatString.apply(null, [str, breadcrumb].concat(Array.prototype.slice.call(arguments, 2)))
    }
    function isGlobalAnnotationType(annotationKey) {
        return typeof annotationKey === "string" && annotationKey.startsWith("global")
    }
    function getGlobalAnnotation(annotationKey) {
        return globalAnnotations.global[annotationKey.replace("global.", "")]
    }
    function arrayToPrettyList(a) {
        a = a.map(annotationToStr);
        return a.slice(0, -1).join(", ") + " or " + a.slice(-1)
    }
    function annotationToStr(annotation) {
        var a = annotation.typeAnnotation || annotation;
        if (a === "str")
            a = "string";
        else if (a === "bool")
            a = "boolean";
        else if (a === "json")
            a = "json object";
        if (annotation.arrayTypes)
            if (Array.isArray(annotation.arrayTypes))
                a = arrayToPrettyList(annotation.arrayTypes);
            else
                a = annotationToStr(annotation.arrayTypes);
        if (annotation.typeValues)
            a = arrayToPrettyList(annotation.typeValues);
        if (annotation.stringValues)
            a = a.replace("string", "string in " + niceStr(annotation.stringValues));
        if (annotation.numericRange)
            a = a.replace("number", "number in " + niceStr(annotation.numericRange));
        return a
    }
    function niceStr(s) {
        if (s == null)
            return "null";
        else if (s === "")
            return "an empty string";
        else if (typeof s === "string")
            return '"' + s + '"';
        else if (Array.isArray(s))
            return "[" + s.map(function(el) {
                return el + ""
            }).join(", ") + "]";
        else if (typeof s === "object")
            return "an object";
        return "'" + s + "'"
    }
}
)();
(function() {
    tdgchart.Tokenizer = function(tokenizers, doBuild) {
        this.tokenizers = tokenizers;
        this.doBuild = doBuild
    }
    ;
    tdgchart.Tokenizer.prototype = {
        parse: function(src) {
            this.src = src;
            this.ended = false;
            this.tokens = [];
            do
                this.next();
            while (!this.ended);
            return this.tokens
        },
        build: function(src, real) {
            if (src)
                this.tokens.push(this.doBuild(src, real, this.tkn))
        },
        next: function() {
            var self = this, plain;
            self.findMin();
            plain = self.src.slice(0, self.min);
            self.build(plain, false);
            self.src = self.src.slice(self.min).replace(self.tkn, function(all) {
                self.build(all, true);
                return ""
            });
            if (!self.src)
                self.ended = true
        },
        findMin: function() {
            var self = this, i = 0, tkn, idx;
            self.min = -1;
            self.tkn = "";
            while ((tkn = self.tokenizers[i++]) != null) {
                idx = self.src[typeof tkn === "string" ? "indexOf" : "search"](tkn);
                if (idx !== -1 && (self.min === -1 || idx < self.min)) {
                    self.tkn = tkn;
                    self.min = idx
                }
            }
            if (self.min === -1)
                self.min = self.src.length
        }
    }
}
)();
(function() {
    tdgchart.prototype.cloneObject = tdgchart.util.cloneObject;
    tdgchart.prototype.mergeObjects = tdgchart.mergeObjects = tdgchart.util.mergeObjects;
    var tdg = tdgchart.util;
    tdgchart.prototype.resetProperties = function() {
        var chart = this;
        chart.series = [];
        chart.set(tdgchart.defaultProperties);
        chart.dataLabels = {
            feelerLine: {}
        };
        chart.axisAutoLayout = {};
        chart.bubbleMarker = {};
        chart.pieProperties.feelerLine = {};
        chart.legend.xy = {};
        chart.xaxisOrdinal = chart.xaxisNumeric = chart.zaxisOrdinal = null;
        chart.legend.align = chart.errorStatus = null;
        for (var k in chart.extensions)
            if (chart.extensions.hasOwnProperty(k))
                chart.extensions[k] = {}
    }
    ;
    function getUserAgent() {
        var ua = navigator.userAgent;
        var browser = navigator.appName;
        var version = "" + parseFloat(navigator.appVersion);
        var nameOffset, verOffset, ix;
        if ((verOffset = ua.indexOf("Chrome")) !== -1) {
            browser = "Chrome";
            version = ua.substring(verOffset + 7)
        } else if ((verOffset = ua.indexOf("Firefox")) !== -1) {
            browser = "Firefox";
            version = ua.substring(verOffset + 8)
        } else if ((verOffset = ua.indexOf("MSIE")) !== -1) {
            browser = "IE";
            version = ua.substring(verOffset + 5)
        } else if ((verOffset = ua.indexOf("Safari")) !== -1) {
            browser = "Safari";
            version = ua.substring(verOffset + 7);
            if ((verOffset = ua.indexOf("Version")) !== -1)
                version = ua.substring(verOffset + 8)
        } else if ((verOffset = ua.indexOf("Opera")) !== -1) {
            browser = "Opera";
            version = ua.substring(verOffset + 6);
            if ((verOffset = ua.indexOf("Version")) !== -1)
                version = ua.substring(verOffset + 8)
        } else if ((nameOffset = ua.lastIndexOf(" ") + 1) < (verOffset = ua.lastIndexOf("/"))) {
            browser = ua.substring(nameOffset, verOffset);
            version = ua.substring(verOffset + 1);
            if (browser.toLowerCase() === browser.toUpperCase())
                browser = navigator.appName
        }
        if ((ix = version.indexOf(";")) !== -1)
            version = version.substring(0, ix);
        if ((ix = version.indexOf(" ")) !== -1)
            version = version.substring(0, ix);
        return browser + ": " + version
    }
    function getTime() {
        var t = new Date;
        return t.getHours() + ":" + t.getMinutes() + " " + t.getDate() + "/" + (t.getMonth() + 1) + "/" + t.getFullYear()
    }
    function nestedLabelObjectToArray(labels) {
        function convert(map) {
            if (Array.isArray(map))
                return map;
            else if (typeof map !== "object")
                return [(map || "") + ""];
            var newArray = [];
            for (var key in map)
                if (map.hasOwnProperty(key)) {
                    var res = {};
                    res[key] = convert(map[key]);
                    newArray.push(res)
                }
            return newArray
        }
        return convert(labels)
    }
    function backwardComaptibilityFixups(chart) {
        var i, idx;
        var matrixType = chart.matrixProperties.chartType;
        var defaultSeries = chart.getDefaultSeries();
        if (!defaultSeries) {
            defaultSeries = {
                series: "all"
            };
            chart.series.push(defaultSeries)
        }
        if (chart.heatmapProperties && chart.heatmapProperties.dataColors)
            chart.colorScale.colors = chart.heatmapProperties.dataColors;
        chart.axisBackwardCompatibleFixup();
        if (chart.chartType === "heatmap" && (typeof chart.yaxis.min === "number" || typeof chart.yaxis.max === "number")) {
            chart.colorScale.min = typeof chart.yaxis.min === "number" ? chart.yaxis.min : chart.colorScale.min;
            chart.colorScale.max = typeof chart.yaxis.max === "number" ? chart.yaxis.max : chart.colorScale.max
        }
        if (chart.yaxis && chart.yaxis.colorScale && chart.yaxis.colorScale.colors && chart.yaxis.colorScale.colors.length)
            chart.colorScale.colors = chart.yaxis.colorScale.colors;
        if (chart.colorMode && typeof chart.colorMode === "string")
            chart.colorMode = {
                mode: chart.colorMode
            };
        if (chart.bubbleMarker && chart.bubbleMarker.maxSize != null)
            chart.zaxis.marker.maxSize = chart.bubbleMarker.maxSize;
        for (i = 0; i < chart.series.length; i++) {
            var s = chart.series[i];
            if (s.marker && s.marker.fillMode)
                s.marker.fillEffect = s.marker.fillMode;
            if (s.showDataValues != null) {
                s.dataLabels = s.dataLabels || {};
                s.dataLabels.visible = s.showDataValues
            }
            if (s.trendline)
                if (Array.isArray(s.trendline))
                    s.trendline.forEach(function(el) {
                        var match = (el.mode || "").match(/([12])stddev/);
                        if (match && match[1]) {
                            el.mode = "stddev";
                            el.order = parseInt(match[1], 10)
                        }
                    });
                else {
                    var match = (s.trendline.mode || "").match(/([12])stddev/);
                    if (match && match[1]) {
                        s.trendline.mode = "stddev";
                        s.trendline.order = parseInt(match[1], 10)
                    }
                }
        }
        if (chart.dataArrayMap && (chart.chartType === "marker" || chart.chartType === "matrix" && matrixType === "marker")) {
            idx = chart.dataArrayMap.indexOf("value");
            if (idx >= 0 && chart.dataArrayMap.indexOf("size") < 0)
                chart.dataArrayMap[idx] = "size"
        }
        if (chart.dataArrayMap && (chart.chartType === "heatmap" || chart.chartType === "matrix" && matrixType === "heatmap")) {
            idx = chart.dataArrayMap.indexOf("value");
            if (idx >= 0 && chart.dataArrayMap.indexOf("color") < 0)
                chart.dataArrayMap[idx] = "color"
        }
        if (chart.axisAutoLayout) {
            var aa = chart.axisAutoLayout;
            if (typeof aa.stagger === "boolean")
                chart.xaxis.labelLayout.stagger = aa.stagger ? "auto" : false;
            if (typeof aa.skip === "boolean")
                chart.xaxis.labelLayout.skip = aa.skip ? "auto" : 0;
            if (typeof aa.rotate90 === "boolean" && (chart.xaxis.labels.rotation == null || chart.xaxis.labels.rotation === "auto"))
                chart.xaxis.labels.rotation = aa.rotate90 ? "auto" : 0
        }
        if (!tdg.isEmpty(chart.trendline.line))
            chart.trendline.lineStyle = chart.trendline.line;
        if (chart.dataLabels) {
            var lbl = defaultSeries.dataLabels = defaultSeries.dataLabels || {};
            for (var k in chart.dataLabels)
                if (chart.dataLabels.hasOwnProperty(k) && chart.dataLabels[k] == null)
                    delete chart.dataLabels[k];
            tdg.mergeObjects(chart.dataLabels, lbl);
            lbl.content = chart.dataLabels.displayMode || lbl.content;
            lbl.content = chart.dataLabels.formatCallback != null ? chart.dataLabels.formatCallback : lbl.content;
            delete lbl.displayMode;
            delete lbl.formatCallback;
            if (chart.dataLabels.visible === true)
                lbl.visible = defaultSeries.showDataValues == null ? chart.dataLabels.visible : defaultSeries.showDataValues;
            else if (chart.dataLabels.visible === false || chart.dataLabels.visible === "auto")
                chart.series.forEach(function(el) {
                    if (el && el.dataLabels)
                        el.dataLabels.visible = chart.dataLabels.visible
                })
        }
        if (chart.pieProperties.feelerLine) {
            defaultSeries.dataLabels = defaultSeries.dataLabels || {};
            defaultSeries.dataLabels.feelerLine = defaultSeries.dataLabels.feelerLine || {};
            tdg.mergeObjects(chart.pieProperties.feelerLine, defaultSeries.dataLabels.feelerLine);
            delete chart.pieProperties.feelerLine
        }
        objLabelsToArray(chart, "groupLabels");
        objLabelsToArray(chart.matrixProperties.rowLabels, "labels");
        objLabelsToArray(chart.matrixProperties.colLabels, "labels");
        if (chart.chartType === "tagcloud" && Array.isArray(chart.data[0])) {
            var data = chart.isPageSliderEnabled() ? chart.data[chart.dataPageSlider.currentPage || 0] : chart.data;
            if (data.length > 1 && chart.dataArrayMap == null) {
                for (i = 0; i < data[0].length; i++)
                    if (data[0] && data[0][i] != null && data[1] && data[1][i] != null)
                        data[0][i] = [data[0][i], data[1][i]];
                chart.cache.setProperty("dataArrayMap", ["value", "color"]);
                if (chart.isPageSliderEnabled())
                    chart.data[chart.dataPageSlider.currentPage || 0] = data.slice(0, 1);
                else
                    chart.data = data.slice(0, 1)
            } else if (chart.dataArrayMap == null) {
                data = data[0];
                for (i = 0; i < data.length; i++)
                    if (data[i] != null && data[i].color == null)
                        if (Array.isArray(data[i]))
                            data[i] = [data[i][0], data[i][0]];
                        else
                            data[i] = [data[i], data[i]];
                chart.cache.setProperty("dataArrayMap", ["value", "color"])
            }
        }
        if (chart.legend.position === "free") {
            var pos = {
                excludeFromLayout: true,
                anchor: "chartBackground",
                orientation: "vertical"
            };
            pos.left = chart.legend.xy.x != null ? chart.legend.xy.x : 350;
            pos.top = chart.legend.xy.y != null ? chart.legend.xy.y : 50;
            chart.cache.setProperty("legend.position", pos)
        }
        if (chart.legend.align != null) {
            if (chart.legend.position == null || typeof chart.legend.position === "string")
                chart.cache.setProperty("legend.position", {
                    side: chart.legend.position,
                    align: chart.legend.align
                });
            else
                chart.cache.setProperty("legend.position.align", chart.legend.align);
            chart.cache.setProperty("legend.align", undefined)
        }
        if (chart.blaProperties.splitY === true)
            chart.splitNumericAxis.splitY.enabled = true
    }
    function objLabelsToArray(obj, key) {
        var v = obj[key];
        if (!Array.isArray(v) && typeof v === "object")
            obj[key] = nestedLabelObjectToArray(v)
    }
    function verifyProperties(chart) {
        chart.chartType = chart.chartType || "bar";
        chart.chartType = chart.chartType.toLowerCase();
        if (chart.chartType === "choropleth")
            chart.chartType = "map";
        var validChartTypes = tdg.get("propertyAnnotations.global.chartType.stringValues", tdgchart);
        if (!tdg.isEmpty(validChartTypes))
            if (!validChartTypes.includes(chart.chartType) && !chart.isExtension(chart.chartType))
                throw new tdgchart.UserError('Unknown Chart Type: "' + chart.chartType + '"');
        if (chart.chartType === "matrix") {
            chart.matrixProperties.chartType = chart.matrixProperties.chartType || "bar";
            chart.matrixProperties.chartType = chart.matrixProperties.chartType.toLowerCase();
            var validMatrixTypes = tdg.get("propertyAnnotations.matrixProperties.chartType.stringValues", tdgchart);
            if (!tdg.isEmpty(validMatrixTypes))
                if (!validMatrixTypes.includes(chart.matrixProperties.chartType))
                    throw new tdgchart.UserError('Unsupported Matrix Chart Type: "' + chart.matrixProperties.chartType + '"');
        }
        if (typeof chart.data === "string" && chart.data.indexOf("sample") >= 0)
            chart.setSampleData();
        if (chart.data == null)
            chart.data = [[]];
        if (chart.dataPageSlider) {
            var cp = chart.dataPageSlider.currentPage || 0;
            chart.dataPageSlider.currentPage = tdg.bound(cp, 0, chart.data.length - 1)
        }
        var o = (chart.blaProperties.orientation + "" || "vertical").toLowerCase();
        if (o.startsWith("h"))
            chart.blaProperties.orientation = "horizontal";
        else
            chart.blaProperties.orientation = "vertical";
        if (chart.previewSelection.enabled)
            for (var i = 0; i < chart.series.length; i++) {
                var series = chart.series[i];
                if (!tdg.isEmpty(series.color) && !tdg.color.isVisible(series.color))
                    series.color = "rgba(255, 255, 255, 0.0001)"
            }
        if (chart.hasOwnProperty("dataBuckets"))
            chart.dataBuckets.getBucket = function(bucketName) {
                var buckets = this.buckets || [];
                for (var i = 0; i < buckets.length; i++)
                    if (buckets[i] && (buckets[i].id === bucketName || buckets[i].id === bucketName.toLowerCase()))
                        return buckets[i];
                return null
            }
    }
    function drawInternal(chart) {
        if (chart.dataSetLimits && chart.dataSetLimits.enabled)
            chart.checkIfTooMuchData();
        chart.cache.clear();
        chart.cache.set("drawStartTime", Date.now());
        chart._postRenderCallbacks = chart._postRenderCallbacks || [];
        chart._postProcessCallbacks = [];
        if (chart.validateProperties)
            chart.validateChartProperties();
        if (chart.drawStaticChart)
            chart.convertToStaticChart();
        chart.cache.set("originalData", tdg.cloneObject(chart.data));
        chart.cache.set("tdgscene", new tdgchart.tdgscene(chart));
        if (!tdg.isNestedLabels(chart.groupLabels) && Array.isArray(chart.groupLabels))
            chart.cache.set("originalGroupLabels", chart.groupLabels.slice(0));
        tdgchart.initLabelDiv();
        verifyProperties(chart);
        backwardComaptibilityFixups(chart);
        chart.flattenSeriesArray();
        chart.applyAutoSettings();
        chart.fixAxesList();
        chart.doHichertProperties();
        if (chart.filter && chart.filter.enabled && !chart.filter.processed) {
            chart.height -= 35;
            chart.filter.text = ""
        }
        var transform;
        if (chart.transform != null) {
            if (chart.transform.scale == "auto")
                chart.cache.setProperty("transform.scale", undefined);
            if (chart.transform.scale == "autoscale")
                chart.cache.setProperty("transform.scale", "auto");
            if (chart.transform.scale == "auto" && (chart.transform.referenceSize.width || chart.transform.referenceSize.height)) {
                var factor;
                if (!chart.transform.referenceSize.width)
                    factor = chart.height / chart.transform.referenceSize.height;
                else if (!chart.transform.referenceSize.height)
                    factor = chart.width / chart.transform.referenceSize.width;
                else
                    factor = Math.min(chart.height / chart.transform.referenceSize.height, chart.width / chart.transform.referenceSize.width);
                if (factor != 1) {
                    chart.cache.setProperty("width", chart.width / factor);
                    chart.cache.setProperty("height", chart.height / factor);
                    chart.cache.setProperty("transform.scale", factor);
                    transform = {
                        scale: factor
                    }
                }
            } else if (tdgchart.extensionManager.isExtension(chart.chartType) && tdg.isANumber(chart.transform.scale)) {
                var outType = tdgchart.extensionManager.getExtensionProperty(chart, "outputFormat");
                if (typeof outType === "string" && outType.toLowerCase() !== "svg") {
                    chart.cache.setProperty("width", chart.width * chart.transform.scale);
                    chart.cache.setProperty("height", chart.height * chart.transform.scale)
                } else
                    transform = chart.transform
            } else
                transform = chart.transform
        }
        var rootPanel = (new pv.Panel).width(chart.width).height(chart.height).className("rootPanel").title(chart.applyTemplate(chart.get("accessibility.title", null, null, null))).desc(chart.applyTemplate(chart.get("accessibility.description", null, null, null)));
        if (transform)
            rootPanel.viewBox(transform);
        rootPanel.computedSize = {
            width: chart.width,
            height: chart.height
        };
        pv._useHTMLtooltips = chart.htmlToolTip.enabled;
        addFillPanel(chart, rootPanel, chart.fill.color, chart.border, undefined, "background", false);
        chart.checkDrawTime();
        if (chart.chartType === "sparkline" || chart.chartType === "bullet" || chart.chartType === "marker") {
            chart.data = chart.normalizeData(chart.data, chart.dataArrayMap);
            chart.drawMicroChart(rootPanel);
            rootPanel.canvas(chart.documentRoot).render();
            chart.cache.get("tdgscene").render();
            if (chart.htmlToolTip.enabled)
                chart.addHTMLToolTips();
            chart.drawIntroAnimation();
            return chart
        }
        if (Array.isArray(chart.data) && chart.data.length && (chart.swapData || chart.swapDataAndLabels) && chart.chartType !== "treemap")
            chart.data = tdg.transpose(chart.data);
        chart._internalData = undefined;
        if (chart.chartType !== "treemap" && chart.chartType !== "circlepack2") {
            chart.data = chart.normalizeData(chart.data, chart.dataArrayMap);
            var data = chart.data;
            if (chart.isPageSliderEnabled())
                data = chart.data[chart.dataPageSlider.currentPage || 0];
            if (chart.isXTimeAxis()) {
                var res = chart.aggregateTimeData(data);
                if (res) {
                    data = res.data;
                    chart.cache.setProperty("groupLabels", res.groupLabels);
                    chart.cache.set("originalGroupLabels", res.groupLabels);
                    chart.cache.set("xaxis_time_labels_count", res.groupLabels.length)
                }
            }
            if (chart.chartType === "matrix" && chart.matrixProperties.colWrapCount)
                chart.initFacetChart(data);
            data = chart.handleShowNullGroups(data);
            var hideSeries = chart.getShowNullSeries(data);
            var res = chart.trimInvisibleSeries(data, hideSeries);
            chart._internalData = res.data;
            chart._internalData.seriesMap = res.seriesMap;
            if (!chart._internalData.length) {
                chart._internalData = [[]];
                chart.cache.setProperty("showNullGroups", true);
                chart._internalData.seriesMap = [null]
            }
            chart.cacheStats(res.data)
        } else
            chart._internalData = chart.isPageSliderEnabled() ? chart.data[chart.dataPageSlider.currentPage || 0] : chart.data;
        chart.sortOrdinalAxes();
        if (chart.isXTimeAxis())
            chart.initTimeScale();
        if (chart.hasColorScale())
            chart.initColorScale();
        if (tdgchart.extensionManager.isExtension(chart.chartType))
            tdgchart.extensionManager.initModules(chart);
        chart.applyAutoSettingsPostData();
        if ((chart.chartType === "scatter" || chart.chartType === "matrix" && chart.matrixProperties.chartType === "scatter") && chart.dataObjHasProp(chart.data, "size"))
            if (chart.chartType === "scatter")
                chart.chartType = "bubble";
            else
                chart.matrixProperties.chartType = "bubble";
        chart.setSeriesColors();
        var overallLayout = chart.getOverallLayout();
        if (chart.chartType === "legend") {
            chart.drawLegend(rootPanel, overallLayout.legend);
            rootPanel.canvas(chart.documentRoot).render();
            chart.cache.get("tdgscene").render();
            return chart
        }
        chart.checkDrawTime();
        var chartLayout;
        switch (chart.chartType) {
        case "bar":
        case "line":
        case "area":
            chartLayout = chart.layoutBLAChart(overallLayout.chart);
            break;
        case "scatter":
        case "bubble":
            chartLayout = chart.layoutXYChart(overallLayout.chart);
            break;
        case "boxplot":
        case "waterfall":
        case "control":
            chartLayout = chart.layoutXOrdYChart(overallLayout.chart);
            break;
        case "pictogram":
            chartLayout = chart.layoutPictogram(overallLayout.chart);
            break;
        case "stock":
            chartLayout = chart.layoutStockChart(overallLayout.chart);
            break;
        case "gantt":
            chartLayout = chart.layoutGanttChart(overallLayout.chart);
            break;
        case "streamgraph":
            chartLayout = chart.layoutStreamGraph(overallLayout.chart);
            break;
        case "histogram":
            chartLayout = chart.layoutHistogram(overallLayout.chart);
            break;
        case "heatmap":
            chartLayout = chart.layoutHeatmap(overallLayout.chart);
            break;
        case "matrix":
            chartLayout = chart.layoutMatrixChart(overallLayout.chart);
            break;
        case "datagrid":
            chartLayout = chart.layoutDataGrid(overallLayout.chart);
            break;
        case "pareto":
        case "mekko":
        default:
            chartLayout = chart.layoutDefaultChart(overallLayout.chart);
            break
        }
        if (chartLayout.chartSize)
            if (chartLayout.matrixLayout && chartLayout.matrixLayout.dim && chartLayout.matrixLayout.dim.cell)
                overallLayout.chartFrame = {
                    x: overallLayout.chart.x + chartLayout.matrixLayout.dim.hHeaderSpace[0],
                    y: overallLayout.chart.y + chartLayout.matrixLayout.dim.vHeaderHeight,
                    width: chartLayout.matrixLayout.dim.chart.width - chartLayout.matrixLayout.dim.hHeaderSpace[0] - chartLayout.matrixLayout.dim.hHeaderSpace[1],
                    height: chartLayout.matrixLayout.dim.chart.height - chartLayout.matrixLayout.dim.vHeaderHeight
                };
            else {
                var size = chartLayout.chartSizeReal || chartLayout.chartSize;
                overallLayout.chartFrame = {
                    x: overallLayout.chart.x + size.x,
                    y: overallLayout.chart.y + size.y,
                    width: size.width,
                    height: size.height
                }
            }
        chart.cache.set("layout", {
            overallLayout: overallLayout,
            chartLayout: chartLayout
        });
        chart.checkDrawTime();
        var drawPanels = chart.prepareDrawPanels(rootPanel, overallLayout.chart);
        var chartPanel = drawPanels.chartPanel;
        var groupPanels;
        if (chart.needAccessibility() && !chart.accessibility.navigation.enabled)
            chartPanel.attributes({
                "aria-hidden": true
            });
        if (!chart.isNarrativeTextChartHidden())
            switch (chart.chartType) {
            case "bar":
            case "line":
            case "area":
                chart.drawBLAChart(chartPanel, chartLayout);
                break;
            case "pie":
                chart.drawPieChart(chartPanel, chartLayout);
                break;
            case "scatter":
            case "bubble":
                groupPanels = chart.createXYPanels(chartPanel, chartLayout.chartSize, chartLayout.axisLayout);
                chart.drawXYChart(groupPanels, chartLayout);
                break;
            case "gauge":
                chart.drawGaugeChart(chartPanel, chartLayout);
                break;
            case "funnel":
                chart.drawFunnelChart(chartPanel, chartLayout);
                break;
            case "waterfall":
                chart.drawWaterfall(chartPanel, chartLayout);
                break;
            case "boxplot":
                chart.drawBoxPlot(chartPanel, chartLayout);
                break;
            case "histogram":
                chart.drawHistogram(chartPanel, chartLayout);
                break;
            case "treemap":
                chart.drawTreemap(chartPanel, chartLayout);
                break;
            case "circlepack2":
                chart.drawCirclePack(chartPanel, chartLayout);
                break;
            case "heatmap":
                groupPanels = chart.createBLAScrollXYPanels(chartPanel, chartLayout.chartSize, chartLayout);
                chart.drawHeatmap(groupPanels, chartLayout);
                break;
            case "pareto":
                chart.drawPareto(chartPanel, chartLayout);
                break;
            case "control":
                chart.drawControl(chartPanel, chartLayout);
                break;
            case "stock":
                chart.drawStockChart(chartPanel, chartLayout);
                break;
            case "gantt":
                chart.drawGanttChart(chartPanel, chartLayout);
                break;
            case "radar":
                chart.drawRadarChart(chartPanel, undefined, chartLayout);
                break;
            case "polar":
                chart.drawPolarChart(chartPanel, undefined, chartLayout);
                break;
            case "bar3d":
            case "area3d":
            case "surface3d":
                chart.draw3dChart(chartPanel, chartLayout);
                break;
            case "map":
                chart.drawMap(chartPanel, chartLayout);
                break;
            case "mekko":
                chart.drawMekko(chartPanel, chartLayout);
                break;
            case "parabox":
                chart.drawParabox(chartPanel, chartLayout);
                break;
            case "tagcloud":
                chart.drawTagCloud(chartPanel, chartLayout);
                break;
            case "streamgraph":
                chart.drawStreamGraph(chartPanel, chartLayout);
                break;
            case "matrix":
                chart.drawMatrixChart(chartPanel, chartLayout);
                break;
            case "datagrid":
                chart.drawDataGridChart(chartPanel, chartLayout);
                break;
            case "pictogram":
                chart.drawPictogram(chartPanel, chartLayout);
                break;
            case "simplelabel":
                chart.drawSimpleLabelChart(chartPanel);
                break;
            case "legend":
                break
            }
        var dx = overallLayout.chartFrame.x + overallLayout.chartFrame.width / 2;
        var maxSize = overallLayout.titleMaxLength;
        chart.drawTitle(rootPanel, chart.title, "title", dx, overallLayout.title.top, null, null, maxSize, overallLayout.title);
        chart.drawTitle(rootPanel, chart.subtitle, "subtitle", dx, overallLayout.subtitle.top, null, null, maxSize, overallLayout.subtitle);
        chart.drawTitle(rootPanel, chart.footnote, "footnote", dx, overallLayout.footnote.bottom, "bottom", null, maxSize, overallLayout.footnote);
        chart.drawLegend(rootPanel, overallLayout.legend);
        chart.drawAnnotations(rootPanel, overallLayout);
        chart.drawNarrativeText(rootPanel, overallLayout);
        chart.drawDataPageSlider(chart.dataPageSlider, rootPanel, overallLayout);
        var version = (tdgchart.version || "???") + "." + (tdgchart.minorVersion || "???");
        if (chart.showDebugString || chart.showVersion) {
            var info1 = [getUserAgent(), "Moonbeam: " + version];
            var info2 = [chart.chartType + " chart", chart.width + "px x " + chart.height + "px", getTime()];
            rootPanel.add(pv.Label).text(chart.showDebugString ? info1.join(", ") : "Moonbeam: " + version).font("bold 10pt Sans-Serif").textStyle("darkred").left(0).bottom(chart.showDebugString ? 15 : 0);
            if (chart.showDebugString)
                rootPanel.add(pv.Label).text(info2.join(", ")).font("bold 10pt Sans-Serif").textStyle("darkred").left(0).bottom(0)
        }
        chart.checkDrawTime();
        rootPanel.canvas(chart.documentRoot).render();
        chart.cache.get("tdgscene").render();
        if (chart._postRenderCallbacks && chart._postRenderCallbacks.length)
            chart._postRenderCallbacks.forEach(function(cb) {
                cb.call(chart)
            });
        chart.postProcessReorder();
        var animationResult;
        if (!tdgchart.extensionManager.isExtension(chart.chartType)) {
            if (chart.filter && chart.filter.enabled)
                chart.addFilter();
            if (chart.htmlToolTip.enabled)
                chart.addHTMLToolTips();
            if (chart.accessibility.navigation.enabled)
                chart.doAccessibilityNavigation();
            chart.rearrangeDataLabels(chartLayout.chartSize);
            chart.doMouseHover();
            chart.processEvents(chartPanel);
            if (!chart.isLeaflet())
                chart.processSelection(overallLayout);
            animationResult = chart.drawIntroAnimation();
            if (chart._selList != null)
                chart.selectData(chart._selList)
        }
        if (Array.isArray(chart.data) && chart.data.length && (chart.swapData || chart.swapDataAndLabels) && chart.chartType !== "treemap")
            chart.data = tdg.transpose(chart.data);
        tdgchart.clearLabelDiv();
        chart.handleRenderComplete(animationResult);
        if (chart.chartType === "map" && chart.mapProperties.engine === "leaflet")
            chart.drawLeafletMap(chartPanel, overallLayout);
        if (tdgchart.extensionManager.isExtension(chart.chartType))
            tdgchart.extensionManager.drawExtensionInternal(chart, chartPanel, chart.documentRoot);
        if (chart._postProcessCallbacks && chart._postProcessCallbacks.length)
            chart._postProcessCallbacks.forEach(function(cb) {
                cb.call(chart)
            });
        chart.cache.restoreCachedProperties();
        return chart
    }
    tdgchart.prototype.addChartFrame = function(panel) {
        var chart = this;
        if (chart.chartType !== "matrix") {
            chart._computedChartFrame = panel.computedSize;
            addFillPanel(chart, panel, chart.chartFrame.fill.color, chart.chartFrame.border, chart.chartFrame.shadow, "chartFrame", true)
        }
    }
    ;
    function getEdgeColors(chart, cdepth, fill) {
        var edgeColors = {
            needToDraw: false,
            leftFill: "transparent",
            bottomFill: "transparent"
        };
        if (cdepth) {
            var leftFillColor = chart.chartFrame.leftedge && chart.chartFrame.leftedge.fill ? chart.chartFrame.leftedge.fill.color : null;
            if (!leftFillColor || leftFillColor === "auto")
                leftFillColor = pv.tdgScene.adjcolor(fill, 1.5);
            if (leftFillColor !== "transparent") {
                edgeColors.needToDraw = true;
                edgeColors.leftFill = leftFillColor
            }
            var bottomFillColor = chart.chartFrame.bottomedge && chart.chartFrame.bottomedge.fill ? chart.chartFrame.bottomedge.fill.color : null;
            if (!bottomFillColor || bottomFillColor === "auto")
                bottomFillColor = pv.tdgScene.adjcolor(fill, .7);
            if (bottomFillColor !== "transparent") {
                edgeColors.needToDraw = true;
                edgeColors.bottomFill = bottomFillColor
            }
        }
        return edgeColors
    }
    function addFillPanel(chart, panel, fill, border, shadow, className, useDepth) {
        var cdepth = useDepth && chart.computeddepth25d();
        var edgeColors = getEdgeColors(chart, cdepth, fill);
        if (fill === "transparent" && (border.color === "transparent" || border.width === 0) && !edgeColors.needToDraw)
            return;
        className = className || "UNKNOWN";
        var fillPanel = panel.add(pv.Bar).antialias(false).fillStyle(fill).shadow(shadow).className(className);
        if (!panel.computedSize)
            return;
        if (border.width > 0) {
            var borderWidth = className === "background" ? border.width * 2 : border.width;
            panel.computedSize.innerBorderSize = borderWidth / 2;
            fillPanel.lineWidth(borderWidth).strokeStyle(border.color).dashStyle(border.dash)
        }
        if (cdepth) {
            fillPanel.left(cdepth).bottom(cdepth).right(-cdepth).top(-cdepth);
            panel.add(pv.Area).data([[0, 0], [cdepth, -cdepth]]).bottom(function(d) {
                return d[0]
            }).height(panel.computedSize.height).left(function() {
                return this.index * cdepth
            }).antialias(false).fillStyle(edgeColors.leftFill).className("fillPanel").lineStyle(border);
            panel.add(pv.Area).data([[0, 0], [cdepth, -cdepth]]).left(function(d) {
                return d[0]
            }).width(panel.computedSize.width).bottom(function() {
                return this.index * cdepth
            }).antialias(false).fillStyle(edgeColors.bottomFill).className("fillPanel").lineStyle(border)
        }
    }
    tdgchart.prototype.redraw = function() {
        var chart = this;
        if (chart.documentRoot == null)
            chart.errorMessage = new tdgchart.InternalError("chart.draw() must be called with a valid HTML element before calling chart.redraw();");
        chart.draw(chart.documentRoot)
    }
    ;
    tdgchart.prototype.draw = function(where) {
        var chart = this;
        if (chart.hasOwnProperty("_isDrawing") && chart._isDrawing)
            return;
        if (where == null) {
            if (chart.containerID == null)
                chart.errorMessage = new tdgchart.InternalError("An HTML element to render this chart must be specified, either as an argument to draw, or by setting chart.containerID");
            where = chart.containerID
        }
        var div;
        if (typeof where === "object" && where instanceof Node) {
            div = where;
            chart.documentRoot = where.id || "INVALID CHART ROOT ID"
        } else if (typeof where === "string") {
            div = document.getElementById(where);
            chart.documentRoot = where
        }
        if (div) {
            if (!div.chart)
                if (typeof aptrinsic !== "undefined") {
                    var startTime = (new Date).getTime();
                    chart.startTime = startTime;
                    window.onunload = function() {
                        var duration = 0;
                        if (chart.startTime) {
                            var endTime = (new Date).getTime();
                            duration = (endTime - chart.startTime) / 1E3
                        }
                        var label = chart.chartType;
                        if (chart.agnosticSettings && chart.agnosticSettings.chartTypeFullName)
                            label = chart.agnosticSettings.chartTypeFullName;
                        if (chart.chartType === "com.esri.map" && chart.extensions["com.esri.map"]) {
                            var mapInfo = chart.extensions["com.esri.map"];
                            var mapLayers = mapInfo._activeLayers;
                            var mapLayer = "";
                            var featureLayer = "";
                            for (var i = 0; i < mapLayers.length; i++)
                                if (mapLayers[i].layerType === "featurelayer") {
                                    if (featureLayer.length > 0)
                                        featureLayer += ",";
                                    featureLayer += mapLayers[i].title
                                } else {
                                    if (mapLayer.length > 0)
                                        mapLayer += ",";
                                    mapLayer += mapLayers[i].title
                                }
                            var baseMap = mapInfo.baseLayer.basemap;
                            if (mapInfo.baseMapInfo.customBaseMaps && mapInfo.baseMapInfo.customBaseMaps[0])
                                baseMap = mapInfo.baseMapInfo.customBaseMaps[0].title;
                            aptrinsic("track", "chart", {
                                type: chart.chartType,
                                label: label,
                                duration: duration,
                                mapLayers: mapLayer,
                                featureLayers: featureLayer,
                                baseMap: baseMap
                            })
                        } else
                            aptrinsic("track", "chart", {
                                type: chart.chartType,
                                label: label,
                                duration: duration
                            })
                    }
                    .bind(this)
                }
            div.chart = chart
        } else if (!chart.errorMessage && !chart.errorStatus)
            chart.errorMessage = new tdgchart.InternalError(tdg.formatString('{0}: "{1}"', tdgchart.translations.NODIVERROR, where));
        if (chart.errorStatus)
            chart.errorMessage = chart.errorStatus;
        if (chart.errorMessage) {
            chart.drawError(where, chart.errorMessage, true);
            return
        }
        if (chart.dataStream.enabled && chart.dataStream.url)
            chart.loadDataStream();
        else {
            chart._isDrawing = true;
            drawInternalWithExtensions(chart);
            chart._isDrawing = false
        }
    }
    ;
    tdgchart.prototype.destroy = function() {
        this.globalMouseRemove()
    }
    ;
    tdgchart.prototype.checkDrawTime = function() {
        var chart = this
          , timeout = chart.drawTimeout;
        if (typeof timeout === "number" && timeout > 0) {
            var start = chart.cache.get("drawStartTime");
            var now = Date.now();
            if (now - start > timeout)
                throw tdgchart.translations.TooMuchRenderTimeError;
        }
    }
    ;
    function drawInternalWithExtensions(chart) {
        var mgr = tdgchart.extensionManager;
        if (!mgr.isExtensionListLoaded()) {
            mgr.registerEvent("extensionListLoad", tdg.partial(drawInternalWithExtensions, [chart]));
            return
        }
        if (mgr.isExtension(chart.chartType))
            mgr.drawExtension(chart, tdg.partial(drawInternal, [chart]));
        else
            chart.errorHandlerWrapper(drawInternal, [chart])
    }
    tdgchart.prototype.needAccessibility = function() {
        var chart = this;
        return !tdg.isEmpty(chart.get("accessibility.title"))
    }
    ;
    tdgchart.scriptConfig = {
        extensionsDir: "extensions"
    };
    tdgchart.getScriptBasePath = function() {
        var path;
        var hasTdgScriptPath = typeof window !== "undefined" && window.tdgScriptPath;
        if (!hasTdgScriptPath && tdgchart.scriptConfig.webappContext) {
            path = tdgchart.scriptConfig.webappContext + "/";
            if (tdgchart.scriptConfig.htmlKey)
                path += tdgchart.scriptConfig.htmlKey + "/"
        } else {
            var scriptPath = tdgchart.getScriptPath();
            var i = scriptPath.indexOf("/tdg");
            path = i >= 0 ? scriptPath.substring(0, i + 1) : scriptPath
        }
        return path
    }
    ;
    tdgchart.getExtensionsPath = function() {
        // var path = tdgchart.getScriptPath();
        // path += tdgchart.scriptConfig.extensionsDir + "/";
        // if (tdgchart.scriptConfig.extensionKey && path.indexOf("/" + tdgchart.scriptConfig.extensionKey + "/") == -1)
        //     path += tdgchart.scriptConfig.extensionKey + "/";
        // return path
        return ""
    }
    ;
    tdgchart.getScriptPath = typeof window !== "undefined" && window.tdgScriptPath ? window.tdgScriptPath : function() {
        if (tdgchart.scriptConfig.webappContext) {
            var path = tdgchart.scriptConfig.webappContext;
            path += "/tdg/jschart/distribution/";
            if (tdgchart.scriptConfig.htmlKey)
                path += tdgchart.scriptConfig.htmlKey + "/";
            return path
        }
        if (!document.scripts)
            return "";
        var i, src, match;
        for (i = 0; i < document.scripts.length; i++) {
            src = document.scripts[i].getAttribute("src");
            if (src && src.includes("tdgchart-min.js")) {
                match = src.match(/(.*\/).*tdgchart-min.js/);
                if (match && match[1])
                    return match[1]
            }
        }
        for (i = 0; i < document.scripts.length; i++) {
            src = document.scripts[i].getAttribute("src");
            if (src) {
                match = src.match(/(.*\/).*tdgchart/);
                if (match && match[1])
                    return match[1]
            }
        }
        return ""
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    function deletePropsFromObj(props, obj) {
        for (var prop in props)
            if (props.hasOwnProperty(prop) && obj.hasOwnProperty(prop) && prop !== "series")
                if (typeof props[prop] === "object")
                    deletePropsFromObj(props[prop], obj[prop]);
                else
                    obj[prop] = undefined
    }
    function resetSeriesProperties(src, seriesArray) {
        var i, len;
        for (i = 0,
        len = seriesArray.length; i < len; i++)
            deletePropsFromObj(src, seriesArray[i]);
        for (i = 0,
        len = seriesArray.length; i < len; i++)
            if (seriesArray[i].series === "all") {
                src.series = "all";
                extendPropSet(src, seriesArray[i]);
                break
            }
    }
    function augmentSeriesArray(src, dest) {
        if (src[0] && src[0].series === "clear")
            return tdg.arrayDeepCopy(src.slice(1));
        dest = dest || [];
        var haveMatch = false;
        for (var i = 0; i < src.length; i++) {
            if (!src[i])
                continue;
            if (src[i].series === "reset")
                resetSeriesProperties(src[i], dest);
            else {
                for (var j = 0; j < dest.length; j++)
                    if (src[i].series === dest[j].series && src[i].group === dest[j].group && src[i].axis === dest[j].axis && src[i].row === dest[j].row && src[i].col === dest[j].col) {
                        dest[j] = extendPropSet(src[i], dest[j]);
                        haveMatch = true;
                        break
                    }
                if (!haveMatch)
                    dest.push(extendPropSet(src[i], {}));
                haveMatch = false
            }
        }
        return dest
    }
    function augmentEventsArray(src, dest) {
        if (src[0] && src[0].namespace === "clear")
            return tdg.arrayDeepCopy(src.slice(1));
        dest = dest || [];
        src = src.filter(function(e) {
            return !!e
        });
        var srcNamespaces = src.map(function(e) {
            return e.namespace
        });
        dest = dest.filter(function(e) {
            return !!e && srcNamespaces.indexOf(e.namespace) == -1
        });
        dest = dest.concat(tdg.arrayDeepCopy(src));
        return dest
    }
    function extendPropSet(src, dest) {
        var prop;
        for (prop in src)
            if (src[prop] && src[prop].constructor === Object) {
                if (dest[prop] && dest[prop].constructor !== Object)
                    dest[prop] = {};
                if (prop === "axisList" && tdg.isEmpty(src[prop]))
                    dest[prop] = {};
                dest[prop] = dest[prop] || {};
                extendPropSet(src[prop], dest[prop])
            } else if (src[prop] && Array.isArray(src[prop]))
                if (prop === "series" && dest[prop])
                    dest[prop] = augmentSeriesArray(src[prop], dest[prop]);
                else if (prop === "events" && dest[prop])
                    dest[prop] = augmentEventsArray(src[prop], dest[prop]);
                else
                    dest[prop] = tdg.arrayDeepCopy(src[prop]);
            else if (prop !== "cache")
                dest[prop] = src[prop] === null ? undefined : src[prop];
        return dest
    }
    tdgchart.prototype.set = function(properties) {
        extendPropSet(properties, this);
        return this
    }
    ;
    tdgchart.prototype.mergeObjectsEx = function(src, dest) {
        extendPropSet(src, dest);
        return dest
    }
    ;
    tdgchart.prototype.get = function(property, defaultValue) {
        var res = tdg.flattenProperty(property, this);
        return res == null ? defaultValue : res
    }
    ;
    tdgchart.prototype.getPadding = function(element, direction) {
        function getPad(direction, padObj) {
            switch (direction) {
            case "left":
                return padObj.left;
            case "right":
                return padObj.right;
            case "top":
                return padObj.top;
            case "bottom":
                return padObj.bottom;
            case "height":
                return padObj.top + padObj.bottom;
            case "aveVert":
                return (padObj.top + padObj.bottom) / 2;
            case "maxVert":
                return Math.max(padObj.top, padObj.bottom);
            case "width":
                return padObj.left + padObj.right;
            case "aveHorz":
                return (padObj.left + padObj.right) / 2;
            case "maxHorz":
                return Math.max(padObj.left, padObj.right)
            }
            return 0
        }
        if (this.labelPadding == null)
            return 0;
        if (typeof this.labelPadding === "number") {
            var p = this.labelPadding;
            if (direction === "width" || direction === "height")
                p *= 2;
            return p
        }
        if (element === "frame")
            return getPad(direction, this.labelPadding.frame);
        if (element === "label")
            return getPad(direction, this.labelPadding.label);
        return 0
    }
    ;
    tdgchart.prototype.stringToProperty = function(s) {
        return tdg.get(s.replace("chart.", ""), this)
    }
    ;
    tdgchart.prototype.convertToStaticChart = function() {
        var chart = this;
        chart.enableBehavior("all", false);
        chart.cache.setProperty("matrixProperties.minCellSize", {
            width: 0,
            height: 0
        });
        chart.cache.setProperty("legend.scroll.enabled", false);
        chart.cache.setProperty("legend.dock.enabled", false);
        chart.cache.setProperty("pieProperties.explodeClick.enabled", false);
        chart.cache.setProperty("xaxis.scroll.enabled", false);
        chart.cache.setProperty("xaxis.labelLayout.scroll", false);
        chart.cache.setProperty("zaxis.scroll.enabled", false);
        chart.cache.setProperty("zaxis.labelLayout.scroll", false);
        chart.cache.setProperty("dataSelection.enabled", false);
        chart.cache.setProperty("previewSelection.enabled", false);
        chart.cache.setProperty("htmlToolTip.enabled", false);
        chart.cache.setProperty("mouseOverIndicator.enabled", false);
        chart.cache.setProperty("introAnimation.enabled", false);
        chart.cache.setProperty("eventDispatcher.events", []);
        var cleanupCallbacks = !chart._callbackList ? [] : chart._callbackList.filter(function(cb) {
            return typeof cb.userInfo === "object" && cb.userInfo._staticChartPreserveEvent ? true : false
        });
        chart.cache.setProperty("_callbackList", cleanupCallbacks)
    }
    ;
    var seriesIDs = ["series", "group", "row", "col", "axis", "page"];
    function addMetadata(obj, seriesEntry) {
        if (obj != null && seriesEntry != null)
            seriesIDs.forEach(function(prop) {
                if (seriesEntry[prop] != null)
                    obj[prop] = seriesEntry[prop]
            })
    }
    var ignoreProps = ["cache", "extensions", "_internalData", "_sizeLegendMarkersInfo"];
    function copyProps(before, after, includeSeriesIDs) {
        var prop, beforeRes, afterRes;
        function copyOneProp(prop, includeSeriesIDs) {
            var res = copyProps(before[prop], after[prop], includeSeriesIDs);
            if (res != null) {
                beforeRes[prop] = res.before;
                afterRes[prop] = res.after
            }
        }
        if (before === after)
            return null;
        if (typeof before !== typeof after || before == null && after != null || before != null && after == null)
            return {
                before: before,
                after: after
            };
        if (Array.isArray(before)) {
            beforeRes = [];
            afterRes = [];
            var maxLength = Math.max((before || []).length, after.length);
            for (var i = 0; i < maxLength; i++) {
                copyOneProp(i);
                if (includeSeriesIDs) {
                    addMetadata(beforeRes[i], before[i]);
                    addMetadata(afterRes[i], after[i])
                }
            }
        } else if (typeof before === "object") {
            beforeRes = {};
            afterRes = {};
            for (prop in before)
                if (after.hasOwnProperty(prop) && !ignoreProps.includes(prop)) {
                    var includeIDs = prop === "series" && Array.isArray(before[prop]);
                    copyOneProp(prop, includeIDs)
                }
            for (prop in after)
                if (!before.hasOwnProperty(prop))
                    afterRes[prop] = after[prop]
        } else
            return {
                before: before,
                after: after
            };
        if (tdg.isEmpty(beforeRes) && tdg.isEmpty(afterRes))
            return null;
        if (tdg.isEmpty(beforeRes))
            beforeRes = null;
        if (tdg.isEmpty(afterRes))
            afterRes = null;
        return {
            before: beforeRes,
            after: afterRes
        }
    }
    tdgchart.prototype.toJSON = function() {
        var markState = {};
        return function toJSONClosure(config) {
            var chart = this, newState, res;
            config = config || {};
            if (typeof config.setMark === "string")
                markState[config.setMark] = tdg.clone(chart);
            else if (typeof config.getMark === "string") {
                if (markState.hasOwnProperty(config.getMark))
                    newState = markState[config.getMark]
            } else
                newState = tdgchart.defaultProperties;
            if (newState) {
                res = copyProps(newState, chart);
                return config.includeBeforeAfter || res == null ? res : res.after
            }
            return null
        }
    }();
    tdgchart.toIBXPropertySheet = tdgchart.prototype.toIBXPropertySheet = function(json) {
        function resolveGlobalAnnotation(annotation, annotations) {
            if (typeof annotation === "string" && annotation.startsWith("global"))
                annotation = tdg.get(annotation, annotations);
            return annotation
        }
        function addObject(properties, annotations, translations, target, level, parentPropName) {
            annotations = annotations || {};
            var propertyName, annotation, propertyValue, translation;
            var orderedProperties = []
              , i = 0;
            for (propertyName in properties) {
                if (!properties.hasOwnProperty(propertyName) || !annotations.hasOwnProperty(propertyName))
                    continue;
                annotation = resolveGlobalAnnotation(annotations[propertyName], annotations);
                if (annotation.private)
                    continue;
                orderedProperties.push({
                    name: propertyName,
                    annotation: annotation,
                    bOrder: i++
                })
            }
            orderedProperties = orderedProperties.sort(function(a, b) {
                if (a.annotation.displayOrder == undefined && b.annotation.displayOrder == undefined)
                    return b.bOrder - a.bOrder;
                if (b.annotation.displayOrder == undefined)
                    return -1;
                if (a.annotation.displayOrder == undefined)
                    return 1;
                return a.annotation.displayOrder - b.annotation.displayOrder
            });
            for (i = 0; i < orderedProperties.length; i++) {
                var p = orderedProperties[i];
                translation = translations[p.name] || {};
                var fullName = parentPropName ? parentPropName + "." + p.name : p.name;
                addOneProperty(fullName, p.annotation, properties[p.name], translation, target, level)
            }
        }
        function resolveTranslation(translation) {
            if (typeof translation === "string")
                return translation;
            else if (translation && typeof translation._translation === "string")
                return translation._translation;
            return null
        }
        function addOneProperty(propertyName, annotation, propertyValue, translation, target, level) {
            var localAnnotation = annotation;
            var annotationParams = {};
            var displayName = resolveTranslation(translation);
            if (!displayName) {
                displayName = propertyName.split(".");
                displayName = displayName[displayName.length - 1]
            }
            var newEntry = {
                displayName: displayName,
                displayValue: propertyValue,
                nameTip: translation._tooltip || "",
                valueTip: translation._valueTooltip || "",
                name: propertyName,
                value: propertyValue,
                expanded: level === 1
            };
            if (typeof annotation === "object" && annotation.hasOwnProperty("typeAnnotation"))
                if (annotation.typeAnnotation === "str")
                    if (Array.isArray(annotation.stringValues) && annotation.stringValues.length) {
                        var stringTranslations = translation._stringValues || annotation.stringValues;
                        annotationParams.stringValues = annotation.stringValues.map(function(el, idx) {
                            return {
                                displayValue: stringTranslations[idx] || el,
                                value: el
                            }
                        });
                        localAnnotation = "strList"
                    } else
                        localAnnotation = "str";
                else if (annotation.typeAnnotation === "number")
                    if (Array.isArray(annotation.numericRange) && annotation.numericRange.length === 2) {
                        annotationParams.numericRange = annotation.numericRange;
                        annotationParams.numericStep = annotation.numericStep;
                        annotationParams.uiType = annotation.uiType || "slider";
                        localAnnotation = "numericRange"
                    } else
                        localAnnotation = "number";
            if (typeof localAnnotation === "string")
                if (localAnnotation === "str") {
                    newEntry.dataType = "string";
                    newEntry.uiType = "text"
                } else if (localAnnotation === "strList") {
                    newEntry.dataType = "string";
                    newEntry.uiType = "select";
                    newEntry.multiSelect = false;
                    newEntry.values = annotationParams.stringValues
                } else if (localAnnotation === "bool") {
                    newEntry.displayValue = "";
                    newEntry.dataType = "bool";
                    newEntry.uiType = "checkbox"
                } else if (localAnnotation === "number") {
                    newEntry.valueMin = -1E6;
                    newEntry.valueMax = 1E6;
                    newEntry.step = 1;
                    newEntry.dataType = "number";
                    newEntry.uiType = "spinner"
                } else if (localAnnotation === "numericRange") {
                    newEntry.dataType = "number";
                    newEntry.uiType = annotationParams.uiType;
                    newEntry.valueMin = annotationParams.numericRange[0];
                    newEntry.valueMax = annotationParams.numericRange[1];
                    newEntry.step = annotationParams.numericStep
                } else if (localAnnotation === "color") {
                    var color = tdgchart.util.color(propertyValue);
                    newEntry.value = {
                        color: color.toHex(),
                        opacity: color.opacity
                    };
                    newEntry.displayValue = "";
                    newEntry.dataType = "color";
                    newEntry.uiType = "colorpicker";
                    newEntry.expanded = false
                } else {
                    if (localAnnotation === "object" || localAnnotation === "json")
                        return
                }
            else if (typeof localAnnotation === "object") {
                newEntry.displayValue = "";
                newEntry.value = "";
                newEntry.dataType = "";
                newEntry.uiType = "label";
                newEntry.props = [];
                addObject(propertyValue, localAnnotation, translation, newEntry.props, level + 1, propertyName)
            }
            target.push(newEntry)
        }
        var locale = (document.documentElement.getAttribute("lang") || "en").split("-")[0];
        var translations = json.translations || {};
        translations = translations[locale] || translations["en"] || {};
        translations = translations.properties || {};
        var res = [];
        addObject(json.properties, json.propertyAnnotations, translations, res, 1);
        res = res.filter(function(el) {
            return el != null
        });
        return res
    }
}
)();
(function() {
    tdgchart.prototype.setSampleData = setSampleData;
    function setSampleData() {
        var chart = this;
        switch (chart.chartType) {
        case "legend":
            chart.data = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
            break;
        case "map":
            if (chart.mapProperties.engine === "leaflet")
                chart.data = [[]];
            else {
                chart.mapProperties.map = "usall";
                chart.data = [[1, 2, 5, 4, 6, 7, 4, 3, 1, 3, 1, 2, 5, 4, 6, 7, 4, 3, 1, 3, 1, 2, 5, 4, 6, 7, 4, 3, 1, 3, 1, 2, 5, 4, 6, 7, 4, 3, 1, 3, 1, 2, 5, 4, 6, 7, 4, 3, 1, 3]]
            }
            break;
        case "treemap":
            chart.data = {
                West: {
                    doodads: 10,
                    widgets: 20,
                    thingies: 30
                },
                East: {
                    doodads: 10,
                    widgets: 20,
                    thingies: 30
                },
                North: {
                    doodads: 10,
                    widgets: 20,
                    thingies: 30
                },
                South: {
                    doodads: 10,
                    widgets: 20,
                    thingies: 30
                }
            };
            break;
        case "histogram":
            chart.data = [[1, 2, 1, 4, 1, 2, 3, 1, 4, 1, 2, 4, 1, 1, 1, 2, 3, 1, 2, 5, 5, 5]];
            break;
        case "waterfall":
            chart.data = [[3, 1, -2, 3]];
            break;
        case "pareto":
            chart.data = [[1, 2, 5, 7, 3]];
            break;
        case "sparkline":
            chart.data = [[1, 4, 2, 6, 1, 2, 3]];
            break;
        case "bullet":
            chart.data = [[5, 1, 4, 7]];
            break;
        case "boxplot":
            chart.data = [[[1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7]], [[1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7]]];
            break;
        case "stock":
            chart.data = [[[5, 2, 3, 4], [8, 2, 4, 5], [6, 2, 5, 3]], [[4, 1, 3, 2], [7, 4, 5, 6], [5, 1, 2, 4]]];
            break;
        case "bubble":
            chart.data = [[[1, 1, 1], [2, 2, 2], [3, 3, 3]], [[2, 1, 1], [2, 3, 2], [3, 1, 3]]];
            break;
        case "polar":
        case "scatter":
            chart.data = [[[1, 1], [2, 2], [3, 3]], [[1, 3], [2, 1], [3, 2]]];
            break;
        case "gantt":
            chart.data = [[[1, 2, 0], [2, 3, 1], [3, 4, 2]], [[1, 3], [2, 4], [3, 5]]];
            break;
        case "pie":
            chart.data = [[1, 2, 3, 5], [2, 3, 4, 6]];
            break;
        case "funnel":
            chart.data = [[1, 2, 3, 4], [4, 5, 6, 7]];
            break;
        case "gauge":
            chart.data = [[1, 2, 3], [4, 5, 6]];
            break;
        case "parabox":
            chart.data = [[1, "A", 5, 1, 3], [7, "C", 1, 3, 1], [5, "B", 7, 5, 4], [2, "A", 1, 3, 6], [1, "A", 7, 7, 8], [1, "B", 7, 3, 8]];
            break;
        case "bar3d":
        case "area3d":
        case "surface3d":
        case "streamgraph":
        case "mekko":
        case "radar":
        case "bar":
        case "line":
        case "area":
        default:
            chart.data = [[1, 2, 3], [3, 4, 5]];
            break
        }
    }
}
)();
(function() {
    var translationLookupURLgeneric = "rb/json/com.ibi.intl.moonbeam.moonbeam.res";
    var translationLookupURLlang = "rb/json/{{LANG}}/com.ibi.intl.moonbeam.moonbeam.res";
    function getTranslationLang() {
        var lang = tdgchart.d3.select("html").attr("lang");
        if (lang)
            return lang;
        if (window && window.navigator)
            if (window.navigator.languages && window.navigator.languages.length > 0)
                return window.navigator.languages[0];
        return undefined
    }
    tdgchart.translations = {
        SERIES: "Series",
        GROUP: "Group",
        TOTAL: "Total",
        OTHER: "Other",
        SIZE: "Size",
        COLOR: "Color",
        VALUE: "Value",
        MIN: "Minimum",
        MAX: "Maximum",
        LOWER: "Lower",
        UPPER: "Upper",
        MEDIAN: "Median",
        MEAN: "Mean",
        MODE: "Mode",
        POINTCOUNT: "Points",
        MIN_WHISKER: "Lower Whisker",
        MAX_WHISKER: "Upper Whisker",
        QUARTILE_1: "Q1",
        QUARTILE_2: "Q2",
        QUARTILE_3: "Q3",
        OUTLIER: "Outlier",
        PERCENTOFTOTAL: "{0} of {1}",
        LONGITUDE: "Longitude",
        LATITUDE: "Latitude",
        TITLE: "Chart Title",
        XTITLE: "X Axis Title",
        YTITLE: "Y Axis Title",
        Y2TITLE: "Y2 Axis Title",
        ZTITLE: "Z Axis Title",
        COLORTITLE: "Color Axis Title",
        PAN: "Pan",
        SELECTION: "Selection",
        UNKNOWN: "Unknown",
        ERROR: "Internal Error",
        USERERROR: "Configuration Error",
        NODIVERROR: "The HTML element to render the chart into does not exist",
        ReadText: "Read Text",
        StopReadText: "Stop Reading",
        decimalSeparator: ".",
        thousandSeparator: ",",
        currencySymbol: "$",
        thousandCompression: "K",
        millionCompression: "M",
        billionCompression: "B",
        trillionCompression: "T",
        Layers: "Layers",
        Switch_Basemap: "Basemaps",
        FailedToLoadError: "Failed to load",
        NoBundledLibError: "Failed to load bundled extension library",
        ExtensionLoadError: "Failed to load external extension library",
        MapLoadError: "Please check your connection to and from Mapping services or check the path to the extension as it may not be valid",
        MapServicesError: "Connection to Map Services were lost, please try again later",
        TooMuchDataError: "Too many data points to draw chart",
        TooMuchRenderTimeError: "Chart took too long to draw",
        NarrativeDisabled: "Narrative Text is disabled",
        NarrativeNoURL: "No Narrative Text URL specified",
        NarrativeErrorConnect: "Unable to connect to Narrative Text server at",
        NarrativeAuthFailed: "Unable to connect to Narrative Text server. Authentication failed.",
        NarrativeToMuchData: "Too much data to perform Narrative Text analysis.",
        NarrativeToMuchData2Dim: "Too much data; Narrative Text is limited to 2 dimensions.",
        NarrativeInsufficientData: "Insufficient data to perform Narrative Text analysis.",
        NarrativeMatrixUnsupported: "Cannot generate Narrative Text in Matrix mode.",
        NarrativeErrorRetrieve: "Unable to retrieve Narrative Text",
        NarrativeErrorParse: "Failed to parse narrative text response",
        NarrativeErrorRequest: "Unable to create Narrative Text request",
        NarrativeInvalidRequest: "Invalid Request",
        NarrativeProperty: "Property",
        NarrativeError: "Error",
        NarrativeRetrieving: "Retrieving Narrative Text..."
    };
    function convertLocale(locale) {
        return {
            ".": locale.decimalSeparator || ".",
            ",": locale.thousandSeparator || ",",
            $: locale.currencySymbol || "$",
            K: locale.thousandCompression || "K",
            M: locale.millionCompression || "M",
            B: locale.billionCompression || "B",
            T: locale.trillionCompression || "T"
        }
    }
    tdgchart.getTranslationLocaleLookup = function() {
        return convertLocale(tdgchart.translations)
    }
    ;
    tdgchart.getLocaleLookup = function(locale) {
        return convertLocale(locale)
    }
    ;
    function loadTranslations() {
        var path = tdgchart.getScriptPath();
        var tdgidx = path.indexOf("tdg");
        if (tdgidx >= 0) {
            path = path.slice(0, tdgidx);
            var lang = getTranslationLang();
            var url;
            if (lang)
                url = path + translationLookupURLlang.replace("{{LANG}}", lang);
            else
                url = path + translationLookupURLgeneric;
            tdgchart.util.ajax(url, {
                asJSON: true,
                async: true,
                onLoad: function(translationJSON) {
                    for (var key in translationJSON)
                        if (translationJSON.hasOwnProperty(key))
                            tdgchart.translations[key] = translationJSON[key]
                }
            })
        }
    }
    if (typeof window !== "undefined")
        loadTranslations()
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.postProcessReorder = function() {
        var chart = this;
        if (chart.depth25d())
            switch (chart.chartType) {
            case "bar":
            case "mekko":
            case "histogram":
            case "pareto":
                reorderBar25dScene(chart);
                break;
            case "gantt":
            case "waterfall":
                reorder_bar25d(chart);
                break;
            case "pie":
                reorder_pie25d(chart);
                break
            }
    }
    ;
    function get_translate(element) {
        var t = {
            x: 0,
            y: 0
        };
        if (element.transform.baseVal.numberOfItems > 0) {
            t.x = element.transform.baseVal.getItem(0).matrix.e;
            t.y = element.transform.baseVal.getItem(0).matrix.f
        }
        return t
    }
    function reorder_shift_labels(l) {
        var dx = parseFloat(l.getAttribute("tdg:dx"));
        var dy = parseFloat(l.getAttribute("tdg:dy"));
        if (dx != null && dy != null && !(dx === 0 && dy === 0)) {
            var labels = l.parentNode.nodeName === "a" ? l.parentNode.parentNode.nextSibling : l.parentNode.nextSibling;
            if (labels && !tdgchart.d3.select(labels).select("text").empty())
                labels.setAttribute("transform", "translate(" + dx + "," + dy + ")")
        }
    }
    function reorder_pie25d(chart) {
        function reposition_labels() {
            var pcenter = parseFloat(this.getAttribute("tdg:center"));
            var pskew = parseFloat(this.getAttribute("tdg:skew"));
            if (pskew) {
                var labels = tdgchart.d3.select(this.parentNode.parentNode).selectAll("text");
                labels.each(function() {
                    var curpos = get_translate(this);
                    var newypos = curpos.y - (curpos.y - pcenter) * pskew;
                    this.setAttribute("transform", "translate(" + curpos.x + "," + newypos + ")")
                });
                var feelers = tdgchart.d3.select(this.parentNode.parentNode).selectAll("[class$='!mfeeler!']");
                feelers.each(function() {
                    this.setAttribute("transform", "translate(0, " + pcenter + ") scale(1," + (1 - pskew) + ") translate(0," + -pcenter + ") ")
                })
            }
        }
        function sort_pie() {
            var ar = tdgchart.d3.select(this).selectAll("g.wedge25d");
            if (ar.empty())
                return;
            var has_a_parent = ar.node().parentNode.nodeName === "a";
            var pp = has_a_parent ? ar.node().parentNode.parentNode : ar.node().parentNode;
            var fc = pp.firstChild;
            var pieces = ar.selectAll("path");
            var idx = [];
            for (var i = 0; i < pieces.length; i++)
                for (var j = 0; j < pieces[i].length; j++)
                    idx.push([i, j]);
            function pie_compare(a, b) {
                var pa = pieces[a[0]][a[1]];
                var pb = pieces[b[0]][b[1]];
                var ret = parseFloat(pa.getAttribute("tdg:seq")) - parseFloat(pb.getAttribute("tdg:seq"));
                if (ret === 0)
                    ret = parseFloat(pa.getAttribute("tdg:ymax")) - parseFloat(pb.getAttribute("tdg:ymax"));
                if (ret === 0 && pa.getAttribute("tdg:seq2") != null && pb.getAttribute("tdg:seq2") != null)
                    ret = parseFloat(pa.getAttribute("tdg:seq2")) - parseFloat(pb.getAttribute("tdg:seq2"));
                return ret
            }
            idx.sort(pie_compare);
            for (var k = 0; k < idx.length; k++) {
                var b = pieces[idx[k][0]][idx[k][1]];
                if (chart.htmlToolTip.enabled) {
                    var t = b.parentNode.getAttribute("tdgtitle");
                    if (t) {
                        b.setAttribute("tdgtitle", t);
                        if (t === "placeholder") {
                            b.tdgtitle = b.parentNode.tdgtitle;
                            b.tdgtitle_dom = b.parentNode.tdgtitle_dom
                        }
                    }
                    b.parentNode.removeChild(b);
                    pp.insertBefore(b, fc)
                } else if (has_a_parent) {
                    var parent_title = b.parentNode.parentNode.getAttribute("title");
                    b.parentNode.removeChild(b);
                    if (fc.previousSibling && fc.previousSibling.getAttribute("title") === parent_title)
                        fc.previousSibling.appendChild(b);
                    else {
                        var a = document.createElementNS(tdg.ns.svg, "a");
                        pp.insertBefore(a, fc);
                        a.setAttributeNS(tdg.ns.xlink, "title", parent_title);
                        a.appendChild(b)
                    }
                } else {
                    b.parentNode.removeChild(b);
                    pp.insertBefore(b, fc)
                }
            }
        }
        var root = tdgchart.d3.select("#" + chart.documentRoot);
        var pies = root.selectAll("g.pie25d");
        pies.each(reposition_labels);
        pies.each(sort_pie)
    }
    function reorderBar25dScene(chart) {
        var primary = "tdg_x"
          , secondary = "tdg_y"
          , invert = 1;
        if (chart.blaProperties.orientation === "horizontal") {
            primary = "tdg_y";
            secondary = "tdg_x";
            invert = -1
        }
        var root = document.getElementById(chart.documentRoot);
        var bars = root.getElementsByClassName("bar25d");
        if (!bars || !bars[0] || !bars[0].parentNode)
            return;
        var parent = bars[0].parentNode;
        bars = Array.prototype.slice.call(bars);
        bars.sort(function(a, b) {
            var dx = (a.getAttribute(primary) - b.getAttribute(primary)) * invert;
            if (dx !== 0)
                return dx;
            return (b.getAttribute(secondary) - a.getAttribute(secondary)) * invert
        });
        tdg.dom.empty(parent);
        for (var i = 0; i < bars.length; i++)
            parent.appendChild(bars[i])
    }
    function reorder_bar25d(chart) {
        var primary = "tdg:zx";
        var secondary = "tdg:zy";
        var pinvert = false;
        var sinvert = false;
        if (chart.blaProperties.orientation === "horizontal") {
            primary = "tdg:zy";
            secondary = "tdg:zx";
            pinvert = true
        } else
            sinvert = chart.blaProperties.seriesLayout === "percent" || chart.blaProperties.seriesLayout === "stacked";
        var root = tdgchart.d3.select("#" + chart.documentRoot);
        var bars = root.selectAll("g.bar25d");
        if (!bars.empty()) {
            bars.each(function() {
                reorder_shift_labels(this)
            });
            var idx = [], i;
            for (i = 0; i < bars[0].length; i++)
                idx.push(i);
            var bcompare = function(a, b) {
                var p = bars[0][a].getAttribute(primary) - bars[0][b].getAttribute(primary);
                if (p !== 0)
                    return pinvert ? -p : p;
                var s = bars[0][a].getAttribute(secondary) - bars[0][b].getAttribute(secondary);
                return sinvert ? -s : s
            };
            idx.sort(bcompare);
            var fc = bars.node().parentNode;
            var has_a_parent = fc.nodeName === "a";
            if (has_a_parent)
                fc = fc.parentNode;
            var pp = fc.parentNode;
            for (i = 0; i < bars[0].length; i++) {
                var b = bars[0][idx[i]];
                if (has_a_parent)
                    b = b.parentNode;
                b.parentNode.removeChild(b);
                pp.insertBefore(b, fc)
            }
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    var secondColorLightenFactor = .91;
    tdgchart.prototype.initColorScale = function(minMax, odata_key) {
        var chart = this;
        var v, scale, colors = chart.colorScale.colors || [];
        var axis = {
            side: chart.hasVerticalLegend() ? "right" : "bottom",
            name: "colorScale",
            properties: chart.colorScale,
            odata_key: odata_key || getColorKey(chart),
            nullval_draws_nothing: chart.chartType === "heatmap" || chart.chartType === "matrix" && chart.matrixProperties.chartType === "heatmap"
        };
        colors = matchFillEffectOpacity(chart, colors);
        chart.cache.set("colorAxis", axis);
        if (chart.hasDiscreteScale()) {
            if (minMax)
                axis.minMax = minMax;
            else {
                var lScaleMinMax = chart.getNumericScale({
                    width: 100,
                    height: 100
                }, axis).domain();
                axis.minMax = {
                    min: lScaleMinMax[0],
                    max: lScaleMinMax[1]
                }
            }
            if (tdg.eq(axis.minMax.min, axis.minMax.max)) {
                v = axis.minMax.min;
                axis.minMax.min = v * .98;
                axis.minMax.max = v * 1.02
            }
            scale = getDiscreteColorScale(colors, chart.colorScale.colorMode, axis.minMax);
            tdg.mergeObjects(scale, axis)
        } else {
            axis.minMax = minMax || chart.getColorScaleMinMax();
            if (tdg.eq(axis.minMax.min, axis.minMax.max)) {
                v = axis.minMax.min;
                axis.minMax.min = v * .98;
                axis.minMax.max = v * 1.02
            }
            scale = getContinuousColorScale(chart, colors, axis.minMax, chart.colorScale.invert);
            tdg.mergeObjects(scale, axis)
        }
        axis.minMax.bIsLog = chart.colorScale.bIsLog
    }
    ;
    function matchFillEffectOpacity(chart, colors) {
        var needOpacityFixup = false;
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        for (var s = 0; s < chart.series.length; s++) {
            var series = chart.series[s];
            var fillEffect = tdg.get("marker.fillEffect", series, "").toLowerCase();
            if (fillEffect === "serieslighten" || fillEffect === "seriesauto" && chartType === "bubble") {
                needOpacityFixup = true;
                break
            }
        }
        if (needOpacityFixup)
            colors = colors.map(function(color) {
                if (typeof color === "object" && color.hasOwnProperty("color"))
                    color.color = tdg.color(color.color).alpha(.6).toString();
                else
                    color = tdg.color(color).alpha(.6).toString();
                return color
            });
        return colors
    }
    function getMapColorDataKey(chart) {
        if (!chart.mapProperties.leaflet || !chart.mapProperties.leaflet.overlayLayers || !chart.mapProperties.leaflet.overlayLayers[0])
            return "color";
        var layer = chart.mapProperties.leaflet.overlayLayers[0];
        var layerType = layer.markerType || chart.mapProperties.markerType;
        if (layerType === "choropleth")
            return "value";
        return "color"
    }
    tdgchart.prototype.hasColorScale = function() {
        var chart = this;
        if (tdgchart.extensionManager.isExtension(chart.chartType)) {
            if (tdgchart.extensionManager.requiresModule(chart.chartType, "legend"))
                return tdgchart.extensionManager.getModuleProperty(chart, "legend", "colorMode") === "data";
            return false
        } else if (!chart.isLeaflet() && chart.hasColorScaleData(chart.data))
            return true;
        else if (chart.cache.get("axisModes", {}).y1 === "color")
            return true;
        else if (chart.chartType === "heatmap" || chart.chartType === "tagcloud")
            return true;
        else if (chart.chartType === "matrix" && chart.matrixProperties.chartType === "heatmap")
            return true;
        else if (chart.chartType === "map")
            if (chart.mapProperties) {
                if (chart.mapProperties.leaflet && chart.mapProperties.leaflet.overlayLayers)
                    if (chart.dataArrayMap)
                        return chart.dataObjHasProp(chart.data, getMapColorDataKey(chart));
                    else {
                        var layers = chart.mapProperties.leaflet.overlayLayers;
                        for (var i = 0; i < layers.length; i++) {
                            var markerType = layers[i] && layers[i].markerType ? layers[i].markerType : chart.mapProperties.markerType;
                            if (markerType === "choropleth")
                                return true
                        }
                    }
                return false
            } else
                return !chart.dataArrayMap || chart.dataObjHasProp(chart.data, "value") ? true : false;
        return false
    }
    ;
    tdgchart.prototype.getColorMode = function() {
        var c = this.colorMode;
        if (typeof c === "string")
            return c || "";
        else if (typeof c === "object" && c.hasOwnProperty("mode"))
            return c.mode || "";
        return "bySeries"
    }
    ;
    function getColorKey(chart) {
        if (chart.chartType === "map")
            return getMapColorDataKey(chart);
        else if (chart.chartType === "tagcloud") {
            if (Array.isArray(chart.dataArrayMap) && chart.dataArrayMap.includes("color"))
                return "color";
            return "value"
        }
        return "color"
    }
    tdgchart.prototype.getColorScaleMinMax = function() {
        var chart = this;
        var minMax;
        if (chart.chartType === "map")
            minMax = chart.getScaleMinMax(chart.colorScale, "colorScale", [chart._internalData[0]], null, getMapColorDataKey(chart));
        else
            minMax = chart.cache.get("colorAxis", {}).minMax;
        if (!minMax)
            minMax = this.getScaleMinMax(chart.colorScale, "colorScale", null, null, getColorKey(chart));
        if (minMax.min === minMax.max && chart.chartType !== "tagcloud") {
            minMax.min -= 1;
            minMax.max += 1
        }
        return minMax
    }
    ;
    tdgchart.prototype.hasDiscreteScale = function() {
        return this.colorScale.colorMode === "discrete" || this.colorScale.colorMode === "bin"
    }
    ;
    var bandEntries = ["start", "stop", "pin"];
    function getContinuousColorScale(chart, colors, minMax, invert) {
        var min = minMax.min
          , max = minMax.max;
        var spread = Math.abs(max - min);
        var colorList, domain;
        var res = {
            scale: null,
            tickMarks: []
        };
        var haveStartStopColorList = colors.some(function(e) {
            return typeof e === "object"
        });
        if (haveStartStopColorList) {
            if (min > max) {
                var t = min;
                min = max;
                max = t
            }
            var bands = tdg.clone(colors).filter(function(el) {
                return typeof el === "object" && (el.hasOwnProperty("start") || el.hasOwnProperty("pin"))
            });
            bands.forEach(function(band) {
                bandEntries.forEach(function(el) {
                    if (tdg.isPercentString(band[el]))
                        band[el] = min + tdg.applyNumOrPercent(band[el], spread);
                    if (tdg.isANumber(band[el]))
                        band[el] = tdg.bound(band[el], min, max)
                })
            });
            var colorStops = [];
            bands.forEach(function(band) {
                bandEntries.forEach(function(el) {
                    if (band[el] != null)
                        colorStops.push({
                            color: tdgchart.util.color.toColor(band.color),
                            value: el === "stop" ? band[el] - 1E-8 : band[el]
                        })
                })
            });
            colorStops.sort(function(a, b) {
                return a.value - b.value
            });
            res.tickMarks = colorStops.map(function(el) {
                return el.value
            });
            domain = tdg.clone(res.tickMarks);
            colorList = colorStops.map(function(el) {
                return el.color
            });
            res.stops = colorStops.map(function(band) {
                return {
                    color: band.color,
                    offset: (band.value - min) / spread
                }
            });
            res.tickMarks = res.tickMarks.filter(function(el, idx, arr) {
                return !tdg.eq(el, arr[idx + 1])
            })
        } else {
            domain = tdg.rangeCount(minMax.min, minMax.max, colors.length);
            colorList = colors.map(tdgchart.util.color.toColor);
            res.stops = colorList.map(function(el, i) {
                return {
                    color: el,
                    offset: i / (colorList.length - 1)
                }
            });
            res.tickMarks = tdg.clone(domain)
        }
        colorList.unshift(colorList[0]);
        domain.unshift(-Number.MAX_VALUE);
        colorList.push(colorList[colorList.length - 1]);
        domain.push(Number.MAX_VALUE);
        if (invert)
            colorList = colorList.reverse();
        res.scale = pv.Scale.linear.apply(null, domain).range(colorList);
        return res
    }
    function getDiscreteColorScale(colors, colorMode, minMax) {
        var min = minMax.min
          , max = minMax.max;
        var spread = Math.abs(max - min);
        var res = {
            scale: null,
            tickMarks: []
        };
        var haveStartStopColorList = colors.some(function(e) {
            return typeof e === "object"
        });
        if (haveStartStopColorList) {
            if (min > max) {
                var t = min;
                min = max;
                max = t
            }
            res.bands = tdg.clone(colors);
            res.bands = res.bands.filter(function(el) {
                return typeof el === "object" && el.hasOwnProperty("start")
            });
            res.bands.forEach(function(band) {
                if (tdg.isPercentString(band.start))
                    band.start = min + tdg.applyNumOrPercent(band.start, spread);
                if (tdg.isPercentString(band.stop))
                    band.stop = min + tdg.applyNumOrPercent(band.stop, spread)
            });
            res.bands.sort(function(a, b) {
                return a.start - b.start
            });
            res.bands.forEach(function(band, i) {
                if (band.stop == undefined)
                    band.stop = res.bands[i + 1] ? res.bands[i + 1].start : max;
                if (band.start < band.stop) {
                    res.tickMarks.push(band.start);
                    res.tickMarks.push(band.stop)
                }
            });
            res.tickMarks.push(min);
            res.tickMarks.push(max);
            res.tickMarks.sort(function(a, b) {
                return a - b
            });
            res.tickMarks = res.tickMarks.filter(function(el, idx) {
                return el !== res.tickMarks[idx + 1]
            });
            res.scale = function(num) {
                for (var i = 0; i < res.bands.length; i++) {
                    var band = res.bands[i];
                    if (band.start <= num && num <= band.stop)
                        return band.color
                }
                return null
            }
            ;
            res.stops = colorBandsToGradientStops(res.bands, minMax)
        } else {
            var linearScale = pv.Scale.linear([min, max]).range(0, colors.length);
            var step = spread / colors.length;
            res.tickMarks = tdg.range(Math.min(min, max), Math.max(min, max), step);
            res.tickMarks.push(Math.max(min, max));
            res.scale = function(num) {
                var temp = Math.floor(linearScale(num));
                if (colors.length === temp)
                    return colors[colors.length - 1];
                return colors[temp]
            }
            ;
            res.stops = colorScaleToGradientStops(colors, colorMode)
        }
        return res
    }
    function colorScaleToGradientStops(colors, mode) {
        var stops = [];
        for (var i = 0; i < colors.length; i++) {
            var color = colors[i];
            if (mode === "discrete") {
                stops.push({
                    offset: i / colors.length,
                    color: color
                });
                stops.push({
                    offset: (i + 1) / colors.length,
                    color: color
                })
            } else
                stops.push({
                    offset: i / (colors.length - 1),
                    color: color
                })
        }
        if (!stops.length)
            stops = [{
                offset: 0,
                color: "black"
            }, {
                offset: 1,
                color: "black"
            }];
        return stops
    }
    function colorBandsToGradientStops(colors, minMax) {
        var min = Math.min(minMax.min, minMax.max);
        var spread = Math.abs(minMax.max - minMax.min);
        var stops = []
          , prevStop = 0;
        colors.forEach(function(band) {
            var start = (band.start - min) / spread;
            var stop = (band.stop - min) / spread;
            if (stop <= 0 || start >= 1)
                return;
            if (start > prevStop) {
                stops.push({
                    offset: prevStop,
                    color: "transparent"
                });
                stops.push({
                    offset: start,
                    color: "transparent"
                })
            }
            stops.push({
                offset: start,
                color: band.color
            });
            stops.push({
                offset: stop,
                color: band.color
            });
            prevStop = stop
        });
        if (prevStop < 1) {
            stops.push({
                offset: prevStop,
                color: "transparent"
            });
            stops.push({
                offset: 1,
                color: "transparent"
            })
        }
        return stops
    }
    tdgchart.prototype.hasColorScaleData = function(data) {
        var chart = this;
        if (typeof data === "object" && (chart.chartType === "treemap" || chart.chartType === "circlepack2"))
            return chart.dataArrayMap && chart.dataArrayMap.indexOf("color") >= 0;
        return data.some(function(el) {
            if (Array.isArray(el))
                return chart.hasColorScaleData(el);
            return el && typeof el === "object" && el.color != null
        })
    }
    ;
    tdgchart.prototype.getColorMetricData = function(data, metricData) {
        var chart = this;
        var mode = chart.getColorMode();
        if (chart.colorMode.data == null)
            return chart.normalizeData([[]]);
        data = data || chart.data;
        metricData = metricData || chart.colorMode.data;
        if (!data || !data.length || !data[0].length)
            return chart.normalizeData([[]]);
        if (mode === "byGroupSelection" || mode === "bySeriesSelection")
            metricData = metricData[0].map(function(el) {
                return [el]
            });
        var m = metricData.map(function(dataArray, idx) {
            var val, d = data[0][idx] || {};
            if (chart.chartType === "bubble" && d.hasOwnProperty("size"))
                val = d.size;
            else if (chart.chartType === "scatter")
                val = 1;
            else if (d.hasOwnProperty("y"))
                val = d.y;
            else if (d.hasOwnProperty("value"))
                val = d.value;
            var sum = tdg.sum(dataArray);
            var normalize = sum > val ? val / sum : 1;
            var newArray = dataArray.map(function(el) {
                return tdg.isPercentString(el) ? tdg.applyNumOrPercent(el, val) : el * normalize
            });
            var pad = Math.abs(tdg.sum(newArray) - val);
            newArray.push(pad < .001 ? undefined : pad);
            return newArray
        });
        return chart.normalizeData(m, ["value"])
    }
    ;
    function exceptionalRiserColor(chart, d) {
        return (chart.getSeriesAndGroup(d._s, d._g) || {
            color: undefined
        }).color
    }
    function colorByMetric(chart, colorModeColors) {
        var seriesCount = chart.seriesCount();
        var mode = chart.getColorMode();
        colorModeColors = colorModeColors || [];
        return function(d) {
            var ids = {
                series: d._s,
                group: d._g
            };
            var exceptionalRiser = exceptionalRiserColor(chart, d);
            if (exceptionalRiser)
                return exceptionalRiser;
            if ((chart.chartType === "scatter" || chart.chartType === "bubble") && this instanceof pv.Wedge)
                seriesCount = this.parent.data().length;
            else if (chart.chartType === "histogram" || chart.chartType === "pie")
                seriesCount = chart.colorMode.data.length + 1;
            if (ids.series === seriesCount - 1 && !((chart.chartType === "pie" || chart.chartType === "bubble" || chart.chartType === "scatter") && mode !== "byMetric"))
                return chart.dataSelection.unselectedColor || "grey";
            function seriesColor(id) {
                return (chart.getSeries(id) || {
                    color: "black"
                }).color || "black"
            }
            if (mode === "byGroupSelection" && ids.group != null)
                return seriesColor(ids.group);
            else if (mode === "bySeriesSelection")
                return seriesColor(ids.series);
            return colorModeColors[ids.series] || seriesColor(0)
        }
    }
    function mixColorsForContrast(colorArray) {
        var i, len = colorArray.length;
        if (len < 4)
            return colorArray;
        var newColorArray = [];
        var mid = len / 2;
        if (len % 2) {
            mid = Math.floor(mid);
            newColorArray.push(colorArray[0]);
            newColorArray.push(colorArray[mid]);
            for (i = len - 2; i > mid; i--) {
                newColorArray.push(colorArray[i]);
                newColorArray.push(colorArray[i - mid])
            }
            newColorArray.push(colorArray[len - 1])
        } else
            for (i = 0; i < mid; i++) {
                newColorArray.push(colorArray[i]);
                newColorArray.push(colorArray[mid + i])
            }
        return newColorArray
    }
    function colorByInterpolation(chart, colors) {
        var domain = tdg.rangeCount(0, Math.max(chart.seriesCount() - 1, 1), colors.length);
        var colorScale = pv.Scale.linear.apply(null, domain).range(colors);
        return function(d) {
            return exceptionalRiserColor(chart, d) || colorScale(d._s)
        }
    }
    function colorByInterpolationAlt(chart, colors) {
        var domain = tdg.rangeCount(0, Math.max(chart.seriesCount() - 1, 1), colors.length);
        var colorScale = pv.Scale.linear.apply(null, domain).range(colors);
        var newColors = tdg.range(domain[domain.length - 1] + 1).map(colorScale);
        var newColorArray = mixColorsForContrast(newColors);
        return function(d) {
            return exceptionalRiserColor(chart, d) || newColorArray[d._s]
        }
    }
    function colorByHeight(chart, colors, panelSize) {
        var gradient, stops, x1 = 0, y1 = 0, x2 = 0, y2 = 0;
        if (chart.blaProperties.orientation === "horizontal")
            if (chart.axisList.y1.invert)
                x1 = panelSize.width;
            else
                x2 = panelSize.width;
        else if (chart.axisList.y1.invert)
            y2 = panelSize.height;
        else
            y1 = panelSize.height;
        if (panelSize && panelSize.isScene) {
            var offset = 1 / (colors.length - 1);
            stops = colors.map(function(el, idx) {
                return [idx * offset, el]
            });
            gradient = {
                type: "linear",
                start: {
                    x: x1,
                    y: y1
                },
                end: {
                    x: x2,
                    y: y2
                },
                stops: stops,
                gradientUnits: "userSpaceOnUse"
            };
            if (chart.isPieLike() || chart.havePieMarkers()) {
                gradient.start.x -= panelSize.width / 2;
                gradient.end.x -= panelSize.width / 2;
                gradient.start.y -= panelSize.height / 2;
                gradient.end.y -= panelSize.height / 2
            }
        } else {
            var makeStops = function(colors) {
                var offset = 1 / (colors.length - 1);
                return colors.map(function(el, idx) {
                    return idx * offset + " " + el
                }).join(",")
            };
            stops = makeStops(colors);
            x1 += "~";
            gradient = "linear-gradient(" + [x1, y1, x2, y2, stops].join(",") + ")"
        }
        return function(d) {
            return exceptionalRiserColor(chart, d) || gradient
        }
    }
    function colorByPosNeg(chart, colorMode) {
        var colorLookup = chart.seriesPropertyLookup("color");
        var posC, negC, neuC = chart.colorMode.neutralColor || "grey";
        if (colorMode === "byPosNeg") {
            posC = chart.colorMode.posColor || "green";
            negC = chart.colorMode.negColor || "red"
        } else if (colorMode === "byNegPos") {
            posC = chart.colorMode.negColor || "red";
            negC = chart.colorMode.posColor || "green"
        }
        return function(d) {
            d = d || {};
            var riserShape = chart.getSeriesAndGroupProperty(d._s, d._g, "riserShape");
            if (riserShape === "bar" || riserShape === "line" || riserShape !== "area" && chart.chartType !== "area") {
                var v = d.percent != null ? d.percent : d.value;
                if (v != null)
                    if (v > 0)
                        return posC;
                    else if (v < 0)
                        return negC;
                return neuC
            }
            return exceptionalRiserColor(chart, d) || colorLookup.call(this, d)
        }
    }
    function colorByGroup(chart) {
        var colorLookup = chart.seriesPropertyLookup("color");
        return function(d) {
            var newD = tdg.cloneObject(d);
            var tmp = newD._s;
            newD._s = newD._g;
            newD._g = tmp;
            return exceptionalRiserColor(chart, newD) || colorLookup.call(this, newD)
        }
    }
    function colorByFirstSeries(chart) {
        var series0Color = chart.getSeries(0).color;
        return function() {
            return series0Color
        }
    }
    tdgchart.prototype.doSeriesColorMode = function(panelSize) {
        var chart = this;
        var colorMode = chart.getColorMode();
        var colorModeColors;
        if (colorMode === "byGroup")
            return colorByGroup(chart);
        else if (colorMode === "byFirstSeries")
            return colorByFirstSeries(chart);
        if (typeof chart.colorMode === "object" && chart.colorMode.hasOwnProperty("colorList"))
            colorModeColors = chart.colorMode.colorList;
        else if (chart.colorModeColors != null)
            colorModeColors = chart.colorModeColors;
        if ((colorMode === "byPosNeg" || colorMode === "byNegPos") && (chart.chartType === "bar" || chart.chartType === "line"))
            return colorByPosNeg(chart, colorMode);
        if (colorMode === "byMetric" || colorMode === "bySeriesSelection" || colorMode === "byGroupSelection")
            return colorByMetric(chart, colorModeColors);
        if (!colorModeColors || !Array.isArray(colorModeColors))
            return undefined;
        colorModeColors = colorModeColors.filter(function(el) {
            return el != null
        });
        if (colorModeColors.length <= 0)
            return undefined;
        if (colorModeColors.length === 1) {
            var hsl = tdg.color(colorModeColors[0]).hsl();
            hsl.l = secondColorLightenFactor;
            colorModeColors = [colorModeColors[0], hsl.rgb().toString()]
        }
        if (colorMode === "byInterpolation")
            return colorByInterpolation(chart, colorModeColors);
        if (colorMode === "byInterpolationAlt")
            return colorByInterpolationAlt(chart, colorModeColors);
        if (colorMode === "byHeight" && panelSize != null)
            return colorByHeight(chart, colorModeColors, panelSize);
        return undefined
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    function auto_value_macro(d, data, ids, userArgs, grouping) {
        var chart = this;
        d = d || {};
        function hasBucket(name) {
            return !chart.dataBuckets || !typeof chart.dataBuckets.getBucket === "function" || chart.dataBuckets.getBucket(name)
        }
        var dataConfig = chart.getDefaultDataArrayMap().map(function(f) {
            return {
                bucket: f,
                dataField: f
            }
        });
        if (chart.isBLA() && dataConfig.length == 1 && dataConfig[0].bucket == "value" && hasBucket(d._axis))
            dataConfig = [{
                bucket: d._axis,
                dataField: "value"
            }];
        else if (chart.chartType == "boxplot")
            dataConfig = [{
                bucket: "markList",
                dataField: "value"
            }];
        else if (chart.chartType == "bubble" && hasBucket("size"))
            dataConfig = [{
                bucket: "size",
                dataField: "size"
            }];
        else if (chart.chartType == "matrix" && chart.matrixProperties.chartType == "marker") {
            var shape = chart.getSerDepProperty("marker.shape", d);
            var isFill = typeof shape === "string" && shape.toLowerCase() === "fill";
            if (isFill && hasBucket("color"))
                dataConfig = [{
                    bucket: "color",
                    dataField: "color"
                }]
        }
        var showValues = dataConfig.map(function(dc) {
            if (hasBucket(dc.bucket)) {
                var val = d[dc.dataField];
                var fmt = tdgchart.templateEngine.macros.bucket_formatting.call(chart, d, data, ids, [dc.bucket]);
                if (!fmt)
                    return val;
                else if (grouping)
                    return chart.formatNumber(val, {
                        mode: fmt,
                        grouping: "auto"
                    }, {
                        bucketID: dc.bucket,
                        object: "templateEngine"
                    }, true);
                else
                    return chart.formatNumber(val, fmt, undefined, true)
            } else
                return null
        }).filter(function(t) {
            return t != null
        });
        if (showValues.length <= 1)
            return showValues[0];
        else
            return "<" + showValues.join(", ") + ">"
    }
    function getAxisAssignments(chart, data) {
        var axisAssignments = {
            seriesAssignment: [],
            countSeriesOnAxis: {}
        };
        if (!data && chart.chartType == "matrix") {
            for (var r = 0; r < chart.data.length; r++)
                for (var c = 0; c < chart.data[r].length; c++)
                    if (Array.isArray(chart.data[r]) && Array.isArray(chart.data[r][c])) {
                        var cell_sa = getAxisAssignments(chart, chart.data[r][c]);
                        for (var i = 0; i < cell_sa.seriesAssignment.length; i++)
                            if (cell_sa.seriesAssignment[i] && !axisAssignments.seriesAssignment[i]) {
                                axisAssignments.seriesAssignment[i] = cell_sa.seriesAssignment[i];
                                axisAssignments.countSeriesOnAxis[cell_sa.seriesAssignment[i]] = Math.max(cell_sa.countSeriesOnAxis[cell_sa.seriesAssignment[i]], axisAssignments.countSeriesOnAxis[cell_sa.seriesAssignment[i]] || 0)
                            }
                    }
            return axisAssignments
        }
        if (!data)
            data = chart.data;
        for (var s = 0; s < data.length; s++)
            for (var g = 0; g < data[s].length; g++) {
                var axis = data[s][g] && data[s][g]._axis;
                if (axis) {
                    axisAssignments.seriesAssignment[s] = axis;
                    axisAssignments.countSeriesOnAxis[axis] = (axisAssignments.countSeriesOnAxis[axis] || 0) + 1;
                    break
                }
            }
        return axisAssignments
    }
    tdgchart.templateEngine = {
        isTemplateString: function(s) {
            return typeof s === "string" && s.includes("{{") && s.includes("}}")
        },
        macros: {
            base_value: function(d, data, ids, userArgs) {
                d = d || {};
                if (ids && ids.axis != null)
                    if (d.hasOwnProperty(ids.axis))
                        return d[ids.axis];
                    else if (typeof ids.axis === "string" && ids.axis.includes("-") && userArgs) {
                        var axis = ids.axis.split("-").filter(function(el) {
                            return el && el.startsWith(userArgs[0])
                        });
                        if (axis.length && d.hasOwnProperty(axis[0]))
                            return d[axis[0]]
                    }
                return tdgchart.templateEngine.macros.default_value.call(this, d)
            },
            base_value_formatted: function(d, data, ids, userArgs) {
                var value = tdgchart.templateEngine.macros.base_value.call(this, d, data, ids, userArgs);
                var userAxis = userArgs && userArgs.length ? userArgs[0] : null;
                if (userAxis) {
                    userAxis = userAxis.toLowerCase() === "x" ? "x" : "y";
                    var axisId = tdgchart.templateEngine.macros[userAxis + "axis_id"].call(this, d, data, ids);
                    var format = this.get("axisList." + axisId + ".numberFormat", null);
                    format = format || this.get(axisId + "axis.numberFormat", "#");
                    return this.formatNumber(value, format, undefined, true)
                }
                return value + ""
            },
            metadata_value: function(d, data, ids, userArgs) {
                d = d || {};
                userArgs = userArgs || [];
                var bucketID = ((userArgs[0] || "") + "").toLowerCase();
                if (bucketID === "default")
                    bucketID = this.getDefaultDataField();
                if (d.hasOwnProperty(bucketID)) {
                    if (this.dataBuckets && typeof this.dataBuckets.getBucket === "function") {
                        var fieldFormat = this.findBucketFormat(bucketID, ids);
                        if (fieldFormat)
                            return this.formatNumber(d[bucketID], fieldFormat, undefined, true)
                    }
                    if (userArgs[1]) {
                        var format = this.getSerDepProperty(userArgs[1] + ".numberFormat", ids);
                        if (format)
                            return this.formatNumber(d[bucketID], format, undefined, true)
                    }
                }
                return tdgchart.templateEngine.macros.default_value.call(this, d)
            },
            default_value: function(d) {
                d = d || {};
                var defaultField = this.getDefaultDataField();
                return d.hasOwnProperty(defaultField) ? d[defaultField] : d.value
            },
            auto_value: function(d, data, ids, userArgs) {
                return auto_value_macro.call(this, d, data, ids, userArgs)
            },
            auto_value_compressed: function(d, data, ids, userArgs) {
                return auto_value_macro.call(this, d, data, ids, userArgs, true)
            },
            data_point_count: function(d, data, ids, userArgs) {
                var field = Array.isArray(userArgs) && userArgs.length > 0 ? userArgs[0] : this.getDefaultDataField();
                if (d.hasOwnProperty(field) && Array.isArray(d[field]))
                    return d[field].length;
                return 0
            },
            group_id: function(d, data, ids) {
                return ids.group
            },
            group_label: function(d, data, ids) {
                var chart = this;
                var label;
                if (d && d.nodeName)
                    label = d.nodeName;
                else
                    label = this.getGroupLabel(ids.group);
                if (chart.isXTimeAxis() && chart.xaxis.timeAxis.tooltipFormat) {
                    var args = [label, chart.xaxis.timeAxis.tooltipFormat];
                    return tdgchart.templateEngine.macros.formatTime.call(this, d, data, ids, args)
                }
                return label
            },
            group_label_nested: function(d, data, ids, userArgs) {
                var idx = parseInt((userArgs || [])[0], 0);
                var s = (tdg.flattenNestedLabels(this.groupLabels) || [])[ids.group];
                return s ? s.split(" > ")[idx] : null
            },
            nested_label: function(d, data, ids) {
                return this.getNestedGroupLabel(ids.group)
            },
            group_count: function() {
                return this.visibleGroupCount()
            },
            group_sum: function(d, data, ids) {
                var key = this.getDefaultToolTipField(d);
                return this.getGroupSum(ids.group, ids.series, null, key)
            },
            auto_percent: function(d, data, ids) {
                var chart = this;
                var percentMacro = "series_percent";
                if (chart.chartType === "mekko")
                    percentMacro = "group_percent";
                else if (chart.isBLA()) {
                    var dataLength = chart.data.length;
                    if (chart.chartType == "matrix" && chart.data[d._r] && chart.data[d._r][d._c])
                        dataLength = chart.data[d._r][d._c].length;
                    if (dataLength > 1) {
                        var axisAssignments = chart.cache.get_or_set("axisAssignments", getAxisAssignments(chart));
                        if (axisAssignments.countSeriesOnAxis[axisAssignments.seriesAssignment[d._s]] > 1)
                            percentMacro = "group_percent"
                    }
                }
                return tdgchart.templateEngine.macros[percentMacro].call(chart, d, data, ids)
            },
            group_percent: function(d, data, ids) {
                var value, key = this.getDefaultToolTipField(d);
                if (key === "percent")
                    value = (d || [])[key] / 100;
                else {
                    var axisID = d._axis.startsWith("y") ? parseInt(d._axis.slice(1)) : null;
                    var sum = this.getGroupSum(ids.group, ids.series, null, key, axisID, ids.row, ids.col) || 1;
                    value = ((d || [])[key] || 0) / sum
                }
                return this.formatNumber(value, "#.00%")
            },
            series_id: function(d, data, ids) {
                var chart = this;
                if (typeof ids.series === "string" && ids.series.includes(tdgchart.getTreemapLabelSeparator())) {
                    var sep = chart.get("treemapProperties.internalLabelSeparator") || "-";
                    return tdg.replaceAll(ids.series, tdgchart.getTreemapLabelSeparator(), sep)
                }
                return ids.series
            },
            series_label: function(d, data, ids) {
                if (d && d.nodeName)
                    return d.nodeName;
                return (this.getSeries(ids.series) || {
                    label: ""
                }).label
            },
            series_count: function() {
                return this.seriesCount()
            },
            series_sum: function(d, data) {
                var chart = this;
                var i = chart.getDefaultToolTipField(d);
                return tdg.sum(data, function(el) {
                    return el[i]
                })
            },
            series_percent: function(d, data) {
                var sum, key = this.getDefaultToolTipField(d);
                if (this.chartType === "treemap" && d && d.parentNode) {
                    var dataArrayIdx = (this.dataArrayMap || []).indexOf(key);
                    dataArrayIdx = dataArrayIdx < 0 ? 0 : dataArrayIdx;
                    var siblings = d.parentNode.childNodes;
                    d = d.nodeValue[dataArrayIdx] || 0;
                    sum = tdg.sum(siblings, function(el) {
                        return el.nodeValue[dataArrayIdx] || 0
                    });
                    return this.formatNumber(d / (sum || 1), "#.00%")
                }
                sum = tdg.sum(data, function(el) {
                    return el[key]
                });
                return this.formatNumber(((d || [])[key] || 0) / (sum || 1), "#.00%")
            },
            axis_id: function(d, data, ids) {
                return ids.axis || "y1"
            },
            xaxis_id: function(d, data, ids) {
                if (typeof ids.axis === "string" && ids.axis.includes("-"))
                    return ids.axis.split("-")[0];
                return ids.axis || "x1"
            },
            yaxis_id: function(d, data, ids) {
                if (typeof ids.axis === "string" && ids.axis.includes("-"))
                    return ids.axis.split("-")[1];
                return ids.axis || "y"
            },
            data_total: function(d, data, ids, userArgs) {
                var dataMap = userArgs || this.dataArrayMap || this.getDefaultDataArrayMap();
                var total = 0;
                function iterate(a) {
                    for (var i = 0; i < a.length; i++) {
                        var v = a[i];
                        if (Array.isArray(v))
                            iterate(v);
                        else if (typeof v === "object")
                            for (var j = 0; j < dataMap.length; j++)
                                if (tdg.isANumber(v[dataMap[j]]))
                                    total += v[dataMap[j]]
                    }
                }
                iterate(this.data);
                return total
            },
            bucket_formatting: function(d, data, ids, userArgs) {
                userArgs = userArgs || [];
                var bucketID = (userArgs[0] || "") + "";
                if (!bucketID || bucketID === "default")
                    bucketID = this.getDefaultDataField();
                var fieldID = userArgs[1];
                var fieldFormat = this.findBucketFormat(bucketID, fieldID != undefined ? {
                    series: fieldID,
                    group: fieldID
                } : ids);
                return fieldFormat
            },
            trend_value: function(d, data, ids, userArgs) {
                var field = userArgs && userArgs.length ? userArgs[0] : "trendline_value";
                var value = (d || {})[field];
                return value
            },
            trend_mode: function(d, data, ids) {
                if (ids.series == null && ids.trendline == null)
                    return this.trendline.mode;
                var series = this.getSeries(ids.series) || {};
                if (Array.isArray(series.trendline) && ids.trendline != null) {
                    var trendline = series.trendline[ids.trendline];
                    return (trendline || {}).mode
                } else if (series.trendline)
                    return series.trendline.mode;
                return ""
            },
            tree_label: function(d, data, ids, userArgs) {
                if (ids && ids.object === "group-header")
                    return ids.misc;
                var nodeNameList = [];
                if (ids && typeof ids.series === "string")
                    nodeNameList = ids.series.split(tdgchart.getTreemapLabelSeparator());
                else
                    nodeNameList = tdgchart.getTreemapNodePath(d);
                if (userArgs && userArgs.length)
                    return nodeNameList[parseInt(userArgs[0], 10)];
                return nodeNameList.join(" > ")
            },
            data_page_slider_current_index: function() {
                if (this.dataPageSlider)
                    return this.dataPageSlider.currentPage;
                return ""
            },
            data_page_slider_current_label: function() {
                if (this.dataPageSlider && this.dataPageSlider.labels)
                    return this.dataPageSlider.labels[this.dataPageSlider.currentPage];
                return ""
            },
            object_id: function(d, data, ids) {
                return ids.object
            },
            misc_id: function(d, data, ids) {
                return ids.misc
            },
            row_id: function(d, data, ids) {
                var row = !this.cache.get("matrixFacetCols") ? ids.row : 0;
                return row
            },
            row_label: function(d, data, ids, userArgs) {
                var colIdx = userArgs && userArgs.length ? parseInt(userArgs[0], 10) || 0 : null;
                if (this.chartType.toLowerCase() === "datagrid")
                    return getNestedLabel(this.dataGridProperties.rowHeader.labels.content, ids.row, colIdx);
                var row = !this.cache.get("matrixFacetCols") ? ids.row : 0;
                return getNestedLabel(this.matrixProperties.rowLabels.labels, row, colIdx)
            },
            col_id: function(d, data, ids) {
                var col = !this.cache.get("matrixFacetCols") ? ids.col : this.cache.get("matrixFacetCols") * ids.row + ids.col;
                return col
            },
            col_label: function(d, data, ids, userArgs) {
                var colIdx = userArgs && userArgs.length ? parseInt(userArgs[0], 10) || 0 : null;
                var labels = this.chartType.toLowerCase() === "datagrid" ? this.dataGridProperties.colHeader.labels.content : this.matrixProperties.colLabels.labels;
                var col = !this.cache.get("matrixFacetCols") ? ids.col : this.cache.get("matrixFacetCols") * ids.row + ids.col;
                return getNestedLabel(labels, col, colIdx)
            },
            xaxis_title: function(d, data, ids) {
                var title;
                if (typeof ids.axis === "string")
                    if (ids.axis.includes("-")) {
                        var xaxis = ids.axis.split("-")[0];
                        title = this.get("axisList." + xaxis + ".title.text", this, "")
                    } else if (ids.axis.startsWith("x"))
                        title = this.get("axisList." + ids.axis + ".title.text", this, "");
                title = title || this.get("axisList.x1.title.text");
                title = title || this.get("xaxis.title.text");
                return title
            },
            yaxis_title: function(d, data, ids) {
                var title;
                if (typeof ids.axis === "string")
                    if (ids.axis.includes("-")) {
                        var yaxis = ids.axis.split("-")[1];
                        title = tdg.get("axisList." + yaxis + ".title.text", this, "")
                    } else if (ids.axis.startsWith("y"))
                        title = tdg.get("axisList." + ids.axis + ".title.text", this, "");
                title = title || this.get("axisList.y1.title.text");
                title = title || this.get("yaxis.title.text");
                return title
            },
            zaxis_title: function() {
                return this.zaxis.title.text
            },
            coloraxis_title: function() {
                return this.colorScale.title.text
            },
            auto_tooltip_content: function(d, data, ids) {
                return this.autoToolTipContent(d, data, ids.series, ids.group)
            },
            extension_bucket: function(d, data, ids, userArgs) {
                if (userArgs.length > 0) {
                    if (userArgs.length > 1 && Array.isArray((d || [])[userArgs[0]]))
                        return d[userArgs[0]][parseInt(userArgs[1], 0)];
                    return d[userArgs[0]]
                }
                return d
            },
            translate: function(d, data, ids, userArgs) {
                return tdgchart.translations[userArgs] || userArgs
            },
            macro: function(d, data, ids, userArgs) {
                return "{{" + userArgs[0] + "}}"
            },
            ocb: function() {
                return "{"
            },
            ccb: function() {
                return "}"
            },
            property_lookup: function(d, data, ids, userArgs) {
                return this.get(userArgs[0])
            },
            parent_name: function() {
                return "NYI"
            },
            other_slice_count: function() {
                return "NYI"
            },
            selected_count: function() {
                return "NYI"
            },
            selected_sum: function() {
                return "NYI"
            },
            "#": function(d, data, ids, userArgs) {
                if (userArgs && userArgs.length > 1)
                    userArgs = [parseFloat(userArgs[0]), userArgs[1], undefined, true];
                return this.formatNumber.apply(this, userArgs)
            },
            formatTime: function(d, data, ids, userArgs) {
                if (!Array.isArray(userArgs) || userArgs.length < 1)
                    return "";
                else if (userArgs.length < 2)
                    return userArgs[0] + "";
                var date = userArgs[0]
                  , format = userArgs[1];
                if (!(date instanceof Date)) {
                    date = tdgchart.d3_time.timeCanonicalParse(date);
                    if (!date)
                        return userArgs[0] + ""
                }
                return date.toString(format)
            },
            multiselect: function(d, selData, ids, userArgs) {
                var chart = this;
                selData = selData || [];
                userArgs = userArgs || ["value"];
                var entries = selData.map(function(de) {
                    return chart.parseTemplate("{{" + userArgs[0] + "}}", de, selData, ids)
                });
                return entries.map(function(v) {
                    return "\\'" + v + "\\'"
                }).join(" OR ")
            }
        },
        filters: {
            formatNumber: function(val, format) {
                return this.formatNumber(val, format, "tooltip", true)
            },
            "#": function(val, format) {
                return this.formatNumber(val, format, "tooltip", true)
            },
            percent: function(val, sum) {
                return val / sum * 100 + "%"
            },
            uppercase: function(s) {
                return (s + "").toUpperCase()
            },
            lowercase: function(s) {
                return (s + "").toLowerCase()
            },
            titlecase: function(s) {
                return (s + "").replace(/([^\W_]+[^\s-]*) */g, function(el) {
                    return el.charAt(0).toUpperCase() + el.substr(1).toLowerCase()
                })
            },
            escape: function(s) {
                return s.replace(/'/g, "\\'").replace(/"/g, "&quot;")
            }
        }
    };
    function getNestedLabel(labels, idx, colIdx) {
        if (tdg.isNestedLabels(labels)) {
            var label = tdg.flattenNestedLabels(labels)[idx] || "";
            return colIdx == null ? label : label.split(" > ")[colIdx]
        }
        return labels && labels.length ? labels[idx] : null
    }
    tdgchart.prototype.applyTemplate = function(text, d, data, ids) {
        var chart = this;
        if (tdgchart.templateEngine.isTemplateString(text))
            return chart.parseTemplate(text, d, data, ids) || text;
        return text
    }
    ;
    tdgchart.prototype.parseTemplate = function(template, d, data, ids) {
        var chart = this;
        function apply_macro(match) {
            match = match.trim();
            var args, parenIdx = match.indexOf("("), lastParenIdx = match.lastIndexOf(")");
            if (parenIdx >= 0 && lastParenIdx > parenIdx) {
                args = match.substring(parenIdx + 1, lastParenIdx);
                args = args.split(/(".*?"|[^",]+)(?=\s*,|\s*$)/).map(function(el) {
                    return (el + "").trim()
                }).filter(function(el) {
                    return el && el !== ","
                });
                args = args.map(function(el) {
                    return el && typeof el.replace === "function" ? el.replace(/^['"](.*)['"]$/, "$1") : el
                });
                match = match.substr(0, parenIdx)
            }
            var macro = tdgchart.templateEngine.macros[match];
            if (macro) {
                if (d == null && data == null && ids == null && args && args.length > 2) {
                    args = args.slice(0, 3).map(function(arg) {
                        arg = arg === "" ? '""' : arg;
                        var a;
                        eval("a = " + arg);
                        return a
                    }).concat([args.slice(3)]);
                    return typeof macro === "function" ? macro.apply(chart, args) : macro + ""
                }
                return typeof macro === "function" ? macro.call(chart, d, data, ids || {}, args) : macro + ""
            }
            if (d && chart.dataArrayMap) {
                var res, dataArrayIdx = chart.dataArrayMap.indexOf(match);
                if (dataArrayIdx >= 0) {
                    if (chart.chartType === "treemap" && d.nodeValue)
                        res = d.nodeValue[dataArrayIdx];
                    else if (Array.isArray(d) && dataArrayIdx < d.length)
                        res = d[dataArrayIdx];
                    else
                        res = d.isNeg && typeof d[match] === "number" && match === "value" ? d[match] * -1 : d[match];
                    if (args && args.length && Array.isArray(res))
                        return res[parseInt(args[0], 0)];
                    return res
                }
            }
            if (d && typeof d === "object" && d.hasOwnProperty(match)) {
                if (args && args.length && Array.isArray(d[match]))
                    return d[match][parseInt(args[0], 0)];
                return d.isNeg && typeof d[match] === "number" && match === "value" ? d[match] * -1 : d[match]
            }
            if (match.indexOf("chart") === 0)
                return chart.stringToProperty(match);
            return match
        }
        function apply_filter(fn, value, args) {
            var filter = tdgchart.templateEngine.filters[fn];
            return filter ? filter.apply(chart, [value].concat(args)) : value
        }
        function build_filter(match) {
            var fn = match.trim();
            var args = fn.match(/(.*?)\((.*?)\)$/);
            if (args && args.length > 2) {
                fn = args[1];
                args = args[2].split(/,(?=(?:[^'"]*['"][^'"]*['"])*[^'"]*$)/).map(function(el) {
                    var haveQuotes = false;
                    el = el.trim();
                    if (el && el.match(/^["']([^"']*)["']$/g)) {
                        haveQuotes = true;
                        el = el.replace(/^["']([^"']*(?=["']))["']$/g, "$1")
                    }
                    var value = haveQuotes ? el : apply_macro(el);
                    return value == null ? el : value
                })
            }
            return {
                fn: fn,
                args: args
            }
        }
        var callStack = []
          , currentMacro = null;
        function tokenCallback(match, isToken, token) {
            if (isToken) {
                if (token === "{{") {
                    if (currentMacro)
                        callStack.push(currentMacro);
                    currentMacro = ""
                } else if (token === "}}") {
                    if (currentMacro == null)
                        return null;
                    var res = apply_macro(currentMacro);
                    if (callStack.length) {
                        currentMacro = callStack.pop() + res;
                        return null
                    } else
                        currentMacro = null;
                    return res
                }
                return null
            } else {
                if (token === "{{" && currentMacro != null) {
                    currentMacro = currentMacro + match;
                    return null
                } else if (token === "}}")
                    if (match && match.includes("|")) {
                        var filter, match_list = match.split("|");
                        var r = apply_macro(match_list[0]);
                        for (var i = 1; i < match_list.length; i++) {
                            filter = build_filter(match_list[i]);
                            r = apply_filter(filter.fn, r, filter.args)
                        }
                        return r
                    } else if (currentMacro == null)
                        return match + token;
                    else {
                        currentMacro += match;
                        return null
                    }
                return match
            }
        }
        var tokenizer = new tdgchart.Tokenizer(["{{", "}}"],tokenCallback);
        return tokenizer.parse(template + "").join("")
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    function labelHeight(chart, label, allowedSpace) {
        if (!label.visible || !label.renderedText)
            return {
                width: 0,
                height: 0
            };
        var font = tdg.textContainsHTML(label.renderedText) ? "" : label.font;
        var lblSize = chart.measureLabel(label.renderedText, font, allowedSpace);
        if (lblSize.height <= 0)
            return tdg.measureFont(label.font);
        return lblSize
    }
    tdgchart.prototype.getOverallLayout = function(excludeLegend) {
        var chart = this;
        var frameInset = chart.get("border.width") || 0;
        var frameTopMargin = chart.getPadding("frame", "top");
        var frameBottomMargin = chart.getPadding("frame", "bottom");
        var labelTopMargin = chart.getPadding("label", "top");
        var legendSide = chart.getLegendSide(true);
        var narrativeSide = chart.get("narrativeText.position", "top");
        function padWithMargin(labelHeight) {
            return labelHeight > 0 ? labelHeight + labelTopMargin : 0
        }
        var allowedSpace = chart.width - chart.getPadding("label", "left") - chart.getPadding("label", "right") - frameInset - frameInset;
        ["title", "subtitle", "footnote"].forEach(function(name) {
            var title = chart[name];
            var text = chart.applyTemplate(title.text, null, null, null);
            chart[name].renderedText = text;
            if (title.visible && !tdg.textContainsHTML(text))
                chart[name].renderedText = chart.applyWrapAndTruncate(text, title.font, title.wrap, name, allowedSpace)
        });
        var titleSize = labelHeight(chart, chart.title, allowedSpace);
        var subtitleSize = labelHeight(chart, chart.subtitle, allowedSpace);
        var footnoteSize = labelHeight(chart, chart.footnote, allowedSpace);
        var dataPageSliderLayout = chart.layoutSlider(chart.dataPageSlider);
        var narrativeIsOrthogonal = (legendSide === "top" || legendSide === "bottom") && (narrativeSide === "left" || narrativeSide === "right");
        var narrativeTextLayout;
        if (!narrativeIsOrthogonal)
            narrativeTextLayout = chart.layoutNarrativeText(titleSize.height, subtitleSize.height, footnoteSize.height, dataPageSliderLayout.size);
        var legendLayout;
        if (excludeLegend)
            legendLayout = {
                topDisplacement: 0,
                bottomDisplacement: 0,
                leftDisplacement: 0,
                rightDisplacement: 0
            };
        else
            legendLayout = chart.layoutLegend(titleSize.height, subtitleSize.height, footnoteSize.height, dataPageSliderLayout.size, narrativeTextLayout);
        if (narrativeIsOrthogonal)
            narrativeTextLayout = chart.layoutNarrativeText(titleSize.height, subtitleSize.height, footnoteSize.height, dataPageSliderLayout.size, legendLayout);
        var topDisplacement = narrativeTextLayout.topDisplacement;
        topDisplacement += legendSide === "top" ? legendLayout.topDisplacement : 0;
        var titleTop = frameTopMargin + frameInset;
        var subtitleTop = titleTop + padWithMargin(titleSize.height);
        var sliderTop = subtitleTop + padWithMargin(subtitleSize.height) + topDisplacement;
        var chartTop = sliderTop + dataPageSliderLayout.size + frameTopMargin;
        if (chart.blaProperties.orientation === "vertical" && !chart.axisList.x1.swapChartSide && ["bar", "line", "area", "pareto", "waterfall", "histogram", "pictogram"].includes(chart.chartType))
            chartTop += 10;
        var footnoteBottom = frameBottomMargin + frameInset;
        if (chart.footnote.visible && tdg.textContainsHTML(chart.footnote.text))
            footnoteBottom = footnoteBottom / 2;
        var chartBottom = footnoteBottom + padWithMargin(footnoteSize.height) + padWithMargin(legendLayout.bottomDisplacement) + padWithMargin(narrativeTextLayout.bottomDisplacement);
        var chartFrameHeight = chart.height - chartTop - chartBottom;
        var chartFrameWidth = chart.width - legendLayout.leftDisplacement - legendLayout.rightDisplacement - narrativeTextLayout.leftDisplacement - narrativeTextLayout.rightDisplacement - frameInset - frameInset;
        ["title", "subtitle", "footnote"].forEach(function(name) {
            if (chart[name].visible && chart[name].align === "chartFrame")
                chart[name].renderedText = chart.truncateLabel(chart[name].renderedText, chart[name].font, chartFrameWidth)
        });
        return {
            title: {
                top: titleTop,
                x: frameInset,
                y: frameInset,
                width: chart.width - frameInset - frameInset,
                height: frameTopMargin + padWithMargin(titleSize.height)
            },
            subtitle: {
                top: subtitleTop,
                x: frameInset,
                y: frameInset + (titleSize.height ? titleTop + titleSize.height : 0),
                width: chart.width - frameInset - frameInset,
                height: padWithMargin(subtitleSize.height)
            },
            footnote: {
                bottom: footnoteBottom,
                x: frameInset,
                y: chart.height - frameBottomMargin - footnoteSize.height - frameInset,
                width: chart.width - frameInset - frameInset,
                height: frameBottomMargin + footnoteSize.height
            },
            titleMaxLength: allowedSpace,
            legend: legendLayout,
            narrativeTextLayout: narrativeTextLayout,
            slider: {
                x: dataPageSliderLayout.size ? 10 : 0,
                y: sliderTop
            },
            chart: {
                x: legendLayout.leftDisplacement + narrativeTextLayout.leftDisplacement + frameInset,
                y: chartTop,
                width: chartFrameWidth,
                height: chartFrameHeight
            }
        }
    }
    ;
    tdgchart.prototype.layoutDefaultChart = function(overallChartSize) {
        return {
            chartSize: {
                width: overallChartSize.width,
                height: overallChartSize.height,
                x: 0,
                y: 0
            }
        }
    }
    ;
    tdgchart.prototype.addPanelOfSize = function(parent, size, className) {
        return this.addPanel(parent, size.x, size.y, size.width, size.height, className)
    }
    ;
    tdgchart.prototype.addPanel = function(parent, x, y, w, h, className) {
        var p = parent.add(pv.Panel).left(x).top(y).width(w).height(h);
        if (className)
            p.className(className);
        p.computedSize = {
            x: x,
            y: y,
            width: w != null ? w : parent.computedSize.width,
            height: h != null ? h : parent.computedSize.height
        };
        return p
    }
    ;
    tdgchart.prototype.prepareDrawPanels = function(rootPanel, overallChartSize) {
        return {
            chartPanel: this.addPanelOfSize(rootPanel, overallChartSize, "chartPanel")
        }
    }
    ;
    tdgchart.prototype.gridLayout = function(panel, data) {
        if (data == null)
            data = this.data.slice(0);
        var seriesCount = data.length;
        var numRows, numCols;
        var chartsPerRow = this.chartsPerRow;
        if (chartsPerRow == null || chartsPerRow <= 0)
            numCols = Math.ceil(Math.sqrt(seriesCount));
        else
            numCols = Math.min(Math.round(chartsPerRow), seriesCount);
        numRows = Math.ceil(seriesCount / numCols);
        var w = panel.computedSize.width / numCols;
        var h = panel.computedSize.height / numRows;
        var dataPanel = panel.add(pv.Panel).data(data);
        var gPanel = dataPanel.add(pv.Panel).antialias(false).width(w).height(h).left(function() {
            return w * (this.parent.index % numCols)
        }).top(function() {
            return h * Math.floor(this.parent.index / numCols)
        });
        return {
            panel: gPanel,
            w: w,
            h: h
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.maxBubbleSize = function(data, odata_key) {
        return tdg.maxR(data, function(el) {
            el = Math.abs(el[odata_key || "size"]);
            return el < 1E-5 || isNaN(el) ? -Infinity : el
        })
    }
    ;
    function minBubbleSize(data, odata_key) {
        return tdg.minR(data, function(el) {
            el = el[odata_key || "size"];
            return el == null ? Infinity : Math.abs(el)
        })
    }
    tdgchart.prototype.bubbleMarkerRadius = function(dim) {
        var chart = this;
        var r = chart.zaxis.marker.maxSize;
        if (!r && r !== 0)
            r = "30%";
        if (tdg.isPercentString(r)) {
            var frame = dim ? dim : chart._computedChartFrame || {
                width: chart.width,
                height: chart.height
            };
            r = tdg.applyNumOrPercent(r, Math.min(frame.width, frame.height))
        }
        return r
    }
    ;
    tdgchart.prototype.isDataDrivenMarkerSize = function() {
        var chart = this;
        var chartType = chart.chartType;
        var matrixType = chart.matrixProperties.chartType;
        if (chartType === "matrix") {
            if (["bubble", "marker"].includes(matrixType))
                return true;
            return (matrixType === "pie" || matrixType === "line" || matrixType === "polar") && chart.dataObjHasProp(chart.data, "size")
        }
        if (chartType === "pie")
            return chart.dataObjHasProp(chart.data, "size");
        var enoughData = chart.data && Array.isArray(chart.data[0]);
        return chartType === "bubble" || chartType === "map" && (chart.mapProperties.markerType === "bubble" || chart.mapProperties.engine === "leaflet") || chartType === "line" && enoughData && Array.isArray(chart.data[0][0]) && chart.data[0][0].length === 2 || chartType === "line" && enoughData && typeof chart.data[0][0] === "object" && chart.data[0][0].size != null || chartType === "polar" && chart.dataObjHasProp(chart.data, "size")
    }
    ;
    tdgchart.prototype.shiftData = function(datum, label) {
        var chart = this;
        if (Array.isArray(datum))
            datum.forEach(function(el, idx) {
                chart.data[idx].shift();
                chart.data[idx].push(el)
            });
        else {
            chart.data[0].shift();
            chart.data[0].push(datum)
        }
        chart.groupLabels.shift();
        chart.groupLabels.push(label)
    }
    ;
    tdgchart.prototype.dataDrivenMarkerSize = function(odata_key, minMaxRadius, minMaxSizeValue, data) {
        var chart = this;
        if (chart.isDataDrivenMarkerSize()) {
            var isPieChart = chart.chartType === "pie";
            var isMatrixPieChart = chart.chartType === "matrix" && chart.matrixProperties.chartType === "pie";
            data = data || (chart.isPageSliderEnabled() ? chart.data : chart._internalData);
            var maxBubbleR = minMaxRadius && minMaxRadius.max ? minMaxRadius.max : chart.bubbleMarkerRadius();
            var maxSizeValue, minSizeValue;
            if (chart.cache.hasKey("sizeLegendMaxRadius"))
                maxBubbleR = Math.min(maxBubbleR, chart.cache.get("sizeLegendMaxRadius") * 2);
            if (minMaxSizeValue) {
                minSizeValue = minMaxSizeValue.min;
                maxSizeValue = minMaxSizeValue.max
            } else if (chart.isPageSliderEnabled()) {
                minSizeValue = tdg.min(chart.data, function(d) {
                    return minBubbleSize(d, odata_key)
                });
                maxSizeValue = tdg.max(chart.data, function(d) {
                    return chart.maxBubbleSize(d, odata_key)
                })
            } else {
                var isMatrixBubble = this.chartType === "matrix" && this.matrixProperties.chartType === "bubble";
                minSizeValue = minBubbleSize(data, odata_key);
                maxSizeValue = chart.maxBubbleSize(isMatrixBubble ? chart.matrixBubbleData : data, odata_key)
            }
            var sizeScale = function(d) {
                return Math.max(2, maxBubbleR * Math.sqrt(Math.abs(d || 0) / maxSizeValue))
            };
            var divisor = isPieChart || isMatrixPieChart ? 1 : 2;
            sizeScale.domain = [minSizeValue, maxSizeValue];
            sizeScale.range = [sizeScale(minSizeValue) / divisor, sizeScale(maxSizeValue) / divisor];
            if ((maxSizeValue === -Infinity || minSizeValue === maxSizeValue) && chart.zaxis.min === 0 && chart.zaxis.max === 0)
                return function() {
                    return maxBubbleR / 8
                }
                ;
            if (chart.isSizeLegendVisible() && sizeScale) {
                var range = sizeScale.range;
                var domain = sizeScale.domain;
                if (!isNaN(domain[0]) && !isNaN(domain[1]) && !isNaN(range[0]) && !isNaN(range[1])) {
                    var sizeScaleRev = function(d) {
                        if (!maxBubbleR)
                            return 0;
                        return (d || 0) / maxBubbleR * ((d || 0) / maxBubbleR) * maxSizeValue
                    };
                    var midRangeVal = (range[0] + range[1]) / 2;
                    var midSizeVal = (domain[0] + domain[1]) / 2;
                    midSizeVal = sizeScaleRev(midRangeVal * divisor);
                    chart._sizeLegendMarkersInfo = [{
                        r: range[1],
                        value: domain[1]
                    }, {
                        r: midRangeVal,
                        value: midSizeVal
                    }, {
                        r: range[0],
                        value: domain[0]
                    }]
                }
            }
            return function(d, data) {
                var z;
                if (Array.isArray(d) && typeof d[0] === "number")
                    z = d[0];
                else
                    z = d[odata_key || "size"];
                if (this && this.shape && this.shape() === "pie") {
                    data.radius = sizeScale(data.size);
                    return data.radius
                } else if (this && this.engine == "pie")
                    return sizeScale(data.size);
                return sizeScale(z) / 2
            }
        } else {
            var lookup = chart.seriesPropertyLookup("marker.size");
            return function(d) {
                var res = lookup.call(this, d);
                if (tdg.isPercentString(res)) {
                    var frame = chart._computedChartFrame || {
                        width: chart.width,
                        height: chart.height
                    };
                    res = tdg.applyNumOrPercent(res, Math.min(frame.width, frame.height))
                }
                if (!this || !this.shape || this.shape() !== "pie")
                    res *= .5;
                return res
            }
        }
    }
    ;
    tdgchart.prototype.checkIfTooMuchData = function() {
        var chart = this;
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        var limit, limits = chart.dataSetLimits.limits || {};
        if (limits.hasOwnProperty(chartType))
            limit = limits[chartType];
        else if (chartType === "bubble" || chartType === "scatter")
            limit = limits.xy;
        else if (chartType === "gauge" || chartType === "funnel")
            limit = limits.pie;
        else
            limit = limits.bla;
        function countData(data) {
            var count = 0;
            for (var i = 0; i < data.length; i++) {
                var d = data[i];
                if (Array.isArray(d) && d.length > 0)
                    count += countData(d);
                else if (d != null)
                    count += 1
            }
            return count
        }
        if (typeof limit === "number" && Array.isArray(chart.data)) {
            if (chart.chartType === "matrix")
                limit *= 2;
            var dataArrayCount = Array.isArray(chart.dataArrayMap) ? chart.dataArrayMap.length || 1 : 1;
            var count = countData(chart.data) / dataArrayCount;
            if (count > limit)
                throw tdgchart.translations.TooMuchDataError;
        }
    }
    ;
    function search(array, prop) {
        return array.some(function(el) {
            if (Array.isArray(el))
                return search(el, prop);
            return typeof el === "object" && el[prop] != null
        })
    }
    tdgchart.prototype.dataObjHasProp = function(array, prop) {
        if (Array.isArray(array) && typeof prop === "string")
            return search(array, prop);
        return false
    }
    ;
    tdgchart.prototype.handleShowNullGroups = function(data) {
        var chart = this;
        if (chart.showNullGroups !== false)
            return data;
        var chartCompressible = ["bar", "line", "area", "waterfall", "heatmap", "streamgraph", "pictogram"].includes(chart.chartType);
        if (chart.chartType === "matrix")
            data = compressMatrix(chart, data);
        else if (chartCompressible) {
            var compGroupObj = getCompGroupObj(chart, data);
            compressDataObj(data, compGroupObj.compressedGroups);
            chart.cache.set("compressedGroups", compGroupObj.compressedGroups)
        }
        return data
    }
    ;
    function compressMatrix(chart, data) {
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        var chartCompressible = ["bar", "line", "area", "waterfall", "heatmap", "streamgraph"].includes(chartType);
        if (!chartCompressible || tdg.isEmpty(data) || !Array.isArray(data))
            return data;
        var gridSize = {
            rows: Math.max(data.length, 1),
            cols: Math.max(tdg.max(data, "length"), 1)
        };
        var isVertical = chart.blaProperties.orientation !== "horizontal";
        var groupCount = chart.groupCount();
        var cellGroupData = [];
        var emptyRows = tdg.repeat(true, gridSize.rows);
        var emptyCols = tdg.repeat(true, gridSize.cols);
        var i, j, d, r, c;
        for (r = 0; r < gridSize.rows; r++) {
            cellGroupData[r] = [];
            for (c = 0; c < gridSize.cols; c++) {
                d = (data[r] || [])[c];
                var cellData = groupsWithData(chart, d, groupCount);
                cellGroupData[r][c] = cellData;
                if (!tdg.isEmpty(cellData) && cellData.some(function(el) {
                    return el != null
                }))
                    emptyRows[r] = emptyCols[c] = false
            }
        }
        if (tdg.isEmpty(cellGroupData))
            return data;
        for (r = emptyRows.length - 1; r >= 0; r--)
            if (emptyRows[r]) {
                data.splice(r, 1);
                cellGroupData.splice(r, 1)
            }
        var rowLabels = chart.get("matrixProperties.rowLabels.labels");
        if (!tdg.isEmpty(rowLabels)) {
            rowLabels = pruneMatrixLabels(rowLabels, emptyRows);
            chart.cache.setProperty("matrixProperties.rowLabels.labels", rowLabels)
        }
        for (c = emptyCols.length - 1; c >= 0; c--)
            if (emptyCols[c])
                for (r = 0; r < data.length; r++) {
                    data[r].splice(c, 1);
                    cellGroupData[r].splice(c, 1)
                }
        var colLabels = chart.get("matrixProperties.colLabels.labels");
        if (!tdg.isEmpty(colLabels)) {
            colLabels = pruneMatrixLabels(colLabels, emptyCols);
            chart.cache.setProperty("matrixProperties.colLabels.labels", colLabels)
        }
        if (tdg.isEmpty(cellGroupData))
            return data;
        if (isVertical)
            cellGroupData = tdg.transpose(cellGroupData);
        var rowGroupData = [];
        for (r = 0; r < cellGroupData.length; r++) {
            rowGroupData[r] = tdg.repeat(false, groupCount);
            for (c = 0; c < cellGroupData[r].length; c++) {
                d = cellGroupData[r][c];
                for (i = 0; i < d.length; i++)
                    if (d[i])
                        rowGroupData[r][i] = true
            }
        }
        var compressedGroups = [];
        for (i = 0; i < rowGroupData.length; i++) {
            compressedGroups[i] = [];
            d = rowGroupData[i];
            for (j = 0; j < d.length; j++)
                if (!d[j])
                    compressedGroups[i].push(j);
            if (compressedGroups[i].length)
                if (isVertical)
                    for (r = 0; r < gridSize.rows; r++) {
                        if (data[r] && Array.isArray(data[r][i]))
                            compressDataObj(data[r][i], compressedGroups[i])
                    }
                else
                    for (c = 0; c < gridSize.cols; c++)
                        if (data[i] && Array.isArray(data[i][c]))
                            compressDataObj(data[i][c], compressedGroups[i])
        }
        var groupCountArray = compressedGroups.map(function(el) {
            return groupCount - el.length
        });
        var totalGroupCount = tdg.sum(groupCountArray);
        var proportion = groupCountArray.map(function(el) {
            return el / totalGroupCount
        });
        if (!chart.cache.get("matrixFacetCols"))
            chart.cache.set("matrixCompressedGroups", {
                compressedGroups: compressedGroups,
                groupCountArray: groupCountArray,
                allGroupCount: totalGroupCount,
                proportion: proportion
            });
        return data
    }
    function hasCompressedGroups(chart) {
        var compressedGroups = chart.cache.get("compressedGroups");
        if (compressedGroups && compressedGroups.length > 0)
            return true;
        compressedGroups = chart.cache.get("matrixCompressedGroups");
        if (compressedGroups != null && compressedGroups.compressedGroups.some(function(el) {
            return el.length > 0
        }))
            return true;
        return false
    }
    function calculateTimeInterval(start, stop, groupCount) {
        var gc = groupCount / 2;
        var span = stop.getTime() - start.getTime();
        if (gc < span / (864E5 * 365.25))
            return "years";
        else if (gc <= span / (864E5 * 30))
            return "months";
        else if (gc <= span / (864E5 * 7))
            return "weeks";
        else if (gc <= span / 864E5)
            return "days";
        else if (gc <= span / 36E5)
            return "hours";
        else if (gc <= span / 6E4)
            return "minutes";
        else if (gc <= span / 1E3)
            return "seconds";
        else
            return "milliseconds"
    }
    function getDataRange(chart) {
        var ds = chart.dataSubset;
        if (ds == null || ds.startGroup == null || ds.stopGroup == null)
            return null;
        var res = {
            start: 0,
            end: chart.groupCount()
        };
        if (typeof ds.startGroup === "string" && !isNaN(parseFloat(ds.startGroup)))
            res.start = parseFloat(ds.startGroup);
        else if (typeof ds.startGroup === "number")
            res.start = ds.startGroup;
        if (typeof ds.stopGroup === "string" && !isNaN(parseFloat(ds.stopGroup)))
            res.end = parseFloat(ds.stopGroup);
        else if (typeof ds.stopGroup === "number")
            res.end = ds.stopGroup;
        return res
    }
    tdgchart.prototype.visibleGroupCount = function() {
        var range = getDataRange(this);
        if (range)
            return Math.max(range.end - range.start, 1);
        return this.groupCount()
    }
    ;
    function haveSparseTimeData(chart) {
        if (chart.needXOrdinalAxis() && chart.xaxis.timeAxis.enabled) {
            var ta = chart.xaxis.timeAxis
              , start = Date.parse(ta.startTime)
              , stop = Date.parse(ta.stopTime);
            if (start != null && !isNaN(start) && stop != null && !isNaN(stop)) {
                var label = Date.parse(chart.groupLabels[0]);
                if (label != null && !isNaN(label))
                    return {
                        start: start,
                        stop: stop
                    }
            }
        }
        return null
    }
    tdgchart.prototype.groupCount = function() {
        var chart = this;
        var data = chart.data;
        if (chart.isPageSliderEnabled())
            data = chart.data[chart.dataPageSlider.currentPage || 0];
        if (chart.isXTimeAxis()) {
            var gc = chart.cache.get("xaxis_time_labels_count");
            if (gc != undefined)
                return chart.cache.get("xaxis_time_labels_count")
        }
        if (chart.innerChartType() === "histogram") {
            if (chart.cache.hasKey("histogramBins", data))
                return chart.cache.get("histogramBins").length;
            var binCount = chart.get("histogramProperties.binCount");
            return typeof binCount === "number" && binCount >= 0 ? binCount : null
        }
        switch (chart.chartType) {
        case "treemap":
            return 0;
        case "matrix":
            return tdg.max(data, function(el) {
                if (el && el.length)
                    return tdg.max(el, function(e) {
                        if (e && e.length)
                            return tdg.max(e, function(a) {
                                return a.length || 0
                            });
                        return 0
                    });
                return 0
            });
        case "pie":
        case "gauge":
        case "funnel":
            return data.length
        }
        var offset = chart.chartType === "waterfall" && chart.waterfallProperties.appendTotalRiser ? 1 : 0;
        var gc = offset + tdg.max(data, "length");
        var startStop = haveSparseTimeData(chart);
        if (startStop != null) {
            var ta = chart.xaxis.timeAxis;
            var interval = ta.interval;
            if (interval == null) {
                interval = calculateTimeInterval(startStop.start, startStop.stop, gc);
                chart.cache.set("xaxis_time_interval", interval)
            }
            var count = 0
              , settings = {};
            settings[interval] = 1;
            while (startStop.start.isBefore(startStop.stop)) {
                count += 1;
                startStop.start.add(settings)
            }
            return count + 1
        }
        return gc
    }
    ;
    function getTreemapSeriesCount(chart) {
        var dataIdx = Array.isArray(chart.dataArrayMap) ? chart.dataArrayMap.indexOf("series") : -1;
        if (dataIdx < 0) {
            var data = chart._internalData || chart.data;
            if (Array.isArray(data) && Array.isArray(data[0]))
                return data.filter(function(el) {
                    return el && el[1] == null ? el : null
                }).length;
            else if (data instanceof tdg.tree.TreeNode)
                return data.childNodes.length;
            else if (typeof data === "object")
                return tdg.keys(data).length;
            return 0
        }
        var count = 0
          , series = [];
        var root = tdg.tree(chart.data);
        root.visitBefore(function(node) {
            if (Array.isArray(node.nodeValue)) {
                var s = node.nodeValue[dataIdx];
                if (s != null && !series.includes(s)) {
                    series.push(s);
                    count++
                }
            }
        });
        chart.cache.set("treemapSeriesMap", series);
        return count
    }
    tdgchart.prototype.seriesCount = function(data) {
        var chart = this;
        if (tdgchart.extensionManager.isExtension(chart.chartType) && tdgchart.extensionManager.requiresModule(chart.chartType, "legend"))
            return tdgchart.extensionManager.getModuleProperty(chart, "legend", "seriesCount");
        data = data || chart._internalData || chart.data;
        if (chart.isPageSliderEnabled())
            data = chart.data[chart.dataPageSlider.currentPage || 0];
        if (hasMatrixDataSet(chart))
            if (chart.matrixProperties.chartType === "pie" || chart.matrixProperties.chartType === "gauge" || chart.matrixProperties.chartType === "funnel")
                return tdg.max(data, function(el) {
                    return tdg.max(el, function(e) {
                        return tdg.max(e, function(a) {
                            return a.length
                        })
                    })
                });
            else
                return tdg.max(data, function(el) {
                    return tdg.max(el, function(e) {
                        return e.length
                    })
                });
        else if (chart.chartType === "pie" || chart.chartType === "gauge" || chart.chartType === "funnel")
            return tdg.max(data, "length");
        else if (chart.chartType === "treemap")
            return getTreemapSeriesCount(chart);
        else if (chart.chartType === "gantt")
            if (data[0] && data[0][0] && data[0][0].series != null)
                return tdg.maxR(data, function(el) {
                    return el.series == null ? 0 : el.series + 1
                });
        return data.length
    }
    ;
    function convertODataToPercent(odata, chart, field) {
        var assignment = chart.getAxisAssignment();
        if (field == null)
            field = "value";
        var toPercent = function(el) {
            el = el.map(function(i) {
                if (i == null) {
                    var r = {};
                    r[field] = 0;
                    return r
                } else if (i[field] == null)
                    return null;
                return i
            });
            var abs = el.map(function(i) {
                return i == null ? 0 : Math.abs(i[field])
            });
            var sums = {};
            for (var i = 0; i < abs.length; i++) {
                if (!sums[assignment[i]])
                    sums[assignment[i]] = 0;
                sums[assignment[i]] += abs[i]
            }
            el.forEach(function(v, idx) {
                if (v != null)
                    v.percent = abs[idx] / sums[assignment[idx]] * 100
            });
            return el
        };
        var data = tdg.transpose(odata);
        data = tdg.transpose(data.map(toPercent));
        return data
    }
    tdgchart.prototype.getDefaultDataArrayMap = function() {
        var chart = this;
        var config = getChartDataConfig(chart);
        return config.map.slice(0, config.baseFields)
    }
    ;
    function getChartDataConfig(chart, chartType) {
        if (chartType == null)
            chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        if (tdgchart.extensionManager.isExtension(chartType))
            return tdgchart.extensionManager.getExtensionDataConfig(chart);
        switch (chartType) {
        case "boxplot":
            return {
                defaultField: "median",
                baseFields: 5,
                map: ["min", "lower", "median", "upper", "max"]
            };
        case "stock":
            return {
                defaultField: "value",
                baseFields: 4,
                map: ["high", "low", "open", "close"]
            };
        case "gantt":
            return {
                defaultField: "to",
                baseFields: 2,
                map: ["from", "to", "series"]
            };
        case "polar":
            return {
                defaultField: "r",
                baseFields: 2,
                map: ["phi", "r", "size", "color"]
            };
        case "bubble":
            return {
                defaultField: "size",
                baseFields: 3,
                map: ["x", "y", "size"],
                fallbackLabelsOrder: ["y", "x"]
            };
        case "scatter":
            return {
                defaultField: "x",
                baseFields: 2,
                map: ["x", "y", "pie"]
            };
        case "control":
            return {
                defaultField: "value",
                baseFields: 2,
                map: ["value", "sampleSize"]
            };
        case "map-2":
            return {
                defaultField: "value",
                baseFields: 2,
                map: ["name", "value"]
            };
        case "map-3":
            return {
                defaultField: "value",
                baseFields: 3,
                map: ["lng", "lat", "value", "color"]
            };
        case "marker":
            return {
                defaultField: "size",
                baseFields: 1,
                map: ["size", "color"]
            };
        case "treemap":
            return {
                defaultField: "size",
                baseFields: 1,
                map: ["size", "color"]
            };
        case "heatmap":
            return {
                defaultField: "color",
                baseFields: 1,
                map: ["color"]
            };
        case "tagcloud":
            return {
                defaultField: "value",
                baseFields: 1,
                map: ["value", "color"]
            };
        case "bullet":
            return {
                defaultField: "value",
                baseFields: 1,
                map: ["value", "markers"]
            };
        case "choropleth":
            return {
                baseFields: 0
            };
        default:
            return {
                defaultField: "value",
                baseFields: 1,
                map: ["value", "size", "color"]
            }
        }
    }
    function getMissingDataFields(chart, dataConfig, dataArrayMap) {
        var missing = [];
        if (!dataArrayMap)
            return null;
        for (var i = 0; i < dataConfig.baseFields; i++)
            if (!dataArrayMap.includes(dataConfig.map[i]))
                missing.push(dataConfig.map[i]);
        return missing.length ? missing : null
    }
    tdgchart.prototype.getDefaultDataField = function(chartType) {
        var chart = this;
        return getChartDataConfig(chart, chartType).defaultField
    }
    ;
    function eachMatrix(data, f) {
        var chart = this;
        return data.map(function(mr) {
            return mr.map(function(mc) {
                return f.call(chart, mc)
            })
        })
    }
    function groupsWithData(chart, data, groupCount) {
        var i, j, res = tdg.repeat(null, groupCount);
        if (!data || !data.length)
            return res;
        var field = chart.getDefaultDataField() || "value";
        for (i = 0; i < data.length; i++) {
            var d = data[i];
            if (!d || !d.length)
                continue;
            var s = chart.getSeries(i);
            if (s && s.hasOwnProperty("visible") && s.visible === false)
                continue;
            for (j = 0; j < d.length; j++) {
                var v = d[j];
                var value = v && v.hasOwnProperty(field) ? v[field] : v;
                if (!res[j] && value != null)
                    res[j] = true
            }
        }
        return res
    }
    function getCompGroupObj(chart, data) {
        var field = chart.getDefaultDataField() || "value";
        var compressedGroups = [];
        var atLeastOneRiser = [];
        for (var i = 0; i < data.length; i++) {
            var s = chart.getSeries(i);
            if (s && s.hasOwnProperty("visible") && s.visible === false)
                continue;
            for (var j = 0; j < data[i].length; j++) {
                var alorIdx = atLeastOneRiser.indexOf(j);
                var cgIdx = compressedGroups.indexOf(j);
                var value = data[i][j] && data[i][j].hasOwnProperty(field) ? data[i][j][field] : data[i][j];
                var badValue = value == null;
                if (!badValue) {
                    if (alorIdx < 0) {
                        atLeastOneRiser.push(j);
                        if (cgIdx >= 0)
                            compressedGroups.splice(cgIdx, 1)
                    }
                } else if (alorIdx < 0 && cgIdx < 0)
                    compressedGroups.push(j)
            }
        }
        return {
            compressedGroups: compressedGroups,
            atLeastOneRiser: atLeastOneRiser
        }
    }
    function compressDataObj(data, compressedGroups) {
        for (var i = 0; i < data.length; i++)
            data[i] = data[i].filter(function(el, idx) {
                return !compressedGroups.includes(idx)
            })
    }
    function hasMatrixDataSet(chart) {
        return chart.chartType === "matrix" || chart.isExtension() && tdgchart.extensionManager.isMatrix(chart.chartType) && chart.get("dataBuckets.matrix") != null
    }
    tdgchart.prototype.normalizeData = function(data, dataArrayMap) {
        var chart = this;
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        function copyFields(odata, data) {
            for (var p in data)
                if (odata.hasOwnProperty(p) && isNaN(parseInt(p, 10)))
                    odata[p] = data[p]
        }
        if (data.isObjective)
            return data;
        function dataToOData(value, s, g, r, c) {
            var o = {};
            if (chartType === "map")
                if (dataArrayMap == null)
                    if (typeof value[0] === "string")
                        dataArrayMap = getChartDataConfig(chart, chartType + "-2").map;
                    else
                        dataArrayMap = getChartDataConfig(chart, chartType + "-3").map;
            if (Array.isArray(value)) {
                for (var i = 0; i < value.length; i++)
                    if (dataArrayMap[i] != null)
                        o[dataArrayMap[i]] = value[i];
                if (dataArrayMap[0] != null)
                    o[dataArrayMap[0]] = value[0]
            } else if (typeof value === "number")
                o[dataArrayMap[0]] = value;
            else if (value && typeof value === "object")
                o = value;
            else
                o[dataArrayMap[0]] = value;
            addSeriesGroupIDs(o, s, g, r, c);
            return o
        }
        function addSeriesGroupIDs(o, s, g, r, c) {
            if (chartType === "pie" || chartType === "gauge" || chartType === "funnel") {
                o._s = g;
                o._g = s
            } else {
                o._s = s;
                o._g = g
            }
            if (o.hasOwnProperty("series"))
                o._s = o.series;
            if (r != null && c != null) {
                o._r = r;
                o._c = c
            }
        }
        if (dataArrayMap == null)
            if (chartType !== "map")
                dataArrayMap = getChartDataConfig(chart, chartType).map;
        function twoDDataToOData(data, seriesCount, r, c) {
            var res = [];
            seriesCount = seriesCount || data.length;
            var groupCount = tdg.max(data, "length");
            for (var s = 0; s < seriesCount; s++) {
                res.push([]);
                for (var g = 0; g < groupCount; g++)
                    if (data[s])
                        res[s].push(dataToOData(data[s][g], s, g, r, c))
            }
            return res
        }
        function matrixDataToOData(data) {
            var res = [];
            for (var r = 0; r < data.length; r++) {
                res.push([]);
                var seriesCount = chartType === "pie" ? null : tdg.max(data[r], "length");
                for (var c = 0; c < data[r].length; c++) {
                    var mc = data[r][c];
                    if (chartType === "marker" && mc && mc[0] && !Array.isArray(mc[0][0]) && typeof mc[0][0] !== "object")
                        mc = [mc];
                    res[r].push(twoDDataToOData(mc, seriesCount, r, c))
                }
            }
            return res
        }
        var odata;
        if (hasMatrixDataSet(chart))
            if (chart.isPageSliderEnabled())
                odata = data.map(matrixDataToOData);
            else
                odata = matrixDataToOData(data);
        else {
            if (chartType === "map" && Array.isArray(data[0]) && !Array.isArray(data[0][0]) && typeof data[0][0] !== "object")
                data = [data];
            if (chart.isPageSliderEnabled())
                odata = data.map(function(el) {
                    return twoDDataToOData(el)
                });
            else
                odata = twoDDataToOData(data)
        }
        copyFields(odata, data);
        odata.isObjective = true;
        chart.proceedMissingDataFields(dataArrayMap, odata);
        return odata
    }
    ;
    function matchTreeNodeBySeriesID(node, seriesID) {
        var seriesIDList = seriesID.split(tdgchart.getTreemapLabelSeparator()).reverse();
        for (var i = 0; i < seriesIDList.length; i++) {
            if (node.nodeName !== seriesIDList[i])
                return false;
            node = node.parentNode
        }
        return true
    }
    tdgchart.prototype.getDataFromIds = function(ids, data, chartType) {
        var chart = this;
        var i, s = ids.series, g = ids.group;
        chartType = chartType || chart.chartType;
        if (chart.isPageSliderEnabled() && chart._internalData == null)
            data = chart.data[chart.dataPageSlider.currentPage || 0];
        else
            data = data || chart._internalData || chart.data || [];
        if (chartType === "treemap") {
            if (s == null && ids.object === "group-header")
                s = ids.misc;
            (s + "").split(tdgchart.getTreemapLabelSeparator()).forEach(function(el) {
                if (data instanceof tdg.tree.TreeNode)
                    data = data.getChild(el);
                else if (data[el])
                    data = data[el]
            });
            return {
                d: data,
                data: data
            }
        } else if (chartType === "datagrid") {
            data = data[ids.row] || [];
            return {
                d: data[ids.col] || {},
                data: data
            }
        }
        if (chartType === "matrix" && ids.row != null) {
            data = data[ids.row];
            if (ids.col != null)
                data = data[ids.col]
        }
        if (ids.misc === "other" && (chartType === "pie" || chartType === "matrix" && chart.matrixProperties.chartType === "pie")) {
            data = data[g] || [];
            var sum = tdg.sum(data, function(el) {
                return el.noLabel ? el.value : 0
            });
            return {
                d: {
                    value: sum,
                    isOtherSlice: true
                },
                data: data
            }
        }
        var test = data[s] || [];
        if (test && test[g] && test[g]._s === s && test[g]._g === g)
            return {
                d: test[g],
                data: test
            };
        if (s != null && g != null)
            for (i = 0; i < data.length; i++)
                for (var j = 0; data[i] && j < data[i].length; j++) {
                    var d = data[i][j];
                    if (d != null && d._s === s && d._g === g)
                        return {
                            d: d,
                            data: data[i]
                        }
                }
        return {
            d: null,
            data: null
        }
    }
    ;
    tdgchart.prototype.proceedMissingDataFields = function(dataArrayMap, data, embed_call) {
        var chart = this;
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        if (chartType === "map" && chart.mapProperties.engine === "leaflet" && chart.mapProperties.markerType === "choropleth")
            chartType = "choropleth";
        var isBLA = chartType === "bar" || chartType === "line" || chartType === "area" || chartType === "mekko";
        var dataConfig = getChartDataConfig(chart);
        var missing = getMissingDataFields(chart, dataConfig, dataArrayMap);
        if (missing == null)
            return;
        if (chart.chartType === "matrix" && !embed_call) {
            data = eachMatrix(data, function(data) {
                chart.proceedMissingDataFields(dataArrayMap, data, true)
            });
            return
        }
        function getFallbackFieldAvailable(chart, dataConfig, missing) {
            if (!missing)
                return null;
            var fallbackOrder = dataConfig.fallbackLabelsOrder ? dataConfig.fallbackLabelsOrder.concat(dataConfig.map) : dataConfig.map;
            for (var i = 0; i < fallbackOrder.length; i++)
                if (!missing.includes(fallbackOrder[i]))
                    return fallbackOrder[i];
            return null
        }
        function dataSetAll(data, field, value) {
            data.forEach(function(row) {
                row.forEach(function(d) {
                    if (chart.dataPageSlider.enabled && Array.isArray(d))
                        d.forEach(function(dd) {
                            dd[field] = value
                        });
                    else
                        d[field] = value
                })
            })
        }
        function axisHideGridAndLabels(axis, axisName, axisMin) {
            var prop = "axisList." + axisName + ".";
            chart.cache.setProperty(prop + "majorGrid.visible", false);
            chart.cache.setProperty(prop + "majorGrid.ticks.visible", false);
            chart.cache.setProperty(prop + "minorGrid.visible", false);
            chart.cache.setProperty(prop + "minorGrid.ticks.visible", false);
            chart.cache.setProperty(prop + "labels.visible", false);
            if (axisMin !== 0)
                axis.baseLineStyle.width = 0
        }
        function numericAxisDataCheck(axis, axisName, field, minMax, value, force) {
            var hide = false;
            if (missing.includes(field) || force) {
                if (axis) {
                    if (minMax != null) {
                        chart.cache.setProperty("axisList." + axisName + ".rawMin", minMax.min);
                        chart.cache.setProperty("axisList." + axisName + ".rawMax", minMax.max)
                    }
                    axisHideGridAndLabels(axis, axisName, minMax.min)
                }
                hide = true;
                dataSetAll(data, field, value)
            }
            return hide
        }
        function dataEmpty(data) {
            return tdg.sum(data, "length") === 0
        }
        var forceAll = false;
        if (dataEmpty(data) && chart.chartType !== "matrix") {
            if (isBLA)
                if (chart.groupLabels.length > 0) {
                    data[0] = [];
                    for (var i = 0; i < chart.groupLabels.length; i++)
                        data[0].push({
                            _s: 0,
                            _g: i
                        })
                } else if (chartType === "area" || chartType === "line")
                    data[0] = [{
                        _s: 0,
                        _g: 0
                    }, {
                        _s: 0,
                        _g: 1
                    }];
                else
                    data[0] = [{
                        _s: 0,
                        _g: 0
                    }];
            else
                data[0] = [{
                    _s: 0,
                    _g: 0
                }];
            forceAll = true
        }
        var hide = false;
        if (chartType === "boxplot") {
            var missingAll = dataConfig.map.every(function(el) {
                return missing.includes(el)
            });
            if (missingAll && !chart.dataArrayMap.includes("markList")) {
                hide = numericAxisDataCheck(chart.axisList.y1, "y1", "lower", {
                    min: -1,
                    max: 1
                }, -.5, forceAll) || hide;
                hide = numericAxisDataCheck(chart.axisList.y1, "y1", "upper", {
                    min: -1,
                    max: 1
                }, .5, forceAll) || hide
            }
        } else if (isBLA) {
            var val = 1;
            if (chart.blaProperties.seriesLayout === "stacked" || chart.blaProperties.seriesLayout === "percent")
                val /= data.length || 1;
            hide = numericAxisDataCheck(chart.axisList.y1, "y1", "value", {
                min: 0,
                max: 1
            }, val, forceAll);
            if (chart.groupLabels.length === 0)
                axisHideGridAndLabels(chart.axisList.x1, "x1", chart.axisList.x1.min)
        } else if (chartType === "scatter" || chartType === "bubble") {
            hide = numericAxisDataCheck(chart.axisList.x1, "x1", "x", {
                min: -1,
                max: 1
            }, 0, forceAll) || hide;
            hide = numericAxisDataCheck(chart.axisList.y1, "y1", "y", {
                min: -1,
                max: 1
            }, 0, forceAll) || hide;
            if (chartType === "bubble") {
                chart.cache.setProperty("zaxis.min", 0);
                chart.cache.setProperty("zaxis.max", 0);
                hide = numericAxisDataCheck(null, null, "size", null, 0, forceAll) || hide
            }
        } else if (chartType === "map")
            hide = numericAxisDataCheck(chart.axisList.y1, "y1", "value", {
                min: 0,
                max: 1
            }, 1, forceAll);
        else if (chartType === "pie" || chartType === "funnel") {
            dataSetAll(data, "value", 1);
            chart.setSeriesProperty("dataLabels.visible", false, true)
        } else if (chartType === "marker") {
            dataSetAll(data, "size", 1);
            chart.series.forEach(function(el) {
                if (!el.dataLabels || !el.dataLabels.content)
                    return;
                var c = el.dataLabels.content;
                if (c === "x" && missing.includes("size") || missing.includes(c))
                    el.dataLabels.visible = false
            })
        } else if (chartType === "tagcloud") {
            if (missing.includes("value"))
                dataSetAll(data, "value", 1);
            if (missing.includes("color"))
                dataSetAll(data, "color", 1)
        }
        if (hide)
            if (!missing.includes(dataConfig.defaultField))
                chart.setSeriesProperty("dataLabels.fallbackContent", dataConfig.defaultField, true);
            else {
                var fallback = getFallbackFieldAvailable(chart, dataConfig, missing);
                if (fallback)
                    chart.setSeriesProperty("dataLabels.fallbackContent", fallback, true);
                else
                    chart.setSeriesProperty("dataLabels.visible", false, true)
            }
    }
    ;
    tdgchart.prototype.adjustData = function(data) {
        if (data.length === 0)
            return data;
        var startStop = haveSparseTimeData(this);
        if (startStop != null) {
            var newData = [];
            var timeLabels = getTimeAxisLabels(this);
            var groupLabels = this.groupLabels;
            for (var i = 0; i < data.length; i++) {
                newData.push([]);
                for (var j = 0, gidx = 0; j < timeLabels.length; j++)
                    if (groupLabels[gidx] === timeLabels[j]) {
                        newData[i].push(data[i][gidx]);
                        gidx += 1
                    } else
                        newData[i].push(null)
            }
            data = newData
        }
        function nullToUndef(el) {
            if (Array.isArray(el)) {
                for (var i = 0; i < el.length; i++)
                    el[i] = nullToUndef(el[i]);
                return el
            } else
                return el === null ? undefined : el
        }
        data = nullToUndef(data);
        var chartType = this.chartType === "matrix" ? this.matrixProperties.chartType : this.chartType;
        var isBLA = chartType === "bar" || chartType === "line" || chartType === "area";
        if (isBLA && this.blaProperties.seriesLayout === "percent")
            data = convertODataToPercent(data, this);
        if (isBLA || this.chartType === "waterfall") {
            var percent = isBLA && this.blaProperties.seriesLayout === "percent";
            data.forEach(function(r) {
                r.forEach(function(d, i) {
                    if (d != null)
                        d.y = percent ? d.percent : d.value;
                    else
                        r[i] = {
                            y: undefined
                        }
                })
            })
        }
        var range = getDataRange(this);
        if (range)
            data = data.map(function(el) {
                return el.slice(range.start, range.end)
            });
        else {
            var gc = this.groupCount();
            data = data.map(function(el) {
                return el.slice(0, gc)
            })
        }
        return data
    }
    ;
    tdgchart.prototype.getSeriesLabels = function(entries, ignoreSwap) {
        var chart = this;
        var i, sid, labels = [];
        if (chart.chartType === "pareto")
            entries = 2;
        var seriesCount = Math.max(chart.seriesCount(), entries == null ? 0 : entries);
        ignoreSwap = ignoreSwap == null ? false : ignoreSwap;
        if (chart.swapDataAndLabels && !ignoreSwap)
            return chart.getGroupLabels(seriesCount, true);
        if (chart.chartType === "gantt")
            if (chart.data[0][0] && chart.data[0][0].series != null)
                seriesCount = tdg.maxR(chart.data, function(el) {
                    return el.series == null ? 0 : el.series + 1
                });
        var defaultLabel = (chart.getDefaultSeries() || {}).label || tdgchart.translations.SERIES;
        for (i = 0; i < seriesCount; i++) {
            sid = i;
            if (!tdg.isEmpty(chart.pieDrillSeriesMap))
                sid = chart.pieDrillSeriesMap[chart.pieDrillSeriesMap.length - 1][i];
            else if (chart._internalData && chart._internalData.hasOwnProperty("seriesMap") && chart._internalData.seriesMap[i] != null)
                sid = chart._internalData.seriesMap[i];
            else if (chart.cache.hasKey("treemapSeriesMap"))
                sid = chart.cache.get("treemapSeriesMap")[i];
            var lbl = defaultLabel + " " + sid;
            var s = chart.getSeries(sid);
            if (s && s.hasOwnProperty("label"))
                lbl = s.label;
            else if (ignoreSwap) {
                s = chart.getSeries(i);
                if (s && s.hasOwnProperty("label"))
                    lbl = s.label
            }
            if (lbl == null)
                labels.push({
                    visible: false
                });
            else
                labels.push(new String(lbl))
        }
        if (chart.chartType === "pie" && chart.pieProperties.otherSlice.threshold != null) {
            var haveOther = false;
            var otherIndices = chart.getOtherSliceIndices();
            for (i = 0; i < labels.length; i++) {
                sid = i;
                if (chart._internalData.hasOwnProperty("seriesMap") && chart._internalData.seriesMap[i] != null)
                    sid = chart._internalData.seriesMap[i];
                if (otherIndices.indexOf(sid) >= 0) {
                    haveOther = true;
                    labels[i].visible = false;
                    if (entries != null)
                        entries += 1
                }
            }
            if (haveOther) {
                if (entries != null)
                    entries += 1;
                var otherStr = new String(chart.pieProperties.otherSlice.legendLabel || tdgchart.translations.OTHER);
                otherStr.isOtherSlice = true;
                labels.push(otherStr)
            }
        }
        labels = entries == null ? labels.slice(0) : labels.slice(0, entries);
        return labels
    }
    ;
    function formatTimeLabel(date, interval, count, format) {
        if (format != null)
            return date.toString(format);
        switch (interval) {
        case "years":
            return date.toString("yyyy");
        case "months":
            if (date.getMonth() === 0)
                return date.toString("MMM yyyy");
            return date.toString("MMM");
        case "weeks":
            return "Week " + (count + 1);
        case "days":
            if (date.getDate() === 1)
                return date.toString("MMM d");
            return date.toString(" d");
        case "hours":
            return date.toString("H:00");
        case "minutes":
            return date.toString(" m");
        case "seconds":
            return date.toString(" s");
        case "milliseconds":
            return date.getTime();
        default:
            return date.toString()
        }
    }
    function getTimeAxisLabels(chart, groupCount, start, stop) {
        if (groupCount == null)
            groupCount = chart.groupCount();
        var ta = chart.xaxis.timeAxis;
        start = start || Date.parse(ta.startTime);
        stop = stop || Date.parse(ta.stopTime);
        var labels = [];
        var interval = ta.interval;
        var format = ta.labelFormat;
        if (start == null || isNaN(start)) {
            start = Date.parse(chart.groupLabels[0]);
            if (start == null || isNaN(start))
                return null
        }
        if (stop == null || isNaN(stop)) {
            stop = Date.parse(chart.groupLabels[chart.groupLabels.length - 1]);
            if (stop == null || isNaN(stop))
                return null
        }
        if (interval == null) {
            interval = calculateTimeInterval(start, stop, groupCount);
            chart.cache.set("xaxis_time_interval", interval)
        }
        var settings = {};
        var localStart = new Date(start);
        settings[interval] = 1;
        while (localStart < stop && labels.length < groupCount - 1) {
            labels.push(formatTimeLabel(localStart, interval, labels.length, format));
            localStart.add(settings)
        }
        labels.push(formatTimeLabel(localStart, interval, labels.length, format));
        return labels
    }
    tdgchart.prototype.getTimeAxisLabels = getTimeAxisLabels;
    function pruneMatrixLabels(labels, compressedGroups) {
        labels = tdg.clone(labels);
        if (tdg.isNestedLabels(labels)) {
            var compressedCols = compressedGroups.map(function(el, idx) {
                return el ? idx : null
            }).filter(tdg.isNotEmpty);
            return pruneNestedCompressedLabels(labels, compressedCols)
        }
        for (var i = labels.length - 1; i >= 0; i--)
            if (compressedGroups[i])
                labels.splice(i, 1);
        return labels
    }
    function pruneNestedCompressedLabels(labels, compressedGroups) {
        if (!compressedGroups || compressedGroups.length <= 0)
            return labels;
        var leafIdx = 0;
        function traverse(label) {
            var i, matches = [];
            if (label[0] && typeof label[0] === "object")
                for (i = 0; i < label.length; i++) {
                    var v = label[i];
                    for (var key in v)
                        if (v.hasOwnProperty(key)) {
                            var res = traverse(v[key]);
                            if (res && res.length) {
                                var ret = {};
                                ret[key] = res;
                                matches.push(ret)
                            }
                        }
                }
            else {
                for (i = 0; i < label.length; i++)
                    if (!compressedGroups.includes(i + leafIdx))
                        matches.push(label[i]);
                leafIdx += label.length
            }
            return matches
        }
        return traverse(labels)
    }
    function getCompressedLabels(chart, colIdx) {
        var lblList = [];
        var i, compGroups, axisCount;
        if (chart.cache.hasKey("matrixCompressedGroups")) {
            var compInfo = chart.cache.get("matrixCompressedGroups");
            axisCount = compInfo.groupCountArray[colIdx];
            compGroups = compInfo.compressedGroups[colIdx]
        } else {
            compGroups = chart.cache.get("compressedGroups");
            axisCount = chart.groupCount()
        }
        var labels = chart.groupLabels;
        if (tdg.isNestedLabels(labels)) {
            var concatSymbol = chart.get("axisList.x1.labels.nestingConcatSymbol");
            if (concatSymbol == null) {
                var pruned = pruneNestedCompressedLabels(labels, compGroups);
                return getNestedGroupLabels(pruned)
            } else
                labels = tdg.flattenNestedLabels(labels, concatSymbol)
        }
        for (i = 0; lblList.length < axisCount && i < labels.length; i++)
            if (compGroups.indexOf(i) < 0)
                lblList.push(labels[i]);
        if (!chart.isXTimeAxis())
            if (lblList.length < axisCount)
                for (i = 0; lblList.length < axisCount; i++)
                    if (compGroups.indexOf(i) < 0)
                        lblList.push(tdgchart.translations.GROUP + " " + i);
        return lblList
    }
    function getNestedGroupLabels(labels, groupCount) {
        var d = 0
          , leafCount = 0;
        var labelInfo = {
            labels: [],
            depths: []
        };
        function findLeaves(info, labelList, depth) {
            for (var i = 0; i < labelList.length; i++) {
                var node = labelList[i];
                if (typeof node === "object")
                    for (var key in node) {
                        if (node.hasOwnProperty(key) && (groupCount == null || leafCount < groupCount)) {
                            info = findLeaves(info, node[key], depth + 1);
                            info.labels.push(key);
                            info.depths.push(depth);
                            d = Math.max(d, depth)
                        }
                    }
                else {
                    leafCount += 1;
                    info.labels.push(node);
                    info.depths.push(Infinity);
                    d = Math.max(d, depth);
                    if (groupCount != null && leafCount >= groupCount)
                        break
                }
            }
            return labelInfo
        }
        labelInfo = findLeaves(labelInfo, labels, 1);
        var res = labelInfo.labels;
        res.nestedLeafCount = leafCount;
        res.nestedOrdAxisDepth = d;
        res.nestedOrdAxisDepthList = labelInfo.depths.map(function(el) {
            return isFinite(el) ? el : d
        });
        return res
    }
    tdgchart.prototype.getGroupLabels = function(groupCount, ignoreSwap, compressedGroupsAxisNum, idx) {
        var chart = this;
        var i, labels = [];
        idx = idx || 0;
        if (chart.cache.hasKey("xaxis_time_scale"))
            return chart.cache.get("xaxis_time_scale").labels;
        if (chart.showNullGroups === false && compressedGroupsAxisNum != null && hasCompressedGroups(chart))
            return getCompressedLabels(chart, compressedGroupsAxisNum);
        if (groupCount == null)
            groupCount = chart.groupCount();
        if (ignoreSwap == null)
            ignoreSwap = false;
        if (chart.swapDataAndLabels && !ignoreSwap)
            return chart.getSeriesLabels(groupCount, true);
        if (chart.xaxis.timeAxis.enabled && chart.needXOrdinalAxis()) {
            labels = getTimeAxisLabels(chart, groupCount);
            if (labels != null)
                return labels
        }
        if (chart.chartType === "histogram" || chart.chartType === "matrix" && chart.matrixProperties.chartType === "histogram")
            return chart.buildHistogramGroupLabels();
        else if (chart.chartType === "treemap")
            return [];
        var dataRange = getDataRange(chart);
        if (dataRange && !ignoreSwap)
            groupCount = Math.min(groupCount, dataRange.end - dataRange.start);
        if (!dataRange || ignoreSwap)
            dataRange = {
                start: 0,
                end: groupCount
            };
        if (typeof chart.groupLabels === "string")
            labels = chart.groupLabels.split(" ").slice(dataRange.start, dataRange.end);
        else if (tdg.isNestedLabels(chart.groupLabels)) {
            var concatSymbol = chart.get("axisList.x1.labels.nestingConcatSymbol");
            if (concatSymbol == null)
                labels = getNestedGroupLabels(chart.groupLabels, groupCount);
            else {
                labels = tdg.flattenNestedLabels(chart.groupLabels, concatSymbol);
                labels = labels.slice(dataRange.start, dataRange.end)
            }
        } else if (Array.isArray(chart.groupLabels)) {
            var lblSlice = chart.groupLabels;
            if (chart.groupLabels[idx] && Array.isArray(chart.groupLabels[idx]))
                lblSlice = chart.groupLabels[idx];
            else if (chart.groupLabels[0] && Array.isArray(chart.groupLabels[0]))
                lblSlice = chart.groupLabels[0];
            labels = lblSlice.slice(dataRange.start, dataRange.end)
        }
        if (!labels.nestedOrdAxisDepthList)
            for (i = labels.length; i < groupCount; i++)
                labels.push(tdgchart.translations.GROUP + " " + i);
        if (chart.chartType === "waterfall" && chart.waterfallProperties.appendTotalRiser && chart.waterfallProperties.totalLabel)
            labels[groupCount - 1] = chart.waterfallProperties.totalLabel;
        return labels
    }
    ;
    tdgchart.prototype.getOriginalGroupLabels = function() {
        return this.cache.get("originalGroupLabels") || this.getGroupLabels()
    }
    ;
    tdgchart.prototype.getGroupLabel = function(groupID) {
        var chart = this
          , labels = [];
        if (typeof chart.groupLabels === "string")
            labels = chart.groupLabels.split(" ");
        else if (tdg.isNestedLabels(chart.groupLabels))
            if (chart.cache.hasKey("flatNestedLabelList"))
                labels = chart.cache.get("flatNestedLabelList");
            else
                labels = chart.cache.set("flatNestedLabelList", tdg.flattenNestedLabels(chart.groupLabels));
        else if (Array.isArray(chart.groupLabels))
            labels = chart.cache.get("originalGroupLabels") || chart.groupLabels;
        return labels[groupID] || tdgchart.translations.GROUP + " " + groupID
    }
    ;
    tdgchart.prototype.getSeriesLabel = function(index) {
        var s = this.getSeries(index);
        if (s && s.hasOwnProperty("originalLabel"))
            return s.originalLabel;
        return s && s.label ? s.label : tdgchart.translations.SERIES + " " + index
    }
    ;
    tdgchart.prototype.getNestedGroupLabel = function(groupID, qualifyPath) {
        var idx = 0;
        function traverse(labels, currentLabel) {
            if (labels[0] && typeof labels[0] === "object")
                for (var i = 0; i < labels.length; i++) {
                    var v = labels[i];
                    for (var key in v)
                        if (v.hasOwnProperty(key)) {
                            var newLabel = currentLabel ? currentLabel + " > " + key : key;
                            if (idx === groupID)
                                return qualifyPath ? newLabel : key;
                            idx += 1;
                            var res = traverse(v[key], newLabel);
                            if (res)
                                return res
                        }
                }
            else
                for (var j = 0; j < labels.length; j++) {
                    if (idx === groupID)
                        return qualifyPath ? currentLabel + " > " + labels[j] : labels[j];
                    idx += 1
                }
        }
        return traverse(this.groupLabels, "")
    }
    ;
    tdgchart.prototype.getGroupSum = function(g, s, data, odataKey, axisID, matrixRow, matrixCol) {
        var chart = this;
        var assignments, axisModes = chart.cache.get("axisModes", {});
        data = data || chart.data;
        odataKey = odataKey || "value";
        if (chart.chartType === "bubble" || chart.chartType === "scatter") {
            var k, v, groupLabel = chart.getGroupLabel(g);
            if (odataKey === "x" && axisModes.y1 === "ordinal") {
                k = "y";
                v = "x"
            } else if (odataKey === "y" && axisModes.x1 === "ordinal") {
                k = "x";
                v = "y"
            }
            if (k && v)
                return tdg.sum(data, function(el) {
                    return tdg.sum(el, function(el2) {
                        return el2[k] === groupLabel ? el2[v] : 0
                    })
                })
        }
        if (axisID == null) {
            var needY2 = chart.needDualY2Axis() && s != null;
            if (needY2)
                axisID = chart.getSeriesAndGroupProperty(s, g, "yAxisAssignment") || 1;
            else if (chart.isBLA() && chart.splitNumericAxis.splitY.enabled)
                data = data.map(function(seriesData) {
                    return seriesData.map(function(datum) {
                        var value = 0;
                        (chart.dataArrayMap || [odataKey]).forEach(function(e) {
                            if (typeof e === "string" && (e.toLowerCase() === "value" || e.startsWith("y")))
                                value += (datum || [])[e] || 0
                        });
                        var res = {};
                        res[odataKey] = value;
                        return res
                    })
                })
        }
        var dataSet = data;
        if (chart.chartType === "matrix" && matrixRow != undefined && matrixCol != undefined)
            dataSet = (data[matrixRow] || [])[matrixCol] || [];
        if (axisID != null) {
            assignments = chart.getAxisAssignment(dataSet);
            if (Array.isArray(chart.dataArrayMap) && (chart.dataArrayMap.includes("y" + axisID) || axisID === 1 && chart.dataArrayMap.includes("value"))) {
                fieldID = axisID === 1 ? "value" : "y" + axisID;
                dataSet = dataSet.map(function(seriesData, idx) {
                    if (fieldID == "value" && assignments[idx] !== axisID)
                        return [];
                    return seriesData.map(function(datum) {
                        var res = {};
                        res[odataKey] = datum[fieldID];
                        return res
                    })
                })
            } else
                dataSet = dataSet.filter(function(el, idx) {
                    return assignments[idx] === axisID
                })
        }
        return tdg.sum(dataSet.map(function(el) {
            if (tdg.isANumber(el[g]))
                return el[g];
            return el[g] && el[g][odataKey] != null ? el[g][odataKey] : 0
        }))
    }
    ;
    tdgchart.prototype.is3levelData = function(data) {
        var a = Array.isArray;
        return a(data) && data.length > 0 && a(data[0]) && data[0].length > 0
    }
    ;
    tdgchart.prototype.is5levelData = function(data) {
        var a = Array.isArray;
        return a(data) && data.length > 0 && a(data[0]) && data[0].length > 0 && a(data[0][0]) && data[0][0].length > 0 && a(data[0][0][0]) && data[0][0][0].length > 0
    }
    ;
    function roundDateToPeriod(time, period) {
        var t = new Date(time);
        function rnd(value, round) {
            return parseInt(value / round) * round
        }
        switch (period) {
        case 6E4:
            t.setUTCSeconds(0);
            return t.getTime();
        case 18E4:
            t.setUTCSeconds(0);
            t.setUTCMinutes(rnd(t.getUTCMinutes(), 3));
            return t.getTime();
        case 9E5:
            t.setUTCSeconds(0);
            t.setUTCMinutes(rnd(t.getUTCMinutes(), 15));
            return t.getTime();
        case 36E5:
            t.setUTCSeconds(0);
            t.setUTCMinutes(0);
            return t.getTime();
        case 108E5:
            t.setUTCSeconds(0);
            t.setUTCMinutes(0);
            t.setUTCHours(rnd(t.getUTCHours(), 3));
            return t.getTime();
        case 216E5:
            t.setUTCSeconds(0);
            t.setUTCMinutes(0);
            t.setUTCHours(rnd(t.getUTCHours(), 6));
            return t.getTime();
        case 432E5:
            t.setUTCSeconds(0);
            t.setUTCMinutes(0);
            t.setUTCHours(rnd(t.getUTCHours(), 12));
            return t.getTime();
        case 864E5:
            t.setUTCSeconds(0);
            t.setUTCMinutes(0);
            t.setUTCHours(0);
            return t.getTime();
        case 6048E5:
            t.setUTCSeconds(0);
            t.setUTCMinutes(0);
            t.setUTCHours(0);
            t.setUTCDay(1);
            return t.getTime();
        case 12096E5:
            t.setUTCSeconds(0);
            t.setUTCMinutes(0);
            t.setUTCHours(0);
            t.setUTCDay(1);
            return t.getTime();
        case 24192E5:
            t.setUTCSeconds(0);
            t.setUTCMinutes(0);
            t.setUTCHours(0);
            t.setUTCDay(1);
            return t.getTime();
        case 2592E6:
            t.setUTCSeconds(0);
            t.setUTCMinutes(0);
            t.setUTCHours(0);
            t.setUTCDate(1);
            return t.getTime()
        }
        return time
    }
    var aggregationRulesDataScience = [{
        above: 0,
        precision: 30 * tdgchart.d3_time.time.minute.duration
    }, {
        above: 5 * tdgchart.d3_time.time.day.duration,
        precision: 1 * tdgchart.d3_time.time.day.duration
    }, {
        above: 1 * tdgchart.d3_time.time.year.duration,
        precision: 1 * tdgchart.d3_time.time.week.duration
    }, {
        above: 5 * tdgchart.d3_time.time.year.duration,
        precision: 4 * tdgchart.d3_time.time.week.duration
    }];
    var aggregationRules = [{
        above: 1 * tdgchart.d3_time.time.minute.duration,
        precision: 1 * tdgchart.d3_time.time.second.duration
    }, {
        above: 1 * tdgchart.d3_time.time.hour.duration,
        precision: 1 * tdgchart.d3_time.time.minute.duration
    }, {
        above: 3 * tdgchart.d3_time.time.hour.duration,
        precision: 1 * tdgchart.d3_time.time.minute.duration
    }, {
        above: 6 * tdgchart.d3_time.time.hour.duration,
        precision: 1 * tdgchart.d3_time.time.minute.duration
    }, {
        above: 12 * tdgchart.d3_time.time.hour.duration,
        precision: 3 * tdgchart.d3_time.time.minute.duration
    }, {
        above: 1 * tdgchart.d3_time.time.day.duration,
        precision: 3 * tdgchart.d3_time.time.minute.duration
    }, {
        above: 3 * tdgchart.d3_time.time.day.duration,
        precision: 15 * tdgchart.d3_time.time.minute.duration
    }, {
        above: 1 * tdgchart.d3_time.time.week.duration,
        precision: 15 * tdgchart.d3_time.time.minute.duration
    }, {
        above: 2 * tdgchart.d3_time.time.week.duration,
        precision: 1 * tdgchart.d3_time.time.hour.duration
    }, {
        above: 1 * tdgchart.d3_time.time.month.duration,
        precision: 3 * tdgchart.d3_time.time.hour.duration
    }, {
        above: 3 * tdgchart.d3_time.time.month.duration,
        precision: 3 * tdgchart.d3_time.time.hour.duration
    }, {
        above: 6 * tdgchart.d3_time.time.month.duration,
        precision: 1 * tdgchart.d3_time.time.day.duration
    }, {
        above: 1 * tdgchart.d3_time.time.year.duration,
        precision: 1 * tdgchart.d3_time.time.day.duration
    }, {
        above: 3 * tdgchart.d3_time.time.year.duration,
        precision: 1 * tdgchart.d3_time.time.week.duration
    }, {
        above: 5 * tdgchart.d3_time.time.year.duration,
        precision: 1 * tdgchart.d3_time.time.week.duration
    }, {
        above: 10 * tdgchart.d3_time.time.year.duration,
        precision: 2 * tdgchart.d3_time.time.week.duration
    }, {
        above: 20 * tdgchart.d3_time.time.year.duration,
        precision: 1 * tdgchart.d3_time.time.month.duration
    }];
    function getAggregation(minMax, rules) {
        rules = rules || aggregationRules;
        var duration = minMax.max - minMax.min;
        var aggrDuration = undefined;
        for (var i = 0; i < rules.length; i++)
            if (duration > rules[i].above)
                aggrDuration = rules[i].precision;
        return aggrDuration
    }
    tdgchart.prototype.aggregateTimeData = function(data) {
        var chart = this;
        if (!chart.xaxis.timeAxis.dataAggregation.enabled)
            return undefined;
        var field = chart.getDefaultDataField() || "value";
        var times = chart.groupLabels.map(function(el) {
            return tdgchart.d3_time.timeCanonicalParse(el)
        });
        var range = times.map(function(t) {
            return t.getTime()
        });
        var minMax = tdg.minMax(times);
        var interval = chart.xaxis.timeAxis.dataAggregation.interval;
        if (interval == "autods" || !interval > 0)
            interval = getAggregation(minMax, aggregationRulesDataScience);
        else if (interval == "auto" || !interval > 0)
            interval = getAggregation(minMax);
        else
            interval *= 1E3;
        data = data || chart.data;
        var runningAverage = chart.xaxis.timeAxis.dataAggregation.runningRange > 0 ? chart.xaxis.timeAxis.dataAggregation.runningRange : 0;
        var roundedStart = chart.xaxis.timeAxis.dataAggregation.round ? roundDateToPeriod(range[0], interval) : range[0];
        var newData = [];
        var needRangeArray = ["min", "max", "first", "last"].indexOf(chart.xaxis.timeAxis.dataAggregation.method) != -1;
        var newGroupLabels = [];
        for (var s = 0; s < data.length; s++) {
            var now = roundedStart;
            var fromDate = now - interval * runningAverage;
            var toDate = now + interval * (runningAverage || 1);
            var fromIdx = 0
              , toIdx = 0;
            var sumInRunningRange = 0;
            var countInRunningRange = 0;
            var countInCurrentInterval = 0;
            var rangeArray = [];
            var newSeriesData = [];
            do {
                if (0 && !runningAverage) {
                    countInRunningRange = 0;
                    sumInRunningRange = 0;
                    fromIdx = toIdx + 1;
                    rangeArray = []
                } else
                    while (range[fromIdx] < fromDate) {
                        if (fromIdx < toIdx && data[s][fromIdx][field] != undefined) {
                            if (needRangeArray)
                                rangeArray.shift();
                            sumInRunningRange -= data[s][fromIdx][field];
                            countInRunningRange--
                        }
                        fromIdx++
                    }
                countInCurrentInterval = 0;
                while (toIdx < range.length && range[toIdx] < toDate) {
                    if (data[s][toIdx][field] != undefined) {
                        if (needRangeArray)
                            rangeArray.push(data[s][toIdx][field]);
                        sumInRunningRange += data[s][toIdx][field];
                        countInRunningRange++;
                        countInCurrentInterval++
                    }
                    toIdx++
                }
                var dp = null;
                if (countInCurrentInterval)
                    switch (chart.xaxis.timeAxis.dataAggregation.method) {
                    case "min":
                        dp = rangeArray.reduce(function(a, b) {
                            return Math.min(a, b)
                        });
                        break;
                    case "max":
                        dp = rangeArray.reduce(function(a, b) {
                            return Math.max(a, b)
                        });
                        break;
                    case "first":
                        dp = rangeArray[0];
                        break;
                    case "last":
                        dp = rangeArray[rangeArray.length - 1];
                        break;
                    case "average":
                    default:
                        dp = sumInRunningRange / countInRunningRange;
                        break
                    }
                var value = {
                    _s: s,
                    _g: newSeriesData.length,
                    axis: data[s][0] && data[s][0].axis
                };
                value[field] = dp;
                newSeriesData.push(value);
                if (s == 0)
                    newGroupLabels.push(now);
                now += interval;
                fromDate += interval;
                toDate += interval
            } while (toIdx < range.length);
            newData.push(newSeriesData)
        }
        newData.isObjective = true;
        function timestring(m) {
            m = typeof m == "object" ? m : new Date(m);
            return m.getUTCFullYear() + ("0" + (m.getUTCMonth() + 1)).slice(-2) + ("0" + m.getUTCDate()).slice(-2) + " " + ("0" + m.getUTCHours()).slice(-2) + ":" + ("0" + m.getUTCMinutes()).slice(-2) + ":" + ("0" + m.getUTCSeconds()).slice(-2) + ".000"
        }
        return {
            data: newData,
            groupLabels: newGroupLabels.map(timestring)
        }
    }
    ;
    tdgchart.prototype.sortData = function(data, sort, defaultKey) {
        var chart = this;
        if (!tdg.isEmpty(sort)) {
            if (typeof sort === "string")
                sort = {
                    by: defaultKey || "label",
                    order: sort.toLowerCase() === "ascending" ? "ascending" : "descending"
                };
            for (var i = 0; i < data.length; i++)
                data[i] = sortOneGroup(chart, data[i], sort)
        }
        return data
    }
    ;
    function sortBy(data, key, order) {
        if (order === "ascending")
            return data.sort(function(a, b) {
                if (a[key] == undefined && b[key] == undefined)
                    return 0;
                if (a[key] == undefined)
                    return -1;
                if (b[key] == undefined)
                    return 1;
                return a[key] > b[key] ? 1 : a[key] < b[key] ? -1 : 0
            });
        else
            return data.sort(function(a, b) {
                if (a[key] == undefined && b[key] == undefined)
                    return 0;
                if (a[key] == undefined)
                    return 1;
                if (b[key] == undefined)
                    return -1;
                return a[key] < b[key] ? 1 : a[key] > b[key] ? -1 : 0
            })
    }
    function sortOneGroup(chart, data, sort) {
        if (sort.by === "value")
            return sortBy(data, "value", sort.order);
        else if (Array.isArray(chart.dataArrayMap) && chart.dataArrayMap.includes(sort.by))
            return sortBy(data, sort.by, sort.order);
        else {
            for (var i = 0; i < data.length; i++)
                data[i]._label = chart.getSeriesLabel(data[i]._s);
            return sortBy(data, "_label", sort.order)
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    function getBarWidthScale(chart, data, odata_key, x, barSizeMinMax) {
        var minMax = barSizeMinMax || chart.getDataSetMinMax({}, "", data, "absolute", odata_key);
        var min = minMax.min < 0 ? 0 : minMax.min;
        var max = Math.max(Math.abs(minMax.min), Math.abs(minMax.max));
        var layout = chart.getRiserSeriesLayout("bar");
        var maxWidth = layout === "sidebyside" ? x.range().band / x.seriesCount : x.range().band;
        var minWidth = tdg.applyNumOrPercent(chart.zaxis.marker.minSize || 0, maxWidth);
        minWidth = tdg.bound(minWidth, 2, maxWidth);
        return pv.Scale.linear(min, max).range(minWidth, maxWidth)
    }
    function getLineWidthScale(chart, data, odata_key, y) {
        var minMax = chart.getScaleMinMax({}, "", data || this._internalData, null, odata_key || "size");
        var maxRange = y.range()[1] * .2;
        return pv.Scale.linear(minMax.min, minMax.max).range(1, maxRange)
    }
    function hasSizeScaleData(data) {
        return data.some(function(r) {
            return r.some(function(d) {
                return typeof d === "object" && d.size != null
            })
        })
    }
    tdgchart.prototype.dataTextAnchorOverride = function(invert, isStacked, overrides) {
        var chart = this;
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        var positions = chart.getSeriesPropertyList("dataLabels.position");
        var res = positions.map(function(el) {
            return dataTextAnchorHelper(invert, isStacked, el || "center", isHorizontal)
        });
        overrides = overrides || [];
        var positionOverrides = overrides.map(function(override) {
            return override && override.position ? dataTextAnchorHelper(invert, isStacked, override.position || "center", isHorizontal) : null
        });
        function resLookup(d, idx) {
            if (positionOverrides[this.index])
                return positionOverrides[this.index][idx].apply(this, arguments);
            if (res[d._s] && typeof res[d._s][idx] === "function")
                return res[d._s][idx].apply(this, arguments);
            else if (res[0] && typeof res[0][idx] === "function")
                return res[0][idx].apply(this, arguments);
            return positions[0]
        }
        return {
            anchor: tdg.partial(resLookup, [null, 0]),
            properties: {
                textAlign: tdg.partial(resLookup, [null, 1]),
                textBaseline: tdg.partial(resLookup, [null, 2])
            }
        }
    }
    ;
    tdgchart.prototype.dataTextAnchor = function(invert, isStacked) {
        return this.dataTextAnchorOverride(invert, isStacked, null)
    }
    ;
    function dataTextAnchorHelper(invert, isStacked, position, isHorizontal) {
        position = position.toLowerCase();
        if (isStacked)
            if (position === "top" || position === "right" || position === "insidetop")
                position = "insidetop";
            else if (position === "bottom" || position === "left" || position === "insidebottom")
                position = "insidebottom";
            else
                position = "center";
        function posFactory(a, b) {
            return function() {
                return invert(this) ? a : b
            }
        }
        var bottomTop = posFactory("bottom", "top");
        var topBottom = posFactory("top", "bottom");
        var leftRight = posFactory("left", "right");
        var rightLeft = posFactory("right", "left");
        var identity = function(v) {
            return function() {
                return v
            }
        };
        if (isHorizontal)
            switch (position) {
            case "top":
            case "right":
                return [leftRight, rightLeft, identity("middle")];
            case "bottom":
            case "left":
                return [rightLeft, leftRight, identity("middle")];
            case "insidetop":
                return [leftRight, leftRight, identity("middle")];
            case "insidebottom":
                return [rightLeft, rightLeft, identity("middle")]
            }
        else
            switch (position) {
            case "top":
            case "right":
                return [bottomTop, identity("center"), topBottom];
            case "bottom":
            case "left":
                return [topBottom, identity("center"), bottomTop];
            case "insidetop":
                return [bottomTop, identity("center"), bottomTop];
            case "insidebottom":
                return [topBottom, identity("center"), topBottom]
            }
        return [identity("center"), identity("center"), identity("middle")]
    }
    tdgchart.prototype.anySeriesHaveMarkers = function(data, checkAll) {
        var chart = this;
        var haveMarkers = false;
        if (((chart.getDefaultSeries() || {}).marker || {}).visible)
            return true;
        var seriesIDs = data.map(function(el) {
            return el && el[0] ? el[0]._s : null
        });
        for (var i = 0; i < seriesIDs.length; i++) {
            m = (chart.getSeries(seriesIDs[i]) || {}).marker;
            haveMarkers = haveMarkers || !!(m && m.visible)
        }
        return haveMarkers
    }
    ;
    tdgchart.prototype.addMarkers = function(riser, data) {
        var chart = this;
        var m, chartType = chart.chartType, forceMarkers = false;
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        var haveMarkers = chart.anySeriesHaveMarkers(data);
        if (chartType === "line" || chartType === "area")
            forceMarkers = tdg.max(data, "length") <= 1;
        haveMarkers = haveMarkers || forceMarkers;
        var visibleCallback = chart.seriesPropertyLookup("marker.visible");
        function markerIsVisible(m, d, data, i) {
            if (chartType == "radar" && i == data.length - 1)
                return false;
            return forceMarkers || chartType !== "area" && chartType !== "streamgraph" && visibleCallback.call(m, d)
        }
        var mustGenerateMarkers = chart.mouseOverIndicator.enabled || chart.needHTMLToolTip() || chart.dataSelection.enabled || haveMarkers && chartType === "line" && chart.areDataLabelsVisible();
        if (!haveMarkers && !mustGenerateMarkers && !chart.accessibility.navigation.enabled)
            return null;
        var anchor = isHorizontal ? "right" : "top";
        function aa(d) {
            var riserShape = chart.getSeriesAndGroupProperty(d._s, null, "riserShape") || chartType;
            return riserShape === "line" ? "center" : anchor
        }
        var accessibilityMarkersCount = 0
          , limit = chart.accessibility.navigation.tabLimit;
        var marker = riser.anchor(aa).add(pv.Dot).className(chart.classNameLookup(chart.depth25d() ? " marker25d" : "marker", "marker")).display(function(d, data) {
            if (d == null || !mustGenerateMarkers)
                return null;
            return markerIsVisible(this, d, data, this.index) ? null : "none"
        }).title(chart.seriesToolTipLookup()).includeRadius(chart.mouseOverIndicator.enabled || chart.needHTMLToolTip()).visible(function(d, data) {
            var generateAccessibilityMarker = chart.accessibility.navigation.enabled && (limit == undefined || accessibilityMarkersCount++ < limit);
            return d.value != null && (mustGenerateMarkers || generateAccessibilityMarker ? true : markerIsVisible(this, d, data, this.index))
        });
        function markerInvisibleWrapper(prop, markerProp) {
            return function(d) {
                if (d == null)
                    return null;
                return visibleCallback.call(this, d) && chartType !== "area" ? prop.call(this, d) : markerProp
            }
        }
        function shadowParam(d) {
            if (d != null && visibleCallback.call(this, d))
                return chart.riserShadow ? "parent" : null;
            return null
        }
        m = chart.mouseOverIndicator.marker;
        if (m)
            marker.fillStyle(markerInvisibleWrapper(chart.markerFillStyle(), m.color || "white")).strokeStyle(markerInvisibleWrapper(chart.markerStrokeStyle(), m.border.color || "black")).lineWidth(markerInvisibleWrapper(chart.seriesPropertyLookup("marker.border.width"), m.border.width || 1)).dashStyle(markerInvisibleWrapper(chart.seriesPropertyLookup("marker.border.dash"), m.border.dash || "")).shape(markerInvisibleWrapper(chart.seriesMarkerShapeLookup(), m.shape || "circle")).angle(markerInvisibleWrapper(chart.markerRotationLookup(), tdg.radians(m.rotation) || 0)).radius(markerInvisibleWrapper(chart.dataDrivenMarkerSize(), m.size / 2 || 10)).shadow(shadowParam);
        chart.addBevel(marker);
        return marker
    }
    ;
    function findSingletons(chart, riserList, riserShape) {
        var singletons = []
          , haveSingletons = false;
        var isRadar = chart.chartType == "radar" || chart.chartType === "matrix" && chart.matrixProperties.chartType == "radar";
        if (riserShape === "line" || riserShape === "area")
            for (s = 0; s < riserList.length; s++) {
                var riserSubList = riserList[s];
                if (tdg.isEmpty(riserSubList))
                    continue;
                singletons[s] = [];
                minNotNull = 0;
                for (g = 0; g < riserSubList.length; g++) {
                    var riser = riserSubList[g]
                      , d = riser.d;
                    if (d.value != undefined)
                        minNotNull++;
                    else {
                        if (minNotNull == 1)
                            if (isRadar && g == 1) {
                                if (riserSubList[riserSubList.length - 1].d.value == undefined) {
                                    singletons[s][0] = true;
                                    haveSingletons = true
                                }
                            } else {
                                singletons[s][g - 1] = true;
                                haveSingletons = true
                            }
                        minNotNull = 0
                    }
                }
                if (minNotNull == 1)
                    if (isRadar) {
                        if (riserSubList[0].d.value == undefined) {
                            singletons[s][g - 1] = true;
                            haveSingletons = true
                        }
                    } else {
                        singletons[s][g - 1] = true;
                        haveSingletons = true
                    }
            }
        return haveSingletons ? singletons : null
    }
    tdgchart.prototype.addMarkersScene = function(markerGroup, riserList, data, riserShape, yAxisName, x, riserBaseColorFn) {
        var chart = this;
        var rawChartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        var haveMarkers = false
          , forceMarkers = false;
        var seriesIDs = data.map(function(el) {
            return el && el[0] ? el[0]._s : null
        });
        var m, i, s, g;
        if (riserShape !== "area")
            for (i = 0; i < seriesIDs.length; i++) {
                m = (chart.getSeries(seriesIDs[i]) || {}).marker;
                haveMarkers = haveMarkers || !!(m && m.visible);
                if (haveMarkers)
                    break
            }
        var singletons = findSingletons(chart, riserList, riserShape);
        if (riserShape !== "area")
            haveMarkers = haveMarkers || ((chart.getDefaultSeries() || {}).marker || {}).visible;
        haveMarkers = haveMarkers || singletons;
        var accessibilityMarkersCount = 0
          , limit = chart.accessibility.navigation.tabLimit;
        var mustGenerateMarkers = chart.mouseOverIndicator.enabled || chart.needHTMLToolTip() || chart.dataSelection.enabled;
        if (!haveMarkers && !mustGenerateMarkers && !chart.accessibility.navigation.enabled)
            return;
        var seriesStyle = {};
        var fillLookup = chart.markerFillStyle();
        var borderColorLookup = chart.markerStrokeStyle();
        var shapeLookup = chart.seriesMarkerShapeLookup();
        var sizeLookup = chart.dataDrivenMarkerSize();
        var markers = [];
        for (s = 0; s < riserList.length; s++) {
            var riserSubList = riserList[s];
            if (tdg.isEmpty(riserSubList))
                continue;
            markers[s] = [];
            var seriesGroup = markerGroup.group(null, null, null, null, null, null, seriesStyle);
            for (g = 0; g < riserSubList.length; g++) {
                var riser = riserSubList[g]
                  , d = riser.d;
                if (!riser || !tdg.isANumber(riser.props.x) || !tdg.isANumber(riser.props.y))
                    continue;
                var visible = !!chart.getSerDepProperty("marker.visible", d);
                var ids = {
                    series: s,
                    group: g,
                    object: "marker",
                    misc: "marker",
                    axis: yAxisName
                };
                var shape = chart.applyTemplate(shapeLookup(d), d, riser.data, ids);
                var markerSize = chart.getSerDepProperty("marker.size", d);
                if (markerSize === "groupWidth")
                    riser.props.size = x.range().band;
                else
                    riser.props.size = sizeLookup(d) * 2;
                var rotation = !shape || shape === "circle" ? null : chart.getSerDepProperty("marker.rotation", d);
                var antialias = !tdg.isEmpty(rotation) || pv.SvgScene.shapeRequiresAntiAlias(shape);
                var generateAccessibilityMarker = chart.accessibility.navigation.enabled && (limit == undefined || accessibilityMarkersCount++ < limit);
                if (d._s == undefined && d._g == undefined)
                    continue;
                var markerStyle = {
                    className: chart.getRiserClassName(seriesGroup, d, "marker", "marker", yAxisName),
                    title: chart.getSerDepProperty("tooltip", d),
                    rotation: rotation,
                    antialias: antialias === true ? null : antialias,
                    visible: visible || singletons && singletons[s][g] || generateAccessibilityMarker
                };
                if (visible) {
                    markerStyle.color = fillLookup(d);
                    markerStyle.border = borderColorLookup(d);
                    markerStyle.lineWidth = chart.getSerDepProperty("marker.border.width", d);
                    markerStyle.dash = chart.getSerDepProperty("marker.border.dash", d)
                } else if (singletons && singletons[s][g]) {
                    riserBaseColorFn = riserBaseColorFn || borderColorLookup;
                    markerStyle.color = markerStyle.border = riserBaseColorFn(d, riserShape === "area" ? riserSubList : riserSubList[g].data);
                    markerStyle.lineWidth = 0;
                    markerStyle.dash = "";
                    shape = "circle";
                    var lineWidth = chart.getSerDepProperty("border.width", d) || 4;
                    riser.props.size = Math.max(2, lineWidth) + 2
                } else if (generateAccessibilityMarker) {
                    markerStyle.color = "rgba(0,0,0,0)";
                    markerStyle.border = "rgba(0,0,0,0)"
                } else {
                    var hoverMarker = chart.get("mouseOverIndicator.marker", {});
                    hoverMarker.border = hoverMarker.border || {};
                    markerStyle.color = hoverMarker.color || "white";
                    markerStyle.border = hoverMarker.border.color || "black";
                    markerStyle.lineWidth = hoverMarker.border.width || 1;
                    markerStyle.dash = hoverMarker.border.dash || "";
                    riser.props.size = hoverMarker.size || 10;
                    shape = hoverMarker.shape || "circle"
                }
                if ((chart.htmlToolTip.enabled || chart.mouseOverIndicator.enabled) && shape !== "circle")
                    markerStyle.includeRadius = riser.props.size;
                var pt = riser.props.point || riser.props;
                markers[s][g] = seriesGroup.dot(pt.x, pt.y, riser.props.size, shape, markerStyle)
            }
        }
        chart.addBevel(markers, markerGroup)
    }
    ;
    function drawStackTotalLabels(chart, group, groupWidth, riserList, axisProperties, isHorizontal, isMekko) {
        riserList = tdg.transpose(riserList);
        var i, j, riser, pad = 5;
        var lbl = chart.get("blaProperties.stackTotalLabel", {});
        var labelStyle = {
            className: "stackTotalLabel"
        };
        var dataLabelsVisible = chart.areDataLabelsVisible();
        var groupStyle = {
            font: lbl.font,
            color: lbl.color
        };
        if (riserList[0] && riserList[0].some(function(el) {
            return el && el.riserShape === "line"
        }) && dataLabelsVisible && chart.getSeriesProperty("dataLabels.position").some(function(el) {
            return el === "top"
        })) {
            var seriesList = [];
            for (i = 0; i < riserList.length; i++)
                if (Array.isArray(riserList[i]))
                    for (j = 0; j < riserList[i].length; j++)
                        if (riserList[i][j])
                            seriesList[riserList[i][j]._s] = true;
            var maxFont, maxFontSize = 0;
            for (i = 0; i < seriesList.length; i++)
                if (seriesList[i]) {
                    var font = chart.getSeriesAndGroupProperty(i, null, "dataLabels.font");
                    var fontSize = parseFloat(tdg.fontToFontParts(font).fontSize);
                    if (fontSize > maxFontSize) {
                        maxFontSize = fontSize;
                        maxFont = font
                    }
                }
            var hichertTopOffset = chart.hichertProperties && chart.hichertProperties.dataLabelsPadding || 0;
            pad = tdg.measureFont(maxFont).height + 5 + hichertTopOffset
        }
        var labelGroup = group.group("totallabels", null, null, null, null, null, groupStyle);
        var labelList = [];
        for (i = 0; i < riserList.length; i++) {
            var sum = 0;
            for (j = 0; j < riserList[i].length; j++) {
                riser = (riserList[i] || [])[j];
                if (riser && riser.d && riser.d.value != null)
                    sum += riser.d.value
            }
            labelList.push(sum)
        }
        var labelPadLookup = chart.seriesPropertyLookup("dataLabels.pad");
        var extraPad = labelPadLookup.call(this, {
            series: 0
        }) || 0;
        if (tdg.isPercentString(extraPad))
            extraPad = tdg.applyNumOrPercent(extraPad, parseFloat(tdg.fontToFontParts(lbl.font).fontSize), 0, 100) || 0;
        var labelConfig = [];
        var rotation = lbl.rotation;
        for (i = 0; i < labelList.length; i++) {
            if (!Array.isArray(riserList[i]))
                continue;
            var value = labelList[i];
            var riserGroup = riserList[i] || [];
            if (isHorizontal)
                if (tdg.xor(value < 0, axisProperties.invert)) {
                    riserGroup = riserGroup.filter(function(el) {
                        return el && tdg.isANumber(el.props.x)
                    });
                    riser = tdg.min(riserGroup, "props.x", "key")
                } else {
                    riserGroup = riserGroup.filter(function(el) {
                        return el && tdg.isANumber(el.props.x)
                    });
                    riser = tdg.max(riserGroup, function(el) {
                        return el.props.x + (el.props.w || 0)
                    }, "key")
                }
            else if (tdg.xor(value < 0, axisProperties.invert)) {
                riserGroup = riserGroup.filter(function(el) {
                    return el && tdg.isANumber(el.props.y)
                });
                riser = tdg.max(riserGroup, function(el) {
                    return el.props.y + (el.props.h || 0)
                }, "key")
            } else {
                riserGroup = riserGroup.filter(function(el) {
                    return el && tdgchart.util.isANumber(el.props.y)
                });
                riser = tdg.min(riserGroup, "props.y", "key")
            }
            if (!riser || !riser.props || !lbl.displayZero && value === 0)
                continue;
            var ids = chart.getMarkSeriesAndGroupID(riser, riser.d);
            if (typeof lbl.visible === "function" && !lbl.visible.call(chart, {
                value: value
            }, ids.series, ids.group))
                continue;
            var text = chart.formatNumber(value, lbl.numberFormat, "stackTotalLabel");
            if (isMekko && !isHorizontal) {
                text = chart.truncateLabel(text, lbl.font, riser.props.w);
                if (tdg.measureLabelWidth(text, lbl.font) >= riser.props.w)
                    continue
            }
            labelConfig[i] = {
                text: text,
                riser: riser
            };
            if (rotation == "auto") {
                labelConfig[i].size = chart.measureLabel(labelConfig[i].text, lbl.font);
                if (!isHorizontal && groupWidth / riserList.length < labelConfig[i].size.width)
                    rotation = 270
            }
        }
        if (rotation == "auto")
            rotation = 0;
        var rotationInfo;
        for (i = 0; i < labelList.length; i++) {
            if (!labelConfig[i])
                continue;
            labelStyle = {};
            labelStyle.className = "stackTotalLabel";
            if (rotation) {
                labelStyle.shift = -.15;
                rotationInfo = {
                    rotation: rotation,
                    lblSize: labelConfig[i].size || chart.measureLabel(labelConfig[i].text, lbl.font)
                }
            } else
                rotationInfo = null;
            var anchorConfig = chart.getDataLabelAnchorPoint(labelConfig[i].riser, isHorizontal ? "right" : "top", labelConfig[i].riser.d, "sideBySide", rotationInfo, pad, extraPad);
            tdg.mergeObjects(anchorConfig, labelStyle);
            labelGroup.label(anchorConfig.x, anchorConfig.y, labelConfig[i].text, labelStyle)
        }
    }
    function verticalRoundedTipBar(seriesGroup, datum, riserStyle) {
        var p = new tdgchart.tdgscene.path;
        var roundRadius = Math.round(.14 * datum.width);
        var top = {
            x: 0,
            y: 0
        };
        var bottom = {
            x: 0,
            y: 0
        };
        var count = (datum.onBaseline !== "bottom") + (datum.onBaseline !== "top");
        if (datum.height < 2 * count)
            roundRadius = 0;
        if (roundRadius > 2) {
            if (datum.onBaseline !== "bottom")
                bottom = {
                    x: roundRadius,
                    y: roundRadius
                };
            if (datum.onBaseline !== "top")
                top = {
                    x: roundRadius,
                    y: roundRadius
                };
            if (top.y > datum.height / 2)
                top.y = datum.height / 2;
            if (bottom.y > datum.height / 2)
                bottom.y = datum.height / 2
        }
        p.moveTo(datum.width / 2, 0, true);
        p.lineTo(datum.width / 2 - top.x, 0, true);
        if (top.x)
            p.arcTo(top.x, top.y, 0, 0, 1, top.x, top.y, true);
        p.lineTo(0, datum.height - top.y - bottom.y, true);
        if (bottom.x)
            p.arcTo(bottom.x, bottom.y, 0, 0, 1, -bottom.x, bottom.y, true);
        p.lineTo(-datum.width + 2 * bottom.x, 0, true);
        if (bottom.x)
            p.arcTo(bottom.x, bottom.y, 0, 0, 1, -bottom.x, -bottom.y, true);
        p.lineTo(0, -datum.height + bottom.y + top.y, true);
        if (top.x)
            p.arcTo(top.x, top.y, 0, 0, 1, top.x, -top.y, true);
        p.closePath();
        var riser = seriesGroup.path(datum.x, datum.y, p, riserStyle);
        riser.props.w = datum.width;
        riser.props.h = datum.height;
        return riser
    }
    function horizontalRoundedTipBar(seriesGroup, datum, riserStyle) {
        var p = new tdgchart.tdgscene.path;
        var roundRadius = Math.round(.14 * datum.width);
        var left = {
            x: 0,
            y: 0
        };
        var right = {
            x: 0,
            y: 0
        };
        var count = (datum.onBaseline !== "right") + (datum.onBaseline !== "left");
        if (datum.height < 2 * count)
            roundRadius = 0;
        var x = datum.y
          , y = datum.x;
        var width = datum.height
          , height = datum.width;
        if (roundRadius > 2) {
            if (datum.onBaseline !== "right")
                right = {
                    x: roundRadius,
                    y: roundRadius
                };
            if (datum.onBaseline !== "left")
                left = {
                    x: roundRadius,
                    y: roundRadius
                };
            if (left.x > width / 2)
                left.x = width / 2;
            if (right.x > width / 2)
                right.x = width / 2
        }
        p.moveTo(0, height / 2, true);
        p.lineTo(0, height / 2 - left.y, true);
        if (left.y)
            p.arcTo(left.x, left.y, 0, 0, 0, left.x, left.y, true);
        p.lineTo(width - left.x - right.x, 0, true);
        if (right.y)
            p.arcTo(right.x, right.y, 0, 0, 0, right.x, -right.y, true);
        p.lineTo(0, -height + 2 * right.y, true);
        if (right.y)
            p.arcTo(right.x, right.y, 0, 0, 0, -right.x, -right.y, true);
        p.lineTo(-width + right.x + left.x, 0, true);
        if (left.y)
            p.arcTo(left.x, left.y, 0, 0, 0, -left.x, left.y, true);
        p.closePath();
        var riser = seriesGroup.path(x, y, p, riserStyle);
        riser.props.w = width;
        riser.props.h = height;
        return riser
    }
    function drawSceneBars(chart, group, w, h, data, barData, yAxisName) {
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        var depth = chart.depth25d()
          , depthGap = depth ? chart.getRiserDepthGap() : null;
        var riserList = [];
        yAxisName = chart.splitNumericAxis.splitY.enabled ? yAxisName : null;
        var isRounded = (chart.blaProperties.barEffect === "halfRound" || chart.blaProperties.barEffect === "fullRound") && !depth;
        var seriesGroup, groupStyle = {
            antialias: isRounded ? true : false
        };
        var barGroup = depth ? group.group("risers", null, null, null, null, null, groupStyle) : group.group("risers");
        var colorLookup = chart.seriesColorLookup({
            width: w,
            height: h,
            isScene: true
        });
        for (var s = 0; s < barData.length; s++) {
            seriesGroup = depth ? barGroup : barGroup.group(null, null, null, null, null, null, groupStyle);
            for (var g = 0; g < barData[s].length; g++) {
                var datum = (barData[s] || [])[g];
                if (!datum)
                    continue;
                var d = datum.d;
                var smallRiserStyle;
                var cornerRadius = chart.getSerDepProperty("border.cornerRadius", d);
                if (cornerRadius && typeof cornerRadius === "object" && isHorizontal)
                    cornerRadius = {
                        x: cornerRadius.y,
                        y: cornerRadius.x
                    };
                if (!yAxisName && d._axis && d._axis != "y1")
                    yAxisName = d._axis;
                var riserStyle = {
                    color: colorLookup(d),
                    lineStyle: chart.getSerDepProperty("border", d),
                    className: chart.getRiserClassName(seriesGroup, d, "riser", "bar", yAxisName),
                    title: chart.getSerDepProperty("tooltip", d),
                    depth: depth,
                    dmargin: depthGap,
                    cornerRadius: cornerRadius
                };
                if (chart.htmlToolTip.enabled && datum.smallRiserY != null) {
                    smallRiserStyle = tdg.clone(riserStyle);
                    riserStyle = {
                        color: smallRiserStyle.color,
                        lineStyle: smallRiserStyle.lineStyle,
                        className: riserStyle.className.replace("riser", "tinyPlaceholder"),
                        depth: smallRiserStyle.depth,
                        dmargin: smallRiserStyle.dmargin
                    };
                    smallRiserStyle.color = "transparent";
                    if (tdg.color.isLineVisible(smallRiserStyle.lineStyle))
                        smallRiserStyle.lineStyle.color = "transparent"
                }
                var bar;
                if ((chart.blaProperties.barEffect === "halfRound" || chart.blaProperties.barEffect === "fullRound") && !depth)
                    if (isHorizontal)
                        bar = horizontalRoundedTipBar(seriesGroup, datum, riserStyle);
                    else
                        bar = verticalRoundedTipBar(seriesGroup, datum, riserStyle);
                else if (isHorizontal)
                    bar = seriesGroup.rect(datum.y, datum.x, datum.height, datum.width, riserStyle);
                else
                    bar = seriesGroup.rect(datum.x, datum.y, datum.width, datum.height, riserStyle);
                if (chart.htmlToolTip.enabled && datum.smallRiserY != null)
                    if (isHorizontal)
                        seriesGroup.rect(datum.smallRiserY, datum.x, 5, datum.width, smallRiserStyle);
                    else
                        seriesGroup.rect(datum.x, datum.smallRiserY, datum.width, 5, smallRiserStyle);
                bar.d = d;
                bar.data = data[s];
                riserList[s] = riserList[s] || [];
                riserList[s][g] = bar
            }
        }
        return riserList
    }
    tdgchart.prototype.getRiserSeriesLayout = function(riserShape) {
        var chart = this;
        riserShape = (riserShape || "bar").toLowerCase();
        var layout = chart.get("blaProperties.comboCharts." + riserShape + "SeriesLayout") || chart.get("blaProperties.seriesLayout");
        if (!["sidebyside", "absolute", "stacked", "percent"].includes(layout))
            return riserShape === "bar" ? "sidebyside" : "absolute";
        return layout.toLowerCase()
    }
    ;
    function buildBarPositions(chart, data, x, y, y2, w, h, needY2, axisAssignment, config) {
        var s, g, d, v, xPos, yPos, res = [];
        var isHorizontal = chart.get("blaProperties.orientation") === "horizontal";
        var layout = chart.getRiserSeriesLayout("bar");
        var isMekko = chart.cache.hasKey("mekkoData");
        var baseline = y && chart.axisList.y1 ? chart.getAxisBaseline(y, chart.axisList.y1.invert, true) : null;
        var baselineY2 = needY2 ? chart.getAxisBaseline(y2, chart.axisList.y2.invert, true) : null;
        var isStacked = layout === "stacked" || layout === "percent";
        var isSideBySide = layout === "sidebyside";
        config = config || {};
        var yDomain, y2Domain;
        var yRange, y2Range;
        var yMin, yMax, y2Min, y2Max, yRange;
        if (y) {
            yDomain = y.domain();
            yRange = y.range();
            if (chart.axisList.y1.invert)
                yDomain.reverse();
            yMin = yDomain[0];
            yMax = yDomain[1]
        }
        if (needY2 && y2) {
            y2Domain = y2.domain();
            y2Range = y2.range();
            if (y2 && chart.axisList.y2.invert)
                y2Domain.reverse();
            y2Min = y2Domain[0];
            y2Max = y2Domain[1]
        }
        if (isStacked) {
            data = tdg.transpose(data);
            if (chart.blaProperties.sort)
                data = chart.sortData(data, chart.blaProperties.sort)
        }
        axisAssignment = axisAssignment.map(function(el) {
            return needY2 && y2 ? el - 1 : 0
        });
        var onAxisSeriesIndex = [];
        if (layout === "absolute" && needY2) {
            var assignments = {};
            for (s = 0; s < data.length; s++) {
                var axis = axisAssignment[s] || 0;
                assignments[axis] = assignments[axis] == undefined ? 0 : assignments[axis] + 1;
                onAxisSeriesIndex[s] = assignments[axis]
            }
        }
        var groupWidth;
        if (isSideBySide)
            groupWidth = x.range().band / (config.sideBySideBarCount == null ? data.length : config.sideBySideBarCount);
        else
            groupWidth = x.range().band / (needY2 ? 2 : 1);
        var barWidth = groupWidth;
        if (config.barSizeMinMax || hasSizeScaleData(data))
            barWidth = getBarWidthScale(chart, data, "size", x, config.barSizeMinMax).by(function(d) {
                return d.size || 0
            });
        else if (isMekko) {
            var mekkoData = chart.cache.get("mekkoData");
            barWidth = function(d, g) {
                return (isHorizontal ? h : w) * mekkoData.mekkoGroupSums[g] / mekkoData.mekkoTotal
            }
        } else if (layout === "absolute" && data.length > 1) {
            var absInset = tdg.bound(chart.get("blaProperties.absoluteInset", .3), .01, 1);
            absInset = groupWidth * (1 - absInset) / (data.length - 1);
            barWidth = function(d, s) {
                var index = !needY2 ? s : onAxisSeriesIndex[s];
                return Math.max(groupWidth - index * absInset, 1)
            }
        }
        var hasSmallRisers = false;
        for (s = 0; s < data.length; s++) {
            var prevValue = 0
              , prevYPos = baseline
              , prevNegValue = 0
              , prevNegYPos = baseline;
            var prevY2Value = 0
              , prevY2Pos = baselineY2
              , prevNegY2Value = 0
              , prevNegY2Pos = baselineY2;
            var groupData = data[s];
            var groupYSum, groupY2Sum;
            if (layout === "percent") {
                groupYSum = tdg.sum(groupData, function(el) {
                    el = el || {};
                    return axisAssignment[el._s] === 0 ? Math.abs(el.value || 0) : 0
                });
                groupY2Sum = tdg.sum(groupData, function(el) {
                    el = el || {};
                    return axisAssignment[el._s] === 1 ? Math.abs(el.value || 0) : 0
                })
            }
            res[s] = res[s] || [];
            var onBaseline;
            for (g = 0; g < groupData.length; g++) {
                d = groupData[g] || {};
                var seriesID = isStacked ? g : s;
                var groupID = isStacked ? s : g;
                var isOnY2 = needY2 && d._onY2 ? 1 : axisAssignment[d._s] || 0;
                var pv = prevValue
                  , pp = prevYPos;
                if (isOnY2) {
                    pv = prevY2Value;
                    pp = prevY2Pos
                }
                v = d.value == null && d.y2 != null ? d.y2 : d.value;
                if (!tdg.isANumber(v))
                    continue;
                if (layout === "percent")
                    v = Math.abs(v) / (isOnY2 ? groupY2Sum : groupYSum) * 100;
                else if (layout === "stacked" && v < 0)
                    if (isOnY2) {
                        pv = prevNegY2Value;
                        pp = prevNegY2Pos
                    } else {
                        pv = prevNegValue;
                        pp = prevNegYPos
                    }
                if (layout !== "stacked")
                    v = isOnY2 ? tdg.bound(v, y2Min, y2Max) : tdg.bound(v, yMin, yMax);
                d._yMin = pv;
                d._yMax = v + pv;
                yPos = isOnY2 ? y2(v + pv) : y(v + pv);
                yPos = isOnY2 ? tdg.bound(yPos, y2Range) : tdg.bound(yPos, yRange);
                var width = typeof barWidth === "function" ? barWidth(d, s) : barWidth;
                var height = Math.abs(yPos - pp);
                if (!tdg.isANumber(width) || width < 0 || !tdg.isANumber(height))
                    continue;
                if (isMekko)
                    xPos = x(groupID);
                else if (!isSideBySide) {
                    var dualY_offset = !isHorizontal || !needY2 ? width * isOnY2 : width * !isOnY2;
                    xPos = x(groupID) + dualY_offset + (groupWidth - width) / 2;
                    if (layout === "absolute" && needY2 && isOnY2)
                        xPos += groupWidth - width
                } else
                    xPos = x(groupID) + seriesID * groupWidth + (groupWidth - width) / 2;
                onBaseline = undefined;
                if (chart.blaProperties.barEffect === "halfRound") {
                    var isBaseline, swap;
                    if (isOnY2) {
                        isBaseline = pp == baselineY2;
                        swap = chart.axisList.y2.invert
                    } else {
                        isBaseline = pp == baseline;
                        swap = chart.axisList.y1.invert
                    }
                    if (v < 0)
                        swap = !swap;
                    if (isBaseline)
                        if (isHorizontal)
                            onBaseline = swap ? "right" : "left";
                        else
                            onBaseline = swap ? "top" : "bottom"
                }
                res[s][g] = {
                    x: xPos,
                    y: isHorizontal ? Math.min(pp, yPos) : Math.min(h - pp, h - yPos),
                    width: width,
                    height: height,
                    d: d,
                    onBaseline: onBaseline
                };
                var smallRisersUnsupported = chart.blaProperties.barEffect === "halfRound" || chart.blaProperties.barEffect === "fullRound";
                if (height < 5 && !smallRisersUnsupported) {
                    hasSmallRisers = true;
                    var r = res[s][g];
                    if (isStacked)
                        res[s][g].smallRiserY = r.y - (5 - r.height) / 2;
                    else if (isHorizontal)
                        res[s][g].smallRiserY = v < 0 ? r.y - 5 + r.height : r.y;
                    else
                        res[s][g].smallRiserY = v < 0 ? r.y : r.y - 5 + r.height
                }
                if (isStacked)
                    if (layout === "stacked" && v < 0)
                        if (isOnY2) {
                            prevNegY2Pos = yPos;
                            prevNegY2Value += v
                        } else {
                            prevNegYPos = yPos;
                            prevNegValue += v
                        }
                    else if (isOnY2) {
                        prevY2Pos = yPos;
                        prevY2Value += v
                    } else {
                        prevYPos = yPos;
                        prevValue += v
                    }
            }
        }
        chart.cache.set("hasSmallRisers", hasSmallRisers);
        return isStacked ? tdg.transpose(res) : res
    }
    function checkLabelBarFit(chart, riser, label, isHorizontal) {
        if (!chart.getSeriesAndGroupProperty(riser.d._s, riser.d._g, "dataLabels.clipToContainer"))
            return true;
        var font = chart.getSeriesAndGroupProperty(riser.d._s, riser.d._g, "dataLabels.font");
        if (isHorizontal)
            return tdg.measureLabelWidth(label.props.text, font) + 4 < riser.props.w;
        return tdg.measureFont(font).height < riser.props.h
    }
    function needY2Axis(chart, data, assignment) {
        var s;
        if (Array.isArray(chart.dataArrayMap) && chart.dataArrayMap.includes("y2") && !chart.splitNumericAxis.splitY.enabled)
            for (s = 0; s < data.length; s++) {
                var series = chart.getSeries(data[s][0]._s);
                if (!series || !series.riserShape || series.riserShape.y2 === "bar")
                    return true
            }
        else
            for (s = 0; s < data.length; s++)
                if (assignment[data[s][0]._s] === 2)
                    return true;
        return false
    }
    tdgchart.prototype.addBar = function(group, w, h, data, x, y, y2, config) {
        if (!data || data.length === 0)
            return null;
        var chart = this;
        var s, g;
        var cfg = {};
        cfg.assignment = chart.getAxisAssignment(data);
        cfg.needY2 = y2 != null && needY2Axis(chart, data, cfg.assignment);
        cfg.isMekko = chart.cache.hasKey("mekkoData");
        cfg.layout = chart.getRiserSeriesLayout("bar");
        cfg.isHorizontal = chart.blaProperties.orientation === "horizontal";
        var barData = buildBarPositions(chart, data, x, y, y2, w, h, cfg.needY2, cfg.assignment, config);
        var riserList = drawSceneBars(chart, group, w, h, data, barData, y && y.axisName);
        chart.addBevel(riserList, group);
        if (chart.areDataLabelsVisible()) {
            var labelGroup = group.group("datalabels");
            var labels = chart.doDataLabelsScene(labelGroup, riserList);
            for (s = 0; s < labels.length; s++) {
                if (!labels[s])
                    continue;
                var pos = labels[s].position || "center";
                if (cfg.layout !== "sidebyside" && pos !== "top" || pos === "center" || pos.includes("inside"))
                    for (g = 0; g < labels[s].length; g++) {
                        var label = labels[s][g]
                          , riser = riserList[s][g];
                        if (riser && label && !checkLabelBarFit(chart, riser, label, cfg.isHorizontal))
                            if (cfg.layout === "sidebyside") {
                                var anchor = chart.getDataLabelAnchorPoint(riser, "top", riser.d);
                                label.props.x = anchor.x;
                                label.props.y = anchor.y;
                                tdg.mergeObjects(anchor, label.props.attrs)
                            } else
                                label.parent.removeChild(label)
                    }
            }
        }
        blaStackTotals(chart, group, w, riserList, cfg);
        if (!chart.isComboChart())
            chart.doErrorBars(group, x, y);
        return riserList
    }
    ;
    function fillEffectToColor(chart, fillStyle) {
        if (!fillStyle || typeof fillStyle !== "string" && typeof fillStyle !== "object")
            return null;
        if (typeof fillStyle !== "string")
            return function() {
                return fillStyle
            }
            ;
        var colorLookup = chart.seriesColorLookup();
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        if (fillStyle === "seriesAuto")
            fillStyle = "30%";
        if (fillStyle === "seriesLighten")
            return function(d) {
                var riserColor = tdg.color(colorLookup.call(this, d)).toOpaqueColorString();
                return new tdg.color.LinearGradient(isHorizontal ? "100%" : 0,0,0,isHorizontal ? 0 : "100%",[[0, riserColor, .3], [1, "none", 0]])
            }
            ;
        else if (fillStyle === "seriesLightenOpaque")
            return function(d) {
                var riserColor = tdg.color(colorLookup.call(this, d));
                return new tdg.color.LinearGradient(isHorizontal ? "100%" : 0,0,0,isHorizontal ? 0 : "100%",[[0, riserColor.lighter(.1).toOpaqueColorString(), riserColor.a], [1, "rgb(255,255,255)", riserColor.a]])
            }
            ;
        else if (tdg.isPercentString(fillStyle)) {
            var lerp = tdg.parsePercent(fillStyle, -1);
            return function(d) {
                var riserColor = tdg.color(colorLookup.call(this, d));
                return riserColor.isComplexFill ? riserColor : riserColor.alpha(lerp)
            }
        }
        return function() {
            return fillStyle
        }
    }
    function getAxisZeroValue(chart, s, axis, axisProp) {
        var domain = axis.domain();
        if (axisProp.invert)
            domain.reverse();
        var zero = Math.min(Math.max(0, domain[0]), domain[1]);
        return zero
    }
    function getStackedPointData(chart, data, needY2, assignment, y, y2) {
        var d, s, g;
        var pointData = [];
        var tdata = tdg.transpose(data);
        for (s = 0; s < tdata.length; s++) {
            pointData[s] = [];
            var axis = needY2 && assignment[s] != 1 ? y2 : y;
            var axisProp = chart.axisList[needY2 && assignment[s] != 1 ? "y2" : "y1"];
            var zero = getAxisZeroValue(chart, s, axis, axisProp);
            var cpos = 0
              , cneg = 0
              , cy2Pos = 0
              , cy2Neg = 0;
            for (g = 0; g < tdata[s].length; g++) {
                d = tdg.clone(tdata[s][g]);
                if (d == null)
                    continue;
                if (d.y == null) {
                    d.yTop = null;
                    d.yBottom = cpos
                } else if (d.y >= 0)
                    if (assignment[d._s] === 2 || d._onY2) {
                        d.yBottom = cy2Pos || zero;
                        cy2Pos += d.y;
                        d.y = d.yTop = cy2Pos
                    } else {
                        d.yBottom = cpos || zero;
                        cpos += d.y;
                        d.y = d.yTop = cpos
                    }
                else if (assignment[d._s] === 2 || d._onY2) {
                    d.yBottom = cy2Neg || zero;
                    cy2Neg += d.y;
                    d.y = d.yTop = cy2Neg
                } else {
                    d.yBottom = cneg || zero;
                    cneg += d.y;
                    d.y = d.yTop = cneg
                }
                pointData[s][g] = d
            }
        }
        return tdg.transpose(pointData)
    }
    function getPointData(chart, data, needY2, assignment, y, y2, riserShape) {
        var d, g, s;
        var pointData = [];
        for (s = 0; s < data.length; s++) {
            pointData[s] = [];
            var axis = needY2 && assignment[s] != 1 ? y2 : y;
            var axisProp = chart.axisList[needY2 && assignment[s] != 1 ? "y2" : "y1"];
            var zero = getAxisZeroValue(chart, s, axis, axisProp);
            for (g = 0; g < data[s].length; g++) {
                d = tdg.clone(data[s][g]);
                if (d == null)
                    continue;
                if (axisProp.bIsLog && d.value <= 0) {
                    d.value = undefined;
                    d.y = undefined
                }
                if (riserShape === "area")
                    if (d.y == null || d.y >= zero) {
                        d.yTop = d.y;
                        d.yBottom = zero
                    } else {
                        d.yTop = zero;
                        d.yBottom = d.y
                    }
                else {
                    d.yTop = d.y;
                    d.yBottom = zero
                }
                pointData[s][g] = d
            }
        }
        return pointData
    }
    function getBetweenData(chart, data, needY2, assignment, y, y2, riserShape) {
        var d, g, s;
        var pointData = [];
        for (s = 0; s < data.length; s++) {
            pointData[s] = [];
            var series = chart.getSeries(s);
            if (!series || !series.fillBetweenSeries || !data[series.fillBetweenSeries.toSeries])
                continue;
            var axis = needY2 && assignment[s] != 1 ? y2 : y;
            var axisProp = chart.axisList[needY2 && assignment[s] != 1 ? "y2" : "y1"];
            var zero = getAxisZeroValue(chart, s, axis, axisProp);
            for (g = 0; g < data[s].length; g++) {
                d = tdg.clone(data[s][g]);
                d2 = tdg.clone(data[series.fillBetweenSeries.toSeries][g]);
                if (d == null || d2 == null)
                    continue;
                if (d2.y != undefined) {
                    d.yTop = d.y;
                    d.yBottom = d2.y
                }
                pointData[s][g] = d
            }
        }
        return pointData
    }
    function drawLineAreaMissing(chart, data, group, riserGroup, pointData, x, y, y2, cfg) {
        if (chart.blaProperties.missingDataMode === "curved")
            chart.cache.setProperty("blaProperties.missingDataMode", "linear");
        if (chart.blaProperties.missingDataMode !== "zero" && chart.blaProperties.missingDataMode !== "linear")
            return;
        for (var s = 0; s < pointData.length; s++) {
            var missingPointsData = computeMissingPoints(chart, data, group, riserGroup, s, pointData[s], x, y, y2, cfg);
            drawLineAreaMissingSeries(chart, data, group, riserGroup, s, missingPointsData, x, y, y2, cfg)
        }
    }
    function computeMissingPoints(chart, data, group, riserGroup, s, pointData, x, y, y2, cfg) {
        var g = 0;
        var mSeries = [];
        var zero;
        var lastEnd;
        var isStacked = chart.blaProperties.seriesLayout == "stacked" || chart.blaProperties.seriesLayout == "percent";
        var isReversed = cfg.riserShape === "area" && !isStacked;
        while (g < pointData.length) {
            if (!tdg.isANumber(pointData[g].yTop)) {
                var gap = {
                    start: g
                };
                while (g < pointData.length && !tdg.isANumber(pointData[g].yTop))
                    g++;
                gap.length = g - gap.start;
                var axis = cfg.needY2 && cfg.assignment[s] != 1 ? y2 : y;
                var axisProp = chart.axisList[cfg.needY2 && cfg.assignment[s] != 1 ? "y2" : "y1"];
                if (gap.start != 0 && g != pointData.length) {
                    var dstart = mSeries[gap.start - 1] = pointData[gap.start - 1];
                    var dend = mSeries[g] = pointData[g];
                    var starty = !isReversed || dstart.value >= 0 || dstart.yBottom == undefined ? dstart.yTop : dstart.yBottom;
                    var endy = !isReversed || dend.value >= 0 || dend.yBottom == undefined ? dend.yTop : dend.yBottom;
                    var isXTimeAxis = chart.isXTimeAxis();
                    var time_from, time_diff;
                    if (isXTimeAxis) {
                        time_from = x(tdgchart.d3_time.timeCanonicalParse(cfg.timeAxisGroupLabels[gap.start - 1]));
                        time_diff = x(tdgchart.d3_time.timeCanonicalParse(cfg.timeAxisGroupLabels[g])) - time_from
                    }
                    var exponent_start, exponent_diff;
                    if (axisProp.bIsLog && dstart.value > 0) {
                        exponent_start = Math.log10(dstart.value);
                        exponent_diff = Math.log10(dend.value) - exponent_start
                    }
                    for (var i = 0; i < gap.length; i++) {
                        var yy = 0, value, yTop, yBottom;
                        if (chart.blaProperties.missingDataMode !== "zero") {
                            var proportion;
                            if (!isXTimeAxis)
                                proportion = (i + 1) / (gap.length + 1);
                            else {
                                var time_now = x(tdgchart.d3_time.timeCanonicalParse(cfg.timeAxisGroupLabels[gap.start + i]));
                                proportion = (time_now - time_from) / time_diff
                            }
                            if (!axisProp.bIsLog) {
                                value = dstart.value + (dend.value - dstart.value) * proportion;
                                yy = starty + (endy - starty) * proportion
                            } else
                                yy = value = Math.pow(10, exponent_start + exponent_diff * proportion)
                        } else {
                            if (zero == undefined)
                                zero = getAxisZeroValue(chart, s, axis, axisProp);
                            value = zero;
                            yy = zero
                        }
                        mSeries[gap.start + i] = {
                            value: value,
                            y: yy,
                            _g: gap.start + i,
                            _s: dstart._s,
                            _onY2: dstart._onY2,
                            _axis: dstart._axis
                        }
                    }
                    if (g + 1 < pointData.length && tdg.isANumber(pointData[g + 1].yTop))
                        mSeries[g]._subPathEnd = true
                } else {
                    for (var i = 0; i < gap.length; i++)
                        mSeries[gap.start + i] = {};
                    mSeries[g] = {}
                }
                lastEnd = g
            } else
                mSeries[g] = {};
            g++
        }
        return mSeries
    }
    function drawLineAreaMissingSeries(chart, data, group, riserGroup, s, pointDataSeries, x, y, y2, cfg) {
        var riserSeries = [];
        var yScale, firstDatum = null;
        var points = [];
        for (var g = 0; g < pointDataSeries.length; g++) {
            var d = (pointDataSeries || [])[g];
            yScale = y2 && (d._onY2 || cfg.assignment[d._s] === 2) ? y2 : y;
            var xIndex = cfg.isXTimeAxis ? tdgchart.d3_time.timeCanonicalParse(cfg.timeAxisGroupLabels[g]) : g;
            var dx = x(xIndex) + cfg.xOffset;
            var dy = cfg.isHorizontal ? yScale(d.y) : cfg.h - yScale(d.y);
            if (!d || !tdg.isANumber(d.y))
                points.push(cfg.isHorizontal ? {
                    x: null,
                    y: dx
                } : {
                    x: dx,
                    y: null
                });
            else {
                points.push(cfg.isHorizontal ? {
                    x: dy,
                    y: dx
                } : {
                    x: dx,
                    y: dy
                });
                firstDatum = firstDatum == null ? d : firstDatum
            }
            if (d._subPathEnd)
                points.push({
                    x: null,
                    y: null
                });
            riserSeries[g] = {
                d: d,
                data: data[s],
                _s: s,
                _g: g
            }
        }
        if (firstDatum == null)
            return undefined;
        var riserStyle = {
            depth: cfg.depth,
            interpolation: cfg.interpolation,
            isHorizontal: cfg.isHorizontal,
            baseline: cfg.isHorizontal ? yScale(0) : cfg.h - yScale(0),
            riserShape: cfg.riserShape,
            lineStyle: {}
        };
        riserStyle.lineStyle.width = chart.blaProperties.missingDataLineStyle.width;
        riserStyle.lineStyle.dash = chart.blaProperties.missingDataLineStyle.dash;
        if (chart.blaProperties.missingDataLineStyle.color)
            riserStyle.lineStyle.color = chart.blaProperties.missingDataLineStyle.color;
        else if (cfg.riserShape === "area") {
            riserStyle.lineStyle.color = chart.getSerDepProperty("border.color", firstDatum);
            if (!tdg.color.isVisible(riserStyle.lineStyle.color))
                riserStyle.lineStyle.color = cfg.areaFillColor(firstDatum, riserSeries)
        } else
            riserStyle.lineStyle.color = cfg.lineBorderColor(firstDatum, data[s]);
        var seriesGroup = riserGroup.group(null, null, null, null, null, null, {});
        seriesGroup.riserPath(0, 0, points, null, riserStyle)
    }
    function drawLineAreaSeries(chart, data, group, riserGroup, s, pointData, x, y, y2, cfg) {
        var riserSeries = [];
        var seriesGroup, seriesStyle = {};
        seriesGroup = riserGroup.group(null, null, null, null, null, null, seriesStyle);
        var yScale, seriesID, firstDatum = null;
        var haveMarkers = cfg.widthScale ? chart.getSeriesAndGroupProperty(s, null, "marker.visible") : false;
        var haveWidthScale = cfg.widthScale != null && !haveMarkers;
        var points = []
          , bottomPoints = haveWidthScale || cfg.lineFillFx || cfg.riserShape === "area" ? [] : null;
        var g;
        for (g = 0; g < pointData[s].length; g++) {
            var d = (pointData[s] || [])[g];
            yScale = y2 && (d._onY2 || cfg.assignment[d._s] === 2) ? y2 : y;
            var xIndex = cfg.isXTimeAxis ? tdgchart.d3_time.timeCanonicalParse(cfg.timeAxisGroupLabels[g]) : g;
            var dx = x(xIndex) + cfg.xOffset;
            var dy = cfg.isHorizontal ? yScale(d.yTop) : cfg.h - yScale(d.yTop);
            var yBottom = cfg.isHorizontal ? yScale(d.yBottom) : cfg.h - yScale(d.yBottom);
            if (!d || !tdg.isANumber(d.yTop)) {
                if (cfg.riserShape === "area" && cfg.layout === "percent")
                    points.push(cfg.isHorizontal ? {
                        x: yBottom,
                        y: dx
                    } : {
                        x: dx,
                        y: yBottom
                    });
                else
                    points.push(cfg.isHorizontal ? {
                        x: null,
                        y: dx
                    } : {
                        x: dx,
                        y: null
                    });
                if (cfg.riserShape === "area" || cfg.lineFillFx)
                    bottomPoints.push(cfg.isHorizontal ? {
                        x: yBottom,
                        y: dx
                    } : {
                        x: dx,
                        y: yBottom
                    })
            } else {
                if (cfg.riserShape === "area") {
                    points.push(cfg.isHorizontal ? {
                        x: dy,
                        y: dx
                    } : {
                        x: dx,
                        y: dy
                    });
                    bottomPoints.push(cfg.isHorizontal ? {
                        x: yBottom,
                        y: dx
                    } : {
                        x: dx,
                        y: yBottom
                    })
                } else if (haveWidthScale) {
                    var lineWidth = Math.max(cfg.widthScale(d.size) / 2, 0);
                    if (cfg.isHorizontal) {
                        points.push({
                            x: dy + lineWidth,
                            y: dx
                        });
                        bottomPoints.push({
                            x: dy - lineWidth,
                            y: dx
                        })
                    } else {
                        points.push({
                            x: dx,
                            y: dy - lineWidth
                        });
                        bottomPoints.push({
                            x: dx,
                            y: dy + lineWidth
                        })
                    }
                } else if (cfg.lineFillFx)
                    if (cfg.isHorizontal) {
                        points.push({
                            x: dy,
                            y: dx
                        });
                        bottomPoints.push({
                            x: yScale(d.yBottom),
                            y: dx
                        })
                    } else {
                        points.push({
                            x: dx,
                            y: dy
                        });
                        bottomPoints.push({
                            x: dx,
                            y: cfg.h - yScale(d.yBottom)
                        })
                    }
                else
                    points.push(cfg.isHorizontal ? {
                        x: dy,
                        y: dx
                    } : {
                        x: dx,
                        y: dy
                    });
                seriesID = d._s;
                firstDatum = firstDatum == null ? d : firstDatum
            }
            var props;
            if (cfg.riserShape === "line")
                props = {
                    x: points[points.length - 1].x,
                    y: points[points.length - 1].y,
                    size: 0
                };
            else if (cfg.isHorizontal)
                props = {
                    x: dy > yBottom ? yBottom : dy,
                    y: dx,
                    w: Math.abs(dy - yBottom),
                    h: 0,
                    point: {
                        x: d.value < 0 ? yBottom : dy,
                        y: dx
                    }
                };
            else
                props = {
                    x: dx,
                    y: dy > yBottom ? yBottom : dy,
                    w: 0,
                    h: Math.abs(dy - yBottom),
                    point: {
                        x: dx,
                        y: d.value < 0 ? yBottom : dy
                    }
                };
            riserSeries[g] = {
                d: d,
                data: data[s],
                _s: s,
                _g: g,
                type: cfg.riserShape === "line" ? "dot" : "area",
                riserShape: cfg.riserShape,
                props: props
            }
        }
        var depthIndex, groupDepthOffset;
        if (firstDatum == null)
            return undefined;
        else {
            var riserStyle = {
                title: chart.getSerDepProperty("tooltip", d),
                depth: cfg.depth,
                interpolation: cfg.interpolation,
                isHorizontal: cfg.isHorizontal,
                baseline: cfg.isHorizontal ? yScale(0) : cfg.h - yScale(0),
                riserShape: cfg.riserShape,
                lineStyle: {}
            };
            if (cfg.depth) {
                depthIndex = cfg.layout === "stacked" || cfg.layout === "percent" ? 0 : data.length - s - 1;
                groupDepthOffset = depthIndex * Math.ceil(cfg.depth / Math.SQRT2);
                seriesGroup.x = groupDepthOffset;
                seriesGroup.y = -groupDepthOffset;
                riserStyle.dmargin = cfg.depthGap;
                riserStyle.containerHeight = cfg.h
            }
            if (cfg.lineFillFx) {
                riserStyle.className = chart.buildClassName("lineFill", seriesID, 0, "lineFill");
                riserStyle.color = cfg.lineFillFx(firstDatum);
                seriesGroup.riserPath(0, 0, points, bottomPoints, riserStyle)
            }
            riserStyle.className = chart.getRiserClassName(group, {
                _s: seriesID,
                _g: 0
            }, "riser", cfg.riserShape, cfg.yAxisName);
            if (cfg.riserShape === "area") {
                riserStyle.color = cfg.areaFillColor(firstDatum, riserSeries);
                riserStyle.lineStyle.color = chart.getSerDepProperty("border.color", d)
            } else {
                var borderColor = cfg.lineBorderColor(firstDatum, data[s]);
                riserStyle.color = haveWidthScale || cfg.depth ? borderColor : null;
                riserStyle.lineStyle.color = haveWidthScale ? chart.getSerDepProperty("border.color", d) : borderColor
            }
            riserStyle.lineStyle.width = chart.getSerDepProperty("border.width", d);
            riserStyle.lineStyle.dash = chart.getSerDepProperty("border.dash", d);
            riserStyle.lineStyle = cfg.depth && cfg.riserShape === "line" ? null : riserStyle.lineStyle;
            seriesGroup.riserPath(0, 0, points, cfg.lineFillFx ? null : bottomPoints, riserStyle);
            if (pointData[s])
                for (g = 0; g < pointData[s].length; g++)
                    riserSeries[g].props.attrs = riserStyle
        }
        return riserSeries
    }
    function blaStackTotals(chart, group, w, riserList, cfg) {
        var stackTotalsVisible = chart.get("blaProperties.stackTotalLabel.visible");
        var needStackTotals = (!!stackTotalsVisible || typeof stackTotalsVisible === "function") && (cfg.layout === "stacked" || cfg.isMekko);
        if (!needStackTotals)
            return;
        if (!cfg.needY2)
            drawStackTotalLabels(chart, group, w, riserList, chart.axisList.y1, cfg.isHorizontal, cfg.isMekko);
        else {
            var y1RiserList = []
              , y2RiserList = [];
            for (var s = 0; s < riserList.length; s++) {
                y1RiserList[s] = [];
                y2RiserList[s] = [];
                if (!riserList[s]) {
                    y1RiserList[s].push(null);
                    y2RiserList[s].push(null);
                    continue
                }
                for (var g = 0; g < riserList[s].length; g++) {
                    var r = (riserList[s] || [])[g];
                    if (r && cfg.assignment[s] === 2) {
                        y1RiserList[s].push(null);
                        y2RiserList[s].push(r)
                    } else if (r) {
                        y1RiserList[s].push(r);
                        y2RiserList[s].push(null)
                    } else {
                        y1RiserList[s].push(null);
                        y2RiserList[s].push(null)
                    }
                }
            }
            drawStackTotalLabels(chart, group, w, y1RiserList, chart.axisList.y1, cfg.isHorizontal, cfg.isMekko);
            drawStackTotalLabels(chart, group, w, y2RiserList, chart.axisList.y2, cfg.isHorizontal, cfg.isMekko)
        }
    }
    function drawLineAreaDataLabels(chart, data, group, riserList, cfg) {
        var depthIndex, groupDepthOffset;
        var labels = chart.doDataLabelsScene(group.group("datalabels"), riserList);
        if (cfg.depth)
            for (s = 0; s < labels.length; s++)
                if (labels[s] && labels[s][0]) {
                    depthIndex = cfg.layout === "stacked" || cfg.layout === "percent" ? 0 : data.length - s - 1;
                    groupDepthOffset = (depthIndex + 1) * Math.ceil(cfg.depth / Math.SQRT2);
                    var o = cfg.riserShape === "area" ? Math.ceil(cfg.depth * (1 - cfg.depthGap) / Math.SQRT2) : 0;
                    var dt = Math.ceil(cfg.depth * cfg.depthGap / 2);
                    labels[s][0].parent.x = groupDepthOffset - o - dt;
                    labels[s][0].parent.y = -groupDepthOffset + o + dt
                }
    }
    function getAreaFillColorFn(chart, x, cfg) {
        return function(d, data) {
            var cs = chart.cache.get("colorAxis");
            if (cs) {
                var groupCount = data.length - 1;
                var axisWidth = x(groupCount) + cfg.xOffset;
                var stops = data.map(function(el, idx) {
                    var v = 0;
                    if (el && el.d && el.d[cs.odata_key] != null)
                        v = el.d[cs.odata_key];
                    return {
                        offset: idx / groupCount,
                        color: cs.scale(v)
                    }
                });
                return {
                    type: "linear",
                    gradientUnits: "userSpaceOnUse",
                    start: cfg.isHorizontal ? {
                        x: 0,
                        y: cfg.xOffset
                    } : {
                        x: cfg.xOffset,
                        y: 0
                    },
                    end: cfg.isHorizontal ? {
                        x: 0,
                        y: axisWidth
                    } : {
                        x: axisWidth,
                        y: 0
                    },
                    stops: stops
                }
            }
            return cfg.areaFillFx ? cfg.areaFillFx(d) : cfg.seriesColorLookup(d)
        }
    }
    function getLineBorderColorFn(chart, x, cfg) {
        return function(d, data) {
            if (d && d.color != null) {
                var markerPanelWidth = x(data.length - 1);
                var gradString = "linear-gradient(0%,0%,100%,0%,";
                for (var i = 0; i < data.length; i++) {
                    var posRatio = x(i) / markerPanelWidth;
                    var color = cfg.seriesColorLookup(data[i]);
                    if (color && color.hasOwnProperty("color"))
                        color = color.color;
                    if (i < data.length - 1)
                        gradString += " " + posRatio + " " + color + ",";
                    else
                        gradString += " " + posRatio + " " + color + ")"
                }
                return gradString
            }
            var colorMode = chart.getColorMode();
            if (colorMode === "byPosNeg" || colorMode === "byNegPos")
                return chart.getSerDepProperty("color", d);
            var tmpG = d._g;
            d._g = null;
            var res = cfg.seriesColorLookup(d);
            d._g = tmpG;
            return res
        }
    }
    tdgchart.prototype.addLineArea = function(group, w, h, data, x, y, y2, config, riserShape) {
        if (!data || data.length === 0)
            return;
        var chart = this;
        var colorLookup;
        var isBetween = riserShape == "between";
        if (!isBetween)
            colorLookup = chart.seriesColorLookup({
                width: w,
                height: h,
                isScene: true
            });
        else {
            riserShape = "area";
            colorLookup = chart.seriesPropertyLookup("fillBetweenSeries.fill")
        }
        var cfg = {
            w: w,
            h: h,
            isHorizontal: chart.blaProperties.orientation === "horizontal",
            riserShape: riserShape,
            layout: chart.getRiserSeriesLayout(riserShape),
            depth: chart.depth25d(),
            depthGap: chart.depth25d() ? chart.getRiserDepthGap() : null,
            xOffset: x.range().band / 2,
            isXTimeAxis: chart.isXTimeAxis(),
            assignment: chart.getAxisAssignment(data),
            yAxisName: chart.splitNumericAxis.splitY.enabled ? y.axisName : null,
            widthScale: riserShape === "line" && hasSizeScaleData(data) ? getLineWidthScale(chart, data, "size", y) : null,
            interpolation: chart.get("blaProperties.lineConnection", "linear"),
            areaFillFx: riserShape === "area" ? fillEffectToColor(chart, chart.blaProperties.areaFillEffect) : null,
            lineFillFx: riserShape === "line" ? fillEffectToColor(chart, chart.blaProperties.lineFillEffect) : null,
            seriesColorLookup: colorLookup,
            timeAxisGroupLabels: chart.cache.get("xaxis_time_scale", {}).compressedLabels || chart.groupLabels
        };
        cfg.needY2 = y2 != null && needY2Axis(chart, data, cfg.assignment);
        cfg.antialias = !(cfg.interpolation.includes("step") || cfg.interpolation.includes("baseline"));
        cfg.lineBorderColor = getLineBorderColorFn(chart, x, cfg);
        cfg.areaFillColor = getAreaFillColorFn(chart, x, cfg);
        if (!cfg.depth && chart.chartFrame.clip) {
            group.w = w;
            group.h = h;
            group.clip = true
        }
        var pointData;
        if (isBetween)
            pointData = getBetweenData(chart, data, cfg.needY2, cfg.assignment, y, y2);
        else if (cfg.layout === "stacked" || cfg.layout === "percent")
            pointData = getStackedPointData(chart, data, cfg.needY2, cfg.assignment, y, y2);
        else
            pointData = getPointData(chart, data, cfg.needY2, cfg.assignment, y, y2, riserShape);
        var groupStyle = {
            antialias: cfg.antialias === true ? null : cfg.antialias
        };
        var riserGroup = group.group("risers", null, null, null, null, null, groupStyle);
        var riserList = [];
        drawLineAreaMissing(chart, data, group, riserGroup, pointData, x, y, y2, cfg);
        for (var s = 0; s < pointData.length; s++)
            riserList[s] = drawLineAreaSeries(chart, data, group, riserGroup, s, pointData, x, y, y2, cfg);
        var riserBaseColorFn = riserShape === "area" ? cfg.areaFillColor : cfg.lineBorderColor;
        chart.addMarkersScene(group.group("markers"), riserList, data, riserShape, cfg.yAxisName, x, riserBaseColorFn);
        if (chart.areDataLabelsVisible())
            drawLineAreaDataLabels(chart, data, group, riserList, cfg);
        blaStackTotals(chart, group, w, riserList, cfg);
        if (!chart.isComboChart())
            chart.doErrorBars(group, x, y)
    }
    ;
    function drawColorRanges(chart, panel, axisLayout) {
        chart.drawAxisColorRanges(panel, axisLayout.xScalesList[0], axisLayout.xAxisList[0]);
        chart.drawAxisColorRanges(panel, axisLayout.yScalesList[0], axisLayout.yAxisList[0]);
        chart.drawAxisColorRanges(panel, axisLayout.yScalesList[1], axisLayout.yAxisList[1])
    }
    function drawAltFrameFills(chart, panel, axisLayout) {
        chart.drawAltFrameFill(panel, axisLayout.xScalesList[0], axisLayout.xAxisList[0]);
        chart.drawAltFrameFill(panel, axisLayout.yScalesList[0], axisLayout.yAxisList[0]);
        chart.drawAltFrameFill(panel, axisLayout.yScalesList[1], axisLayout.yAxisList[1])
    }
    function drawColorByMetricChart(chart, panel, chartLayout) {
        if (chart.colorMode.mode !== "byMetric" && chart.colorMode.mode !== "bySeriesSelection" && chart.colorMode.mode !== "byGroupSelection")
            return null;
        var metricData = chart.getColorMetricData();
        var originalColors = chart.colorMode.colorList;
        var originalLayout = chart.blaProperties.seriesLayout;
        if (chart.chartType === "bar" || chart.chartType === "area") {
            if (chart.cache.hasKey("mekkoData")) {
                var mekkoData = chart.cache.get("mekkoData");
                metricData.isMekko = true;
                metricData.mekkoTotal = mekkoData.mekkoTotal;
                metricData.mekkoGroupSums = mekkoData.mekkoGroupSums
            }
            metricData = tdg.transpose(metricData);
            chart.transposeIDs(metricData);
            chart._internalData = metricData;
            chart.blaProperties.seriesLayout = chart.cache.hasKey("mekkoData") ? "percent" : "stacked"
        } else if (chart.chartType === "line") {
            var haveUnselected = metricData.some(function(el) {
                return el.length !== 0 && el[el.length - 1].value != null
            });
            chart.colorMode.colorList = (chart.colorMode.colorList || ["red", "green"]).slice(0);
            originalColors = chart.colorMode.colorList.slice(0);
            chart.blaProperties.comboCharts.barSeriesLayout = "stacked";
            chart.blaProperties.comboCharts.lineSeriesLayout = "absolute";
            chart.getDefaultSeries().riserShape = "bar";
            (chart.getSeries(0) || {}).riserShape = (chart.getSeries(1) || {}).riserShape = "line";
            if (haveUnselected)
                metricData.map(function(el, idx) {
                    el.unshift({
                        value: tdg.sum(metricData[idx].slice(0, -1), "value"),
                        _s: idx,
                        _g: -1
                    })
                });
            else
                metricData.map(function(el, idx) {
                    el.unshift({
                        _s: idx,
                        _g: 0
                    })
                });
            var barData = tdg.transpose(metricData);
            chart.transposeIDs(barData, 2);
            chart._internalData = chart.data.concat(barData);
            chart._internalData.seriesMap = tdg.range(barData.length);
            chart.colorMode.colorList.unshift((chart.getSeries(1) || {}).color);
            chart.colorMode.colorList.unshift((chart.getSeries(0) || {}).color)
        }
        chartLayout = chart.layoutBLAChart(chartLayout.chartSize);
        chart.drawBLAChart(panel, chartLayout);
        (chart.getSeries(1) || {}).riserShape = null;
        chart.colorMode.colorList = originalColors;
        chart.blaProperties.seriesLayout = originalLayout;
        chart._internalData = null;
        return null
    }
    function getMultSubsetMinMaxList(chart, dataByAxis) {
        var minMaxList = [];
        var nullMinMax = {
            min: Infinity,
            max: -Infinity
        };
        for (var axisName in dataByAxis)
            if (dataByAxis.hasOwnProperty(axisName)) {
                var tmp = [], minMax;
                var tmpMinMax = {
                    min: Infinity,
                    max: -Infinity,
                    step: null,
                    name: axisName
                };
                for (var chartType in dataByAxis[axisName])
                    if (dataByAxis[axisName].hasOwnProperty(chartType)) {
                        var axisProperties = chart.axisNameToAxisProperties(axisName) || chart.axisList.y1;
                        if (dataByAxis[axisName][chartType].length)
                            minMax = chart.getScaleMinMax(axisProperties, axisName, dataByAxis[axisName][chartType], chart.blaProperties.comboCharts[chartType + "SeriesLayout"], "y");
                        else
                            minMax = nullMinMax;
                        tmp.push(minMax)
                    }
                for (var i = 0; i < tmp.length; i++) {
                    var v = tmp[i];
                    if (v.min != null && isFinite(v.min))
                        tmpMinMax.min = Math.min(tmpMinMax.min, v.min);
                    if (v.max != null && isFinite(v.max))
                        tmpMinMax.max = Math.max(tmpMinMax.max, v.max);
                    if (v.step != null && isFinite(v.step))
                        tmpMinMax.step = Math.max(tmpMinMax.step || -Infinity, v.step)
                }
                minMaxList.push(tmpMinMax)
            }
        return minMaxList
    }
    tdgchart.prototype.rearangeBLAInternalData = function(rawDataSet) {
        var chart = this;
        var defaultSeries = chart.getDefaultSeries();
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        var defaultShape = defaultSeries == null ? chartType : defaultSeries.riserShape || chartType || "bar";
        var odata = {
            bar: [],
            line: [],
            area: []
        };
        var dataByAxis = {};
        var axisData, axisCount = 0, dataSubsetCount = 0;
        function pushDataSeries(axisName, riserShape, newDataSeries) {
            if (!dataByAxis[axisName]) {
                dataByAxis[axisName] = {
                    bar: [],
                    line: [],
                    area: []
                };
                axisCount++
            }
            dataByAxis[axisName][riserShape].push(newDataSeries);
            odata[riserShape].push(newDataSeries);
            newDataSeries.forEach(function(el) {
                if (el)
                    el._axis = axisName
            })
        }
        for (var i = 0; i < rawDataSet.length; i++) {
            var series = chart.getSeries(i);
            var assignedAxis = "y1";
            var riserShape = defaultShape;
            if (series != null)
                if (chart.cache.hasKey("mekkoData")) {
                    assignedAxis = "y1";
                    riserShape = "bar"
                } else {
                    assignedAxis = typeof series.yAxisAssignment === "number" ? "y" + series.yAxisAssignment : assignedAxis;
                    if (typeof series.riserShape === "object" && series.riserShape.y1)
                        riserShape = series.riserShape.y1;
                    else
                        riserShape = ["bar", "line", "area"].includes(series.riserShape) ? series.riserShape : defaultShape
                }
            pushDataSeries(assignedAxis, riserShape, rawDataSet[i]);
            for (var j = 0; chart.dataArrayMap && j < chart.dataArrayMap.length; j++) {
                var axisMatch = chart.dataArrayMap[j].match(/^y[0-9]+$/);
                if (axisMatch) {
                    axisMatch = axisMatch[0];
                    var newDataSeries = rawDataSet[i].map(function(el) {
                        if (!el)
                            return null;
                        if (el._axis == null)
                            el._axis = "y1";
                        el = tdg.cloneObject(el);
                        el._axis = axisMatch;
                        el.value = el[axisMatch];
                        if (!chart.splitNumericAxis.splitY.enabled && axisMatch === "y2")
                            el._onY2 = true;
                        return el
                    });
                    var newRiserShape = riserShape;
                    if (!chart.splitNumericAxis.splitY.enabled && axisMatch === "y2" && series && typeof series.riserShape === "object" && series.riserShape.y2)
                        newRiserShape = series.riserShape.y2;
                    pushDataSeries(axisMatch, newRiserShape, newDataSeries)
                }
            }
        }
        for (var axis in dataByAxis)
            if (dataByAxis.hasOwnProperty(axis))
                for (axisData in dataByAxis[axis])
                    if (dataByAxis[axis].hasOwnProperty(axisData)) {
                        dataSubsetCount += dataByAxis[axis][axisData].length ? 1 : 0;
                        dataByAxis[axis][axisData] = chart.adjustData(dataByAxis[axis][axisData])
                    }
        for (axisData in odata)
            if (odata.hasOwnProperty(axisData))
                odata[axisData] = chart.adjustData(odata[axisData]);
        return {
            odata: odata,
            dataByAxis: dataByAxis,
            dataSubsetCount: dataSubsetCount,
            axisCount: axisCount
        }
    }
    ;
    tdgchart.prototype.drawBLARisers = function(panel, odata, x, y, y2, config) {
        var chart = this;
        var scene = chart.cache.get("tdgscene");
        var w = panel.computedSize.width;
        var h = panel.computedSize.height;
        var group;
        if ((chart.isComboChart() || chart.chartType !== "bar") && (chart.htmlToolTip.enabled || chart.mouseOverIndicator.enabled)) {
            var baseGroup = scene.group(panel, "eventPanel");
            baseGroup.rect(0, 0, w, h, {
                color: "transparent",
                "pointer-events": "all"
            });
            group = baseGroup.group("groupPanel")
        } else
            group = scene.group(panel, "groupPanel");
        var areaGroup = group
          , barGroup = group
          , lineGroup = group;
        if (chart.isComboChart()) {
            areaGroup = group.group("areaRisers");
            barGroup = group.group("barRisers");
            lineGroup = group.group("lineRisers")
        }
        var odata = odata || {};
        var hasBetweenFill = chart.series.some(function(el) {
            return el.fillBetweenSeries && el.fillBetweenSeries.toSeries != null
        });
        chart.addLineArea(areaGroup, w, h, odata.area, x, y, y2, config, "area");
        chart.addBar(barGroup, w, h, odata.bar, x, y, y2, config);
        if (hasBetweenFill)
            chart.addLineArea(lineGroup, w, h, odata.line, x, y, y2, config, "between");
        chart.addLineArea(lineGroup, w, h, odata.line, x, y, y2, config, "line")
    }
    ;
    function getMinMaxList(chart, dataObj) {
        var hasSplitAxes = chart.splitNumericAxis.splitY.enabled && chart.isBLA();
        var dataByAxis = dataObj.dataByAxis;
        var minMaxList = [];
        if (hasSplitAxes && dataObj.axisCount > 1)
            minMaxList = chart.getSplitAxesMinMaxList(dataByAxis);
        else if (dataObj.dataSubsetCount > 1)
            minMaxList = getMultSubsetMinMaxList(chart, dataByAxis);
        else {
            var tmp_minMaxList = chart.getSplitAxesMinMaxList(dataByAxis);
            if (tmp_minMaxList.length == 1 && tmp_minMaxList[0].name == "y2")
                minMaxList = [{
                    name: "y1",
                    noData: true
                }, tmp_minMaxList[0]]
        }
        return minMaxList
    }
    tdgchart.prototype.preprocessBLAData = function() {
        var chart = this;
        var dataObj = chart.rearangeBLAInternalData(chart._internalData);
        return {
            dataObj: dataObj,
            minMaxList: getMinMaxList(chart, dataObj)
        }
    }
    ;
    tdgchart.prototype.layoutXOrdYChart = function(overallChartSize) {
        var chart = this;
        var chartLayout = chart.layoutDefaultChart(overallChartSize);
        function doLayout(size) {
            chartLayout.axisLayout = chart.getXOrdYAxisLayout(size);
            chartLayout.chartSize = chart.updateSizeAxisLayout(size, chartLayout.axisLayout.spacing);
            return chartLayout.chartSize
        }
        doLayout(chartLayout.chartSize);
        chart.applyBLAScrolling(chartLayout, doLayout);
        return chartLayout
    }
    ;
    tdgchart.prototype.layoutBLAChart = function(overallChartSize) {
        var chart = this;
        var chartLayout = chart.layoutDefaultChart(overallChartSize);
        var mode = chart.getColorMode();
        if ((mode === "byMetric" || mode === "bySeriesSelection" || mode === "byGroupSelection") && !chart.colorMode.hasOwnProperty("isProcessed"))
            return chartLayout;
        chartLayout.blaInfo = chart.preprocessBLAData();
        function doLayout(size) {
            chartLayout.axisLayout = chart.getXOrdYAxisLayout(size, chartLayout.blaInfo.minMaxList);
            chartLayout.chartSize = chart.updateSizeAxisLayout(size, chartLayout.axisLayout.spacing);
            return chartLayout.chartSize
        }
        doLayout(chartLayout.chartSize);
        chart.applyBLAScrolling(chartLayout, doLayout);
        return chartLayout
    }
    ;
    tdgchart.prototype.applyBLAScrolling = function(chartLayout, doLayout) {
        var chart = this;
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        var inset = chartLayout.axisLayout.spacing.inset;
        chartLayout.scrollParams = chart.getScrollParams(chart, chartLayout.chartSize, chartLayout.axisLayout.spacing.inset);
        if (!chartLayout.scrollParams.enabled)
            return;
        var pad = chartLayout.scrollParams.size > 0 ? chartLayout.scrollParams.size + 5 : 0;
        if (isHorizontal) {
            chartLayout.chartSize.width -= pad;
            chartLayout.axisLayout.spacing.w -= pad;
            chartLayout.scrollParams.virt.width -= pad;
            chartLayout.scrollParams.view.width = chartLayout.scrollParams.virt.width
        } else {
            chartLayout.chartSize.height -= pad;
            chartLayout.axisLayout.spacing.h -= pad;
            chartLayout.scrollParams.virt.height -= pad;
            chartLayout.scrollParams.view.height = chartLayout.scrollParams.virt.height
        }
        var virtSize = {
            x: chartLayout.chartSize.x - inset.left,
            y: chartLayout.chartSize.y - inset.top,
            width: chartLayout.scrollParams.virt.width + inset.left + inset.right,
            height: chartLayout.scrollParams.virt.height + inset.top + inset.bottom
        };
        chartLayout.chartSizeReal = tdg.cloneObject(chartLayout.chartSize);
        var virtChartSize = doLayout(virtSize);
        if (isHorizontal)
            chartLayout.chartSizeReal.width = virtChartSize.width;
        else
            chartLayout.chartSizeReal.height = virtChartSize.height;
        var fit = chart.get("axisList.x1.groupFit");
        if (fit && fit.rule === "maxCount" && tdg.isANumber(fit.startGroup)) {
            var x = chartLayout.axisLayout.xScalesList[0];
            chartLayout.scrollParams.view.x = (x(1) - x(0)) * fit.startGroup * -1
        }
    }
    ;
    tdgchart.prototype.drawBLAChart = function(panel, chartLayout) {
        var chart = this;
        var mode = chart.getColorMode();
        if ((mode === "byMetric" || mode === "bySeriesSelection" || mode === "byGroupSelection") && !chart.colorMode.hasOwnProperty("isProcessed")) {
            chart.colorMode.isProcessed = true;
            drawColorByMetricChart(chart, panel, chartLayout);
            delete chart.colorMode.isProcessed;
            return null
        }
        var dataObj = chartLayout.blaInfo.dataObj;
        var chartPanels = chart.createBLAScrollXYPanels(panel, chartLayout.chartSize, chartLayout);
        chart.drawXOrdinalYChart(chartPanels, chartLayout, dataObj, chart.drawBLARisers, dataObj.dataByAxis);
        return null
    }
    ;
    tdgchart.prototype.drawPareto = function(panel, chartLayout) {
        var chart = this;
        var oData = chart.data;
        var oGroupLabels = chart.groupLabels.slice(0);
        var s0 = chart.getSeries(0);
        var s1 = chart.getSeries(1);
        var s0Shape = s0.riserShape;
        var s1Shape = s1.riserShape;
        var s0Axis = s0.yAxisAssignment;
        var s1Axis = s1.yAxisAssignment;
        var y1min = chart.axisList.y1.min;
        var y1max = chart.axisList.y1.max;
        var y2min = chart.axisList.y2.min;
        var y2max = chart.axisList.y2.max;
        var combo = chart.blaProperties.comboCharts;
        var blaLayout = chart.blaProperties.seriesLayout;
        var groupLabels = chart.getGroupLabels();
        var data1 = (chart.data[0] || []).map(function(el) {
            return {
                value: Math.abs(el.value || 0),
                label: groupLabels[el._g] || "",
                _s: 0,
                _g: el._g
            }
        });
        data1.sort(function(b, a) {
            return a.value < b.value ? -1 : a.value > b.value ? 1 : 0
        });
        var sum = tdg.sum(data1, "value");
        var runningTotal = 0;
        var data2 = data1.map(function(el) {
            var v = el.value / sum;
            runningTotal += v;
            return {
                value: runningTotal,
                _s: 1,
                _g: el._g
            }
        });
        chart.data = chart._internalData = [data1, data2];
        chart._internalData.seriesMap = [0, 1];
        chart.groupLabels = data1.map(function(el) {
            return el.label
        });
        chart.chartType = "bar";
        s0.riserShape = "bar";
        s1.riserShape = "line";
        s0.yAxisAssignment = 1;
        s1.yAxisAssignment = 2;
        chart.blaProperties.seriesLayout = "sideBySide";
        chart.blaProperties.comboCharts = {
            barSeriesLayout: "sideBySide",
            lineSeriesLayout: "absolute"
        };
        chart.cache.setProperty("axisList.y1.min", y1min == null ? 0 : y1min);
        chart.cache.setProperty("axisList.y1.max", y1max == null ? sum : y1max);
        chart.cache.setProperty("axisList.y2.min", y2min == null ? 0 : y2min);
        chart.cache.setProperty("axisList.y2.max", y2max == null ? 1 : y2max);
        chart.cache.setProperty("axisList.y2.numberFormat", "#%");
        chart.cache.setProperty("axisList.y2.invert", chart.axisList.y1.invert);
        chartLayout = chart.layoutBLAChart(chartLayout.chartSize);
        chart.drawBLAChart(panel, chartLayout);
        chart.chartType = "pareto";
        chart.data = oData;
        chart.groupLabels = oGroupLabels;
        s0.riserShape = s0Shape;
        s1.riserShape = s1Shape;
        s0.yAxisAssignment = s0Axis;
        s1.yAxisAssignment = s1Axis;
        chart.blaProperties.seriesLayout = blaLayout;
        chart.blaProperties.comboCharts = combo
    }
    ;
    tdgchart.prototype.drawMekko = function(panel, chartLayout) {
        var chart = this;
        var data = chart._internalData;
        var groupSums = [];
        var total = 0;
        var group, series;
        var seriesLayout = chart.blaProperties.seriesLayout;
        var maxSeriesLength = tdg.max(data, "length");
        for (series = 0; series < maxSeriesLength; series++) {
            var sum = 0;
            for (group = 0; group < data.length; group++)
                sum += Math.abs(data[group][series] ? data[group][series].value || 0 : 0);
            groupSums.push(sum);
            total += sum
        }
        chart.cache.set("mekkoData", {
            mekkoGroupSums: groupSums,
            mekkoTotal: total
        });
        chart.chartType = "bar";
        chart.blaProperties.seriesLayout = "percent";
        chart.cache.setProperty("axisList.y1.numberFormat", "#`%");
        chart.blaProperties.stackTotalLabel.visible = true;
        reorderDataAndLabelsFromSums(chart, data);
        chartLayout = chart.layoutBLAChart(chartLayout.chartSize);
        chart.drawBLAChart(panel, chartLayout);
        chart.chartType = "mekko";
        chart.blaProperties.seriesLayout = seriesLayout
    }
    ;
    function reorderDataAndLabelsFromSums(chart, data) {
        var groupLabels = tdg.clone(chart.getGroupLabels());
        var mekkoData = chart.cache.get("mekkoData");
        for (var g = 0; g < mekkoData.mekkoGroupSums.length; g++) {
            var max = 0;
            var maxIndex = 0;
            for (var s = g; s < mekkoData.mekkoGroupSums.length; s++)
                if (mekkoData.mekkoGroupSums[s] > max) {
                    max = mekkoData.mekkoGroupSums[s];
                    maxIndex = s
                }
            var v = mekkoData.mekkoGroupSums[maxIndex];
            mekkoData.mekkoGroupSums[maxIndex] = mekkoData.mekkoGroupSums[g];
            mekkoData.mekkoGroupSums[g] = v;
            if (maxIndex < groupLabels.length) {
                v = groupLabels[maxIndex];
                groupLabels[maxIndex] = groupLabels[g];
                groupLabels[g] = v
            }
            for (var d = 0; d < data.length; d++) {
                v = data[d][maxIndex];
                data[d][maxIndex] = data[d][g];
                data[d][g] = v
            }
        }
        chart.cache.setProperty("groupLabels", groupLabels)
    }
    tdgchart.prototype.isBar = function() {
        var chartType = this.chartType === "matrix" ? this.matrixProperties.chartType : this.chartType;
        return ["bar", "waterfall", "boxplot", "histogram", "stock", "gantt", "mekko", "pictogram"].includes(chartType)
    }
    ;
    tdgchart.prototype.isBLA = function() {
        var chartType = this.chartType === "matrix" ? this.matrixProperties.chartType : this.chartType;
        return chartType === "bar" || chartType === "line" || chartType === "area"
    }
    ;
    tdgchart.prototype.isComboChart = function() {
        var chart = this;
        if (!chart.isBLA() || chart.cache.hasKey("mekkoData"))
            return false;
        if (!chart._internalData || !chart._internalData.seriesMap)
            return false;
        var seriesMap = chart._internalData.seriesMap;
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        for (var s = 0; s < chart.series.length; s++) {
            var series = chart.series[s];
            if (!series || !series.riserShape || series.series !== "all" && !seriesMap.includes(series.series))
                continue;
            var r = series.riserShape;
            if (typeof r === "object" && r.y1 && r.y2) {
                if (r.y1 !== r.y2 && chart.needDualY2Axis())
                    return true;
                r = r.y1 + ""
            }
            r = r === "line" || r === "area" ? r : "bar";
            if (r !== chartType)
                return true
        }
        return false
    }
    ;
    tdgchart.prototype.getBLAXScalesList = function(panelSize, xAxisList, index) {
        var chart = this;
        var isBar = chart.isBar() || chart.series.some(function(el) {
            return el.riserShape === "bar"
        });
        var gap = Math.max(0, Math.min(chart.blaProperties.barGroupGapWidth || 0, 1));
        var extendToFrameEdge = chart.blaProperties.extendToFrameEdge;
        var groupCount;
        if (index != null && chart.cache.hasKey("matrixCompressedGroups")) {
            var compInfo = chart.cache.get("matrixCompressedGroups");
            groupCount = compInfo.groupCountArray[index]
        }
        var pad = xAxisList[0].padding || [0, 0];
        var size = xAxisList[0].size || panelSize;
        var inset = 1;
        if (isBar)
            inset = 1 - gap;
        else if (extendToFrameEdge)
            inset = 2;
        var x = chart.getOrdinalScale(size, inset, null, xAxisList[0].properties.invert, null, groupCount);
        x.side = xAxisList[0].side;
        x.panelOffset = pad[0];
        return [x]
    }
    ;
    tdgchart.prototype.createBLAScrollXYPanels = function(rootPanel, chartSize, chartLayout) {
        var chart = this;
        if (!chartLayout.scrollParams || !chartLayout.scrollParams.enabled)
            return chart.createXYPanels(rootPanel, chartSize, chartLayout.axisLayout);
        var isVertical = chart.blaProperties.orientation === "vertical";
        var visibleRiserPanel = chart.addPanelOfSize(rootPanel, chartLayout.chartSizeReal);
        var scrolledPanel = chart.addBLAAxisScrollBar(chart, visibleRiserPanel, null, chartLayout.scrollParams).p;
        var riserPanel = chart.addPanel(scrolledPanel);
        var rootPanels = {
            chart: riserPanel
        };
        var inset = chartLayout.axisLayout.spacing.inset;
        if (chartLayout.axisLayout.spacing.axisAt.left.length)
            rootPanels.left = chart.addPanel(isVertical ? visibleRiserPanel : scrolledPanel, -inset.left, 0, inset.left, null);
        if (chartLayout.axisLayout.spacing.axisAt.right.length)
            rootPanels.right = chart.addPanel(isVertical ? visibleRiserPanel : scrolledPanel, chartLayout.chartSizeReal.width, 0, inset.right, null);
        if (chartLayout.axisLayout.spacing.axisAt.bottom.length)
            rootPanels.bottom = chart.addPanel(isVertical ? scrolledPanel : visibleRiserPanel, 0, chartLayout.chartSizeReal.height, null, -inset.bottom);
        if (chartLayout.axisLayout.spacing.axisAt.top.length)
            rootPanels.top = chart.addPanel(isVertical ? scrolledPanel : visibleRiserPanel, 0, -inset.top, null, inset.top);
        rootPanels.xAxisStaticTitles = staticTitlePanels(chart, chartLayout.axisLayout, visibleRiserPanel, chartLayout.chartSizeReal);
        return chart.createXYPanelsM(rootPanels, {
            x: 0,
            y: 0,
            width: chartSize.width,
            height: chartSize.height
        }, chartLayout.axisLayout, true)
    }
    ;
    function staticTitlePanels(chart, axisLayout, visibleRiserPanel, chartSizeReal) {
        var staticTitles = {};
        for (var i = 0; i < axisLayout.xAxisList.length; i++) {
            var xAxis = axisLayout.xAxisList[i];
            switch (xAxis.side) {
            case "left":
                staticTitles[xAxis.name] = chart.addPanel(visibleRiserPanel, 0, 0, 0, null);
                break;
            case "right":
                staticTitles[xAxis.name] = chart.addPanel(visibleRiserPanel, chartSizeReal.width, 0, 0, null);
                break;
            case "top":
                staticTitles[xAxis.name] = chart.addPanel(visibleRiserPanel, 0, 0, null, 0);
                break;
            case "bottom":
                staticTitles[xAxis.name] = chart.addPanel(visibleRiserPanel, 0, chartSizeReal.height, null, 0);
                break
            }
        }
        return staticTitles
    }
    tdgchart.prototype.addBLAAxisScrollBar = function(chart, panel, riserPanel, scrollParams) {
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        var barid = chart.isScrollMiniChart(chart.axisList.x1) ? "slider-h" : isHorizontal ? "rp-v" : "rp-h";
        var riserPanel = {
            name: "riserPanel",
            x: 0,
            y: 0,
            w: scrollParams.view.width,
            h: scrollParams.view.height,
            virt_w: scrollParams.virt.width,
            virt_h: scrollParams.virt.height,
            scroll_h: isHorizontal ? 0 : 1,
            scroll_v: isHorizontal ? 1 : 0,
            start_x: scrollParams.view.x || 0,
            start_y: scrollParams.view.y || 0,
            clip: false,
            className: "scrollriserPanel",
            debugColor: "rgba(0,255,0, 0.3)"
        };
        riserPanel.p = chart.addScrollPanel(panel, riserPanel);
        if (!scrollParams.noScrollBar)
            chart.addScrollBar(panel, barid, scrollParams.position, isHorizontal ? scrollParams.view.height : scrollParams.view.width, scrollParams.size, riserPanel);
        return riserPanel
    }
    ;
    tdgchart.prototype.drawXOrdinalYChart = function(chartPanels, chartLayout, dataObj, drawRisers, dataByAxis, config) {
        var chart = this;
        var axisLayout = chartLayout.axisLayout;
        var isMatrix = chart.chartType === "matrix";
        var i, axisName;
        var x = axisLayout.xScalesList[0];
        var yScalesList = axisLayout.yScalesList;
        var isBar = chart.isBar();
        isBar = isBar || chart.series.some(function(el) {
            return el.riserShape === "bar"
        });
        if (!isMatrix) {
            chart.addChartFrame(chartPanels.riser.bg);
            if (!chart.splitNumericAxis.splitY.enabled) {
                drawAltFrameFills(chart, chartPanels.riser.bg, axisLayout);
                drawColorRanges(chart, chartPanels.riser.bg, axisLayout)
            }
        }
        if (axisLayout.hasSplitAxes)
            for (i = 0; i < yScalesList.length; i++) {
                axisName = axisLayout.yAxisList[i].name;
                if (chartPanels.risers[axisName].panel)
                    drawRisers.call(chart, chartPanels.risers[axisName].panel, dataByAxis[axisName], x, yScalesList[i], null)
            }
        else if (chartPanels.riser.panel)
            drawRisers.call(chart, chartPanels.riser.panel, dataObj.odata || dataObj, x, yScalesList.y1, yScalesList.y2, config);
        chart.drawOrdinalAxis(chartPanels, x, axisLayout.xAxisList[0], axisLayout.spacing, !isBar);
        chart.drawNumericAxis(chartPanels, yScalesList, axisLayout.yAxisList, axisLayout.spacing);
        for (i = 0; i < yScalesList.length; i++) {
            axisName = axisLayout.yAxisList[i].name;
            var drawPanel = chartPanels.risers[axisName].fg;
            if (drawPanel)
                chart.drawNumericBaseline(drawPanel, yScalesList[i], axisLayout.yAxisList[i])
        }
        if (axisLayout.hasSplitAxes)
            for (i = 0; i < yScalesList.length; i++) {
                axisName = axisLayout.yAxisList[i].name;
                chart.drawAxisDivider(chartPanels.axis[axisName], axisLayout.yAxisList[i])
            }
        if (!axisLayout.hasSplitAxes)
            chart.drawReferenceLines(chartPanels.riser, axisLayout, axisLayout.spacing);
        chart.doTrendline(chartPanels.risers, dataObj.dataByAxis, chart.data, axisLayout.xScalesList, yScalesList);
        if (!axisLayout.hasSplitAxes)
            chart.drawChartFrameAnnotations(chartPanels, x, yScalesList.y1, axisLayout.yAxisList[0].side)
    }
}
)();
(function() {
    function addRotateInteraction(chart, panel) {
        function rotate_view(chart, panel, r, t) {
            if (chart.threedProperties.startRotate == null)
                chart.threedProperties.startRotate = chart.threedProperties.rotate;
            if (chart.threedProperties.startTilt == null)
                chart.threedProperties.startTilt = chart.threedProperties.tilt;
            chart.threedProperties.rotate = r;
            chart.threedProperties.tilt = t;
            panel.rotate(chart.threedProperties.rotate / 180 * Math.PI);
            panel.tilt(chart.threedProperties.tilt / 180 * Math.PI);
            panel.render()
        }
        function rotate() {
            function within(x, min, max) {
                if (x < min)
                    return min;
                if (x > max)
                    return max;
                return x
            }
            var r = within(chart.threedProperties.rotate - this.delta.dx / 5, 0, 90);
            var t = within(chart.threedProperties.tilt + this.delta.dy / 5, 0, 90);
            rotate_view(chart, panel, r, t)
        }
        function resetRotate() {
            if (chart.threedProperties.startRotate != null && chart.threedProperties.startTilt != null)
                rotate_view(chart, panel, chart.threedProperties.startRotate, chart.threedProperties.startTilt)
        }
        panel.add(pv.Panel).events("all").event("dblclick", chart.interaction.dblclick === "resetView" ? resetRotate : null).event("mousedown", pv.Behavior.delta()).event("touchstart", pv.Behavior.delta()).event("delta", rotate)
    }
    function add3dInteraction(chart, panel) {
        if (chart.interaction.mousedrag === "rotate")
            addRotateInteraction(chart, panel)
    }
    tdgchart.prototype.d3d_chart_frame = function(p) {
        p.add(pv.Wall3d).left(0).right(0).top(0).bottom(0).back(0).fillStyle(this.chartFrame.fill.color).lineStyle(this.chartFrame.border);
        p.add(pv.Wall3d).left(0).top(0).bottom(0).front(0).back(0).fillStyle(pv.tdgScene.adjcolor(this.chartFrame.fill.color, 1.5)).lineStyle(this.chartFrame.border);
        p.add(pv.Wall3d).left(0).right(0).bottom(0).front(0).back(0).fillStyle(pv.tdgScene.adjcolor(this.chartFrame.fill.color, .7)).lineStyle(this.chartFrame.border)
    }
    ;
    tdgchart.prototype.d3d_prep_panel = function(parent_panel, depth) {
        return parent_panel.add(pv.Panel3d).depth(depth).rotate(this.threedProperties.rotate / 180 * Math.PI).tilt(this.threedProperties.tilt / 180 * Math.PI)
    }
    ;
    tdgchart.prototype.draw3dChart = function(panel) {
        var rootpanel = panel;
        var seriesCount = this.seriesCount();
        var h = rootpanel.computedSize.height;
        var section = rootpanel.computedSize.width / this.visibleGroupCount();
        var depth_mult = 100;
        var p = this.d3d_prep_panel(rootpanel, seriesCount * depth_mult);
        add3dInteraction(this, p);
        this.d3d_chart_frame(p);
        var barGapSize = 1 - this.blaProperties.barGroupGapWidth
          , axisInset = this.chartType === "bar" ? barGapSize : 1;
        p.computedSize = rootpanel.computedSize;
        p.computedSize.depth = seriesCount * depth_mult;
        var x = this.getOrdinalScale(panel.computedSize, axisInset);
        var y = this.getNumericScale(rootpanel.computedSize, {
            side: "",
            properties: this.yaxis
        });
        var z = this.getSeriesOrdinalScale(panel, axisInset);
        var yAbsValues = this.yaxis.absValues;
        this.yaxis.side = this.yaxis.swapChartSide ? "right-back" : "left-front";
        this.xaxis.side = "front-bottom";
        this.zaxis.side = "right-bottom";
        this.drawNumericAxis3d(p, y, {
            properties: this.yaxis,
            side: this.yaxis.side
        });
        this.drawOrdinalAxis3d(p, x, null, this.chartType !== "bar3d");
        this.drawSeriesOrdinalAxis3d(p, z, null, false);
        var margin = 0;
        var dmargin = 100 * this.getRiserDepthGap() / 2;
        var depth, mark;
        if (this.chartType === "bar3d") {
            margin = section * this.blaProperties.barGroupGapWidth / 2;
            mark = pv.Bar3d
        } else if (this.chartType === "area3d") {
            margin = section / 2;
            mark = pv.Area3d
        } else {
            mark = pv.Surface3d;
            dmargin = depth_mult / 2;
            depth = depth_mult;
            margin = section / 2
        }
        var chart = this;
        var textLookup = function(d) {
            var nf = chart.getSeriesAndGroupProperty(d._s, d._g, "dataLabels.numberFormat");
            if (d == null || d.value == null)
                return null;
            var neg = d.isNeg != null && d.isNeg;
            if (d.actualValue != null)
                d = d.actualValue;
            else if (d.value != null)
                d = d.value;
            if (neg)
                d *= -1;
            return chart.formatNumber(d, nf)
        };
        var hscale = h / (y.domain()[1] - y.domain()[0]);
        var data = this.adjustData(this._internalData);
        var rdata = [];
        for (var i = 0; i < data.length; i++)
            rdata.push(data[data.length - i - 1]);
        var riser = p.add(pv.Panel3d).depth(seriesCount * depth_mult).front(function() {
            return dmargin + depth_mult * (seriesCount - this.index - 1)
        });
        var reversed_order = false;
        if (reversed_order)
            riser.data(rdata).add(mark).className(chart.classNameLookup("bar", "riser")).data(function(d) {
                return d
            }).visible(function(d) {
                return d.value != null || chart.chartType === "area3d"
            }).depth(depth || depth_mult - 2 * dmargin).bottom(function() {
                return -y.domain()[0] * hscale
            }).height(function(d) {
                return (yAbsValues ? Math.abs(d) : d) * hscale
            }).left(function() {
                return margin + this.index * section
            }).width(section - margin * 2).fillEffect(this.threedProperties.shadeSides ? "shadeSides" : null).fillStyle(this.seriesColorLookup()).lineWidth(this.seriesPropertyLookup("border.width")).strokeStyle(this.seriesPropertyLookup("border.color")).dashStyle(this.seriesPropertyLookup("border.dash")).title(this.seriesToolTipLookup());
        else
            riser.data(data).add(mark).className(chart.classNameLookup("bar", "riser")).data(function(d) {
                return d
            }).visible(function(d) {
                return d.value != null || chart.chartType === "area3d"
            }).depth(depth || depth_mult - 2 * dmargin).bottom(function() {
                return -y.domain()[0] * hscale
            }).height(function(d) {
                return (yAbsValues ? Math.abs(d.value) : d.value) * hscale
            }).left(function() {
                return margin + this.index * section
            }).width(section - margin * 2).fillEffect(this.threedProperties.shadeSides ? "shadeSides" : null).fillStyle(this.seriesColorLookup()).lineWidth(this.seriesPropertyLookup("border.width")).strokeStyle(this.seriesPropertyLookup("border.color")).dashStyle(this.seriesPropertyLookup("border.dash")).title(this.seriesToolTipLookup());
        if (this.areDataLabelsVisible())
            riser.add(pv.Label3d).data(function(d) {
                return d
            }).bottom(function(d) {
                return (yAbsValues ? Math.abs(d.value) : Math.max(d.value, 0) - y.domain()[0]) * hscale + 20
            }).left(function() {
                return this.index * section + section / 2
            }).front(-dmargin + depth_mult / 2).textAlign("center").textBaseline("middle").className("dataText").font(this.seriesPropertyLookup("dataLabels.font")).textStyle(this.seriesPropertyLookup("dataLabels.color")).text(textLookup).visible(chart.dataLabelVisibleLookup())
    }
}
)();
tdgchart.prototype.depth25d = function() {
    switch (this.chartType) {
    case "bar":
    case "waterfall":
    case "histogram":
    case "gantt":
    case "pareto":
    case "line":
    case "area":
    case "pie":
    case "mekko":
        return this.depth > 0 ? this.depth : 0
    }
    return false
}
;
tdgchart.prototype.computeddepth25d = function() {
    switch (this.chartType) {
    case "pie":
        return this.depth > 0 ? this.depth : 0;
    case "bar":
    case "waterfall":
    case "histogram":
    case "gantt":
    case "pareto":
        return this.depth > 0 ? this.depth / Math.sqrt(2) : 0;
    case "line":
    case "area":
        if (this.blaProperties.seriesLayout !== "percent" && this.blaProperties.seriesLayout !== "stacked")
            return this.depth > 0 ? this.data.length * this.depth / Math.sqrt(2) : 0;
        else
            return this.depth > 0 ? this.depth / Math.sqrt(2) : 0
    }
    return 0
}
;
tdgchart.prototype.getRiserDepthGap = function() {
    return tdgchart.util.bound(this.riserDepthGap || 0, 0, 1)
}
;
tdgchart.prototype.getRiserDepthGapInset = function() {
    var depth = this.depth25d()
      , depthGap = this.getRiserDepthGap();
    return Math.ceil(depth * depthGap / 2 / Math.SQRT2)
}
;
(function() {
    tdgchart.initLabelDiv = initLabelDiv;
    tdgchart.clearLabelDiv = clearLabelDiv;
    tdgchart._measureLabelCache = {
        size: {},
        fontSize: {}
    };
    var tdg = tdgchart.util;
    var isIE = /MSIE|Trident/.test(typeof window !== "undefined" && window.navigator ? window.navigator.userAgent : undefined);
    tdgchart.prototype.applyWrapAndTruncate = function(text, font, wrap, type, maxWidth) {
        if (text == null)
            return null;
        if (typeof text === "string" && text.indexOf("\n") >= 0)
            return text;
        var chart = this;
        var linesArray, wrappedLbl;
        wrap = wrap == null ? "auto" : wrap;
        var maxLines = convertAutoWrap(type, wrap);
        if (!maxLines || maxLines < 2 || tdg.textContainsHTML(text))
            return chart.truncateLabel(text, font, maxWidth);
        var lblObj = {
            text: text,
            wrap: wrap,
            font: font
        };
        var firstWordWidth = chart.measureLabel(text.split(" ")[0], font).width;
        if (firstWordWidth < maxWidth)
            wrappedLbl = wrapLabel(lblObj, maxLines, maxWidth);
        else if (firstWordWidth > maxWidth)
            wrappedLbl = wrapLabel(lblObj, maxLines, firstWordWidth + 1);
        wrappedLbl = wrappedLbl || text;
        linesArray = wrappedLbl.split("\n");
        if (maxLines > linesArray.length)
            return chart.truncateLabel(wrappedLbl, font, maxWidth);
        else {
            linesArray.length = maxLines;
            linesArray[linesArray.length - 1] = chart.truncateLabel(linesArray[linesArray.length - 1], font, maxWidth);
            wrappedLbl = linesArray.reduce(function(prev, cur, idx) {
                return prev + cur + (idx < linesArray.length - 1 ? "\n" : "")
            }, "")
        }
        return wrappedLbl
    }
    ;
    function convertAutoWrap(label, wrap) {
        if (wrap === "auto")
            switch (label) {
            case "title":
            case "subtitle":
            case "footnote":
            case "colLabels":
                return 3;
            case "legend":
            case "axis":
            case "legend-labels":
            case "rowLabels":
                return 2;
            default:
                return 2
            }
        return wrap || 1
    }
    function wrapLabel(label, maxWrapLines, maxWidth) {
        if (!maxWrapLines || maxWrapLines < 2)
            return label.text;
        var words = label.text.split(" ");
        if (words.length < 2)
            return label.text;
        words = words.filter(function(str) {
            return str !== ""
        });
        var lineCount = 1
          , currentLine = ""
          , text = "";
        for (var i = 0; i < words.length; i++) {
            currentLine += (currentLine === "" ? "" : " ") + words[i];
            if (tdgchart.measureLabel(currentLine, label.font).width >= maxWidth && lineCount < maxWrapLines) {
                text = text.trim();
                text += "\n";
                lineCount += 1;
                currentLine = "";
                i--;
                continue
            }
            text += words[i];
            if (i < words.length - 1)
                text += " "
        }
        if (text[0] === "\n")
            text = text.slice(1);
        return text
    }
    function initLabelDiv() {
        if (tdgchart._cachedLabelDiv == null) {
            var cache = tdgchart._cachedLabelDiv = {};
            cache.divSVG = document.createElement("div");
            var newSVG = document.createElementNS(tdg.ns.svg, "svg");
            newSVG.setAttribute("xmlns", tdg.ns.svg);
            cache.divSVG.appendChild(newSVG);
            var useForeignObject = document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Extensibility", "1.1");
            if (!useForeignObject) {
                var outerdiv = document.createElement("div");
                var div = document.createElement("div");
                outerdiv.setAttribute("style", "position: absolute; left: -1000px; top: -1000px; all: unset; font-size: 10pt; font-family: Sans-Serif; color: black");
                outerdiv.appendChild(div);
                cache.ieDIV = outerdiv;
                cache.div = div
            } else {
                var fo = document.createElementNS(tdg.ns.svg, "foreignObject");
                fo.setAttribute("x", "-1000");
                fo.setAttribute("y", "-1000");
                fo.setAttribute("width", "2000");
                fo.setAttribute("height", "1000");
                var objectBody = document.createElementNS(tdg.ns.xhtml, "body");
                objectBody.setAttribute("xmlns", tdg.ns.xhtml);
                objectBody.setAttribute("marginWidth", "0");
                objectBody.setAttribute("marginHeight", "0");
                objectBody.setAttribute("style", "all: unset; o:p; font-size: 10pt; font-family: Sans-Serif; color: black");
                var div = document.createElement("div");
                div.setAttribute("style", "position:absolute");
                objectBody.appendChild(div);
                newSVG.appendChild(fo);
                fo.appendChild(objectBody);
                cache.div = div
            }
            cache.svg = document.createElementNS(tdg.ns.svg, "svg");
            cache.svg.setAttribute("style", "position: absolute; left: -1000px; top: -1000px");
            cache.singleLineDiv = document.createElementNS(tdg.ns.svg, "text");
            cache.singleLineDiv.appendChild(document.createTextNode(""));
            cache.svg.appendChild(cache.singleLineDiv);
            if (window !== window.parent && document.body.clientWidth === 0)
                try {
                    window.parent.document.body.appendChild(cache.svg);
                    window.parent.document.body.appendChild(cache.divSVG);
                    if (cache.ieDIV)
                        window.parent.document.body.appendChild(cache.ieDIV)
                } catch (e$9) {
                    document.body.appendChild(cache.svg);
                    document.body.appendChild(cache.divSVG);
                    if (cache.ieDIV)
                        document.body.appendChild(cache.ieDIV)
                }
            else {
                document.body.appendChild(cache.svg);
                document.body.appendChild(cache.divSVG);
                if (cache.ieDIV)
                    document.body.appendChild(cache.ieDIV)
            }
        }
    }
    function clearLabelDiv() {
        if (tdgchart._cachedLabelDiv) {
            if (tdgchart._cachedLabelDiv.svg)
                tdgchart._cachedLabelDiv.svg.parentNode.removeChild(tdgchart._cachedLabelDiv.svg);
            if (tdgchart._cachedLabelDiv.divSVG) {
                tdgchart._cachedLabelDiv.div = null;
                tdgchart._cachedLabelDiv.divSVG.parentNode.removeChild(tdgchart._cachedLabelDiv.divSVG)
            }
            if (tdgchart._cachedLabelDiv.ieDIV) {
                tdgchart._cachedLabelDiv.div = null;
                tdgchart._cachedLabelDiv.ieDIV.parentNode.removeChild(tdgchart._cachedLabelDiv.ieDIV)
            }
        }
        tdgchart._cachedLabelDiv = null
    }
    function rawHTMLText(label) {
        var domContainer = document.createElement("div");
        domContainer.innerHTML = label;
        return domContainer.textContent
    }
    tdgchart.prototype.truncateLabel = function(label, font, maxWidth) {
        var chart = this;
        if (typeof label !== "string")
            label = label + "";
        if (label.length < 3)
            return label;
        label = label.trim().replace(/  +/g, " ");
        if (tdgchart._measureLabelCache.fontSize[font] && tdgchart.disableFontCache !== true)
            if (tdgchart._measureLabelCache.fontSize[font].width * label.length * .75 < maxWidth)
                return label;
        var lblSize = tdg.measureLabelWidth(label, font);
        if (lblSize <= maxWidth)
            return label;
        if (label.includes("<br>") || label.includes("\n")) {
            var splitChar = label.includes("<br>") ? "<br>" : "\n";
            return label.split(splitChar).map(function(el) {
                return chart.truncateLabel(el, font, maxWidth)
            }).join(splitChar)
        }
        var symbolWidth = chart.truncation.symbol ? tdg.measureLabelWidth(chart.truncation.symbol, font) : 0;
        var haveHTML = false
          , rawLabel = label;
        if (tdg.textContainsHTML(label)) {
            rawLabel = rawHTMLText(label);
            haveHTML = true
        }
        var guess = Math.floor(rawLabel.length * (maxWidth - symbolWidth) / lblSize);
        var truncatedLabel = rawLabel.substring(0, guess);
        if (truncatedLabel.length < 1)
            return haveHTML ? label.replace(rawLabel, rawLabel.charAt(0)) : rawLabel.charAt(0);
        var newLabel = haveHTML ? label.replace(rawLabel, truncatedLabel) : truncatedLabel;
        var truncatedLblSize = tdg.measureLabelWidth(newLabel, font);
        if (truncatedLblSize + symbolWidth >= maxWidth && guess > 1)
            truncatedLabel = rawLabel.substring(0, guess - Math.max(Math.floor(guess / 35), 1));
        truncatedLabel = truncatedLabel.trim() + chart.truncation.symbol || "";
        return haveHTML ? label.replace(rawLabel, truncatedLabel) : truncatedLabel
    }
    ;
    tdgchart.prototype.drawTruncatedTitle = function(panel, label, className, dx, dy, baseline, rotation, maxSize) {
        var chart = this;
        var lbl = tdg.cloneObject(label);
        maxSize = maxSize || panel.computedSize.width - 5;
        lbl.text = chart.truncateLabel(lbl.text, lbl.font, maxSize);
        chart.drawTitle(panel, lbl, className, dx, dy, baseline, rotation, maxSize)
    }
    ;
    tdgchart.prototype.drawTitle = function(panel, label, className, dx, dy, baseline, rotation, maxSize, box) {
        var chart = this;
        if (tdg.textContainsHTML(label.renderedText || label.text)) {
            label = tdg.cloneObject(label);
            label.font = label.color = ""
        }
        chart.drawLabel(panel, label, className, dx, dy, baseline, rotation, maxSize, box)
    }
    ;
    tdgchart.prototype.drawLabel = function(panel, label, className, dx, dy, baseline, rotation, maxSize, box) {
        if (label.visible === false || tdg.isEmpty(label.renderedText) && tdg.isEmpty(label.text))
            return;
        var chart = this;
        var scene = chart.cache.get("tdgscene");
        if (baseline == null && label.valign != null)
            baseline = label.valign;
        baseline = baseline || "top";
        dy = dy == null ? chart.getPadding("label", "aveVert") : dy;
        var w = panel.computedSize.width
          , h = panel.computedSize.height
          , pad = 3;
        var y = baseline === "bottom" ? -pad : pad;
        var labelStyle = {
            className: className,
            font: label.font,
            color: label.color,
            align: label.align || "center",
            valign: "top",
            translate: {
                x: w / 2,
                y: dy
            },
            cursor: "default",
            shift: -.29,
            title: chart.resolveToolTipTitleContent(label.tooltip),
            maxWidth: maxSize
        };
        if (baseline === "bottom") {
            labelStyle.translate.y = h - dy;
            labelStyle.valign = "bottom";
            labelStyle.shift = 0
        } else if (baseline === "middle" || baseline === "center") {
            labelStyle.valign = "middle";
            labelStyle.translate.y = h / 2;
            y = 1.5
        } else if (baseline === "left")
            labelStyle.translate = {
                x: 0,
                y: h / 2
            };
        else if (baseline === "right")
            labelStyle.translate = {
                x: w,
                y: h / 2
            };
        var borderWidth = panel.computedSize.innerBorderSize || 0;
        if (label.align === "left")
            labelStyle.translate.x = borderWidth + pad + pad;
        else if (label.align === "right")
            labelStyle.translate.x = w - borderWidth - pad - pad;
        else if (label.align === "chartFrame") {
            labelStyle.translate.x = dx || 0;
            labelStyle.align = "center"
        }
        if (rotation)
            labelStyle.rotation = chart.getLabelAngleConfig(baseline, rotation).rotation;
        var group = scene.group(panel);
        if (box && (label.backgroundColor && tdg.color.isVisible(label.backgroundColor) || label.border && tdg.color.isLineVisible(label.border))) {
            var style = {
                color: label.backgroundColor,
                lineStyle: label.border,
                cornerRadius: label.border.cornerRadius
            };
            group.rect(box.x, box.y, box.width, box.height, style)
        }
        group.label(0, y, label.renderedText || label.text, labelStyle)
    }
    ;
    tdgchart.measureLabel = tdgchart.prototype.measureLabel = function(label, font, maxWidth) {
        if (tdgchart._cachedLabelDiv == null)
            tdgchart.initLabelDiv();
        if (font == null && label.hasOwnProperty("text") && label.hasOwnProperty("font")) {
            font = label.font;
            label = label.text
        }
        if (typeof label !== "string")
            label = label + "";
        if (label === "")
            label = ".";
        font = font || "10px sans-serif";
        if (typeof font === "function")
            font = font(label);
        var isHTML = tdg.textContainsHTML(label);
        var cache = tdgchart._measureLabelCache;
        if (!isHTML && !maxWidth && cache.size[font] != null && cache.size[font][label] != null && tdgchart.disableFontCache !== true)
            return {
                width: cache.size[font][label].width,
                height: cache.size[font][label].height
            };
        function resetFontAttrs(div) {
            var fontAttrs = ["fontFamily", "fontKerning", "fontSize", "fontStretch", "fontStyle", "fontVariant", "fontVariantLigatures", "fontWeight", "lineHeight"];
            fontAttrs.forEach(function(a) {
                div.style[a] = ""
            })
        }
        var width, height;
        tdgchart._cachedLabelDiv.div.style.width = null;
        if (isHTML || label.includes("\n")) {
            if (isIE)
                resetFontAttrs(tdgchart._cachedLabelDiv.div);
            tdgchart._cachedLabelDiv.div.style.font = font;
            if (isHTML && maxWidth)
                tdgchart._cachedLabelDiv.div.style.width = maxWidth + "px";
            tdgchart._cachedLabelDiv.div.innerHTML = label.replace(/\n/ig, "<br>");
            width = tdgchart._cachedLabelDiv.div.clientWidth;
            height = tdgchart._cachedLabelDiv.div.clientHeight
        } else {
            if (isIE)
                resetFontAttrs(tdgchart._cachedLabelDiv.singleLineDiv);
            tdgchart._cachedLabelDiv.singleLineDiv.style.font = font;
            tdgchart._cachedLabelDiv.singleLineDiv.firstChild.textContent = label;
            if (cache.fontSize[font] == null || tdgchart.disableFontCache) {
                var bbox = tdgchart._cachedLabelDiv.singleLineDiv.getBBox();
                width = bbox.width;
                height = bbox.height
            } else {
                width = tdgchart._cachedLabelDiv.singleLineDiv.getComputedTextLength();
                height = cache.fontSize[font].height
            }
            width = Math.round(width);
            height = Math.round(height)
        }
        cache.size[font] = cache.size[font] || {};
        cache.size[font][label] = {
            width: width,
            height: height
        };
        return {
            width: width,
            height: height
        }
    }
    ;
    function getPctNumberFormat(chart, format) {
        var label = chart.formatNumber(50, format);
        label = label.replace("%", "");
        var idx = label.lastIndexOf(".");
        if (idx >= 0)
            return "#." + "#".repeat(label.length - idx - 1) + "%";
        return "#%"
    }
    tdgchart.prototype.resolveDataLabelContent = function(d, data, ids) {
        function anyFieldUndefined(d) {
            var map = chart.getDefaultDataArrayMap();
            if (chart.havePieMarkers())
                map = ["value"];
            for (var i = 0; i < map.length; i++)
                if (!d.hasOwnProperty(map[i]) || d[map[i]] == null)
                    return true;
            return false
        }
        var chart = this;
        var chartType = chart.chartType;
        var content = chart.getSerDepProperty("dataLabels.content", ids);
        var fallbackContent = chart.getSerDepProperty("dataLabels.fallbackContent", ids);
        var dataNumberFormat = d._numberFormat;
        var transposeData, originalD = d, neg = false;
        if (d == null || d != null && d.noLabel != null && d.noLabel)
            return null;
        if (typeof content === "function")
            return content.call(chart, d, ids.series, ids.group, data, ids.row, ids.col);
        else if (tdgchart.templateEngine.isTemplateString(content))
            return chart.parseTemplate(content, d, data, ids);
        else if (content === "auto")
            if (chartType === "treemap")
                content = "x";
            else if (chart.isBLA() && chart.blaProperties.seriesLayout === "percent")
                content = "x";
            else if (chartType === "matrix" && chart.matrixProperties.chartType === "marker" && chart.getSerDepProperty("marker.shape", ids) === "fill")
                content = "color";
            else if (chartType === "matrix" && chart.matrixProperties.chartType === "marker" && Array.isArray(chart.dataArrayMap) && chart.dataArrayMap.indexOf("size") == -1 && chart.dataArrayMap.indexOf("color") != -1)
                content = "color";
            else if (chartType === "boxplot" && d.value != undefined)
                content = d.value;
            else if (fallbackContent)
                content = fallbackContent;
            else
                content = chart.getDefaultDataField();
        if (Array.isArray(d))
            if (d.filter(function(el) {
                return el != null
            }).length !== d.length)
                return null;
            else if (content === "x" || d.length < 2)
                d = d[0];
            else if (content === "y" || d.length < 3)
                d = d[1];
            else if (content === "z" || content == null)
                d = d[2];
        if (typeof d === "object") {
            if (anyFieldUndefined(d))
                return null;
            else if (d.hasOwnProperty(content + "_time"))
                return d[content + "_time"];
            if (d.isNeg)
                neg = true;
            if (tdgchart.extensionManager.isExtension(chartType)) {
                var defaultField = tdgchart.extensionManager.getModuleProperty(chart, "dataLabels", "defaultDataArrayEntry");
                if (d.hasOwnProperty(defaultField))
                    d = d[defaultField]
            }
        }
        if (typeof d === "object")
            if (d.hasOwnProperty(content))
                d = d[content];
            else if (content === "z" && d.hasOwnProperty("size"))
                d = d.size;
            else if (chartType === "polar" && content === "y" && d.hasOwnProperty("r"))
                d = d.r;
            else if (chartType === "treemap" && content === "x" && d.hasOwnProperty("nodeName"))
                d = d.truncatedNodeName;
            else if (d.actualValue != null)
                d = d.actualValue;
            else if (d.percent != null)
                d = d.percent;
            else if (chartType === "bubble" && d.size != null)
                d = d.size;
            else if (chartType === "waterfall" && d.total != null)
                d = d.total;
            else if (chartType === "polar" && d.phi != null)
                d = d.phi;
            else if (chartType === "gantt" && d.to != null)
                d = d.to;
            else if (chartType === "matrix" && (chart.matrixProperties.chartType === "marker" || chart.matrixProperties.chartType === "bubble") && d.size != null)
                d = d.size;
            else if (d.value != null)
                d = d.value;
            else if (d.color != null)
                d = d.color;
            else if (d.hasOwnProperty("value") && d.value == null)
                return null;
        if (d == null || typeof d === "number" && isNaN(d))
            return null;
        if (typeof d === "string")
            if (chartType === "gantt" || chartType === "treemap" || isNaN(parseFloat(d)))
                return d;
        if (d.actualValue != null)
            d = d.actualValue;
        if (neg || d.isNeg)
            d *= -1;
        if (typeof d === "number" && Math.abs(d) < 1E-4) {
            var displayZero = chart.getSerDepProperty("dataLabels.displayZero", ids);
            if (displayZero === false)
                return null
        }
        var visibleCallback = chart.getSerDepProperty("dataLabels.visible", ids);
        if (visibleCallback && typeof visibleCallback === "function" && !visibleCallback.call(chart, d, ids.series, ids.group, data))
            return null;
        if (content === "seriesLabel") {
            if (originalD.isOtherSlice)
                return chart.pieProperties.otherSlice.legendLabel;
            return chart.getSeriesLabel(ids.series)
        } else if (content === "groupLabel")
            return chart.getGroupLabel(ids.group);
        if (data && content === "%" && (chartType === "pie" || chartType === "matrix" && chart.matrixProperties.chartType === "pie"))
            d = Math.abs(d) / tdg.sum(data.map(function(el) {
                return Math.abs(el.value) || 0
            })) || 0;
        var numberFormat = dataNumberFormat || chart.getSerDepProperty("dataLabels.numberFormat", ids);
        if (chart.isBLA() && (chart.blaProperties.seriesLayout === "stacked" || chart.blaProperties.seriesLayout === "percent") && (content === "cumulative" || content === "%" || content === "%+")) {
            if (transposeData == null)
                transposeData = tdg.transpose(chart.data);
            var axisAssignment = chart.getAxisAssignment();
            var thisAxis = axisAssignment[ids.series];
            var stackData = transposeData[ids.group].map(function(el, idx) {
                return axisAssignment[idx] === thisAxis ? el.value : 0
            });
            if (content === "cumulative")
                d = tdg.sum(stackData.slice(0, ids.series + 1));
            else {
                var denom = tdg.sum(stackData);
                var pct = Math.abs(d) / denom;
                var nf = getPctNumberFormat(chart, numberFormat);
                if (content === "%")
                    return chart.formatNumber(pct, nf, undefined, true);
                else if (content === "%+") {
                    var valStr = chart.formatNumber(d, numberFormat, undefined, true);
                    var pctStr = chart.formatNumber(pct, nf, undefined, true);
                    return valStr + ", " + pctStr
                }
            }
        }
        return chart.formatNumber(d, numberFormat, {
            object: "dataLabels",
            bucketID: content,
            ids: ids
        }, true)
    }
    ;
    tdgchart.prototype.dataTextMarkLookup = function() {
        var chart = this;
        return function(d, data) {
            var ids = chart.getMarkSeriesAndGroupID(this, d, data);
            return chart.resolveDataLabelContent(d, data, ids)
        }
    }
    ;
    tdgchart.prototype.areDataLabelsVisible = function() {
        var chart = this;
        return chart.getSeriesPropertyList("dataLabels.visible").some(tdg.isNotEmpty)
    }
    ;
    tdgchart.prototype.areDataLabelsAt = function(side) {
        var chart = this;
        return chart.areDataLabelsVisible() && chart.getSeriesProperty("dataLabels.position").some(function(el) {
            return el === side
        })
    }
    ;
    tdgchart.prototype.areDataLabelsOutside = function() {
        var chart = this;
        return chart.areDataLabelsAt("outside")
    }
    ;
    function textAlignForRotation(radians) {
        var degrees = radians * 180 / Math.PI;
        if (Math.abs(degrees + 45) < 1E-5)
            return "left";
        if (Math.abs(degrees + 90) < 1E-5)
            return "left";
        if (Math.abs(degrees + 270) < 1E-5)
            return "right";
        return "center"
    }
    function fixBLAAnchor(chart, anchor, d, layout, riserShape) {
        function invert(a) {
            return {
                top: "bottom",
                right: "left",
                bottom: "top",
                left: "right",
                insidetop: "insidebottom",
                insidebottom: "insidetop",
                insideright: "insideleft",
                insideleft: "insideright"
            }[a] || a
        }
        if (riserShape === "area")
            layout = layout || chart.blaProperties.comboCharts.areaSeriesLayout || chart.blaProperties.seriesLayout;
        else if (!riserShape || riserShape === "bar")
            layout = layout || chart.blaProperties.comboCharts.barSeriesLayout || chart.blaProperties.seriesLayout;
        if (riserShape !== "line" && (layout === "stacked" || layout === "percent"))
            anchor = {
                right: "insideright",
                bottom: "insidebottom",
                left: "insideleft"
            }[anchor] || anchor;
        var ignoreOrientation = chart.getSerDepProperty("dataLabels.positionMode", {
            series: d._s
        }) === "ignoreOrientation";
        if (!ignoreOrientation)
            if (chart.blaProperties.orientation === "horizontal")
                anchor = {
                    top: "right",
                    bottom: "left",
                    insidetop: "insideright",
                    insidebottom: "insideleft"
                }[anchor] || anchor;
            else if (anchor === "left")
                anchor = "bottom";
            else if (anchor === "right")
                anchor = "top";
        if (d && d.value < 0 && layout !== "percent")
            anchor = invert(anchor);
        if (chart.isBLA() && d._s != null && (chart.yaxis.invert || chart.y2axis.invert)) {
            var assignment = chart.getAxisAssignment();
            if (assignment[d._s] === 1 && chart.yaxis.invert || assignment[d._s] === 2 && chart.y2axis.invert)
                anchor = invert(anchor)
        }
        return anchor
    }
    tdgchart.prototype.getDataLabelAnchorPoint = function(riser, anchor, d, layout, rotationInfo, pad, extraPad) {
        var isDot = riser.type === "dot";
        var w = isDot ? riser.props.size : riser.props.w;
        var h = isDot ? riser.props.size : riser.props.h;
        var x = riser.props.x + (riser.labelAnchorOffset && riser.labelAnchorOffset.x || 0);
        var y = riser.props.y + (riser.labelAnchorOffset && riser.labelAnchorOffset.y || 0);
        extraPad = extraPad || 0;
        var chart = this;
        var res = {
            x: 0,
            y: 0,
            align: "middle",
            valign: "middle",
            translate: {
                x: 0,
                y: 0
            }
        };
        pad = pad == null ? 3 : pad;
        anchor = anchor.toLowerCase();
        if (chart.isBLA() || chart.chartType === "histogram" || chart.chartType === "control" || chart.chartType === "pictogram")
            anchor = fixBLAAnchor(chart, anchor, d, layout, riser.riserShape);
        function setAlign(align, valign) {
            if (align === "right") {
                res.x = -pad - extraPad;
                res.translate.x = x - (isDot ? w / 2 : 0);
                res.align = "right"
            } else if (align === "left") {
                res.x = pad + extraPad;
                res.translate.x = x + (isDot ? w / 2 : w);
                res.align = "left"
            } else if (align === "middle" || align === "center") {
                res.x = 0;
                res.translate.x = x + (isDot ? 0 : w / 2);
                res.align = "middle"
            }
            if (valign === "top") {
                res.y = -pad - extraPad;
                res.translate.y = y - (isDot ? h / 2 : 0);
                res.valign = "bottom"
            } else if (valign === "bottom") {
                res.y = pad - 3 + extraPad;
                res.translate.y = y + (isDot ? h / 2 : h);
                res.valign = "top"
            } else if (valign === "middle" || valign === "center") {
                res.y = -(pad / 2);
                res.translate.y = y + (isDot ? 0 : h / 2);
                res.valign = "middle"
            }
        }
        var relAnchor = anchor;
        switch (anchor) {
        case "top":
            setAlign("middle", "top");
            break;
        case "right":
            setAlign("left", "middle");
            break;
        case "bottom":
            setAlign("middle", "bottom");
            break;
        case "left":
            setAlign("right", "middle");
            break;
        case "center":
        case "middle":
            setAlign("middle", "middle");
            break;
        case "insidetop":
            relAnchor = "bottom";
            setAlign("middle", "bottom");
            res.translate.y -= h;
            break;
        case "insidebottom":
            relAnchor = "top";
            setAlign("middle", "top");
            res.translate.y += h;
            break;
        case "insideright":
            relAnchor = "left";
            setAlign("right", "middle");
            res.translate.x += w;
            break;
        case "insideleft":
            relAnchor = "right";
            setAlign("left", "middle");
            res.translate.x -= w;
            break
        }
        if (rotationInfo && rotationInfo.rotation) {
            res.translate.x += res.x;
            res.translate.y += res.y;
            res.x = 0;
            res.y = 0;
            var angleConfig = tdgchart.util.getAnchoredLabelAligns(relAnchor, 360 - rotationInfo.rotation);
            if (angleConfig.align)
                res.align = angleConfig.align;
            if (angleConfig.valign)
                res.valign = angleConfig.valign;
            res.rotation = rotationInfo.rotation;
            if (rotationInfo) {
                if (angleConfig.valign != "middle" && (anchor == "insidebottom" || anchor == "insidetop")) {
                    var rad = -rotationInfo.rotation / 180 * Math.PI;
                    var ww = Math.abs(rotationInfo.lblSize.width * Math.cos(rad));
                    var hw = Math.abs(rotationInfo.lblSize.height * Math.sin(rad));
                    if (angleConfig.align == "left")
                        res.translate.x -= (ww - hw) / 2;
                    else if (angleConfig.align == "middle")
                        if (angleConfig.valign == "top")
                            res.translate.x += hw / 2;
                        else {
                            if (angleConfig.valign == "bottom")
                                res.translate.x -= hw / 2
                        }
                    else if (angleConfig.align == "right")
                        res.translate.x += (ww - hw) / 2
                }
                if (angleConfig.align != "middle" && (anchor == "insideleft" || anchor == "insideright")) {
                    var rad = -rotationInfo.rotation / 180 * Math.PI;
                    var wh = Math.abs(rotationInfo.lblSize.width * Math.sin(rad));
                    var hh = Math.abs(rotationInfo.lblSize.height * Math.cos(rad));
                    if (angleConfig.valign == "top")
                        res.translate.y += (wh - hh) / 2;
                    else if (angleConfig.valign == "middle")
                        if (angleConfig.align == "left")
                            res.translate.y -= wh / 2;
                        else {
                            if (angleConfig.align == "right")
                                res.translate.y += wh / 2
                        }
                    else if (angleConfig.valign == "bottom")
                        res.translate.y -= (wh - hh) / 2
                }
            }
        }
        var depthGap = chart.getRiserDepthGapInset();
        res.x += depthGap;
        res.y -= depthGap;
        return res
    }
    ;
    var validBarLabelPositions = ["top", "right", "bottom", "left", "center", "insidebottom", "insidetop"];
    var validLineLabelPositions = ["top", "right", "bottom", "left", "center"];
    var validLabelPositions = {
        bar: validBarLabelPositions,
        histogram: validBarLabelPositions,
        waterfall: validBarLabelPositions,
        pictogram: validBarLabelPositions,
        area: validBarLabelPositions,
        bullet: validBarLabelPositions,
        line: validLineLabelPositions,
        control: validLineLabelPositions,
        bubble: validLineLabelPositions,
        scatter: validLineLabelPositions,
        pie: ["center", "outside", "insidetop", "outsideauto"],
        funnel: ["center", "outside"],
        treemap: ["center", "insidetop", "insidebottom"]
    };
    function getDataLabelPosition(chart, riser) {
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        if (riser.labelPosition)
            return riser.labelPosition;
        var pos = (chart.getSerDepProperty("dataLabels.position", riser.d) || "").toLowerCase();
        if (validLabelPositions.hasOwnProperty(chartType) && validLabelPositions[chartType].includes(pos))
            return pos;
        return "center"
    }
    function getDataLabelVisibleByMaskFn(chart, collectionIDs, riserSubList) {
        var show = chart.getSerDepProperty("dataLabels.dataLabelMask", collectionIDs);
        if (show == undefined)
            return function() {
                return true
            }
            ;
        var first = show.indexOf("first") != -1;
        var last = show.indexOf("last") != -1;
        var high = show.indexOf("high") != -1;
        var low = show.indexOf("low") != -1;
        var mins = []
          , maxs = [];
        return function(g) {
            var d = riserSubList[g].d;
            if (high)
                if (maxs[g] == undefined)
                    maxs[g] = tdg.max(riserSubList[g].data, "value");
            if (low)
                if (mins[g] == undefined)
                    mins[g] = tdg.min(riserSubList[g].data, "value");
            if (first && g == 0)
                return true;
            else if (last && g == riserSubList.length - 1)
                return true;
            else if (high && d && d.value == maxs[g])
                return true;
            else if (low && d && d.value == mins[g])
                return true;
            return false
        }
    }
    tdgchart.prototype.doDataLabelsScene = function(labelGroup, riserList, position) {
        var chart = this;
        if (!chart.areDataLabelsVisible())
            return null;
        var rotationGlobal = !chart.dataLabels || chart.dataLabels.rotation == null ? 0 : chart.dataLabels.rotation;
        var labels = [];
        var perDatumLookup;
        var labelStyle = {
            "pointer-events": "none"
        };
        if (chart.previewSelection.enabled)
            labelStyle = {};
        var labelPadLookup = chart.seriesPropertyLookup("dataLabels.pad");
        for (var s = 0; s < riserList.length; s++) {
            var riserSubList = riserList[s];
            if (!riserSubList)
                continue;
            var seriesID = tdg.get("d._s", riserSubList.find(function(el) {
                return el && el.d && el.d._s != null
            }));
            var axisID = tdg.get("d._axis", riserSubList.find(function(el) {
                return el && el.d && el.d._s != null
            }));
            var collectionIDs = {
                series: seriesID,
                group: null,
                axis: axisID
            };
            var visible = chart.getSerDepProperty("dataLabels.visible", collectionIDs);
            if (visible === false)
                continue;
            var rotation = chart.getSerDepProperty("dataLabels.rotation", collectionIDs);
            if (rotation == undefined)
                rotation = rotationGlobal;
            var getDataLabelVisibleByMask = getDataLabelVisibleByMaskFn(chart, collectionIDs, riserSubList);
            var useNegColor = chart.getSerDepProperty("dataLabels.useNegativeColor", collectionIDs);
            var negColor = useNegColor ? chart.getSerDepProperty("dataLabels.negativeColor", collectionIDs) : null;
            var seriesStyle = {
                font: chart.getSerDepProperty("dataLabels.font", collectionIDs),
                color: chart.getSerDepProperty("dataLabels.color", collectionIDs) || "black"
            };
            if (typeof seriesStyle.color === "function") {
                perDatumLookup = seriesStyle.color;
                seriesStyle.color = null
            }
            labels[s] = labels[s] || [];
            var seriesGroup;
            if (!Array.isArray(labelGroup))
                seriesGroup = labelGroup.group(null, null, null, null, null, null, seriesStyle);
            var extraPad = labelPadLookup.call(this, collectionIDs) || 0;
            if (tdg.isPercentString(extraPad))
                extraPad = tdg.applyNumOrPercent(extraPad, parseFloat(tdg.fontToFontParts(seriesStyle.font).fontSize), 0, 100) || 0;
            var rotationInfo;
            for (var g = 0; g < riserSubList.length; g++) {
                if (Array.isArray(labelGroup))
                    seriesGroup = labelGroup[g].group(null, null, null, null, null, null, seriesStyle);
                var riser = riserSubList[g];
                if (!riser || riser.ignoreLabel)
                    continue;
                if (chart.getExceptionalSerDepProperty("dataLabels.visible", riser.d) === false)
                    continue;
                if (!getDataLabelVisibleByMask(g))
                    continue;
                var ids = chart.getMarkSeriesAndGroupID(riser, riser.d, riser.data);
                var text = chart.resolveDataLabelContent(riser.d, riser.data, ids);
                if (!text)
                    continue;
                labels[s].position = undefined;
                if (position)
                    if (Array.isArray(position))
                        labels[s].position = Array.isArray(position[s]) && position[s][g];
                    else
                        labels[s].position = position;
                if (!labels[s].position)
                    labels[s].position = getDataLabelPosition(chart, riser);
                if (negColor && riser.d.value < 0)
                    labelStyle.color = negColor;
                else
                    labelStyle.color = perDatumLookup ? perDatumLookup.call(riser.element || riser, riser.d) : null;
                if (riser.font)
                    labelStyle.font = riser.font;
                labelStyle.className = chart.getRiserClassName(seriesGroup, riser.d, "dataLabels", "dataLabels");
                if (rotation) {
                    labelStyle.shift = -.15;
                    rotationInfo = {
                        rotation: rotation,
                        lblSize: chart.measureLabel(text, labelStyle.font)
                    }
                } else
                    rotationInfo = null;
                var anchorConfig = chart.getDataLabelAnchorPoint(riser, labels[s].position, riser.d, undefined, rotationInfo, undefined, extraPad);
                tdg.mergeObjects(anchorConfig, labelStyle);
                labels[s][g] = seriesGroup.label(anchorConfig.x, anchorConfig.y, text, labelStyle)
            }
        }
        return labels
    }
    ;
    tdgchart.prototype.doDataLabels = function(parent, anchor, properties, overrides) {
        var chart = this;
        if (!chart.areDataLabelsVisible())
            return null;
        var seriesColorLookup = chart.seriesPropertyLookup("dataLabels.color");
        function colorLookup(d) {
            if (overrides && overrides[this.index] && overrides[this.index].color)
                return overrides[this.index].color;
            if (d.value < 0) {
                var useNegColor = chart.getSerDepProperty("dataLabels.useNegativeColor", d);
                if (useNegColor)
                    return chart.getSerDepProperty("dataLabels.negativeColor", d) || "red"
            }
            var res = seriesColorLookup.call(this, d);
            if (typeof res === "function")
                res = res.call(this, d);
            return res || "black"
        }
        if (anchor == null)
            anchor = function(d) {
                return chart.getSerDepProperty("dataLabels.position", d) || "center"
            }
            ;
        properties = properties || {};
        var rotation = !chart.dataLabels || chart.dataLabels.rotation == null ? 0 : tdg.radians(chart.dataLabels.rotation);
        if (rotation !== 0)
            properties.textAlign = textAlignForRotation(rotation);
        var label = parent.anchor(anchor).add(pv.Label).className(chart.classNameLookup("dataLabels", "dataLabels")).font(this.seriesPropertyLookup("dataLabels.font")).textStyle(colorLookup).textAngle(rotation).textMargin(3 + (chart.hichertProperties && chart.hichertProperties.dataLabelsPadding || 0)).text(chart.dataTextMarkLookup()).visible(chart.dataLabelVisibleLookup());
        if (!chart.previewSelection.enabled)
            label.events("none");
        for (var p in properties)
            if (properties.hasOwnProperty(p) && typeof label[p] === "function")
                label[p](properties[p]);
        return label
    }
    ;
    function rearrangeBLADataLabels(chart) {
        function collision(a, b) {
            var xmargin = 0
              , ymargin = -1;
            var ax1 = a.pos.x - xmargin;
            var ax2 = a.pos.x + a.bbox.width + xmargin;
            var bx1 = b.pos.x - xmargin;
            var bx2 = b.pos.x + b.bbox.width + xmargin;
            var ay1 = a.pos.y - ymargin;
            var ay2 = a.pos.y + a.bbox.height + ymargin;
            var by1 = b.pos.y - ymargin;
            var by2 = b.pos.y + b.bbox.height + ymargin;
            if (ax2 <= bx1 || bx2 <= ax1 || ay2 <= by1 || by2 <= ay1)
                return null;
            else
                return {
                    left: bx2 - ax1,
                    right: ax2 - bx1,
                    up: by2 - ay1,
                    down: ay2 - by1
                }
        }
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        var root = tdgchart.d3.select("#" + chart.documentRoot);
        function detachBox(box) {
            return {
                x: box.x,
                y: box.y,
                width: box.width,
                height: box.height
            }
        }
        var prev;
        root.selectAll("text[class^=dataLabels],text[class^=stackTotalLabel]").each(function() {
            var ids = chart.classNameToIds(this);
            var anchor = this.getAttribute("text-anchor");
            var bbox = this.getBBox();
            if (bbox) {
                bbox = detachBox(bbox);
                bbox.height = Math.floor(bbox.height * 100) / 100
            }
            var x, y, t = tdgchart.translateStrToObject(this.getAttribute("transform"));
            if (t == null)
                return;
            var labelX = t.x;
            if (anchor === "end")
                labelX -= bbox.width;
            else if (anchor === "middle")
                labelX -= bbox.width / 2;
            var now = {
                l: this,
                pos: {
                    x: labelX,
                    y: t.y
                },
                bbox: bbox
            };
            if (prev) {
                var bar, c = collision(prev, now);
                if (c)
                    if (isHorizontal) {
                        var left = true;
                        if (chart.chartType === "line")
                            left = now.pos.x < prev.pos.x;
                        else if (chart.chartType === "bar")
                            bar = root.select('*[class^="riser!s*!g' + ids.group + "]").node();
                        if (left) {
                            x = t.x + c.left;
                            now.pos.x += c.left;
                            this.setAttribute("transform", "translate(" + x + ", " + t.y + ")")
                        }
                    } else {
                        var up = true;
                        if (chart.chartType === "line")
                            up = now.pos.y < prev.pos.y;
                        else if (chart.chartType === "bar") {
                            bar = root.select('*[class$="g' + ids.group + '!mbar!"]').node();
                            if (bar)
                                up = parseFloat(bar.getAttribute("y")) >= now.pos.y
                        }
                        if (up) {
                            y = t.y - c.up;
                            now.pos.y -= c.up;
                            this.setAttribute("transform", "translate(" + t.x + ", " + y + ")")
                        } else {
                            y = t.y + c.down;
                            now.pos.y += c.down;
                            this.setAttribute("transform", "translate(" + t.x + ", " + y + ")")
                        }
                    }
            }
            prev = now
        })
    }
    tdgchart.prototype.rearrangeDataLabels = function(chartSize) {
        var chart = this;
        if (chart.isBLA() && chart.hichertProperties) {
            rearrangeBLADataLabels(chart);
            return
        }
        if (chart.chartType !== "bubble" && chart.chartType !== "scatter")
            return;
        var root = tdgchart.d3.select("#" + chart.documentRoot);
        function detachBox(box) {
            return {
                x: box.x,
                y: box.y,
                width: box.width,
                height: box.height
            }
        }
        root.selectAll("text[class^=dataLabels]").each(function() {
            var ids = chart.classNameToIds(this);
            var marker = root.select('*[class^="riser!s' + ids.series + "!g" + ids.group + '!mmarker"]').node();
            if (!marker)
                return;
            var markerBBox = marker.getBBox();
            if (markerBBox) {
                markerBBox = detachBox(markerBBox);
                markerBBox.height = Math.floor(markerBBox.height * 100) / 100
            }
            var anchor = this.getAttribute("text-anchor");
            var bbox = this.getBBox();
            if (bbox) {
                bbox = detachBox(bbox);
                bbox.height = Math.floor(bbox.height * 100) / 100
            }
            var x, y, t = tdgchart.translateStrToObject(this.getAttribute("transform"));
            if (t == null)
                return;
            var labelX = t.x;
            if (anchor === "end")
                labelX -= bbox.width;
            else if (anchor === "middle")
                labelX -= bbox.width / 2;
            var rotate = this.getAttribute("transform").match(/rotate\([^)]*\)/);
            if (rotate)
                return;
            if (labelX + bbox.width >= chartSize.width) {
                if (anchor !== "middle") {
                    x = t.x - markerBBox.width - 3;
                    this.setAttribute("transform", "translate(" + x + ", " + t.y + ")")
                }
                this.setAttribute("text-anchor", "end")
            }
            if (labelX <= 0) {
                if (anchor !== "middle") {
                    x = t.x + markerBBox.width + 3;
                    var transform = "translate(" + x + ", " + t.y + ")";
                    var rotate = this.getAttribute("transform").match(/rotate\([^)].*\)/);
                    this.setAttribute("transform", transform)
                }
                this.setAttribute("text-anchor", null)
            }
            if (t.y <= 0) {
                if (anchor === "middle")
                    y = t.y + markerBBox.height + bbox.height;
                else
                    y = t.y + bbox.height;
                this.setAttribute("transform", "translate(" + t.x + ", " + y + ")")
            }
            if (t.y >= chartSize.height) {
                if (anchor === "middle")
                    y = t.y - markerBBox.height - bbox.height;
                else
                    y = t.y - bbox.height;
                this.setAttribute("transform", "translate(" + t.x + ", " + y + ")")
            }
        })
    }
    ;
    tdgchart.prototype.nestedHeaderDepth = function(labels) {
        function depth(labelList, d) {
            var maxDepth;
            if (labelList[0] && typeof labelList[0] === "object")
                for (var i = 0; i < labelList.length; i++) {
                    var v = labelList[i];
                    for (var key in v)
                        if (v.hasOwnProperty(key))
                            maxDepth = Math.max(d, depth(v[key], d + 1))
                }
            else
                return d;
            return maxDepth
        }
        return depth(labels, 1)
    }
    ;
    tdgchart.prototype.nestedRowWidths = function(labels, font, leftPad, rightPad) {
        var columnWidths = [];
        leftPad = leftPad == null ? 5 : leftPad;
        rightPad = rightPad == null ? 5 : rightPad;
        var pad = leftPad + rightPad;
        function visit(labelList, d) {
            if (!Array.isArray(labelList))
                labelList = [labelList || ""];
            if (labelList[0] && typeof labelList[0] === "object")
                for (var i = 0; i < labelList.length; i++) {
                    var v = labelList[i];
                    for (var key in v)
                        if (v.hasOwnProperty(key)) {
                            columnWidths[d] = Math.max(columnWidths[d] || 0, tdg.measureLabelWidth(key, font) + pad);
                            visit(v[key], d + 1)
                        }
                }
            else
                for (var j = 0; j < labelList.length; j++)
                    columnWidths[d] = Math.max(columnWidths[d] || 0, tdg.measureLabelWidth(labelList[j], font) + pad)
        }
        visit(labels, 0);
        return columnWidths
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    var MAX_ORD_LABEL_LENGTH = .3;
    var NESTED_LABEL_DESCENDER_LENGTH = 3;
    function getAxisTickLength(axis) {
        if (!axis || !axis.majorGrid || !axis.majorGrid.ticks || !axis.majorGrid.ticks.visible)
            return 0;
        if (axis.majorGrid.ticks.style === "inner") {
            if (axis.labels && axis.labels.visible || axis.title && axis.title.visible)
                return 0;
            return 1
        }
        return axis.majorGrid.ticks.length || 0
    }
    tdgchart.prototype.fixAxesList = function() {
        var chart = this;
        var newAxisList = chart.axisList ? tdg.clone(chart.axisList) : {};
        for (var axis in newAxisList)
            if (newAxisList.hasOwnProperty(axis)) {
                var defaultAxis;
                if (axis.startsWith("x"))
                    defaultAxis = chart.xaxis;
                else
                    defaultAxis = axis === "y2" ? chart.y2axis : chart.yaxis;
                newAxisList[axis] = tdg.merge(newAxisList[axis], tdg.clone(defaultAxis))
            }
        newAxisList.x1 = newAxisList.x1 || tdg.clone(chart.xaxis);
        newAxisList.y1 = newAxisList.y1 || tdg.clone(chart.yaxis);
        newAxisList.y2 = newAxisList.y2 || tdg.clone(chart.y2axis);
        chart.cache.setProperty("axisList", newAxisList)
    }
    ;
    tdgchart.prototype.getAxisList = function(axisConfig) {
        var chart = this;
        var hasSplitAxes = chart.splitNumericAxis.splitY.enabled && chart.isBLA();
        var needY2 = chart.chartType === "matrix" || hasSplitAxes ? false : chart.needDualY2Axis();
        axisConfig = axisConfig || [];
        var res = axisConfig.map(function(el) {
            var defaultAxis;
            if (needY2 && el.name === "y2")
                defaultAxis = chart.y2axis;
            else if (el.name.startsWith("x"))
                defaultAxis = chart.xaxis;
            else
                defaultAxis = chart.yaxis;
            var axis = chart.axisList[el.name] ? chart.axisList[el.name] : tdg.clone(defaultAxis);
            return {
                properties: axis,
                config: el,
                name: el.name
            }
        });
        return res
    }
    ;
    tdgchart.prototype.axisNameToClassName = function(axisName) {
        var chart = this;
        var axisModes = chart.cache.get("axisModes", {});
        if (axisName === "x1")
            return axisModes[axisName] === "numeric" ? "xaxisNumeric" : "xaxisOrdinal";
        else if (axisName === "z1")
            return axisModes[axisName] === "numeric" ? "zaxisNumeric" : "zaxisOrdinal";
        else if (axisName === "y1")
            return axisModes[axisName] === "ordinal" ? "yaxisOrdinal" : "yaxis";
        else if (axisName.match(/y[0-9]/))
            return axisName + "axis";
        return axisName
    }
    ;
    tdgchart.prototype.axisNameToAxisProperties = function(axisName) {
        var chart = this;
        if (axisName === "x1")
            return chart.axisList.x1;
        else if (axisName === "z1")
            return chart.zaxis;
        else if (axisName.match(/y[0-9]/))
            return chart.axisList[axisName];
        return chart.yaxis
    }
    ;
    tdgchart.prototype.drawGridlines = function(panel, scale, side, gridData, gridProps, className) {
        var chart = this;
        if (!gridProps.visible)
            return;
        var scene = chart.cache.get("tdgscene");
        var gridLineProps = gridProps.lineStyle || {};
        var gridStyle = {
            className: className,
            lineStyle: gridLineProps,
            antialias: false
        };
        var isVertical = side === "left" || side === "right";
        var depth = chart.computeddepth25d();
        var p = new tdgchart.tdgscene.path;
        var i, gridLength;
        if (isVertical) {
            gridLength = panel.computedSize.width;
            for (i = 0; i < gridData.length; i++) {
                p.moveTo(0, panel.computedSize.height - scale(gridData[i]));
                if (depth)
                    p.lineTo(depth, -depth, true);
                p.lineTo(gridLength, 0, true)
            }
        } else {
            gridLength = panel.computedSize.height;
            for (i = 0; i < gridData.length; i++)
                if (depth) {
                    p.moveTo(scale(gridData[i]), gridLength);
                    p.lineTo(depth, -depth, true);
                    p.lineTo(0, -gridLength, true)
                } else {
                    p.moveTo(scale(gridData[i]), 0);
                    p.lineTo(0, gridLength, true)
                }
        }
        if (tdgchart.tdgscene.isTDGSceneGroup(panel))
            panel.path(0, 0, p, gridStyle);
        else
            scene.group(panel).path(0, 0, p, gridStyle)
    }
    ;
    tdgchart.prototype.drawTicks = function(panel, scale, side, gridData, tickProps, className) {
        var chart = this;
        var scene = chart.cache.get("tdgscene");
        var isVertical = side === "left" || side === "right";
        var tickStyle = tickProps.style || "outer";
        var tickLineStyle = {
            className: className,
            lineStyle: tickProps.lineStyle || {},
            antialias: false
        };
        var tickLength = tickProps.visible ? tickProps.length || 0 : 0;
        var actualTickLength = tickStyle === "span" ? tickLength * 2 : tickLength;
        var i, p = new tdgchart.tdgscene.path;
        var inset = 0;
        if (side === "left" || side === "top") {
            var pad = side === "left" ? panel.computedSize.width : panel.computedSize.height;
            inset = pad - (tickStyle === "inner" ? 0 : tickLength)
        } else if (side === "right" || side === "bottom")
            inset = tickStyle === "outer" ? 0 : -tickLength;
        if (isVertical)
            for (i = 0; i < gridData.length; i++) {
                p.moveTo(inset, panel.computedSize.height - scale(gridData[i]));
                p.lineTo(actualTickLength, 0, true)
            }
        else
            for (i = 0; i < gridData.length; i++) {
                p.moveTo(scale(gridData[i]), inset);
                p.lineTo(0, actualTickLength, true)
            }
        if (tdgchart.tdgscene.isTDGSceneGroup(panel))
            panel.path(0, 0, p, tickLineStyle);
        else
            scene.group(panel).path(0, 0, p, tickLineStyle)
    }
    ;
    tdgchart.prototype.drawAltFrameFill = function(panel, scale, axis) {
        if (!scale || !axis)
            return;
        if ((!axis.properties.altFrameColor || axis.properties.altFrameColor === "transparent") && (!axis.properties.altFrameColor1 || axis.properties.altFrameColor1 === "transparent"))
            return;
        var chart = this, tmpData, gridData;
        var o = axis.side === "top" || axis.side === "bottom";
        var w = panel.computedSize.width;
        var h = panel.computedSize.height;
        var cdepth = chart.computeddepth25d();
        var gapWidth = scale.splitBanded ? scale.range()[0] / 2 : 0;
        if (scale.splitBanded) {
            tmpData = tdg.range(0, scale.range().length);
            gridData = tmpData.map(function(el) {
                return {
                    start: scale(el),
                    stop: scale(el + 1)
                }
            });
            gridData[0].start = gapWidth;
            gridData[gridData.length - 1].stop = undefined
        } else
            gridData = scale.grid.slice(0, -1).map(function(el, idx) {
                return {
                    start: scale(el),
                    stop: scale(scale.grid[idx + 1])
                }
            });
        function bottom(d) {
            return d.start + cdepth - gapWidth
        }
        function top(d) {
            return (o ? w : h) - d.stop - cdepth + gapWidth
        }
        var c1 = axis.properties.altFrameColor == null ? "transparent" : axis.properties.altFrameColor;
        var c2 = axis.properties.altFrameColor1 == null ? "transparent" : axis.properties.altFrameColor1;
        var bars = panel.add(pv.Bar).data(gridData).className(function() {
            return chart.axisNameToClassName(axis.name) + "-altFrameFill" + (this.index % 2 ? "" : "1")
        }).fillStyle(function() {
            return this.index % 2 ? c1 : c2
        });
        var pad = axis.orthPadding || [0, 0];
        if (o)
            bars.left(bottom).right(top).top(0 - cdepth - pad[0]).bottom(0 + cdepth - pad[1]);
        else
            bars.bottom(bottom).top(top).left(0 + cdepth - pad[0]).right(0 - cdepth - pad[1])
    }
    ;
    tdgchart.prototype.drawAxisColorRanges = function(panel, scale, axis) {
        if (scale == null || axis.properties.colorBands == null || axis.properties.colorBands.length <= 0)
            return;
        var chart = this;
        var scene = chart.cache.get("tdgscene");
        var isVertical = axis.side === "left" || axis.side === "right";
        var pw = panel.computedSize.width
          , ph = panel.computedSize.height;
        var cdepth = chart.computeddepth25d();
        var axisName = chart.axisNameToClassName(axis.name);
        function pos(v) {
            var res = 0
              , offset = isVertical ? ph : pw;
            if (scale.splitBanded) {
                v = tdg.isPercentString(v) ? tdg.applyNumOrPercent(v, 1) : v;
                if (typeof v === "object" && typeof v.group === "number") {
                    offset = typeof v.offset === "number" ? scale.range().band * v.offset : 0;
                    res = scale(v.group) + offset
                } else if (typeof v === "string") {
                    var p = scale.ordPos(v);
                    res = p == null ? offset : p
                } else if (typeof v === "number")
                    res = axis.properties.invert ? offset - offset * v : offset * v
            } else if (tdg.isPercentString(v)) {
                v = tdg.applyNumOrPercent(v, offset);
                res = tdg.xor(isVertical, axis.properties.invert) ? offset - v : v
            } else if (tdg.isANumber(v)) {
                var d = axis.properties.invert ? tdg.reverse(scale.domain()) : scale.domain();
                v = scale(tdg.bound(v, d));
                res = isVertical ? offset - v : v
            }
            return res
        }
        var group = scene.group(panel);
        for (var i = 0; i < axis.properties.colorBands.length; i++) {
            var band = axis.properties.colorBands[i];
            if (!band.color || !tdg.color.isVisible(band.color))
                continue;
            var style = {
                color: band.color,
                antialias: false,
                lineStyle: band.border || null,
                className: chart.buildClassName(axisName + "-colorBand", null, null, i)
            };
            var start = pos(band.start);
            var stop = pos(band.stop);
            var x = isVertical ? 0 : start;
            var y = isVertical ? start : 0;
            var w = isVertical ? pw : stop - x;
            var h = isVertical ? stop - y : ph;
            if (h < 0) {
                y += h;
                h *= -1
            }
            if (w < 0) {
                x += w;
                w *= -1
            }
            if (cdepth) {
                x += cdepth;
                y -= cdepth
            }
            if (tdgchart.util.geom.isValidRect({
                x: x,
                y: y,
                width: w,
                height: h
            }))
                group.rect(x, y, w, h, style);
            if (band.label && band.label.text) {
                var lblStyle = {
                    className: chart.buildClassName(axisName + "-colorBandLabel", null, null, i),
                    font: band.label.font || "12pt arial",
                    color: band.label.color || "black",
                    valign: "bottom"
                };
                group.label(x + 5, y + h - 5, band.label.text, lblStyle)
            }
        }
    }
    ;
    tdgchart.prototype.drawAxisBodyLine = function(panel, axisName, side, lineProps, pad) {
        var chart = this;
        var scene = chart.cache.get("tdgscene");
        var group = scene.group(panel);
        var w = panel.computedSize.width
          , h = panel.computedSize.height;
        var lineStyle = {
            className: axisName + "-bodyLineStyle",
            lineStyle: lineProps,
            antialias: false
        };
        pad = pad || [0, 0];
        if (side === "left")
            group.line(w, -pad[0], w, h + pad[1], lineStyle);
        else if (side === "right")
            group.line(0, -pad[0], 0, h + pad[1], lineStyle);
        else if (side === "top")
            group.line(-pad[0], h, w + pad[1], h, lineStyle);
        else
            group.line(-pad[0], 0, w + pad[1], 0, lineStyle)
    }
    ;
    tdgchart.prototype.drawAxisBodyLine3d = function(panel, axisName, side, line) {
        var bodyLine = panel.add(pv.Rule3d).className(axisName + "-bodyLineStyle").lineStyle(line);
        var sides = side.split("-");
        for (var s = 0; s < sides.length; s++)
            bodyLine[sides[s]](0)
    }
    ;
    tdgchart.prototype.getAxisBaseline = function(axis, invert, customBaseline) {
        var baselineValue = 0;
        if (customBaseline === true && axis.baselineValue && typeof axis.baselineValue === "number")
            baselineValue = parseFloat(axis.baselineValue, 10) || 0;
        var baseline = axis(baselineValue);
        var domain = axis.domain();
        var domainMin = invert ? domain[1] : domain[0];
        var domainMax = invert ? domain[0] : domain[1];
        if (domainMin > baselineValue)
            baseline = axis(domainMin);
        else if (domainMax < baselineValue)
            baseline = axis(domainMax);
        return baseline
    }
    ;
    tdgchart.prototype.getAxisBaselineValue = function(axis) {
        var baselineValue = 0;
        if (axis.baselineValue && typeof axis.baselineValue === "number")
            baselineValue = parseFloat(axis.baselineValue, 10) || 0;
        return baselineValue
    }
    ;
    tdgchart.prototype.drawReferenceLines = function(riserPanels, axisLayout, layout, isAbove) {
        if (!riserPanels.bg && !riserPanels.fg)
            return;
        var panelSize = (riserPanels.bg || riserPanels.fg).computedSize;
        var chart = this;
        function width(d) {
            var b = 0
              , rLine = this.rLine();
            if (rLine && rLine.bottom && rLine.bottom === "chartBorder")
                b = -layout.leftInset;
            return d ? b : panelSize.width
        }
        function height(d) {
            var b = 0
              , rLine = this.rLine();
            if (rLine && rLine.bottom && rLine.bottom === "chartBorder")
                b = layout.bottomTitleOffset - chart.getPadding("frame", "bottom");
            return d ? b : panelSize.height
        }
        function visible(anchor) {
            return function(d) {
                return anchor === "start" ? d === 1 : d === 0
            }
        }
        function getAxis(refLineAxisName) {
            if (refLineAxisName === "x")
                return {
                    axis: axisLayout.xAxisList[0],
                    scale: axisLayout.xScalesList[0]
                };
            else if (refLineAxisName === "y2")
                return {
                    axis: axisLayout.yAxisList[1],
                    scale: axisLayout.yScalesList[1]
                };
            return {
                axis: axisLayout.yAxisList[0],
                scale: axisLayout.yScalesList[0]
            }
        }
        for (var i = 0; i < chart.referenceLines.length; i++) {
            var rLine = chart.referenceLines[i];
            if (rLine == null)
                continue;
            if (isAbove != null && (rLine.aboveRisers == null && !isAbove || rLine.aboveRisers != null && rLine.aboveRisers !== isAbove))
                continue;
            var drawPanel;
            if (riserPanels.fg && (rLine.aboveRisers || rLine.aboveRisers == null))
                drawPanel = riserPanels.fg;
            else
                drawPanel = riserPanels.bg;
            if (!drawPanel)
                continue;
            var axis = getAxis(rLine.axis);
            var scale = axis.scale;
            axis = axis.axis;
            var v = rLine.value;
            var w = panelSize.width;
            var h = panelSize.height;
            var bottom, left, lineAlign = null;
            if (axis == null || scale == null || v == null || typeof v === "number" && isNaN(v))
                continue;
            if (scale.splitBanded && typeof v === "string" && v.indexOf("%") < 0 && scale.ordPos(v) == null)
                continue;
            var line = drawPanel.add(pv.Line).def("rLine", rLine).className("refLine").data([0, 1]).antialias(false).lineStyle(rLine.line || {
                color: "black",
                width: 1,
                dash: ""
            });
            if (scale.splitBanded) {
                if (tdg.isPercentString(v))
                    v = tdg.parsePercent(v);
                else if (typeof v !== "number" || !(v > 0 && v < 1)) {
                    lineAlign = typeof v === "number" ? scale(v) : scale.ordPos(v);
                    switch (rLine.ordinalAlign) {
                    case "left":
                        lineAlign -= scale.range()[0] / 2;
                        break;
                    case "right":
                        lineAlign += scale.range()[0] * 2;
                        break;
                    case "riserRight":
                        lineAlign += scale.range().band;
                        break;
                    case "center":
                        lineAlign += scale.range().band / 2;
                        break
                    }
                }
                if (axis.side === "left" || axis.side === "right") {
                    bottom = lineAlign == null ? h * (1 - v) : lineAlign;
                    line.top(bottom).left(width)
                } else {
                    left = lineAlign == null ? w * v : lineAlign;
                    line.left(left).bottom(height)
                }
            } else if (axis.side === "left" || axis.side === "right") {
                bottom = tdg.isPercentString(v) ? h * tdg.parsePercent(v) : scale(v);
                line.bottom(bottom).left(width)
            } else {
                left = tdg.isPercentString(v) ? w * tdg.parsePercent(v) : scale(v);
                line.left(left).bottom(height)
            }
            if (rLine.label && rLine.label.text || rLine.showValue) {
                var text = rLine.label && rLine.label.text ? rLine.label.text : "";
                if (rLine.showValue) {
                    text += text ? " " : "";
                    text += rLine.value
                }
                var side;
                if (axis.side === "left" || axis.side === "right")
                    side = rLine.anchor === "start" ? "left" : "right";
                else
                    side = rLine.anchor === "start" ? "top" : "bottom";
                var pos = {
                    left: {
                        anchor: "top",
                        align: "left",
                        base: "bottom"
                    },
                    right: {
                        anchor: "top",
                        align: "right",
                        base: "bottom"
                    },
                    top: {
                        anchor: "top",
                        align: "left",
                        base: "bottom"
                    },
                    bottom: {
                        anchor: "top",
                        align: "left",
                        base: "top"
                    }
                }[side];
                line.anchor(pos.anchor).add(pv.Label).textAlign(pos.align).textBaseline(pos.base).visible(visible(rLine.anchor)).className("refLineText").font(rLine.label ? rLine.label.font : "10pt Arial").textStyle(rLine.label ? rLine.label.color || "black" : "black").text(text)
            }
        }
    }
    ;
    tdgchart.prototype.drawAxisDivider = function(axisPanels, axis) {
        var chart = this;
        var o = axis.side === "top" || axis.side === "bottom";
        var dividerLineStyle = axis.name.startsWith("x") ? chart.splitNumericAxis.splitX.dividerLine : chart.splitNumericAxis.splitY.dividerLine;
        if (!tdg.color.isLineVisible(dividerLineStyle))
            return;
        function dividers(panel) {
            var w = panel.computedSize.width;
            var h = panel.computedSize.height;
            var divider = panel.add(pv.Line).data([0, 1]).antialias(false).strokeStyle(dividerLineStyle.color || "black").lineWidth(dividerLineStyle.width || 0).className(function() {
                return chart.axisNameToClassName(axis.name) + "-dividerLineStyle"
            });
            var pad = axis.orthPadding || [0, 0];
            if (o)
                divider.left(0).top(function(d) {
                    return d ? -pad[0] : h + pad[1]
                });
            else
                divider.bottom(0).left(function(d) {
                    return d ? -pad[0] : w + pad[1]
                })
        }
        dividers(axisPanels.fg);
        if (axis.properties.labels.excludeMin && axisPanels.axis)
            dividers(axisPanels.axis);
        if (axis.properties.labels.excludeMin && axisPanels.title)
            dividers(axisPanels.title)
    }
    ;
    tdgchart.prototype.axisBackwardCompatibleFixup = function() {
        var chart = this;
        var axisModes = chart.cache.set("axisModes", {});
        axisModes.colorScale = "numeric";
        if (chart.yaxis.mode != null)
            axisModes.y1 = chart.yaxis.mode;
        var isMatrixBubbleOrScatter = chart.chartType === "matrix" && (chart.matrixProperties.chartType === "bubble" || chart.matrixProperties.chartType === "scatter");
        if (isMatrixBubbleOrScatter || ["bubble", "scatter", "polar"].includes(chart.chartType)) {
            tdg.mergeObjects(chart.xaxisNumeric, chart.xaxis);
            if (chart.is3levelData(chart.data)) {
                var i, d = chart.data[0][0];
                if (chart.is5levelData(chart.data))
                    d = chart.data[0][0][0][0];
                if (chart.xaxis.mode == null) {
                    i = chart.dataArrayMap ? chart.dataArrayMap.indexOf("x") : 0;
                    i = i == null ? 0 : i;
                    axisModes.x1 = d && typeof d[i] === "string" && !chart.xaxis.timeAxis.enabled ? "ordinal" : "numeric"
                } else
                    axisModes.x1 = chart.xaxis.mode;
                if (chart.yaxis.mode == null) {
                    i = chart.dataArrayMap ? chart.dataArrayMap.indexOf("y") : 1;
                    i = i == null ? 1 : i;
                    axisModes.y1 = d && typeof d[i] === "string" && !chart.yaxis.timeAxis.enabled ? "ordinal" : "numeric"
                } else
                    axisModes.y1 = chart.yaxis.mode
            } else
                axisModes.x2 = "numeric"
        } else {
            tdg.mergeObjects(chart.xaxisOrdinal, chart.xaxis);
            axisModes.x1 = "ordinal"
        }
        tdg.mergeObjects(chart.zaxisOrdinal, chart.zaxis);
        if (chart.zaxis.mode == null)
            axisModes.z1 = "ordinal";
        else
            axisModes.z1 = chart.zaxis.mode;
        if (chart.xaxis.labelLayout && !tdg.isEmpty(chart.xaxis.labelLayout.scroll))
            chart.xaxis.scroll.enabled = chart.xaxis.labelLayout.scroll;
        if (!tdg.isEmpty(chart.xaxis.scroll.groups) && chart.xaxis.scroll.enabled) {
            var g = chart.xaxis.scroll.groups;
            if (tdg.isANumber(g.maxCount) && g.maxCount > 0) {
                chart.xaxis.groupFit = chart.xaxis.groupFit || {};
                chart.xaxis.groupFit.rule = "maxCount";
                chart.xaxis.groupFit.value = g.maxCount
            } else if (tdg.isANumber(g.minSize) && g.minSize > 0) {
                chart.xaxis.groupFit = chart.xaxis.groupFit || {};
                chart.xaxis.groupFit.rule = "minSize";
                chart.xaxis.groupFit.value = g.minSize
            }
        }
        if (chart.colorScale.colorMode === "discrete" || chart.colorScale.colorMode === "bin")
            if (Array.isArray(chart.colorScale.colorBands) && chart.colorScale.colorBands.length > 0) {
                chart.colorScale.colors = chart.colorScale.colorBands;
                delete chart.colorScale.colorBands
            }
    }
    ;
    function fixHorizontalOrdinalLabels(chart, panelSize, labels, labelSizes, maxLabel, matrixMasterChartSize) {
        var pde = {
            offset: 0
        };
        var panelWidth = panelSize.width;
        var pad = chart.getPadding("label", "aveHorz");
        var haveTruncated = false;
        var rotation = chart.axisList.x1.labels.rotation;
        var opts = chart.axisList.x1.labelLayout;
        var maxOrdLabelPct = tdg.isPercentString(opts.spaceLimit) ? tdg.parsePercent(opts.spaceLimit) : MAX_ORD_LABEL_LENGTH;
        var maxVSpace = maxOrdLabelPct * (matrixMasterChartSize ? matrixMasterChartSize.height : panelSize.height);
        if (!chart.axisList.x1.labels.visible || panelWidth == null)
            return {
                offset: 0,
                pde: pde
            };
        var dataSubset = chart.dataSubset.stopGroup - chart.dataSubset.startGroup;
        if (!isNaN(dataSubset) && dataSubset > 0)
            panelWidth = labels.length * panelWidth / dataSubset;
        var fit = chart.get("axisList.x1.groupFit");
        if (fit && fit.rule !== "auto" && tdg.isANumber(fit.value))
            if (fit.rule === "exactSize")
                panelWidth = labels.length * fit.value;
            else if (fit.rule === "maxSize")
                panelWidth = Math.min(panelWidth, labels.length * fit.value);
            else if (fit.rule === "minSize")
                panelWidth = Math.max(panelWidth, labels.length * fit.value);
        panelWidth -= pad;
        if (typeof rotation === "number") {
            var space = 0;
            if (rotation === 45 || rotation === 135) {
                maxVSpace /= .707;
                if (maxLabel.width > maxVSpace) {
                    haveTruncated = true;
                    pde.truncate = Math.floor(maxVSpace)
                }
                space = Math.min(maxVSpace, maxLabel.width);
                space = Math.sqrt(space * space / 2) - maxLabel.height + pad + pad + pad
            } else if (rotation === 90 || rotation === 270) {
                if (maxLabel.width > maxVSpace) {
                    haveTruncated = true;
                    pde.truncate = Math.floor(maxVSpace)
                }
                space = Math.min(maxVSpace, maxLabel.width) - maxLabel.height + pad
            }
            pde.rotation = rotation;
            pde.offset = space;
            if (pde.rotation === 45 || pde.rotation === 135)
                return {
                    offset: space,
                    pde: pde
                }
        }
        var labelWidths = labelSizes.map(function(el) {
            return el.width
        });
        if (rotation === 90 || rotation === 270)
            labelSizes = labelSizes.map(function(el) {
                return el.height
            });
        else
            labelSizes = labelWidths;
        var neededSpace = tdg.sum(labelSizes) + pad * labels.length;
        var groupWidth = panelWidth / labels.length;
        var halfWidths = labelSizes.map(function(el) {
            return el / 2
        });
        var haveOverlap = false;
        var manualLayout = opts.stagger === true || typeof opts.skip === "number";
        for (var i = 1; i < halfWidths.length; i++)
            if (halfWidths[i - 1] + halfWidths[i] >= groupWidth - pad / 3) {
                haveOverlap = true;
                break
            }
        if (!manualLayout && neededSpace <= panelWidth && !haveOverlap)
            return {
                offset: pde.offset,
                pde: pde
            };
        if ((!rotation || rotation === "auto") && (opts.stagger === true || haveOverlap && opts.stagger === "auto" && chart.chartType !== "matrix" && neededSpace <= panelWidth * 1.5 && maxVSpace > maxLabel.height * 2)) {
            haveTruncated = true;
            pde.truncate = Math.floor(groupWidth * 1.8);
            pde.stagger = true;
            pde.offset = maxLabel.height + chart.getPadding("label", "aveHorz");
            haveOverlap = false
        }
        var rotatedLabelSpace = maxLabel.height * labels.length;
        if (haveOverlap && !pde.stagger && (rotation === "auto" || rotation == null) && maxLabel.width > maxLabel.height) {
            if (maxLabel.width > maxVSpace) {
                haveTruncated = true;
                pde.solution = "autorotate";
                pde.truncate = Math.floor(maxVSpace)
            }
            pde.rotation = 90;
            pde.offset = Math.min(maxVSpace, maxLabel.width) - maxLabel.height + pad;
            pde.labelLength = Math.min(maxVSpace, maxLabel.width);
            haveOverlap = rotatedLabelSpace >= panelWidth
        }
        if (typeof opts.skip === "number" && opts.skip > 0 || haveOverlap && opts.skip === "auto")
            if (pde.rotation === 90 && maxLabel.width > maxLabel.height) {
                pde.skip = opts.skip === "auto" ? Math.ceil(rotatedLabelSpace / panelWidth) : opts.skip;
                var visibleLabelSizes = labelWidths.filter(function(el, idx) {
                    return idx % pde.skip === 0
                });
                pde.offset = Math.min(maxVSpace, tdg.max(visibleLabelSizes)) - maxLabel.height + pad;
                haveOverlap = false
            } else {
                var avgLblWidth = neededSpace / labels.length;
                pde.skip = opts.skip === "auto" ? Math.max(1, Math.floor(avgLblWidth / groupWidth)) : opts.skip;
                haveTruncated = true;
                pde.truncate = Math.floor(groupWidth * (pde.skip + 1))
            }
        if (!haveTruncated && haveOverlap) {
            pde.solution = "last resort truncation";
            pde.truncate = Math.floor(groupWidth * .95)
        }
        return {
            offset: pde.offset,
            pde: pde
        }
    }
    function fixVerticalOrdinalLabels(chart, axis, panelSize, labels, maxLabel, labelSize, matrixMasterChartSize) {
        var res = 0;
        var panelHeight = panelSize.height;
        var opts = axis.labelLayout;
        var maxOrdLabelPct = tdg.isPercentString(opts.spaceLimit) ? tdg.parsePercent(opts.spaceLimit) : MAX_ORD_LABEL_LENGTH;
        var maxHSpace = maxOrdLabelPct * (matrixMasterChartSize ? matrixMasterChartSize.width : panelSize.width);
        var pde;
        if (!axis.labels.visible || panelHeight == null)
            return {
                offset: 0,
                pde: pde
            };
        var pad = chart.getPadding("label", "aveHorz");
        var neededHeight = labels.length * maxLabel.height;
        if (maxLabel.width > maxHSpace) {
            pde = {
                truncate: maxHSpace
            };
            res = maxHSpace - labelSize + pad + pad
        }
        if (neededHeight <= panelHeight)
            return {
                offset: res,
                pde: pde
            };
        if (opts.skip) {
            var skipFactor = Math.ceil(maxLabel.height * labels.length / panelHeight);
            pde = {
                solution: "skip",
                skip: skipFactor,
                offset: 0,
                truncate: pde && pde.truncate
            };
            return {
                offset: res,
                pde: pde
            }
        }
        return {
            offset: res,
            pde: pde
        }
    }
    function getAxisLabels(chart, axis, minMax) {
        if (axis.config && axis.config.min != null && axis.config.max != null && !chart.splitNumericAxis.splitY.enabled)
            minMax = minMax || axis.config;
        else if (minMax && minMax.min != null && minMax.max != null)
            ;
        else
            minMax = chart.getScaleMinMax(axis.properties, axis.name);
        var scaleType = axis.properties.bIsLog ? "log" : "linear";
        var scale = pv.Scale[scaleType](minMax.min, minMax.max);
        scale.stepSize = minMax.step;
        return chart.getGridLabels(scale, axis)
    }
    tdgchart.prototype.getLabelSizes = function(axis) {
        var chart = this;
        var labels;
        if (axis.labels)
            labels = axis.labels;
        else if (axis === chart.zaxis)
            labels = chart.getSeriesLabels();
        else if (chart.cache.get("axisModes", {})[axis.name] === "ordinal")
            labels = chart.getGroupLabels();
        else
            labels = getAxisLabels(chart, axis);
        var labelSizes = labels.map(function(el) {
            return chart.measureLabel(el, axis.labels.font)
        });
        return labelSizes
    }
    ;
    tdgchart.prototype.isOrthogonalAxis = function(axis) {
        if (!axis)
            return false;
        else if (axis.name === "colorScale")
            return true;
        else if (axis.properties.title && axis.properties.title.position === "orthogonal" && (axis.side === "left" || axis.side === "right"))
            return true;
        return false
    }
    ;
    function buildAxisLabels(chart, axis, minMax, lbls) {
        var rawChartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        if (axis.labels)
            return axis.labels;
        if (axis.properties === chart.zaxis)
            return chart.getSeriesLabels();
        if (chart.cache.get("axisModes", {})[axis.name] === "ordinal") {
            if (rawChartType === "scatter" || rawChartType === "bubble")
                if (axis.properties === chart.xaxis)
                    return chart.getGroupLabels(null, null, null, 0);
                else
                    return chart.getGroupLabels(null, null, null, 1);
            return chart.getGroupLabels()
        }
        if (axis.properties === chart.colorScale || axis.name === "colorScale")
            if (lbls)
                return lbls;
            else {
                var minmax = chart.getColorScaleMinMax();
                var colorAxis = chart.getNumericScale({
                    width: 100,
                    height: 100
                }, chart.colorScale, {
                    min: minmax.min,
                    max: minmax.max
                });
                return [chart.formatNumber(colorAxis.domain()[1], chart.colorScale.numberFormat)]
            }
        return getAxisLabels(chart, axis, minMax)
    }
    function getTitleSize(chart, axis, axisSize, pad) {
        var space = 0
          , size = 0;
        if (axis.properties.title.visible && axis.name !== "colorScale")
            if (chart.isOrthogonalAxis(axis))
                size = space = 1;
            else {
                size = chart.measureLabel(axis.properties.title.text, axis.properties.title.font).height;
                space = size + pad
            }
        return {
            size: size,
            space: space
        }
    }
    tdgchart.prototype.axisWidth = function(axis, panelSize, lbls, minMax, matrixMasterChartSize) {
        var chart = this;
        var pad = chart.getPadding("label", "aveHorz");
        var labelsPad = axis && axis.properties && axis.properties.labels && axis.properties.labels.pad || 0;
        if (tdg.isPercentString(labelsPad))
            labelsPad = tdg.parsePercent(labelsPad, 0, 100) * tdg.measureFont(axis.properties.labels.font).height;
        if (axis == null || minMax && minMax.noData) {
            if (matrixMasterChartSize != null)
                return {
                    size: 0,
                    titleOffset: 0,
                    halfLabel: 0
                };
            return {
                size: pad,
                titleOffset: 0,
                halfLabel: 0
            }
        }
        var haveLabels = axis.properties.labels.visible;
        if (!haveLabels && matrixMasterChartSize != null)
            pad = 0;
        var tickSize = getAxisTickLength(axis.properties);
        var tickPad = pad + labelsPad + tickSize;
        var halfLabel = 0;
        var labelSize, res, axisSize, titleLayout;
        var pde, fix;
        var labels = buildAxisLabels(chart, axis, minMax, lbls);
        var descenderLength = NESTED_LABEL_DESCENDER_LENGTH;
        var nestedLabelDepths = labels.nestedOrdAxisDepthList;
        var nestedOrdAxisDepth = labels.nestedOrdAxisDepth;
        if (nestedOrdAxisDepth == null || axis.name !== "x1")
            nestedOrdAxisDepth = 1;
        var labelSizes, maxLabel;
        if (nestedOrdAxisDepth === 1 && labels.length > 25) {
            var oneCharWidth = chart.measureLabel("W", axis.properties.labels.font).width;
            maxLabel = {
                charLength: 0,
                size: {
                    width: 0,
                    height: 0
                }
            };
            var labelsToSize = labels;
            if (labels.length > 1E3) {
                var evryNth = Math.ceil(labels.length / 100);
                labelsToSize = labels.filter(function(l, i) {
                    return i < 100 || i > labels.length - 100 || i % evryNth == 0
                })
            }
            labelSizes = labelsToSize.map(function(el) {
                if (el.length > maxLabel.charLength - 2) {
                    var res = chart.measureLabel(el || "", axis.properties.labels.font);
                    if (res.width > maxLabel.size.width) {
                        maxLabel.charLength = el.length;
                        maxLabel.size.width = res.width
                    }
                    if (res.height > maxLabel.size.height)
                        maxLabel.size.height = res.height;
                    return res
                }
                return {
                    width: el.length * oneCharWidth,
                    height: maxLabel.size.height
                }
            });
            labelSizes[labelSizes.length - 1] = chart.measureLabel(labels[labels.length - 1] || "", axis.properties.labels.font);
            maxLabel = maxLabel.size
        } else {
            labelSizes = labels.map(function(el) {
                return chart.measureLabel(el || "", axis.properties.labels.font)
            });
            maxLabel = {
                width: tdg.max(labelSizes, "width") || 0,
                height: tdg.max(labelSizes, "height") || 0
            }
        }
        if (nestedOrdAxisDepth === 1 || (axis.side === "top" || axis.side === "bottom")) {
            var axisMode = chart.cache.get("axisModes", {})[axis.name];
            if (axis.side === "top" || axis.side === "bottom") {
                labelSize = haveLabels ? maxLabel.height + tickSize + labelsPad : tickSize;
                labelSize += axis.side === "top" ? pad : 0
            } else
                labelSize = haveLabels ? maxLabel.width + tickPad + pad : tickPad;
            if (haveLabels && nestedOrdAxisDepth < 2 && axisMode === "ordinal")
                if (axis.side === "top" || axis.side === "bottom") {
                    fix = fixHorizontalOrdinalLabels(chart, panelSize, labels, labelSizes, maxLabel, matrixMasterChartSize);
                    pde = fix.pde;
                    labelSize += fix.offset
                } else {
                    fix = fixVerticalOrdinalLabels(chart, axis.properties, panelSize, labels, maxLabel, labelSize, matrixMasterChartSize);
                    pde = fix.pde;
                    labelSize += fix.offset
                }
            if (haveLabels && axisMode !== "ordinal" && axis.properties.labels.rotation) {
                var rot = axis.properties.labels.rotation;
                if (axis.side === "top" || axis.side === "bottom") {
                    if (rot === 45 || rot === 90 || rot === 135 || rot === 270)
                        labelSize = maxLabel.width + tickPad + pad
                } else if (rot === 90 || rot === 270)
                    labelSize = maxLabel.height + tickPad + pad
            }
            if (axis.side === "top" || axis.side === "bottom") {
                var lastLabel = labelSizes[labelSizes.length - 1] || {
                    width: 0
                };
                halfLabel = haveLabels ? lastLabel.width / 2 + pad : pad;
                if (nestedOrdAxisDepth > 1 && haveLabels) {
                    axisSize = nestedOrdAxisDepth * (maxLabel.height + descenderLength) + Math.max(tickSize, 3);
                    if (axisSize > MAX_ORD_LABEL_LENGTH * chart.height) {
                        descenderLength = 0;
                        axisSize = nestedOrdAxisDepth * (maxLabel.height + descenderLength) + Math.max(tickSize, 3)
                    }
                } else
                    axisSize = labelSize;
                titleLayout = getTitleSize(chart, axis, axisSize, pad);
                res = {
                    pde: pde,
                    size: axisSize + titleLayout.space,
                    axisSize: axisSize,
                    titleOffset: labelSize + titleLayout.size / 2,
                    titleOff: axis.side === "bottom" ? axisSize + titleLayout.space - titleLayout.size : axisSize + pad,
                    titleHeight: titleLayout.size,
                    halfLabel: halfLabel,
                    nestedDepth: nestedOrdAxisDepth,
                    labelHeight: maxLabel.height,
                    descenderLength: descenderLength
                }
            } else {
                titleLayout = getTitleSize(chart, axis, labelSize, pad);
                res = {
                    pde: pde,
                    size: labelSize + titleLayout.space,
                    axisSize: labelSize,
                    titleOffset: labelSize + titleLayout.size / 2,
                    titleOff: labelSize,
                    titleHeight: titleLayout.size,
                    halfLabel: halfLabel
                }
            }
        } else {
            var i, margin = 8;
            var nestedColWidths = [];
            axisSize = haveLabels ? tickSize + labelsPad : 8 + tickSize;
            if (haveLabels) {
                for (i = 0; i < labelSizes.length; i++) {
                    var labelDepth = nestedLabelDepths[i] - 1;
                    nestedColWidths[labelDepth] = Math.max(nestedColWidths[labelDepth] || 0, labelSizes[i].width)
                }
                axisSize = tickSize + labelsPad + tdg.sum(nestedColWidths) + margin * nestedColWidths.length;
                var maxAxisSize = Math.max(MAX_ORD_LABEL_LENGTH * 2, .6) * chart.width;
                if (axisSize > maxAxisSize) {
                    nestedColWidths = nestedColWidths.map(function(el) {
                        return el * maxAxisSize / axisSize
                    });
                    axisSize = tickSize + labelsPad + tdg.sum(nestedColWidths) + margin * nestedColWidths.length
                }
            }
            titleLayout = getTitleSize(chart, axis, axisSize, pad);
            res = {
                pde: pde,
                size: axisSize + titleLayout.space,
                axisSize: axisSize,
                titleOffset: axisSize + pad / 2,
                titleOff: axisSize,
                titleHeight: titleLayout.size,
                halfLabel: axisSize / labels.length / 2,
                nestedDepth: nestedOrdAxisDepth,
                nestedColWidths: nestedColWidths,
                labelHeight: maxLabel.height,
                descenderLength: descenderLength
            }
        }
        return res
    }
    ;
    var angleConfig = {
        0: 0,
        45: -45,
        "-90": 90,
        90: -90,
        135: 45,
        180: 180,
        270: 90
    };
    var anchorConfig = {
        top: {
            0: ["middle", "bottom"],
            45: ["left", "bottom"],
            90: ["left", "middle"],
            "-90": ["left", "middle"],
            135: ["right", "middle"],
            180: ["middle", "top"],
            270: ["right", "middle"]
        },
        right: {
            0: ["left", "middle"],
            45: ["left", "top"],
            90: ["middle", "top"],
            "-90": ["middle", "top"],
            135: ["left", "bottom"],
            180: ["right", "middle"],
            270: ["middle", "bottom"]
        },
        bottom: {
            0: ["middle", "top"],
            45: ["right", "top"],
            90: ["right", "middle"],
            "-90": ["right", "middle"],
            135: ["left", "top"],
            180: ["middle", "bottom"],
            270: ["left", "middle"]
        },
        left: {
            0: ["right", "middle"],
            45: ["right", "bottom"],
            90: ["middle", "right"],
            "-90": ["middle", "right"],
            135: ["right", "top"],
            180: ["left", "middle"],
            270: ["middle", "top"]
        }
    };
    tdgchart.prototype.getLabelAngleConfig = function(axisSide, rotation) {
        var align = (anchorConfig[axisSide] || anchorConfig.bottom)[rotation || 0];
        return {
            rotation: angleConfig[rotation || 0],
            align: align[0],
            valign: align[1]
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.layoutAxis = function(panelSize, axisList, matrixMasterChartSize) {
        var chart = this;
        var padLeft = chart.getPadding("frame", "left");
        var padRight = chart.getPadding("frame", "right");
        var groupCount = chart.groupCount();
        var layout = {
            titleOffset: {},
            inset: {},
            axisAt: {}
        };
        var isMatrix = chart.chartType === "matrix";
        var w, h = panelSize.height;
        function maxLayout(axisAt, size) {
            if (!axisAt.length)
                return chart.axisWidth(null, size, null, null, matrixMasterChartSize);
            var layouts = axisAt.map(function(el) {
                if (el.config && el.config.colMinMax && el.name.startsWith("x")) {
                    var colLayoutList = el.config.colMinMax.map(function(rowConfig) {
                        return chart.axisWidth(el, size, null, rowConfig, matrixMasterChartSize)
                    });
                    return tdg.max(colLayoutList, "titleOffset", "key")
                } else if (el.config && el.config.rowMinMax) {
                    var rowLayoutList = el.config.rowMinMax.map(function(rowConfig) {
                        return chart.axisWidth(el, size, null, rowConfig, matrixMasterChartSize)
                    });
                    return tdg.max(rowLayoutList, "titleOffset", "key")
                }
                return chart.axisWidth(el, size, null, el.config, matrixMasterChartSize)
            });
            var maxLayout = tdg.max(layouts, "titleOffset", "key");
            axisAt.forEach(function(el) {
                el.layout = maxLayout
            });
            return maxLayout
        }
        ["left", "right", "top", "bottom"].forEach(function(side) {
            layout.axisAt[side] = axisList.filter(function(el) {
                return el && el.side === side
            })
        });
        var leftLayout = maxLayout(layout.axisAt.left, panelSize);
        var rightLayout = maxLayout(layout.axisAt.right, panelSize);
        var leftInset = leftLayout.size;
        var rightInset = rightLayout.size;
        layout.titleOffset.left = -leftLayout.titleOffset;
        layout.titleOffset.right = rightLayout.titleOffset;
        if (chart._isChartSlider)
            leftInset = rightInset = 0;
        w = panelSize.width;
        if (matrixMasterChartSize == null)
            w = panelSize.width - leftInset - rightInset;
        var aspectRatio = getAspectRatio(chart, layout, chart.chartFrame.proportions);
        if (aspectRatio && !isMatrix)
            if (w > h * aspectRatio)
                w = h * aspectRatio;
            else if (w < h * aspectRatio)
                h = w / aspectRatio;
        var topLayout = maxLayout(layout.axisAt.top, {
            width: w,
            height: h
        });
        var bottomLayout = maxLayout(layout.axisAt.bottom, {
            width: w,
            height: h
        });
        var bottomInset = bottomLayout.size;
        var topInset = topLayout.size;
        if (chart.chartType !== "matrix")
            topInset = Math.max(0, topLayout.size - chart.getPadding("frame", "top"));
        function titleHeight(axis) {
            if (axis && chart.isOrthogonalAxis(axis) && axis.properties.title && axis.properties.title.visible && !tdg.isEmpty(axis.properties.title.text))
                return chart.measureLabel(axis.properties.title).height;
            return 0
        }
        topInset += Math.max(titleHeight(layout.axisAt.left[0]), titleHeight(layout.axisAt.right[0]));
        var pde = {};
        for (var i = 0; i < axisList.length; i++)
            if (axisList[i].layout.pde)
                pde = axisList[i].layout.pde;
        function numLabelMayStickMax(axis) {
            return axis.length && chart.cache.get("axisModes", {})[axis[0].name] !== "ordinal" && !axis[0].properties.labels.excludeMax
        }
        if (chart.chartType !== "matrix" && (numLabelMayStickMax(layout.axisAt.bottom) || numLabelMayStickMax(layout.axisAt.top)))
            rightInset = Math.max(rightLayout.size, topLayout.halfLabel, bottomLayout.halfLabel);
        if (chart.cache.hasKey("mekkoData") && chart.blaProperties.stackTotalLabel.visible)
            if (chart.blaProperties.orientation === "vertical")
                topInset += tdg.measureFont(chart.blaProperties.stackTotalLabel.font).height + padLeft;
            else {
                var mekkoData = chart.cache.get("mekkoData");
                var lblList = mekkoData.mekkoGroupSums.map(function(el) {
                    var l = chart.formatNumber(el, chart.blaProperties.stackTotalLabel.numberFormat, "stackTotalLabel");
                    return chart.measureLabel(l, chart.blaProperties.stackTotalLabel.font)
                });
                rightInset += tdg.max(lblList, "width")
            }
        layout.titleOffset.bottom = -bottomInset;
        layout.titleOffset.top = -topInset;
        w = panelSize.width - leftInset - rightInset;
        h = panelSize.height - topInset - bottomInset;
        var space;
        if (pde.rotation === 45) {
            space = Math.max(0, pde.offset - leftInset - w / groupCount / 2 + padLeft + padLeft);
            w -= space;
            leftInset += space
        } else if (pde.rotation === 135) {
            space = Math.max(0, pde.offset - rightInset - w / groupCount / 2 + padRight + padRight);
            w -= space;
            rightInset += space
        }
        var inset = chart.computeddepth25d();
        if (inset > h / 2)
            inset = h / 2;
        h -= inset;
        w -= inset;
        topInset += inset;
        if (aspectRatio && !isMatrix)
            if (w > h * aspectRatio) {
                var newWidth = h * aspectRatio;
                leftInset += (w - newWidth) / 2;
                rightInset += (w - newWidth) / 2;
                w = newWidth
            } else if (w < h * aspectRatio) {
                var newHeight = w / aspectRatio;
                topInset += (h - newHeight) / 2;
                bottomInset += (h - newHeight) / 2;
                h = newHeight
            }
        layout.inset.top = topInset;
        layout.inset.left = leftInset;
        layout.inset.right = rightInset;
        layout.inset.bottom = bottomInset;
        layout.w = w;
        layout.h = h;
        layout.titleHeight = {};
        layout.titleOff = {};
        layout.axisSize = {};
        layout.size = {};
        ["left", "right", "top", "bottom"].forEach(function(side) {
            if (!layout.axisAt[side].length)
                layout.titleHeight[side] = layout.titleOff[side] = layout.axisSize[side] = layout.size[side] = 0;
            else
                layout.axisAt[side].forEach(function(el) {
                    layout.titleHeight[side] = Math.max(layout.titleHeight[side] || 0, el.layout.titleHeight || 0);
                    layout.titleOff[side] = Math.max(layout.titleOff[side] || 0, el.layout.titleOff || 0);
                    layout.axisSize[side] = Math.max(layout.axisSize[side] || 0, el.layout.axisSize || 0);
                    layout.size[side] = Math.max(layout.size[side] || 0, el.layout.size || 0)
                })
        });
        return layout
    }
    ;
    tdgchart.prototype.updateSizeAxisLayout = function(size, layout) {
        if (layout) {
            size.x += layout.inset.left || 0;
            size.y += layout.inset.top || 0;
            size.width = layout.w;
            size.height = layout.h
        }
        return size
    }
    ;
    function getAspectRatio(chart, layout, proportions) {
        if (!proportions || !proportions.aspectRatio)
            return null;
        if (proportions.mode == "byChartFrameAspect")
            return proportions.aspectRatio;
        if (proportions.mode == "byCellAspect") {
            var firstHorizAxis = layout.axisAt.left.length ? layout.axisAt.left[0] : layout.axisAt.right[0];
            if (!firstHorizAxis || !firstHorizAxis.name)
                return null;
            var firstVertAxis = layout.axisAt.bottom.length ? layout.axisAt.bottom[0] : layout.axisAt.top[0];
            if (!firstVertAxis || !firstVertAxis.name)
                return null;
            var axisModes = chart.cache.get("axisModes", {});
            if (!axisModes || axisModes[firstHorizAxis.name] !== "ordinal" || axisModes[firstVertAxis.name] !== "ordinal")
                return null;
            var cols = chart.visibleGroupCount();
            var rows = chart.seriesCount();
            if (cols && rows)
                return proportions.aspectRatio * cols / rows
        }
        return null
    }
    function newPanel(parent, x, y, w, h) {
        var r = parent.add(pv.Panel).left(x).top(y).width(w).height(h);
        r.computedSize = {
            width: w,
            height: h
        };
        return r
    }
    function newSidePanel(rootPanel, chartSize, axis, offset, size, separateAxisPanels, reversePadding) {
        if (!size)
            return null;
        var width = axis.size ? axis.size.width : chartSize.width;
        var height = axis.size ? axis.size.height : chartSize.height;
        var panelOffset = axis.panelOffset || 0;
        var expand = 0;
        if (axis.padding && reversePadding) {
            panelOffset -= axis.padding[0];
            expand = axis.padding[0] + axis.padding[1]
        }
        switch (axis.side) {
        case "left":
            return newPanel(rootPanel, separateAxisPanels ? rootPanel.computedSize.width - offset - size : chartSize.x - offset - size, chartSize.y + panelOffset, size, height + expand);
        case "right":
            return newPanel(rootPanel, separateAxisPanels ? offset : chartSize.x + chartSize.width + offset, chartSize.y + panelOffset, size, height + expand);
        case "top":
            return newPanel(rootPanel, chartSize.x + panelOffset, separateAxisPanels ? rootPanel.computedSize.height - offset - size : chartSize.y - offset - size, width + expand, size);
        case "bottom":
            return newPanel(rootPanel, chartSize.x + panelOffset, separateAxisPanels ? offset : chartSize.y + chartSize.height + offset, width + expand, size)
        }
        return null
    }
    function newAxisTitlePanel(rootPanel, chartSize, axis, axisSpacing, separateAxisPanels) {
        return newSidePanel(rootPanel, chartSize, axis, axisSpacing.titleOff, axisSpacing.titleHeight, separateAxisPanels, true)
    }
    function newAxisPanel(rootPanel, chartSize, axis, axisSpacing, separateAxisPanels) {
        return newSidePanel(rootPanel, chartSize, axis, 0, axisSpacing.axisSize, separateAxisPanels)
    }
    function newRiserPanel(rootPanel, chartSize, xAxis, yAxis) {
        xAxis = xAxis || {};
        yAxis = yAxis || {};
        var size = xAxis.size || chartSize;
        var vertOffset = 0
          , horizOffset = 0;
        if (yAxis.panelOffset)
            if (yAxis.side === "left" || yAxis.side === "right")
                vertOffset = yAxis.panelOffset;
            else if (yAxis.side === "top" || yAxis.side === "bottom")
                horizOffset = yAxis.panelOffset;
        if (xAxis.panelOffset)
            if (xAxis.side === "left" || xAxis.side === "right")
                vertOffset = xAxis.panelOffset;
            else if (xAxis.side === "top" || xAxis.side === "bottom")
                horizOffset = xAxis.panelOffset;
        return newPanel(rootPanel, chartSize.x + horizOffset, chartSize.y + vertOffset, size.width, size.height, "rgba(253,0,254,0.2)")
    }
    tdgchart.prototype.createXYPanels = function(rootPanel, chartSize, axisLayout) {
        var panels = {
            chart: rootPanel,
            left: rootPanel,
            right: rootPanel,
            top: rootPanel,
            bottom: rootPanel
        };
        return this.createXYPanelsM(panels, chartSize, axisLayout)
    }
    ;
    tdgchart.prototype.createXYPanelsM = function(rootPanels, chartSize, axisLayout, separateAxisPanels, matrixChartPadding) {
        var xAxisList = axisLayout.xAxisList || [];
        var yAxisList = axisLayout.yAxisList || [];
        var i, xName, yName;
        var axisSpacing, axisRootPanel, axisPanel, axisTitlePanel;
        var mpad = matrixChartPadding;
        var rootPanel = rootPanels.chart;
        var chartPanels = {
            chartSize: chartSize,
            root: rootPanels.chart,
            axis: {},
            riser: {},
            risers: {}
        };
        if (rootPanel && mpad)
            chartPanels.matrixCell = {
                bg: newPanel(rootPanel, chartSize.x - mpad.left, chartSize.y - mpad.top, chartSize.width + mpad.left + mpad.right, chartSize.height + mpad.top + mpad.bottom)
            };
        if (axisLayout.hasSplitAxes) {
            if (rootPanel)
                chartPanels.riser = {
                    bg: newPanel(rootPanel, chartSize.x, chartSize.y, chartSize.width, chartSize.height),
                    panel: newPanel(rootPanel, chartSize.x, chartSize.y, chartSize.width, chartSize.height),
                    fg: newPanel(rootPanel, chartSize.x, chartSize.y, chartSize.width, chartSize.height)
                };
            for (var xIdx = 0; xIdx < xAxisList.length; xIdx++) {
                var xaxis = xAxisList[xIdx];
                xName = xAxisList.length > 1 ? xaxis.name : "";
                for (i = 0; i < yAxisList.length; i++) {
                    var yaxis = yAxisList[i];
                    chartPanels.risers[xName + yaxis.name] = {};
                    if (rootPanel) {
                        var panelSize = tdg.clone(chartSize);
                        if (yaxis.side === "left" || yaxis.side === "right")
                            panelSize.height = yaxis.size.height;
                        else
                            panelSize.width = yaxis.size.width;
                        chartPanels.risers[xName + yaxis.name] = {
                            bg: newRiserPanel(rootPanel, panelSize, xaxis, yaxis),
                            panel: newRiserPanel(rootPanel, panelSize, xaxis, yaxis),
                            fg: newRiserPanel(rootPanel, panelSize, xaxis, yaxis)
                        }
                    }
                }
            }
        } else {
            if (rootPanel)
                chartPanels.riser = {
                    bg: newRiserPanel(rootPanel, chartSize, xAxisList[0], yAxisList[0]),
                    panel: newRiserPanel(rootPanel, chartSize, xAxisList[0], yAxisList[0]),
                    fg: newRiserPanel(rootPanel, chartSize, xAxisList[0], yAxisList[0])
                };
            for (i = 0; i < yAxisList.length; i++) {
                yName = yAxisList[i].name;
                chartPanels.risers[yName] = chartPanels.riser
            }
        }
        if (rootPanel && mpad)
            chartPanels.matrixCell.fg = newPanel(rootPanel, chartSize.x - mpad.left, chartSize.y - mpad.top, chartSize.width + mpad.left + mpad.right, chartSize.height + mpad.top + mpad.bottom);
        for (i = 0; i < xAxisList.length; i++) {
            xName = xAxisList[i].name || "x";
            axisRootPanel = rootPanels[xAxisList[i].side];
            if (axisRootPanel) {
                axisSpacing = xAxisList[i].layout;
                axisPanel = newAxisPanel(axisRootPanel, chartSize, xAxisList[i], axisSpacing, separateAxisPanels);
                if (rootPanels.xAxisStaticTitles && rootPanels.xAxisStaticTitles[xName])
                    axisTitlePanel = newAxisTitlePanel(rootPanels.xAxisStaticTitles[xName], rootPanels.xAxisStaticTitles[xName].computedSize, xAxisList[i], axisSpacing, separateAxisPanels);
                else
                    axisTitlePanel = newAxisTitlePanel(axisRootPanel, chartSize, xAxisList[i], axisSpacing, separateAxisPanels);
                chartPanels.axis[xName] = {
                    bg: chartPanels.riser.bg,
                    fg: chartPanels.riser.fg,
                    axis: axisPanel,
                    title: axisTitlePanel
                }
            } else
                chartPanels.axis[xName] = {
                    bg: chartPanels.riser.bg,
                    fg: chartPanels.riser.fg
                };
            if (!chartPanels.xAxis)
                chartPanels.xAxis = chartPanels.axis[xName]
        }
        for (i = 0; i < yAxisList.length; i++) {
            xName = xAxisList.length > 1 ? xAxisList[0].name : "";
            yName = yAxisList[i].name;
            axisRootPanel = rootPanels[yAxisList[i].side];
            if (axisRootPanel) {
                axisSpacing = yAxisList[i].layout;
                axisPanel = newAxisPanel(axisRootPanel, chartSize, yAxisList[i], axisSpacing, separateAxisPanels);
                axisTitlePanel = newAxisTitlePanel(axisRootPanel, chartSize, yAxisList[i], axisSpacing, separateAxisPanels);
                chartPanels.axis[yName] = {
                    size: yAxisList[i].size,
                    bg: chartPanels.risers[xName + yName].bg,
                    fg: chartPanels.risers[xName + yName].fg,
                    axis: axisPanel,
                    title: axisTitlePanel
                }
            } else
                chartPanels.axis[yName] = {
                    size: yAxisList[i].size,
                    bg: chartPanels.risers[xName + yName].bg,
                    fg: chartPanels.risers[xName + yName].fg
                };
            if (!chartPanels.yAxis)
                chartPanels.yAxis = chartPanels.axis[yName]
        }
        return chartPanels
    }
    ;
    function getAxisConfig(axisConfig, name, needY2) {
        if (typeof axisConfig === "object" && !Array.isArray(axisConfig)) {
            axisConfig.name = name;
            axisConfig = [axisConfig]
        }
        if (!axisConfig || axisConfig.length === 0) {
            axisConfig = [{
                name: name
            }];
            if (needY2)
                axisConfig.push({
                    name: "y2"
                })
        }
        if (axisConfig && axisConfig.length)
            axisConfig = axisConfig.sort(function(a, b) {
                if (a.name > b.name)
                    return 1;
                else if (a.name < b.name)
                    return -1;
                return 0
            });
        return axisConfig
    }
    function getAxisMargin(chart, groupFit, size, groupCount) {
        var groupSize, axisPad = 0;
        groupFit = groupFit || {};
        var rules = ["minsize", "maxsize", "exactsize", "labelheight"];
        if (typeof groupFit.rule === "string" && rules.includes(groupFit.rule.toLowerCase()))
            if (groupFit.rule === "labelHeight") {
                groupSize = tdg.measureFont(chart.get("axisList.x1.labels.font")).height;
                groupSize += groupFit.value ? tdg.applyNumOrPercent(groupFit.value, groupSize) : 3;
                axisPad = size - groupCount * groupSize
            } else {
                groupSize = tdg.applyNumOrPercent(groupFit.value, size);
                var pad = size - groupCount * groupSize;
                if ((groupFit.rule === "maxSize" || groupFit.rule === "exactSize") && pad > 0)
                    axisPad = pad;
                if ((groupFit.rule === "minSize" || groupFit.rule === "exactSize") && pad < 0)
                    axisPad = pad
            }
        return axisPad
    }
    tdgchart.prototype.getOrdAxisMargin = function(groupFit, size, useSeries, index) {
        var chart = this;
        var groupCount;
        if (index != null && chart.cache.hasKey("matrixCompressedGroups")) {
            var compInfo = chart.cache.get("matrixCompressedGroups");
            groupCount = compInfo.groupCountArray[index]
        }
        var vgc = groupCount ? groupCount : useSeries ? chart.seriesCount() : chart.visibleGroupCount();
        return getAxisMargin(chart, groupFit, size, vgc)
    }
    ;
    tdgchart.prototype.getAxisPadding = function(inset, size) {
        if (tdg.isPercentString(inset) && inset !== "auto") {
            var val = tdg.parsePercent(inset) * size;
            return [val, val]
        } else if (typeof inset === "number")
            return [inset, inset];
        else if (typeof inset === "object") {
            var start = tdg.applyNumOrPercent(inset.start, size);
            var end = tdg.applyNumOrPercent(inset.end, size);
            return [start, end]
        }
        return null
    }
    ;
    function getAxisPadMargin(chart, axisLayout, axis, axisLength, margin, invertDirection, noPad) {
        var padding = chart.getAxisPadding(axis.inset, axisLength);
        if (margin <= 0 && !padding)
            return null;
        if (noPad)
            padding = [0, 0];
        else if (axis.inset === "auto") {
            var MAX_PAD = 15;
            var pad = Math.floor(Math.min(margin, 2 * MAX_PAD) / 2);
            padding = [pad, pad]
        } else
            padding = padding || [0, 0];
        margin = Math.max(0, margin - padding[0] - padding[1]);
        var marginBefore, axisPosition = axis.position;
        if (invertDirection)
            if (axisPosition === "start")
                axisPosition = "end";
            else if (axisPosition === "end")
                axisPosition = "start";
        switch (axis.position) {
        case "start":
            marginBefore = 0;
            break;
        case "middle":
            marginBefore = Math.floor(margin / 2);
            break;
        case "end":
            marginBefore = margin;
            break;
        default:
            if (!axis.position)
                marginBefore = invertDirection ? margin : 0;
            else if (typeof axis.position === "number")
                marginBefore = Math.floor(Math.min(margin, axis.position));
            else
                marginBefore = Math.floor(tdg.applyNumOrPercent(axis.position, margin))
        }
        return {
            padding: padding,
            margin: [marginBefore, margin - marginBefore]
        }
    }
    function applyOrdAxisPadMargin(chart, axisLayout) {
        var isVertical = chart.blaProperties.orientation === "vertical";
        var axisLength = isVertical ? axisLayout.spacing.w : axisLayout.spacing.h;
        var margin = chart.getOrdAxisMargin(chart.axisList.x1.groupFit, axisLength);
        var padMargin = getAxisPadMargin(chart, axisLayout, chart.axisList.x1, axisLength, margin, false);
        if (!padMargin)
            return;
        margin = padMargin.margin;
        var pad = padMargin.padding;
        var newSize = {
            width: axisLayout.spacing.w,
            height: axisLayout.spacing.h
        };
        newSize[isVertical ? "width" : "height"] -= pad[0] + pad[1] + margin[0] + margin[1];
        axisLayout.xAxisList[0].panelOffset = pad[0] + margin[0];
        axisLayout.xAxisList[0].size = newSize;
        axisLayout.xAxisList[0].padding = pad;
        axisLayout.xAxisList[0].margin = margin;
        axisLayout.yAxisList.forEach(function(axis) {
            axis.orthPadding = pad
        })
    }
    function applyNumAxisPadMargin(chart, axisLayout, minMax) {
        if (!axisLayout || axisLayout.hasSplitAxes)
            return;
        var isVertical = chart.blaProperties.orientation === "vertical";
        var axisLength = isVertical ? axisLayout.spacing.h : axisLayout.spacing.w;
        var scale = chart.getNumericScale({
            width: axisLayout.spacing.w,
            height: axisLayout.spacing.h
        }, axisLayout.yAxisList[0], minMax);
        var margin = getAxisMargin(chart, chart.axisList.y1.groupFit, axisLength, scale.grid.length - 1);
        var padMargin = getAxisPadMargin(chart, axisLayout, chart.axisList.y1, axisLength, margin, isVertical, true);
        if (!padMargin)
            return;
        var intervalMode = chart.get("axisList.y1.intervalMode");
        if (!intervalMode) {
            chart.cache.setProperty("axisList.y1.intervalMode", "count");
            chart.cache.setProperty("axisList.y1.intervalValue", scale.grid.length);
            axisLayout.yAxisList[0].properties.intervalMode = "count";
            axisLayout.yAxisList[0].properties.intervalValue = scale.grid.length
        }
        margin = padMargin.margin;
        var pad = padMargin.padding;
        var newSize = {
            width: axisLayout.spacing.w,
            height: axisLayout.spacing.h
        };
        newSize[isVertical ? "height" : "width"] -= pad[0] + pad[1] + margin[0] + margin[1];
        axisLayout.spacing.inset.top = pad[0] + margin[0];
        axisLayout.yAxisList[0].size = newSize;
        axisLayout.yAxisList[0].padding = pad;
        axisLayout.yAxisList[0].margin = margin;
        axisLayout.spacing.w = newSize.width;
        axisLayout.spacing.h = newSize.height
    }
    function setAxisSides(chart, axisList, needY2) {
        var isVertical = chart.blaProperties.orientation === "vertical";
        axisList.forEach(function(axis) {
            if (axis && axis.name && axis.name.startsWith("y"))
                if (isVertical)
                    axis.side = axis.properties.swapChartSide ? "right" : "left";
                else
                    axis.side = axis.properties.swapChartSide ? "top" : "bottom"
        });
        if (needY2 && !chart.splitNumericAxis.splitY.enabled) {
            var y2side = chart.axisList.y1.swapChartSide ? isVertical ? "left" : "bottom" : isVertical ? "right" : "top";
            axisList.forEach(function(axis) {
                if (axis && axis.name === "y2")
                    axis.side = y2side
            })
        }
    }
    tdgchart.prototype.getAxisPanelSize = function(rootPanelSize, hAxisCount, vAxisCount, hasSplitAxes) {
        var chart = this;
        var res;
        if (hasSplitAxes && (hAxisCount || vAxisCount)) {
            var hGapRatio, vGapRatio;
            if (chart.isBLA() && chart.blaProperties.orientation === "horizontal") {
                hGapRatio = chart.get("splitNumericAxis.splitY.axisGap", .1);
                vGapRatio = chart.get("splitNumericAxis.splitX.axisGap", .1)
            } else {
                hGapRatio = chart.get("splitNumericAxis.splitX.axisGap", .1);
                vGapRatio = chart.get("splitNumericAxis.splitY.axisGap", .1)
            }
            var hGap = Math.min(hAxisCount > 1 ? rootPanelSize.width * hGapRatio : 0, rootPanelSize.width / 2);
            var totalWidth = rootPanelSize.width - hGap * (hAxisCount - 1);
            var width = totalWidth / hAxisCount;
            var vGap = Math.min(vAxisCount > 1 ? rootPanelSize.height * vGapRatio : 0, rootPanelSize.height / 2);
            var totalHeight = rootPanelSize.height - vGap * (vAxisCount - 1);
            var height = totalHeight / vAxisCount;
            res = {
                width: width,
                height: height,
                hGap: hGap,
                vGap: vGap
            }
        } else
            res = {
                width: rootPanelSize.width,
                height: rootPanelSize.height,
                hGap: 0,
                vGap: 0
            };
        return res
    }
    ;
    tdgchart.prototype.getXOrdYAxisLayout = function(chartSize, minMax, matrixMasterChartSize) {
        var chart = this;
        var axisLayout = {};
        var isVertical = chart.blaProperties.orientation === "vertical";
        var isMatrix = chart.chartType === "matrix";
        axisLayout.xAxisList = [{
            name: "x1",
            side: chart.axisList.x1.swapChartSide ? isVertical ? "top" : "right" : isVertical ? "bottom" : "left",
            properties: chart.axisList.x1
        }];
        axisLayout.hasSplitAxes = chart.splitNumericAxis.splitY.enabled && chart.isBLA();
        var needY2 = axisLayout.hasSplitAxes ? false : chart.needDualY2Axis();
        var axisConfig = getAxisConfig(minMax, "y1", needY2);
        axisLayout.yAxisList = chart.getAxisList(axisConfig);
        setAxisSides(chart, axisLayout.yAxisList, needY2);
        axisLayout.spacing = chart.layoutAxis(chartSize, axisLayout.yAxisList.concat(axisLayout.xAxisList), matrixMasterChartSize);
        applyOrdAxisPadMargin(chart, axisLayout);
        applyNumAxisPadMargin(chart, axisLayout, minMax);
        var size = axisLayout.xAxisList[0].size || axisLayout.yAxisList[0].size || {
            width: axisLayout.spacing.w,
            height: axisLayout.spacing.h
        };
        var hAxisCount = isVertical ? 1 : axisConfig.length || 1;
        var vAxisCount = isVertical ? axisConfig.length || 1 : 1;
        var axisPanelSize = chart.getAxisPanelSize(size, hAxisCount, vAxisCount, axisLayout.hasSplitAxes);
        if (axisLayout.hasSplitAxes) {
            var length = isVertical ? axisPanelSize.height : axisPanelSize.width;
            for (var i = 0; i < axisLayout.yAxisList.length; i++) {
                axisLayout.yAxisList[i].panelOffset = (length + (isVertical ? axisPanelSize.vGap : axisPanelSize.hGap)) * i;
                axisLayout.yAxisList[i].size = axisPanelSize
            }
        }
        axisLayout.xScalesList = chart.getBLAXScalesList(axisPanelSize, axisLayout.xAxisList);
        axisLayout.yScalesList = chart.getScalesList(axisPanelSize, axisLayout.yAxisList);
        return axisLayout
    }
    ;
    tdgchart.prototype.getXYAxisLayout = function(chartSize, minMaxXY, matrixMasterChartSize) {
        function getAxisFromMinMax(minMaxXY, axisName) {
            minMaxXY = minMaxXY || [];
            if (minMaxXY.rowMinMax || minMaxXY.colMinMax)
                if (axisName === "x")
                    return {
                        colMinMax: minMaxXY.colMinMax.map(function(el) {
                            for (var key in el)
                                if (el.hasOwnProperty(key) && key.startsWith(axisName))
                                    return el[key];
                            return null
                        })
                    };
                else
                    return {
                        rowMinMax: minMaxXY.rowMinMax.map(function(el) {
                            for (var key in el)
                                if (el.hasOwnProperty(key) && key.startsWith(axisName))
                                    return el[key];
                            return null
                        })
                    };
            return minMaxXY.filter(function(el) {
                return el && el.name && el.name.startsWith(axisName)
            })
        }
        var chart = this;
        var labels, i;
        var axisLayout = {};
        var haveOrdX = chart.cache.get("axisModes", {}).x1 === "ordinal";
        var haveOrdY = chart.cache.get("axisModes", {}).y1 === "ordinal";
        var splitProps = chart.splitNumericAxis;
        axisLayout.hasSplitAxes = !haveOrdX && splitProps.splitX.enabled || !haveOrdY && splitProps.splitY.enabled;
        var minMaxX = getAxisFromMinMax(minMaxXY, "x");
        var XAxisConfig = getAxisConfig(minMaxX, "x1", false);
        axisLayout.xAxisList = chart.getAxisList(XAxisConfig);
        var minMaxY = getAxisFromMinMax(minMaxXY, "y");
        var YAxisConfig = getAxisConfig(minMaxY, "y1", false);
        axisLayout.yAxisList = chart.getAxisList(YAxisConfig);
        var allAxis = axisLayout.xAxisList.concat(axisLayout.yAxisList);
        axisLayout.xAxisList.forEach(function(axis) {
            axis.side = axis.properties.swapChartSide ? "top" : "bottom"
        });
        if (haveOrdX)
            axisLayout.xAxisList[0].labels = chart.getXYOrdAxisLabels("x");
        axisLayout.yAxisList.forEach(function(axis) {
            axis.side = axis.properties.swapChartSide ? "right" : "left"
        });
        if (haveOrdY)
            axisLayout.yAxisList[0].labels = chart.getXYOrdAxisLabels("y");
        if (allAxis.length > 1)
            allAxis.forEach(function(axis) {
                if (axis.properties.min == "xymin" || axis.properties.max == "xymax" || axis.properties.min == "xyauto" || axis.properties.max == "xyauto") {
                    axis.syncScale = allAxis;
                    chart.cache.set("axisScaleMinMax", {})
                }
            });
        axisLayout.spacing = chart.layoutAxis(chartSize, axisLayout.yAxisList.concat(axisLayout.xAxisList), matrixMasterChartSize);
        var size = axisLayout.xAxisList[0].size || axisLayout.yAxisList[0].size || {
            width: axisLayout.spacing.w,
            height: axisLayout.spacing.h
        };
        var axisPanelSize = chart.getAxisPanelSize(size, XAxisConfig.length || 1, YAxisConfig.length || 1, axisLayout.hasSplitAxes);
        if (axisLayout.hasSplitAxes) {
            for (i = 0; i < axisLayout.xAxisList.length; i++) {
                axisLayout.xAxisList[i].panelOffset = (axisPanelSize.width + axisPanelSize.hGap) * i;
                axisLayout.xAxisList[i].size = axisPanelSize
            }
            for (i = 0; i < axisLayout.yAxisList.length; i++) {
                axisLayout.yAxisList[i].panelOffset = (axisPanelSize.height + axisPanelSize.vGap) * i;
                axisLayout.yAxisList[i].size = axisPanelSize
            }
        }
        var newSize = {
            width: axisLayout.spacing.w,
            height: axisLayout.spacing.h
        };
        if (haveOrdX) {
            labels = axisLayout.xAxisList[0].labels;
            axisLayout.xScalesList = [chart.getOrdinalScale(newSize, 1, "horizontal", chart.axisList.x1.invert, false, labels.length, labels)]
        } else
            axisLayout.xScalesList = chart.getScalesList(axisPanelSize, axisLayout.xAxisList);
        if (haveOrdY) {
            labels = axisLayout.yAxisList[0].labels;
            axisLayout.yScalesList = [chart.getOrdinalScale(newSize, 1, "vertical", chart.axisList.y1.invert, false, labels.length, labels)]
        } else
            axisLayout.yScalesList = chart.getScalesList(axisPanelSize, axisLayout.yAxisList);
        return axisLayout
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    var globalAxisHeadroom = 1.1;
    tdgchart.prototype.getAxisAssignment = function(data) {
        var chart = this;
        var s = chart.getDefaultSeries();
        var defaultAxis = s == null || s.yAxisAssignment == null ? 1 : Math.min(2, s.yAxisAssignment) || 1;
        var assignment = tdg.repeat(defaultAxis, (data || chart._internalData || chart.data).length);
        chart.series.forEach(function(el) {
            if (el.group == null)
                if (chart.splitNumericAxis.splitY.enabled)
                    assignment[el.series] = el.yAxisAssignment || defaultAxis;
                else if (chart.cache.hasKey("mekkoData"))
                    assignment[el.series] = 1;
                else
                    assignment[el.series] = Math.min(2, el.yAxisAssignment) || defaultAxis
        });
        return assignment
    }
    ;
    function minMaxFromValueList(data, valueList) {
        return tdg.minMaxR(data, function(el) {
            var values = valueList.map(function(v) {
                return el[v] || 0
            });
            values = tdg.arrayFlat(values);
            return Math.min.apply(null, values)
        }, function(el) {
            var values = valueList.map(function(v) {
                return el[v] || 0
            });
            values = tdg.arrayFlat(values);
            return Math.max.apply(null, values)
        })
    }
    function getScaleMinMaxTreemap(chart, data, odata_key) {
        var root = tdg.tree(data);
        var res = {
            min: Infinity,
            max: -Infinity
        };
        var idx = odata_key === "color" ? 1 : 0;
        if (chart.dataArrayMap)
            idx = chart.dataArrayMap.indexOf(odata_key);
        root.visitBefore(function(node) {
            var v = node.nodeValue;
            if (Array.isArray(v))
                if (v.length <= 1 && odata_key === "color" && idx === 1 && !chart.dataArrayMap)
                    v = v[0];
                else
                    v = v[idx];
            if (tdg.isANumber(v)) {
                res.min = Math.min(res.min, v);
                res.max = Math.max(res.max, v)
            }
        });
        return res
    }
    function minMaxFromZero(axis) {
        return axis.mustIncludeZero == null || !!axis.mustIncludeZero
    }
    function isEnoughDepth(data) {
        var depth = function(array) {
            function depth(arr, d) {
                var maxDepth;
                if (!Array.isArray(arr))
                    return d;
                if (Array.isArray(arr) && arr.length === 0)
                    return ++d;
                for (var i = 0; i < arr.length; i++)
                    maxDepth = Math.max(d, depth(arr[i], d + 1));
                return maxDepth
            }
            return depth(array, 1)
        }(data);
        return depth >= 4
    }
    function resolveObjectDataKey(chart, chartType, axis) {
        if (axis === chart.colorScale && chart.cache.hasKey("colorAxis"))
            return chart.cache.get("colorAxis").odata_key;
        if (chartType === "scatter" || chartType === "bubble" || chartType === "map" && chart.mapProperties.markerType === "bubble")
            return axis === chart.axisList.y1 || axis === chart.yaxis ? "y" : "x";
        else if (chartType === "polar")
            return axis === chart.axisList.y1 || axis === chart.yaxis ? "r" : "phi";
        else if (chartType === "marker")
            return axis === chart.axisList.y1 || axis === chart.yaxis ? "color" : "value";
        else if (chartType === "map")
            return "value";
        else if (chartType === "treemap")
            return "size";
        return axis === chart.colorScale ? "color" : "value"
    }
    tdgchart.prototype.getDataSetMinMax = function(axisProperties, axisName, data, layout, odata_key, chartType) {
        var chart = this;
        if (!chartType)
            chartType = chart.chartType;
        var matrixType = chartType === "matrix" ? chart.matrixProperties.chartType : null;
        if (typeof axisProperties.min === "number" && typeof axisProperties.max === "number")
            return {
                min: axisProperties.min,
                max: axisProperties.max
            };
        if (axisProperties.rawMin != null && axisProperties.rawMax != null)
            return {
                min: axisProperties.rawMin,
                max: axisProperties.rawMax
            };
        if (data == null && chart.isPageSliderEnabled()) {
            var tmp = chart.data.map(function(el) {
                return chart.getDataSetMinMax(axisProperties, axisName, el, layout, odata_key)
            });
            return tdg.minMax(tmp, "min", "max")
        }
        odata_key = odata_key || resolveObjectDataKey(chart, matrixType || chartType, axisProperties);
        var i, j, value;
        var minMax = {
            min: Infinity,
            max: -Infinity
        };
        var passedDataIsUndefined = data == null;
        var chartData = chart._internalData || chart.data;
        data = data == null ? chartData : data;
        if (chartType === "matrix" && isEnoughDepth(data))
            for (var r = 0; r < data.length; r++)
                for (var c = 0; c < data[r].length; c++) {
                    var rcMinMax = chart.getDataSetMinMax(axisProperties, axisName, data[r][c], layout, odata_key, matrixType);
                    if (rcMinMax.max > minMax.max)
                        minMax.max = rcMinMax.max;
                    if (rcMinMax.min < minMax.min)
                        minMax.min = rcMinMax.min
                }
        else if (chartType === "marker")
            if (data[0] && data[0][0])
                minMax = {
                    min: data[0][0][odata_key],
                    max: data[0][0][odata_key]
                };
            else if (data[0])
                minMax = {
                    min: data[0][odata_key],
                    max: data[0][odata_key]
                };
            else
                minMax = {
                    min: data[odata_key],
                    max: data[odata_key]
                };
        else if (chartType === "boxplot")
            minMax = minMaxFromValueList(data, ["min", "lower", "median", "upper", "max", "outliers"]);
        else if (chartType === "bullet" && data[0] && data[0][0] && data[0][0].markers)
            minMax = tdg.minMax(data[0][0].markers.concat(data[0][0].value || 0));
        else if (chartType === "stock")
            minMax = minMaxFromValueList(data, ["high", "low", "open", "close"]);
        else if (chartType === "gantt")
            minMax = minMaxFromValueList(data, ["fromValue", "toValue"]);
        else if (chartType === "treemap")
            minMax = getScaleMinMaxTreemap(chart, data, odata_key);
        else if (chartType === "control") {
            var controlMode = chart.get("controlProperties.mode");
            if ((controlMode === "u" || controlMode === "p") && data[0] && data[0][0] && data[0][0].hasOwnProperty("sampleSize"))
                minMax = tdg.minMax(data[0].map(function(el) {
                    return el.value / el.sampleSize
                }));
            else
                minMax = tdg.minMax(data[0], "value")
        } else if (chartType === "tagcloud") {
            if (data[0] && chart.tagcloudProperties.maxNumberOfTags > 0 && chart.tagcloudProperties.maxNumberOfTags < data[0].length)
                data = [data[0].slice().sort(function(a, b) {
                    return b.value - a.value
                }).slice(0, chart.tagcloudProperties.maxNumberOfTags)];
            minMax = tdg.minMax(data[0].filter(function(el) {
                return el[odata_key] != null
            }), odata_key)
        } else {
            var isBLA = chartType === "bar" || chartType === "line" || chartType === "area" || chartType === "waterfall";
            var splitYMatrix = chart.splitNumericAxis.splitY.enabled && chartType === "matrix";
            layout = layout || (axisName != "colorScale" ? chart.blaProperties.seriesLayout : "sideBySide");
            if (passedDataIsUndefined && (axisName === "y1" || axisName === "y2")) {
                var assignment = chart.getAxisAssignment();
                data = [];
                if (!chart.needDualY2Axis())
                    data = chartData.slice(0);
                else
                    for (i = 0; i < chartData.length; i++)
                        if (axisName === "y1" && assignment[i] === 1 || axisName === "y2" && assignment[i] === 2)
                            data.push(chartData[i])
            }
            if (chartType === "waterfall") {
                var sum = 0;
                data[0].map(function(el, index) {
                    sum = chart.isSubtotalRiser(index, el) ? el.value || 0 : sum + (el.value || 0);
                    minMax.min = Math.min(minMax.min, sum);
                    minMax.max = Math.max(minMax.max, sum)
                })
            } else if ((isBLA || splitYMatrix) && layout === "stacked" && odata_key !== "color") {
                var tData = tdg.transpose(data);
                var lMin = 0
                  , lMax = 0;
                for (i = 0; i < tData.length; i++) {
                    for (j = 0; j < tData[i].length; j++) {
                        value = tData[i][j] || 0;
                        if (typeof value === "object" && odata_key)
                            value = value[odata_key] || 0;
                        if (value < 0) {
                            lMin += value;
                            minMax.min = Math.min(minMax.min, lMin);
                            minMax.max = Math.max(minMax.max, lMin)
                        } else {
                            lMax += value;
                            minMax.min = Math.min(minMax.min, lMax);
                            minMax.max = Math.max(minMax.max, lMax)
                        }
                    }
                    lMin = lMax = 0
                }
            } else if ((isBLA || splitYMatrix) && layout === "percent") {
                minMax.min = 0;
                minMax.max = 100
            } else {
                var min = Infinity
                  , max = -Infinity;
                for (var s = 0; s < data.length; s++)
                    if (data[s] && data[s].length)
                        for (var g = 0; g < data[s].length; g++) {
                            var v = (data[s][g] || {})[odata_key];
                            if (v != null && (!axisProperties.bIsLog || v > 0)) {
                                min = Math.min(min, v);
                                max = Math.max(max, v)
                            }
                        }
                if (min === Infinity || max === -Infinity) {
                    minMax = {
                        min: 0,
                        max: 1,
                        noData: true
                    };
                    min = 0;
                    max = 1
                }
                if (min === max)
                    if (min === 0) {
                        minMax = {
                            min: 0,
                            max: 1
                        };
                        min = 0;
                        max = 1
                    } else {
                        var globalAxisHeadroom = axisProperties.globalAxisHeadroom == null ? 1.1 : axisProperties.globalAxisHeadroom;
                        max = min * globalAxisHeadroom * .95
                    }
                if (axisProperties.bIsLog) {
                    minMax.min = min;
                    minMax.max = max
                } else {
                    var spread = max - min;
                    if (spread > 0 && (!minMaxFromZero(axisProperties) && spread < 1 || spread < .5)) {
                        var powerOfTen = -Math.floor(Math.log10(spread));
                        var mult = Math.pow(10, powerOfTen);
                        minMax.min = Math.floor(min * mult) / mult;
                        minMax.max = Math.ceil(max * mult) / mult
                    } else {
                        minMax.min = Math.floor(min);
                        minMax.max = Math.ceil(max)
                    }
                }
            }
        }
        if (!tdg.isEmpty(chart.referenceLines))
            for (i = 0; i < chart.referenceLines.length; i++) {
                var line = chart.referenceLines[i];
                if (line && typeof line.axis === "string" && typeof line.value === "number")
                    if (line.axis.toLowerCase() === "y" && axisName === "y1" || line.axis.toLowerCase() === "y2" && axisName === "y2" || line.axis.toLowerCase() === "x" && axisName === "x1") {
                        minMax.min = Math.min(minMax.min, line.value);
                        minMax.max = Math.max(minMax.max, line.value)
                    }
            }
        var stats = chart.cache.get("stats", {});
        for (var entry in stats)
            if (stats.hasOwnProperty(entry)) {
                entry = stats[entry];
                var yAxisAssignment = entry.yAxisAssignment === 2 ? "y2" : "y1";
                if (yAxisAssignment !== axisName)
                    continue;
                for (var stat in entry) {
                    var statParam = entry.hasOwnProperty(stat) && stat != "yAxisAssignment" ? stat : undefined;
                    if (statParam && tdg.isANumber(entry[statParam])) {
                        minMax.min = Math.min(minMax.min, entry[statParam]);
                        minMax.max = Math.max(minMax.max, entry[statParam])
                    }
                }
            }
        return minMax
    }
    ;
    function isPercentScale(chart, layout, axisName) {
        var chartType = chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        layout = layout || (axisName != "colorScale" ? chart.blaProperties.seriesLayout : "sideBySide");
        return chartType === "mekko" && axisName !== "colorScale" || chart.isBLA() && layout === "percent"
    }
    tdgchart.prototype.getScaleMinMax = function(axisProperties, axisName, data, layout, odata_key, chartType) {
        var chart = this;
        chartType = chartType || chart.chartType;
        axisProperties = axisProperties || {};
        var axisMinMax = {
            min: axisProperties.min,
            max: axisProperties.max
        };
        if (axisMinMax.min === "xyauto" || axisMinMax.min === "auto" || axisMinMax.min === "autoPerRow")
            axisMinMax.min = null;
        if (axisMinMax.max === "xyauto" || axisMinMax.max === "auto" || axisMinMax.max === "autoPerRow")
            axisMinMax.max = null;
        var matrixType = chartType === "matrix" ? chart.matrixProperties.chartType : null;
        if (typeof axisMinMax.min === "number" && typeof axisMinMax.max === "number")
            return {
                min: axisMinMax.min,
                max: axisMinMax.max
            };
        odata_key = odata_key || resolveObjectDataKey(chart, matrixType || chartType, axisProperties);
        var minMax;
        if (axisProperties.min === "autoGlobal" || axisProperties.max === "autoGlobal") {
            var tmp = chart.data.map(function(el) {
                return chart.getDataSetMinMax(axisProperties, axisName, [el], layout, odata_key, chartType)
            });
            minMax = tdg.minMax(tmp, "min", "max")
        } else
            minMax = chart.getDataSetMinMax(axisProperties, axisName, data, layout, odata_key, chartType);
        if (axisProperties.bIsLog)
            return minMax;
        minMax.min = typeof axisProperties.rawMin === "number" ? axisProperties.rawMin : minMax.min;
        minMax.max = typeof axisProperties.rawMax === "number" ? axisProperties.rawMax : minMax.max;
        minMax.min = typeof axisMinMax.min === "number" ? axisMinMax.min : minMax.min;
        minMax.max = typeof axisMinMax.max === "number" ? axisMinMax.max : minMax.max;
        if (chartType !== "sparkline" && odata_key !== "size" && axisProperties.mustIncludeZero !== false) {
            if (minMax.min > 0 && axisMinMax.min == null)
                minMax.min = 0;
            if (minMax.max < 0 && axisMinMax.max == null)
                minMax.max = 0
        }
        var globalAxisHeadroom = axisProperties.globalAxisHeadroom == null ? 1.1 : axisProperties.globalAxisHeadroom;
        if (minMax.min === minMax.max && odata_key !== "size") {
            minMax.min -= axisMinMax.min == null ? 1 : 0;
            minMax.max += axisMinMax.min == null ? 1 : 0
        } else if (minMax.max < minMax.min && axisMinMax.max == null)
            minMax.max = minMax.min * globalAxisHeadroom;
        if ((odata_key === "x" || odata_key === "y") && (chartType === "bubble" || chartType === "scatter" || matrixType === "bubble" || matrixType === "scatter"))
            if (axisProperties.headroom <= 1) {
                if (axisMinMax.min == null && minMax.min < 0)
                    minMax.min *= globalAxisHeadroom;
                if (axisMinMax.max == null && minMax.max > 0)
                    minMax.max *= globalAxisHeadroom
            }
        if (!isPercentScale(chart, layout, axisName))
            minMax = adjustForHeadroom(minMax, axisProperties);
        minMax = adjustNiceMinMax(minMax, axisMinMax.min, axisMinMax.max);
        if (axisName === "colorScale" && Array.isArray(chart.colorScale.colors)) {
            var cbMinMax = getColorBandsMinMax(chart);
            if (cbMinMax.min != null && axisMinMax.min == null)
                minMax.min = Math.min(minMax.min, cbMinMax.min);
            if (cbMinMax.max != null && axisMinMax.max == null)
                minMax.max = Math.max(minMax.max, cbMinMax.max)
        }
        if (chart.cache.get("axisModes")[axisName] === "count") {
            minMax.min = Math.floor(minMax.min);
            minMax.max = Math.ceil(minMax.max);
            var span = minMax.max - minMax.min;
            var div = Math.floor(span / (span % 2 ? 3 : 4));
            minMax.step = Math.max(1, div)
        }
        if (!isFinite(minMax.min) && !isFinite(minMax.max)) {
            var axisMode = chart.cache.get("axisModes", {})[axisName];
            minMax = {
                min: 0,
                max: 1
            };
            if (axisMode == "numeric")
                minMax.noData = true
        }
        return minMax
    }
    ;
    function getColorBandsMinMax(chart) {
        var min = Infinity
          , max = -Infinity;
        for (var i = 0, l = chart.colorScale.colors.length; i < l; i++) {
            var band = chart.colorScale.colors[i] || {};
            min = Math.min(min, band.start, band.stop);
            max = Math.max(max, band.start, band.stop)
        }
        return {
            min: min,
            max: max
        }
    }
    function adjustForHeadroom(minMax, axis) {
        var newMinMax = {
            min: minMax.min,
            max: minMax.max
        };
        if (minMax.noData)
            newMinMax.noData = true;
        if (!axis.bIsLog && axis.headroom && axis.headroom > 1) {
            var extraRoom = (axis.headroom - 1) * (minMax.max - minMax.min);
            if (axis.min == null && minMax.min !== 0)
                if (minMax.min > 0 && minMax.min - extraRoom < 0)
                    newMinMax.min = 0;
                else
                    newMinMax.min -= extraRoom;
            if (axis.max == null && minMax.max !== 0)
                if (minMax.max < 0 && minMax.max + extraRoom > 0)
                    newMinMax.max = 0;
                else
                    newMinMax.max += extraRoom
        }
        return newMinMax
    }
    function adjustNiceMinMax(minMax, requiredMin, requiredMax) {
        if (requiredMin != null && requiredMin !== "autoGlobal" && (requiredMax != null && requiredMin !== "autoGlobal"))
            return minMax;
        var start = minMax.min;
        var end = minMax.max;
        var reverse = end < start;
        var min = reverse ? end : start;
        var max = reverse ? start : end;
        var bottom, top;
        var span = max - min;
        if (!span || !isFinite(span))
            return {
                min: minMax.min,
                max: minMax.max
            };
        var fTestVal, magnitude = Math.log(span) / Math.LN10;
        if (Math.abs(magnitude - Math.round(magnitude)) <= 1E-7)
            fTestVal = Math.pow(10, magnitude - 2);
        else
            fTestVal = Math.pow(10, Math.floor(magnitude) - 1);
        var nScaleFactor = 1
          , nFirst2Digits = Math.round(span / fTestVal) - 1;
        if (nFirst2Digits >= 8 && nFirst2Digits <= 10)
            nScaleFactor = 2;
        else if (nFirst2Digits >= 11 && nFirst2Digits <= 13)
            nScaleFactor = 3;
        else if (nFirst2Digits >= 14 && nFirst2Digits <= 26)
            nScaleFactor = 4;
        else if (nFirst2Digits >= 27 && nFirst2Digits <= 44)
            nScaleFactor = 5;
        else if (nFirst2Digits >= 45 && nFirst2Digits <= 79)
            nScaleFactor = 10;
        else if (nFirst2Digits >= 80 && nFirst2Digits <= 99)
            nScaleFactor = 20;
        var stepSize = nScaleFactor * fTestVal;
        if (typeof requiredMin === "number")
            bottom = requiredMin;
        else {
            bottom = Math.floor(min / stepSize) * stepSize;
            while (bottom > min && Math.abs(bottom - min) > 1E-9)
                bottom -= stepSize
        }
        if (typeof requiredMax === "number")
            top = requiredMax;
        else {
            top = bottom;
            while (top < max && Math.abs(top - max) > 1E-9)
                top += stepSize
        }
        var res = {
            min: reverse ? top : bottom,
            max: reverse ? bottom : top,
            step: stepSize
        };
        if (minMax.noData)
            res.noData = true;
        return res
    }
    var noDualY = ["waterfall", "boxplot", "histogram", "pie", "gauge", "funnel", "scatter", "bubble"];
    var forceDualY = ["pareto", "polar"];
    tdgchart.prototype.needDualY2Axis = function() {
        var chart = this;
        var t = chart.chartType;
        if (chart.splitNumericAxis.splitY.enabled || chart.cache.hasKey("mekkoData") || noDualY.includes(t))
            return false;
        else if (forceDualY.includes(t))
            return true;
        for (var i = 0; i < chart.series.length; i++) {
            var axis;
            if (chart.series[i] != null)
                axis = chart.series[i].yAxisAssignment;
            if (axis != null && axis >= 2 && (chart.series[i].series < chart.seriesCount() || chart.series[i].series === "all"))
                return true
        }
        if (Array.isArray(chart.dataArrayMap) && chart.dataArrayMap.includes("y2"))
            return true;
        return false
    }
    ;
    tdgchart.prototype.getScalesList = function(panelSize, axesList) {
        var chart = this;
        var scalesList = [];
        scalesList.panelSize = panelSize;
        for (var i = 0; i < axesList.length; i++) {
            var size = axesList[i].size || panelSize;
            var scale;
            if (axesList[i].config && axesList[i].config.colMinMax && axesList[i].name.startsWith("x"))
                scale = axesList[i].config.colMinMax.map(function(config) {
                    var min = axesList[i].properties.min;
                    var max = axesList[i].properties.max;
                    if (Array.isArray(min))
                        axesList[i].properties.min = config.min;
                    if (Array.isArray(max))
                        axesList[i].properties.max = config.max;
                    var res = chart.getNumericScale(size, axesList[i], config);
                    axesList[i].properties.min = min;
                    axesList[i].properties.max = max;
                    return res
                });
            else if (axesList[i].config && axesList[i].config.rowMinMax)
                scale = axesList[i].config.rowMinMax.map(function(config) {
                    var min = axesList[i].properties.min;
                    var max = axesList[i].properties.max;
                    if (Array.isArray(min))
                        axesList[i].properties.min = config.min;
                    if (Array.isArray(max))
                        axesList[i].properties.max = config.max;
                    var res = chart.getNumericScale(size, axesList[i], config);
                    axesList[i].properties.min = min;
                    axesList[i].properties.max = max;
                    return res
                });
            else
                scale = chart.getNumericScale(size, axesList[i], axesList[i].config);
            scale.axisName = axesList[i].name;
            scalesList.push(scale)
        }
        scalesList[axesList[0].name] = scalesList[0];
        var secondAxisName = axesList[1] && axesList[1].name ? axesList[1].name : axesList[0].name.charAt(0) + "2";
        scalesList[secondAxisName] = scalesList[1];
        for (var n = 0; n < scalesList.length; n++)
            if (scalesList[n].axisName && !scalesList[scalesList[n].axisName])
                scalesList[scalesList[n].axisName] = scalesList[n];
        return scalesList
    }
    ;
    tdgchart.prototype.getNumericScale = function(panelSize, axis, axisConfig) {
        var chart = this;
        var minMax = tdg.clone(axisConfig);
        var size = axis.side === "left" || axis.side === "right" ? panelSize.height : panelSize.width;
        if (Array.isArray(minMax))
            minMax = minMax.filter(function(el) {
                return el.name === axis.name
            })[0] || null;
        if (axis.syncScale && (minMax == null || minMax.min == null || minMax.max == null)) {
            var scaleCache = chart.cache.get("axisScaleMinMax", {});
            minMax = {};
            axis.syncScale.forEach(function(axis) {
                if (scaleCache[axis.name] == undefined)
                    scaleCache[axis.name] = chart.getScaleMinMax(axis.properties, axis.name);
                var aMinMax = scaleCache[axis.name];
                if (minMax.min == undefined || aMinMax.min < minMax.min)
                    minMax.min = aMinMax.min;
                if (minMax.max == undefined || aMinMax.max > minMax.max)
                    minMax.max = aMinMax.max
            });
            if (axis.properties.absValues === true) {
                minMax.max = Math.max(minMax.max, -minMax.min);
                minMax.min = 0
            }
        }
        if (minMax == null || minMax.min == null || minMax.max == null) {
            minMax = this.getScaleMinMax(axis.properties, axis.name);
            if (axis.properties.absValues === true) {
                minMax.max = Math.max(minMax.max, -minMax.min);
                minMax.min = 0
            }
        }
        if (axis.properties.invert) {
            var t = minMax.min;
            minMax.min = minMax.max;
            minMax.max = t
        }
        var scaleType = axis.properties.bIsLog ? "log" : "linear";
        var scale = pv.Scale[scaleType](minMax.min, minMax.max).range(0, size);
        scale.stepSize = minMax.step;
        var min = axis.properties.min;
        var max = axis.properties.max;
        min = min === "xyauto" || min === "auto" || min === "autoPerRow" || min === "autoGlobal" ? null : min;
        max = max === "xyauto" || max === "auto" || max === "autoPerRow" || max === "autoGlobal" ? null : max;
        min = Array.isArray(min) ? minMax.min : min;
        max = Array.isArray(max) ? minMax.max : max;
        if (min != null || max != null) {
            var domain = scale.domain();
            domain[axis.properties.invert ? 1 : 0] = min == null || min === "min" || min == "xymin" ? domain[axis.properties.invert ? 1 : 0] : min;
            domain[axis.properties.invert ? 0 : 1] = max == null || max === "max" || max == "xymax" ? domain[axis.properties.invert ? 0 : 1] : max;
            if (axis.properties.invert)
                scale.domain(tdg.max(domain), tdg.min(domain));
            else
                scale.domain(tdg.min(domain), tdg.max(domain))
        }
        scale.baselineValue = axis.properties.baseLineValue;
        scale.type = "numeric";
        scale.grid = buildGridData(chart, scale, axis, panelSize);
        return scale
    }
    ;
    tdgchart.prototype.drawNumericBaseline = function(panel, scale, axis) {
        if (axis.config.noData)
            return;
        var chart = this;
        var lineProps = axis.properties.baseLineStyle;
        if (!lineProps || !lineProps.width)
            return;
        var scene = chart.cache.get("tdgscene");
        var isVertical = axis.side === "left" || axis.side === "right";
        var size = panel.computedSize;
        var panelSize = isVertical ? size.height : size.width;
        var y0 = scale(this.getAxisBaselineValue(scale));
        var range = scale.range();
        y0 = Math.max(y0, range[0] || 0);
        y0 = Math.min(y0, range[1] || 0);
        var axisMode = chart.cache.get("axisModes", {})[axis.name];
        if (axisMode == "ordinal") {
            var min = axis.properties.invert ? scale.domain()[1] : scale.domain()[0];
            var max = axis.properties.invert ? scale.domain()[0] : scale.domain()[1];
            if (min > 0)
                y0 = axis.properties.invert ? panelSize : 0;
            else if (max < 0)
                y0 = axis.properties.invert ? 0 : panelSize
        }
        var lineStyle = {
            className: chart.axisNameToClassName(axis.name) + "-baseLineStyle",
            lineStyle: lineProps,
            antialias: false
        };
        var pad = axis.orthPadding || [0, 0];
        if (isVertical) {
            y0 = size.height - y0;
            scene.group(panel).line(-pad[0], y0, size.width + pad[1], y0, lineStyle)
        } else
            scene.group(panel).line(y0, -pad[0], y0, size.height + pad[1], lineStyle)
    }
    ;
    function gridDataLog(scale, axisProperties, preserveScale) {
        var domain = scale.domain();
        var grid = [];
        var min = tdg.min(domain)
          , max = tdg.max(domain);
        var invert = axisProperties.invert && domain[0] > domain[1];
        if (min <= 0)
            min = 1;
        if (max <= 0)
            max = 10;
        var logmin = Math.log10(min);
        var intlogmin = Math.round(logmin);
        var minAtIntBoundary = Math.abs(logmin - intlogmin) < 1E-5 * Math.max(logmin, intlogmin);
        var logmax = Math.log10(max);
        var intlogmax = Math.round(logmax);
        var maxAtIntBoundary = Math.abs(logmax - intlogmax) < 1E-5 * Math.max(logmax, intlogmax);
        var i = minAtIntBoundary ? intlogmin : Math.floor(logmin);
        var j = maxAtIntBoundary ? intlogmax : Math.ceil(logmax);
        for (; i <= j; i++)
            grid.push(Math.pow(10, i));
        if (axisProperties.min != null && axisProperties.max != null && axisProperties.max > 0 && axisProperties.min > axisProperties.max) {
            invert = true;
            grid[0] = axisProperties.max;
            grid[grid.length - 1] = axisProperties.min
        } else {
            if (axisProperties.min != null && axisProperties.min > 0)
                grid[0] = axisProperties.min;
            if (axisProperties.max != null && axisProperties.max > 0)
                grid[grid.length - 1] = axisProperties.max
        }
        if (invert)
            grid = grid.reverse();
        if (preserveScale)
            return grid;
        var gl = grid.length - 1
          , dl = domain.length - 1;
        if (Math.abs(grid[0] - domain[0]) > 1E-5) {
            domain[0] = grid[0];
            scale.domain(domain[0], domain[dl])
        }
        if (Math.abs(grid[gl] - domain[dl]) > 1E-5) {
            domain[dl] = grid[gl];
            scale.domain(domain[0], domain[dl])
        }
        return grid
    }
    function buildGridData(chart, scale, axis, panelSize, preserveScale) {
        if (axis.properties.bIsLog)
            return gridDataLog(scale, axis.properties, preserveScale);
        var i, v, step;
        var grid = scale.ticks(true);
        var domain = scale.domain();
        if (axis.name === "y1" && chart.axisList.y2.majorGrid.lockToY1)
            chart.cache.set("y2LockValue", grid.length);
        if (axis.name === "y2" && chart.axisList.y2.majorGrid.lockToY1 && chart.cache.hasKey("y2LockValue")) {
            grid = tdg.range(domain[0], domain[1], domain[1] / (chart.cache.get("y2LockValue") - 1));
            grid.push(domain[1]);
            return grid
        }
        if (axis.name === "colorScale" && chart.cache.hasKey("colorAxis"))
            return chart.cache.get("colorAxis").tickMarks;
        grid[0] = domain[0];
        grid[grid.length - 1] = domain[1];
        if (typeof axis.properties.min === "number" && !chart.splitNumericAxis.splitY.enabled)
            grid[0] = axis.properties.min;
        if (typeof axis.properties.max === "number" && !chart.splitNumericAxis.splitY.enabled)
            grid[grid.length - 1] = axis.properties.max;
        var min = grid[0]
          , max = grid[grid.length - 1];
        var mode = axis.properties.intervalMode;
        var value = tdg.toNum(axis.properties.intervalValue);
        if (axis.properties.labels.visible && panelSize && !mode) {
            var lblDim = 0, axisSize;
            if (axis.side === "left" || axis.side === "right") {
                lblDim = tdg.measureFont(axis.properties.labels.font).height;
                axisSize = panelSize.height;
                if (lblDim * (grid.length - 1) >= axisSize) {
                    mode = "count";
                    value = Math.floor((axisSize + lblDim) / lblDim);
                    value = value > 4 ? value - 1 : value;
                    value = Math.max(2, Math.min(grid.length - 1, value))
                }
            } else if ((axis.side === "top" || axis.side === "bottom") && chart.chartType !== "gantt" && grid.length > 1) {
                var minDim, maxDim, gap = 5;
                axisSize = panelSize.width || panelSize.computedSize.width;
                var axisSettings = {
                    islog: axis.properties.bIsLog,
                    min: min,
                    max: max
                };
                for (i = 0; i < grid.length; i++) {
                    v = chart.formatNumber(grid[i], axis.properties.numberFormat, axisSettings);
                    v = chart.measureLabel(v, axis.properties.labels.font).width;
                    lblDim = Math.max(lblDim, v);
                    if (i === 0)
                        minDim = v;
                    else if (i === grid.length - 1)
                        maxDim = v
                }
                if (minDim / 2 + gap + maxDim / 2 > axisSize)
                    return [max];
                var maxLblCount = Math.floor(axisSize / (lblDim + gap));
                if (maxLblCount < 2)
                    return [min, max];
                if (maxLblCount < grid.length) {
                    var interval;
                    if (axis.properties.min == null && axis.properties.max == null) {
                        var pad = Math.floor(grid.length / (maxLblCount + 1));
                        interval = max - grid[grid.length - 2];
                        for (i = 0; i < pad; i++)
                            grid.push(grid[grid.length - 1] + interval);
                        var skipCount = Math.ceil(grid.length / (maxLblCount + 1));
                        grid = grid.filter(function(el, idx) {
                            return idx % skipCount === 0
                        })
                    } else {
                        interval = (max - min) / maxLblCount;
                        var newGrid = [];
                        for (i = 0; i < maxLblCount + 1; i++)
                            newGrid.push(min + i * interval);
                        grid = newGrid
                    }
                }
            }
        }
        if (value != null && mode != null)
            switch (mode) {
            case "interval":
                if (value > 0)
                    if (axis.properties.invert && min > max)
                        grid = tdg.range(max, min + value, value).reverse();
                    else
                        grid = tdg.range(min, max + value, value);
                break;
            case "count":
                grid = tdg.rangeCount(min, max, value);
                break;
            case "skip":
                var skip = Math.max(value + 1, 0);
                grid = grid.filter(function(el, idx) {
                    return idx % (skip + 1) === 0
                });
                if (grid[grid.length - 1] !== max)
                    grid.push(max);
                break
            }
        if (chart.chartType === "histogram")
            if (axis.properties.invert) {
                max = domain[0];
                min = domain[1];
                step = Math.ceil((max - min) / 5);
                grid = tdg.range(min, max + 1, step);
                if (grid[grid.length - 1] < max) {
                    domain[0] = grid[grid.length - 1] + step;
                    grid.push(domain[0]);
                    scale.domain(domain[0], domain[1])
                }
                grid = grid.reverse()
            } else {
                min = domain[0];
                max = domain[1];
                step = Math.ceil((max - min) / 5);
                grid = tdg.range(min, max + 1, step);
                if (grid[grid.length - 1] < max) {
                    domain[1] = grid[grid.length - 1] + step;
                    grid.push(domain[1]);
                    scale.domain(domain[0], domain[1])
                }
            }
        for (i = 0; i < grid.length; i++)
            if (Math.abs(grid[i]) < 1E-7)
                grid[i] = 0;
        if (preserveScale)
            return grid;
        if (Math.abs(grid[0] - domain[0]) > 1E-5 && grid[0] !== domain[domain.length - 1]) {
            domain[0] = grid[0];
            scale.domain(domain[0], domain[1])
        }
        var gl = grid.length - 1
          , dl = domain.length - 1;
        if (Math.abs(grid[gl] - domain[dl]) > 1E-5 && grid[gl] !== domain[0]) {
            domain[dl] = grid[gl];
            scale.domain(domain[0], domain[1])
        }
        if (Array.isArray(chart.annotations))
            for (i = 0; i < chart.annotations.length; i++) {
                domain = scale.domain();
                var annotation = chart.annotations[i];
                if (annotation && annotation.position && annotation.position.parent === "yaxis") {
                    v = annotation.position.x == null ? annotation.position.y : annotation.position.x;
                    if (tdg.isPercentString(v)) {
                        v = tdg.parsePercent(v, -5, 5);
                        if (v > 1)
                            scale.domain(domain[0], domain[1] * v);
                        else if (v < 0) {
                            v = (domain[1] - domain[0]) * v;
                            scale.domain(domain[0] + v, domain[1])
                        }
                    } else if (v > domain[1])
                        scale.domain(domain[0], v);
                    else if (v < domain[0])
                        scale.domain(v, domain[1])
                }
            }
        return grid
    }
    tdgchart.prototype.getGridLabels = function(scale, axis) {
        var chart = this;
        var grid = buildGridData(this, scale, axis, null, true);
        var config = {
            object: "axis",
            bucketID: axis.name.replace(/^([x|y])1$/ig, "$1"),
            islog: axis.properties.bIsLog,
            min: grid[0],
            max: grid[grid.length - 1],
            isPercent: isPercentScale(chart, null, axis.name)
        };
        grid = grid.map(function(el) {
            return chart.formatNumber(el, axis.properties.numberFormat, config, true)
        });
        var replaceMin = tdg.get("properties.labels.replaceMin", axis);
        var replaceMax = tdg.get("properties.labels.replaceMax", axis);
        if (!tdg.isEmpty(replaceMin))
            grid[0] = replaceMin + "";
        if (!tdg.isEmpty(replaceMax))
            grid[grid.length - 1] = replaceMax + "";
        return grid
    }
    ;
    tdgchart.prototype.getMinorGridlinesData = function(minorGrid, gridData) {
        var count = (minorGrid.count || 2) + 1;
        var internalNums = function(start, stop) {
            var gap = (stop - start) / count;
            return tdg.range(start + gap, stop, gap)
        };
        var minorData = [];
        for (var i = 0; i < gridData.length - 1; i++)
            minorData = minorData.concat(internalNums(gridData[i], gridData[i + 1]));
        return minorData
    }
    ;
    function drawNumericAxisLabels(chart, panel, scale, axis, axisName, gridData, pde) {
        var isVertical = axis.side === "left" || axis.side === "right";
        var scene = chart.cache.get("tdgscene");
        var labelsPad = axis && axis.properties && axis.properties.labels && axis.properties.labels.pad || 0;
        if (tdg.isPercentString(labelsPad))
            labelsPad = tdg.parsePercent(labelsPad, 0, 100) * tdg.measureFont(axis.properties.labels.font).height;
        var startLabelTime;
        if (chart.chartType === "gantt" && chart.ganttProperties.hasOwnProperty("haveTimeData") && chart.ganttProperties.haveTimeData) {
            var start = Date.parse(chart.ganttProperties.startTime);
            if (start != null)
                startLabelTime = start.getTime()
        }
        var axisConfig = {
            object: "axis",
            bucketID: axis.name.replace(/^([x|y])1$/ig, "$1"),
            islog: axis.properties.bIsLog,
            invert: axis.properties.invert,
            min: gridData[0],
            max: gridData[gridData.length - 1],
            isPercent: isPercentScale(chart, null, axis.name),
            isCount: chart.cache.get("axisModes")[axis.name] === "count"
        };
        var labelProps = axis.properties.labels || {};
        var labels = gridData.map(function(d, idx) {
            if (idx === 0 && !tdg.isEmpty(labelProps.replaceMin))
                return labelProps.replaceMin + "";
            else if (idx === gridData.length - 1 && !tdg.isEmpty(labelProps.replaceMax))
                return labelProps.replaceMax;
            if (startLabelTime != null)
                return (new Date(d + startLabelTime)).toString(chart.ganttProperties.labelFormat);
            var format = axis.properties.numberFormat;
            if (axisConfig.isCount && typeof format === "string" && format.includes("."))
                format = format.slice(0, format.lastIndexOf("."));
            return chart.formatNumber(d, format, axisConfig, true)
        });
        var invert = axis.properties.invert;
        if (labelProps.excludeMin && invert || labelProps.excludeMax && !invert)
            labels[labels.length - 1] = "";
        if (labelProps.excludeMin && !invert || labelProps.excludeMax && invert)
            labels[0] = "";
        if (pde.skip || pde.skipIndex)
            for (var k = 0; k < labels.length; k++)
                if (pde.skip && k % (pde.skip + 1) !== 0)
                    labels[k] = "";
                else if (pde.skipIndex && pde.skipIndex[k])
                    labels[k] = "";
        var rotation = typeof axis.properties.labels.rotation === "number" ? axis.properties.labels.rotation : pde.rotation || 0;
        var tickLength = tdg.get("majorGrid.ticks.length", axis.properties) || 0;
        if (axis.properties.majorGrid.ticks.style === "inner" || !axis.properties.majorGrid.ticks.visible)
            tickLength = 0;
        if (axis.properties.majorGrid.ticks.style === "inner")
            if (isVertical)
                if (axis.side === "left")
                    tickLength += rotation === 90 || rotation === 270 ? 2 : 3;
                else
                    tickLength += rotation === 90 || rotation === 270 ? 1 : 3;
            else if (axis.side === "bottom")
                tickLength += rotation === 90 || rotation === 270 ? 3 : 1;
            else
                tickLength += 2;
        else if (isVertical)
            tickLength += axis.side === "left" ? 2 : 3;
        else
            tickLength += axis.side === "bottom" ? 1 : 2;
        var staggerOffset = 0
          , staggerDistance = 0;
        if (!rotation && pde.offset) {
            staggerOffset = 3;
            staggerDistance = pde.offset
        }
        var commonProps = {
            font: labelProps.font,
            color: labelProps.color
        };
        var labelGroup;
        if (tdgchart.tdgscene.isTDGSceneGroup(panel))
            labelGroup = panel.group(null, null, null, null, null, null, commonProps);
        else
            labelGroup = scene.group(panel, null, null, null, null, null, null, commonProps);
        var anchorLookup = chart.getLabelAngleConfig(axis.side, rotation);
        var labelStyle = {
            align: anchorLookup.align,
            valign: anchorLookup.valign,
            translate: {
                x: axis.side === "left" ? panel.computedSize.width - tickLength - labelsPad : tickLength + labelsPad,
                y: axis.side === "top" ? panel.computedSize.height - tickLength - labelsPad : tickLength + labelsPad
            },
            rotation: anchorLookup.rotation,
            shift: -.15
        };
        var originalLabelStyle = labelStyle;
        for (var i = 0; i < labels.length; i++) {
            labelStyle.className = chart.buildClassName(axisName + "-labels", null, null, i);
            if (isVertical)
                labelStyle.translate.y = panel.computedSize.height - scale(gridData[i]);
            else
                labelStyle.translate.x = scale(gridData[i]);
            if (isVertical && staggerOffset)
                labelStyle.translate.y += i % 2 ? staggerOffset + staggerDistance : staggerOffset;
            if (axis.shiftBaselineLabel && i === 0 && gridData[0] === 0) {
                labelStyle = tdg.cloneObject(originalLabelStyle);
                if (isVertical) {
                    labelStyle.valign = "bottom";
                    labelStyle.translate.y -= 1
                } else {
                    labelStyle.align = "left";
                    labelStyle.translate.x += 2
                }
            }
            labelGroup.label(0, 0, labels[i], labelStyle);
            labelStyle = originalLabelStyle
        }
    }
    function drawNumericAxisTitle(chart, panel, axis, axisName, axisSpacing) {
        var isVerticalText = axis.side === "left" || axis.side === "right";
        var length = isVerticalText ? panel.computedSize.height : panel.computedSize.width;
        var title = tdg.clone(axis.properties.title);
        title.text = chart.applyTemplate(title.text, null, null, null);
        if (isVerticalText && chart.chartType === "matrix")
            length *= chart.splitNumericAxis.splitY.enabled ? .85 : .95;
        function drawAxisTitle(offset, anchor, length, rotation) {
            title.renderedText = chart.truncateLabel(title.text, title.font, length);
            chart.drawTitle(panel, title, axisName + "-title", 0, offset, anchor, rotation)
        }
        function drawAxisTitleOrthogonal(axis) {
            var titleSize = chart.measureLabel(title);
            var y = -titleSize.height - chart.getPadding("label", "aveVert") - 5;
            title.align = axis.side === "right" ? "right" : "left";
            chart.drawTitle(panel, title, axisName + "-title", null, y, "top", 0)
        }
        if (chart.isOrthogonalAxis(axis))
            drawAxisTitleOrthogonal(axis);
        else if (axis.side === "left") {
            var angle = axis.properties.title.position !== "flip" ? 90 : -90;
            var anchor = axis.properties.title.position !== "flip" ? "left" : "right";
            drawAxisTitle(axisSpacing.titleHeight / 2, anchor, length, angle)
        } else if (axis.side === "right") {
            var angle = axis.properties.title.position !== "flip" ? -90 : 90;
            var anchor = axis.properties.title.position !== "flip" ? "right" : "left";
            drawAxisTitle(axisSpacing.titleHeight / 2, anchor, length, angle)
        } else if (axis.side === "top")
            drawAxisTitle(0, "top", length);
        else
            drawAxisTitle(0, "bottom", length)
    }
    tdgchart.prototype.drawNumericAxis = function(chartPanels, scale, axis, axisSpacing) {
        var name, axisPanel, chart = this;
        if (Array.isArray(scale))
            for (var i = 0; i < scale.length; i++) {
                name = axis[i].name;
                axisPanel = chartPanels.axis[name] || chartPanels.yAxis;
                drawNumericAxisSingle(chart, chartPanels.chartSize, axisPanel, scale[i], axis[i], axis[i].layout)
            }
        else {
            name = axis.name;
            axisPanel = chartPanels.axis[name] || chartPanels.yAxis;
            var spacing = axisSpacing && (axisSpacing[name] || axisSpacing);
            drawNumericAxisSingle(chart, chartPanels.chartSize, axisPanel, scale, axis, spacing)
        }
    }
    ;
    tdgchart.prototype.shiftPanelForDepth = function(axis, panel) {
        var chart = this;
        if (panel && (axis.side === "right" || axis.side === "top")) {
            var depth = axis.name === "colorScale" ? 0 : chart.computeddepth25d();
            if (depth) {
                var npanel = panel.add(pv.Panel).left(depth).top(-depth);
                npanel.computedSize = panel.computedSize;
                return npanel
            }
        }
        return panel
    }
    ;
    function drawNumericAxisSingle(chart, chartSize, axisPanels, scale, axis, axisSpacing) {
        if (axis.config && axis.config.noData)
            return;
        var depth = chart.depth25d() && axis.name !== "colorScale";
        var gridlinesPanel = depth || !axis.properties.majorGrid.aboveRisers ? axisPanels.bg : axisPanels.fg;
        var axisTicksPanel = chart.shiftPanelForDepth(axis, axisPanels.axis);
        var axisTitlePanel = chart.shiftPanelForDepth(axis, axisPanels.title);
        var yGrid = axis.properties.majorGrid;
        var gridData = scale.grid;
        var pde = axisSpacing && axisSpacing.pde || {};
        var axisClassName = chart.axisNameToClassName(axis.name);
        if (gridlinesPanel)
            chart.drawGridlines(gridlinesPanel, scale, axis.side, gridData, yGrid, axisClassName + "-majorGrid");
        var minorData, minorGrid = axis.properties.minorGrid || {};
        if (minorGrid.visible && minorGrid.count !== 0 || minorGrid.ticks.visible)
            minorData = chart.getMinorGridlinesData(minorGrid, gridData);
        if (minorData && gridlinesPanel)
            chart.drawGridlines(gridlinesPanel, scale, axis.side, minorData, minorGrid, axisClassName + "-minorGrid");
        if (axisTicksPanel) {
            var tickProps = yGrid.ticks || {};
            if (tickProps.visible && tickProps.length)
                chart.drawTicks(axisTicksPanel, scale, axis.side, gridData, tickProps, axisClassName + "-majorGrid-ticks");
            if (minorData && minorGrid.ticks.visible && minorGrid.ticks.length)
                chart.drawTicks(axisTicksPanel, scale, axis.side, minorData, minorGrid.ticks, axisClassName + "-minorGrid-ticks");
            if (axis.properties.labels.visible)
                drawNumericAxisLabels(chart, axisTicksPanel, scale, axis, axisClassName, gridData, pde)
        }
        if (axisTitlePanel && axis.properties.title.visible && axisSpacing)
            drawNumericAxisTitle(chart, axisTitlePanel, axis, axisClassName, axisSpacing);
        if (axis.properties.bodyLineStyle.color !== "transparent" && axisTicksPanel)
            chart.drawAxisBodyLine(axisTicksPanel, axisClassName, axis.side, axis.properties.bodyLineStyle, axis.padding)
    }
    tdgchart.prototype.drawNumericAxis3d = function(panel, scale, axis) {
        var chart = this;
        var ph = panel.computedSize.height;
        var yGrid = axis.properties.majorGrid;
        var tickLength = yGrid.ticks.length || 0;
        var onRight = axis.side.indexOf("right") !== -1;
        var axisName = "yaxis";
        function gridData() {
            var grid = scale.ticks(true);
            if (axis.properties.min != null && axis.properties.min < grid[0])
                grid.unshift(axis.properties.min);
            if (axis.properties.max != null && axis.properties.max > grid[grid.length - 1])
                grid.push(axis.properties.max);
            return grid
        }
        if (yGrid.visible)
            panel.add(pv.Rule3d).className(function() {
                return chart.buildClassName(axisName + "-majorGrid", null, null, this.index)
            }).data(gridData).strokeStyle(yGrid.lineStyle.color).lineWidth(yGrid.lineStyle.width).bottom(function(d) {
                return (d - scale.domain()[0]) * ph / (scale.domain()[1] - scale.domain()[0])
            }).left(0).front(0).back(0);
        var yGridLines = panel.add(pv.Rule3d).className(function() {
            return chart.buildClassName(axisName + "-majorGrid", null, null, this.index)
        }).data(gridData).strokeStyle(yGrid.visible ? yGrid.lineStyle.color : "transparent").lineWidth(yGrid.lineStyle.width).dashStyle(yGrid.lineStyle.dash);
        yGridLines.bottom(function(d) {
            return (d - scale.domain()[0]) * ph / (scale.domain()[1] - scale.domain()[0])
        }).back(0);
        var yTicks = yGridLines;
        var front, back, left, right;
        if (onRight) {
            front = null;
            back = 0;
            left = null;
            right = 0
        } else {
            front = 0;
            back = null;
            left = 0;
            right = null
        }
        if (yGrid.ticks.visible) {
            yTicks = yGridLines.add(pv.Rule3d).className(function() {
                return chart.buildClassName(axisName + "-majorGrid-ticks", null, null, this.index)
            }).strokeStyle(yGrid.ticks.lineStyle.color).lineWidth(yGrid.ticks.lineStyle.width);
            if (onRight)
                yTicks.front(front).back(back).left(left).depth(0).right(right).width(tickLength);
            else
                yTicks.front(front).back(back).left(left).depth(tickLength).right(right).width(0)
        }
        if (axis.properties.labels.visible) {
            var minMax = {
                min: scale.range()[0],
                max: scale.range()[1]
            };
            yTicks.add(pv.Label3d).className(function() {
                return chart.buildClassName(axisName + "-labels", null, null, this.index)
            }).textAlign(onRight ? "left" : "right").textBaseline("middle").text(function(d) {
                return chart.formatNumber(d, axis.properties.numberFormat, minMax)
            }).font(axis.properties.labels.font).textStyle(axis.properties.labels.color).front(front).back(back).left(left).right(right).depth(0)
        }
        if (axis.properties.bodyLineStyle.color !== "transparent")
            chart.drawAxisBodyLine3d(panel, axisName, axis.side, axis.properties.bodyLineStyle)
    }
    ;
    tdgchart.prototype.getSplitAxesMinMaxList = function(dataByAxis) {
        var chart = this;
        var minMaxList = [];
        var nullMinMax = {
            min: Infinity,
            max: -Infinity
        };
        for (var axisName in dataByAxis)
            if (dataByAxis.hasOwnProperty(axisName)) {
                var tmp = [], minMax;
                for (var chartType in dataByAxis[axisName])
                    if (dataByAxis[axisName].hasOwnProperty(chartType)) {
                        if (dataByAxis[axisName][chartType].length)
                            minMax = chart.getScaleMinMax(chart.axisList[axisName], axisName, dataByAxis[axisName][chartType], null, axisName.charAt(0));
                        else
                            minMax = nullMinMax;
                        tmp.push(minMax)
                    }
                minMax = tdg.minMax(tmp, "min", "max");
                var allNoData = tmp.every(function(el) {
                    return el.noData || !isFinite(el.min) && !isFinite(el.max)
                });
                if (allNoData)
                    minMax.noData = true;
                minMax.name = axisName;
                minMaxList.push(minMax)
            }
        return minMaxList
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.needXOrdinalAxis = function() {
        var ordinalList = ["bar", "line", "area", "waterfall", "pareto", "stock"];
        var chartType = this.chartType;
        if (chartType == "matrix")
            chartType = this.matrixProperties.chartType;
        return ordinalList.indexOf(chartType) >= 0
    }
    ;
    tdgchart.prototype.isXTimeAxis = function() {
        return this.needXOrdinalAxis() && this.xaxis.timeAxis.enabled
    }
    ;
    var d3Time = tdgchart.d3_time;
    var WANT_INDEX0_YEAR = false;
    var timeIntervalFormats = [{
        interval: {
            interval: "year",
            duration: d3Time.time.year.duration
        },
        detailed: function() {
            return true
        },
        range: [],
        format: function() {
            return d3Time.timeFormat("%Y")
        }
    }, {
        interval: {
            interval: "quarter",
            duration: d3Time.time.quarter.duration - 2 * d3Time.time.day.duration
        },
        detailed: function(tick, index) {
            var m = tick.getMonth() + 1;
            return WANT_INDEX0_YEAR && index === 0 || m === 1
        },
        format: function(detailed) {
            return function(tick, index, ticks) {
                var abbreviate = "%b";
                var month = d3Time.timeFormat(abbreviate)(tick);
                var label = month;
                if (detailed[index])
                    label += "\n" + tick.getFullYear();
                return label
            }
        }
    }, {
        interval: {
            interval: "quarter-Q",
            duration: d3Time.time.quarter.duration - 2 * d3Time.time.day.duration
        },
        detailed: function(tick, index) {
            var q = tick.getQuarter();
            return WANT_INDEX0_YEAR && index === 0 || q === 1
        },
        format: function(detailed) {
            return function(tick, index) {
                var q = tick.getQuarter();
                var label = "Q" + q;
                if (detailed[index])
                    label += "\n" + tick.getFullYear();
                return label
            }
        }
    }, {
        interval: {
            interval: "month",
            duration: d3Time.time.month.duration
        },
        detailed: function(tick, index) {
            var m = tick.getMonth() + 1;
            return WANT_INDEX0_YEAR && index === 0 || m === 1
        },
        format: function(detailed) {
            return function(tick, index, ticks) {
                var abbreviate = ticks.length > 12 ? "%b" : "%B";
                var month = d3Time.timeFormat(abbreviate)(tick);
                if (detailed[index])
                    return month + "\n" + tick.getFullYear();
                return month
            }
        }
    }, {
        interval: {
            interval: "week",
            duration: d3Time.time.week.duration
        },
        detailed: function(tick, index) {
            return WANT_INDEX0_YEAR && index === 0 || tick.getMonth() === 0 && tick.getDate() <= 7
        },
        format: function(detailed) {
            return function(tick, index) {
                var label = d3Time.timeFormat("%b %d")(tick);
                if (detailed[index])
                    label += "\n" + tick.getFullYear();
                return label
            }
        }
    }, {
        interval: {
            interval: "day",
            duration: d3Time.time.day.duration
        },
        detailed: function(tick, index, ticks) {
            var prevTick = ticks[index - 1];
            var includeYear = WANT_INDEX0_YEAR && index === 0 || index > 0 && tick.getFullYear() !== prevTick.getFullYear();
            var includeMonth = includeYear || index > 0 && tick.getMonth() !== prevTick.getMonth();
            if (includeYear)
                return 1;
            if (includeMonth)
                return 2;
            return 0
        },
        format: function(detailed) {
            return function(tick, index) {
                var label = d3Time.timeFormat(detailed[index] ? "%b %d" : "%d")(tick);
                if (detailed[index] == 1)
                    label += "\n" + tick.getFullYear();
                return label
            }
        }
    }, {
        interval: {
            interval: "hour",
            duration: d3Time.time.hour.duration
        },
        detailed: function(tick, index, ticks) {
            var prevTick = ticks[index - 1];
            var spansDay = ticks[ticks.length - 1].getDate() !== ticks[0].getDate();
            var seconds = tick.getHours() * 3600 + tick.getMinutes() * 60 + tick.getSeconds();
            var includeDay = WANT_INDEX0_YEAR && index === 0 && spansDay || index === 0 && seconds == 0 || prevTick && tick.getDate() !== prevTick.getDate();
            return includeDay
        },
        format: function(detailed) {
            return function(tick, index) {
                var label = d3Time.timeFormat("%-H:%M")(tick);
                if (detailed[index])
                    label += "\n" + d3Time.timeFormat("%b %d")(tick);
                return label
            }
        }
    }, {
        interval: {
            interval: "minute",
            duration: d3Time.time.minute.duration
        },
        detailed: function() {
            return true
        },
        format: function() {
            return d3Time.timeFormat("%-H:%M")
        }
    }, {
        interval: {
            interval: "second",
            duration: d3Time.time.second.duration
        },
        detailed: function() {
            return true
        },
        format: function() {
            return d3Time.timeFormat("%-H:%M:%S")
        }
    }, {
        interval: {
            interval: "second",
            duration: d3Time.time.second.duration
        },
        detailed: function() {
            return true
        },
        format: function() {
            return d3Time.timeFormat("%-H:%M:%S")
        }
    }];
    function timeLabelFormat(ticks) {
        var duration = ticks[1] - ticks[0];
        for (var i = 0; i < timeIntervalFormats.length; i++) {
            var format = timeIntervalFormats[i];
            if (duration >= format.interval.duration) {
                var detailed = ticks.map(format.detailed);
                var noneIsDetailed = detailed.reduce(function(a, v) {
                    return a + v
                }, 0) == 0;
                if (noneIsDetailed)
                    detailed[0] = 1;
                return ticks.map(format.format(detailed, noneIsDetailed))
            }
        }
        return ticks.map(d3Time.timeFormat("%-H:%M:%S:%L"))
    }
    tdgchart.prototype.initTimeScale = function() {
        var chart = this;
        if (!chart.xaxis || !chart.xaxis.timeAxis || !chart.xaxis.timeAxis.enabled)
            return;
        var timeAxis = chart.xaxis.timeAxis;
        var oldAxis = timeAxis.startTime != null || timeAxis.stopTime != null || timeAxis.interval != null;
        if (oldAxis)
            return;
        var start = Date.parse(chart.xaxis.timeAxis.startTime);
        var stop = Date.parse(chart.xaxis.timeAxis.stopTime);
        var tickCount = 5;
        var scrollParams = chart.getScrollParams(chart, chart);
        if (scrollParams && scrollParams.enabled && scrollParams.virt && scrollParams.virt.width > chart.width)
            tickCount = Math.floor(scrollParams.virt.width / chart.width * 5);
        var groupLabels, times;
        var domain, factors, compressedLabels;
        var compressedGroups = !chart.showNullGroups && chart.cache.get("compressedGroups");
        if (start == null || stop == null || !chart.showNullGroups) {
            groupLabels = chart.getGroupLabels(null, null, compressedGroups ? 0 : undefined);
            times = groupLabels.map(function(el) {
                return tdgchart.d3_time.timeCanonicalParse(el)
            })
        }
        if (start == null || stop == null) {
            var minMax = tdg.minMax(times);
            start = start || minMax.min;
            stop = stop || minMax.max
        }
        if (!compressedGroups)
            domain = [start, stop];
        else {
            groupLabels = groupLabels || chart.getGroupLabels(null, null, 0);
            compressedLabels = chart.getGroupLabels(null, null, 0);
            var idx = [];
            var i = 0;
            var fromGroup = 0;
            while (i < compressedGroups.length) {
                if (fromGroup <= compressedGroups[i] - 1) {
                    idx.push(fromGroup);
                    idx.push(compressedGroups[i] - 1)
                }
                fromGroup = compressedGroups[i] + 1;
                i++
            }
            if (fromGroup < times.length - 1) {
                idx.push(fromGroup);
                idx.push(times.length - 1)
            }
            domain = idx.map(function(i) {
                return times[i]
            });
            var lengths = []
              , totalTime = 0
              , points = 0;
            for (var i = 0; i < domain.length; i += 2) {
                var length = domain[i + 1] - domain[i];
                lengths.push(length);
                totalTime += length;
                points += idx[i + 1] - idx[i]
            }
            var gapsCount = domain.length / 2 - 1;
            totalTime *= (points + gapsCount) / points;
            var sum = 0;
            factors = [0];
            for (var i = 0; i < lengths.length; i++) {
                sum += lengths[i] / totalTime;
                factors.push(sum);
                if (i < lengths.length - 1) {
                    sum += 1 / (points + gapsCount);
                    factors.push(sum)
                }
            }
        }
        var scale = tdgchart.d3_time.scaleTime().domain(domain);
        var ticks = scale.ticks(tickCount);
        var labels;
        if (tdg.isEmpty(timeAxis.labelFormat))
            labels = timeLabelFormat(ticks);
        else
            labels = ticks.map(function(tick) {
                return tick.toString(timeAxis.labelFormat)
            });
        if (labels == null) {
            var format = scale.tickFormat(ticks.length);
            labels = ticks.map(format)
        }
        if (chart.blaProperties.extendToFrameEdge) {
            while (ticks.length && ticks[0] < start) {
                labels.shift();
                ticks.shift()
            }
            while (ticks.length && ticks[ticks.length - 1] > stop) {
                labels.pop();
                ticks.pop()
            }
        } else if (!compressedGroups)
            scale.domain([ticks[0], ticks[ticks.length - 1]]).nice(tickCount);
        var timeInfo = {
            start: start,
            stop: stop,
            scale: scale,
            ticks: ticks,
            labels: labels,
            factors: factors,
            compressedLabels: compressedLabels
        };
        chart.cache.set("xaxis_time_scale", timeInfo)
    }
    ;
    tdgchart.prototype.getOrdinalScale = function(riserpanelSize, inset, orientation, invert, useSeries, groupCount, labelList) {
        var chart = this;
        var gc = groupCount || (useSeries ? chart.seriesCount() : chart.visibleGroupCount());
        var isVertical = orientation == null ? chart.blaProperties.orientation === "horizontal" : orientation !== "horizontal";
        var axisSize = isVertical ? riserpanelSize.height : riserpanelSize.width;
        var x;
        inset = inset == null ? 1 : inset;
        if (chart.cache.hasKey("mekkoData")) {
            var mekkoData = chart.cache.get("mekkoData");
            x = pv.Scale.ordinal(tdg.range(gc)).splitProportional(0, axisSize, mekkoData.mekkoGroupSums, mekkoData.mekkoTotal)
        } else if (chart.cache.hasKey("xaxis_time_scale")) {
            var timeInfo = chart.cache.get("xaxis_time_scale");
            if (timeInfo.factors)
                timeInfo.scale.range(timeInfo.factors.map(function(f) {
                    return f * axisSize
                }));
            else
                timeInfo.scale.range([0, axisSize]);
            x = function(v) {
                if (v instanceof Date)
                    return timeInfo.scale(v);
                else if (typeof v === "number")
                    return timeInfo.scale(timeInfo.ticks[v]);
                return 0
            }
            ;
            var range = timeInfo.ticks.map(x);
            range.band = 0;
            x.range = function() {
                return range
            }
        } else {
            var domain = invert ? tdg.range(gc).reverse() : tdg.range(gc);
            x = pv.Scale.ordinal(domain).splitBanded(0, axisSize, inset)
        }
        x.computedSize = {
            width: riserpanelSize.width,
            height: riserpanelSize.height
        };
        var labels = labelList;
        if (labelList == null)
            labels = useSeries ? chart.getSeriesLabels().map(function(el) {
                return el.toString()
            }) : chart.getGroupLabels();
        x.ordPos = function() {
            return function(lbl) {
                var idx = labels.indexOf(lbl.toString());
                return idx >= 0 ? this(idx) : undefined
            }
        }();
        x.ordGroup = function() {
            return function(lbl) {
                var idx = labels.indexOf(lbl.toString());
                return idx >= 0 ? idx : undefined
            }
        }();
        x.seriesCount = chart.seriesCount();
        x.groupCount = chart.groupCount();
        x.type = "ordinal";
        return x
    }
    ;
    function iterateData(chart, data, fn) {
        if (chart.chartType === "matrix")
            for (var r = 0; r < data.length; r++)
                for (var c = 0; c < data[r].length; c++)
                    data[r][c] = fn(data[r][c]);
        else
            data = fn(data);
        return data
    }
    function getSortOrder(array, order) {
        return array.map(function(el, idx) {
            return {
                v: el,
                i: idx
            }
        }).sort(function(a, b) {
            if (order === "ascending")
                return a.v < b.v ? -1 : a.v > b.v ? 1 : 0;
            return a.v < b.v ? 1 : a.v > b.v ? -1 : 0
        })
    }
    function sortBySortOrder(array, sortOrder) {
        return sortOrder.map(function(el) {
            return array[el.i]
        })
    }
    tdgchart.prototype.sortOrdinalAxes = function() {
        var chart = this;
        var xSort = chart.axisList.x1.sort || {};
        var ySort = chart.axisList.y1.sort || {};
        if (chart.isBLA())
            if (typeof xSort.by === "string" && !xSort.by.startsWith("y") && !xSort.by.startsWith("matrix"))
                sortOneOrdinalAxis(chart, xSort, "series", xSort.by);
            else
                sortOneOrdinalAxis(chart, xSort, "groups", "value");
        else if (chart.chartType === "heatmap" || chart.chartType === "matrix" && chart.matrixProperties.chartType === "heatmap") {
            sortOneOrdinalAxis(chart, xSort, "groups", "color");
            sortOneOrdinalAxis(chart, chart.zaxis.sort || {}, "series", "color")
        } else if (chart.chartType === "bubble" || chart.chartType === "scatter") {
            var axisModes = chart.cache.get("axisModes", {});
            if (axisModes.x1 === "ordinal" && axisModes.y1 === "ordinal") {
                if (xSort.by != null)
                    chart.cache.setProperty("axisList.x1.sort.by", null);
                if (ySort.by != null)
                    chart.cache.setProperty("axisList.y1.sort.by", null)
            }
            if (axisModes.x1 === "ordinal")
                sortOneOrdinalAxis(chart, xSort, "groups", "y");
            if (axisModes.y1 === "ordinal")
                sortOneOrdinalAxis(chart, ySort, "groups", "x")
        }
    }
    ;
    function sortOneOrdinalAxis(chart, sort, sortDimension, odataKey) {
        if (tdg.isEmpty(sort))
            return;
        else if (typeof sort === "string")
            sort = {
                order: sort
            };
        sort.order = (sort.order || "ascending").toLowerCase();
        if (chart.chartType === "matrix" && typeof sort.by === "string" && (sort.by.startsWith("y") || sort.by.startsWith("matrix"))) {
            sortMatrixByValue(chart, sort, sortDimension, odataKey);
            return
        }
        var i, sortedLabels, sortOrder;
        var axisIdx = odataKey === "x" ? 1 : 0;
        var sortBySeries = sortDimension === "series";
        var labels = sortBySeries ? chart.getSeriesLabels() : chart.getGroupLabels(null, true, 0, axisIdx);
        if (sort.by == null) {
            sortOrder = getSortOrder(labels, sort.order);
            sortedLabels = tdg.map(sortOrder, "v")
        } else if (sort.by.startsWith("y") || sort.by === odataKey) {
            var dataSums = [];
            var dataCount = sortBySeries ? chart.seriesCount() : chart.groupCount();
            var yaxisID = sort.by.match(/y([0-9]*)/);
            if (yaxisID && yaxisID[1])
                yaxisID = parseInt(yaxisID[1], 10);
            else
                yaxisID = null;
            for (i = 0; i < dataCount; i++) {
                var v = sortBySeries ? tdg.sum(chart.data[i], odataKey) : chart.getGroupSum(i, 0, null, odataKey, yaxisID);
                dataSums.push(v)
            }
            sortOrder = getSortOrder(dataSums, sort.order);
            sortedLabels = sortBySortOrder(labels, sortOrder)
        }
        var sortOrderFn = tdg.partial(sortBySortOrder, [null, sortOrder]);
        if (sortBySeries) {
            chart.series.forEach(function(el) {
                el.originalLabel = el.label
            });
            chart.setSeriesLabels(sortedLabels, true);
            chart._internalData = iterateData(chart, chart._internalData, sortOrderFn)
        } else {
            if (chart.groupLabels[axisIdx] && Array.isArray(chart.groupLabels[axisIdx]))
                chart.groupLabels[axisIdx] = sortedLabels;
            else
                chart.groupLabels = sortedLabels;
            chart._internalData = iterateData(chart, chart._internalData, function(d) {
                return d.map(sortOrderFn)
            });
            if (chart.cache.hasKey("compressedGroups")) {
                var compGroups = chart.cache.get("compressedGroups");
                for (i = 0; i < compGroups.length; i++)
                    chart.groupLabels.splice(compGroups[i], 0, "")
            }
        }
    }
    function sortMatrixByValue(chart, sort, sortDimension, odataKey) {
        var data = chart._internalData;
        var sortBySeries = sortDimension === "series";
        var dataCount = sortBySeries ? chart.seriesCount() : chart.groupCount();
        var rowSortOrderList = [];
        var r, c, g;
        var sortBy = !sort.by || typeof sort.by !== "string" ? "y" : sort.by.toLowerCase();
        var sortByCol = true;
        if (chart.isBLA() && chart.blaProperties.orientation === "horizontal")
            sortByCol = false;
        else if (chart.matrixProperties.chartType === "heatmap" && sortBySeries)
            sortByCol = false;
        if (sortByCol)
            data = tdg.transpose(data);
        var yaxisID, startSortCol = 0, stopSortCol = data[0].length;
        if (sortBy.startsWith("matrix")) {
            var matrixDim = sortBy.match(/matrix([0-9]*)/);
            if (matrixDim && matrixDim[1])
                matrixDim = parseInt(matrixDim[1], 10);
            if (matrixDim != null) {
                startSortCol = matrixDim;
                stopSortCol = matrixDim + 1
            }
        }
        if (chart.isBLA() && chart.splitNumericAxis.splitY.enabled) {
            yaxisID = sortBy.match(/y([0-9]*)/);
            if (yaxisID && yaxisID[1])
                yaxisID = parseInt(yaxisID[1], 10)
        }
        for (r = 0; r < data.length; r++) {
            var rowSums = tdg.repeat(0, dataCount);
            for (c = startSortCol; c < stopSortCol; c++) {
                var d = data[r][c];
                if (chart.matrixProperties.chartType === "heatmap" && sortBySeries)
                    d = tdg.transpose(d);
                for (g = 0; g < dataCount; g++)
                    rowSums[g] += chart.getGroupSum(g, 0, d, odataKey, yaxisID)
            }
            var rowSortOrder = getSortOrder(rowSums, sort.order);
            rowSortOrderList.push(rowSortOrder);
            for (c = 0; c < data[r].length; c++)
                if (chart.matrixProperties.chartType === "heatmap" && sortBySeries)
                    data[r][c] = sortBySortOrder(data[r][c], rowSortOrder);
                else if (Array.isArray(data[r][c]))
                    for (g = 0; g < data[r][c].length; g++)
                        data[r][c][g] = sortBySortOrder(data[r][c][g], rowSortOrder)
        }
        if (sortByCol)
            data = tdg.transpose(data);
        rowSortOrderList.sortByCol = sortByCol;
        if (sortBySeries)
            chart.cache.set("rowZOrdAxisSortOrderList", rowSortOrderList);
        else
            chart.cache.set("rowOrdAxisSortOrderList", rowSortOrderList)
    }
    tdgchart.prototype.getSeriesOrdinalScale = function(panel, inset) {
        var range = tdg.range((this._internalData || this.data).length);
        return pv.Scale.ordinal(range).splitBanded(0, panel.computedSize.depth, inset)
    }
    ;
    tdgchart.prototype.drawOrdinalAxis = function(chartPanels, x, axis, spacing, drawOnGroups) {
        var chart = this;
        var axisPanels = chartPanels.axis[axis.name] || chartPanels.xAxis;
        var depth = chart.depth25d();
        var gPanels = chartPanels.matrixCell || axisPanels;
        var gridlinesPanel = !depth ? axis.properties.majorGrid.aboveRisers ? gPanels.fg : gPanels.bg : chart.shiftPanelForDepth(axis, gPanels.bg);
        var mekkoData = chart.cache.get("mekkoData");
        var isVertical = axis.side === "left" || axis.side === "right";
        var centerLabels = drawOnGroups || axis.properties.centerGroupLabels;
        var xGrid = axis.properties.majorGrid;
        var xrange = x.range();
        var band = xrange.band / 2;
        var gapWidth = xrange[0] / 2;
        var tickLength = xGrid.ticks.visible ? xGrid.ticks.length || 0 : 0;
        var axisClassName = chart.axisNameToClassName(axis.name);
        var labels;
        if (axis.labels)
            labels = axis.labels;
        else if (axis.name === "x1") {
            var groupCount = chart.visibleGroupCount() + (centerLabels ? 0 : 1);
            labels = chart.getGroupLabels(groupCount, null, chartPanels.compressedGroupsAxisNum || 0)
        } else
            labels = chart.getSeriesLabels(chart.seriesCount());
        var nestedLabels = labels.nestedOrdAxisDepthList != null && axis.properties.labels.nestingConcatSymbol == null;
        x.labelOffset = centerLabels ? band : -gapWidth;
        x.lastTickPos = xrange[xrange.length - 1] + xrange.band - x.labelOffset;
        var flatX = tdg.cloneObject(xrange);
        var flatXLabels = flatX;
        if (mekkoData) {
            var tmpList = xrange.concat(isVertical ? spacing.h : spacing.w);
            flatXLabels = tmpList.map(function(el, idx) {
                return (el + tmpList[idx + 1]) / 2
            });
            flatXLabels.pop()
        } else if (!drawOnGroups && !centerLabels) {
            flatX.push(xrange[0] + xrange[xrange.length - 1] + xrange.band);
            flatXLabels = flatX
        }
        var ordPos = function(idx) {
            if (drawOnGroups)
                return flatX[idx] + band;
            else if (centerLabels)
                return flatX[idx + 1] - gapWidth;
            else
                return flatX[idx] - gapWidth
        };
        var lineCount = drawOnGroups || !centerLabels ? flatX.length : flatX.length - 1;
        var gridData = tdg.range(lineCount);
        if (xGrid.visible && gridlinesPanel && lineCount)
            chart.drawGridlines(gridlinesPanel, ordPos, axis.side, gridData, axis.properties.majorGrid, axisClassName + "-majorGrid");
        if (axisPanels.axis) {
            var tickProps = xGrid.ticks || {};
            if (tickProps.visible && tickProps.length && lineCount)
                chart.drawTicks(axisPanels.axis, ordPos, axis.side, gridData, tickProps, axisClassName + "-majorGrid-ticks");
            if (axis.properties.labels.visible)
                if (nestedLabels)
                    drawNestedLabels(chart, axisPanels.axis, axis, x, axis.layout, labels, centerLabels, tickLength);
                else
                    drawOrdinalLabels(chart, axisPanels.axis, axis, x, flatXLabels, spacing, labels, centerLabels, tickLength)
        }
        if (axis.properties.title.visible && axisPanels.title)
            drawOrdinalTitle(chart, axisPanels.title, axis);
        if (axis.properties.bodyLineStyle.color !== "transparent" && axisPanels.axis)
            chart.drawAxisBodyLine(axisPanels.axis, "xaxisOrdinal", axis.side, axis.properties.bodyLineStyle)
    }
    ;
    function drawOrdinalLabels(chart, panel, axis, scale, flatX, spacing, labels, centerLabels, tickLength) {
        var isVertical = axis.side === "left" || axis.side === "right";
        var mekkoData = chart.cache.get("mekkoData");
        var pde = (axis.layout || {}).pde || {};
        var xrange = scale.range();
        var labelInset = centerLabels ? xrange.band / 2 : -(xrange[0] / 2);
        var scene = chart.cache.get("tdgscene");
        var axisClassName = chart.axisNameToClassName(axis.name);
        var i;
        var labelsPad = axis && axis.properties && axis.properties.labels && axis.properties.labels.pad || 0;
        if (tdg.isPercentString(labelsPad))
            labelsPad = tdg.parsePercent(labelsPad, 0, 100) * tdg.measureFont(axis.properties.labels.font).height;
        var truncationSize, titleHeight;
        if (chart.chartType === "matrix")
            if (isVertical) {
                titleHeight = axis.properties.title.visible ? tdg.measureFont(axis.properties.title.font).height : 0;
                truncationSize = Math.abs(spacing.titleOffset.left) - titleHeight
            } else if (pde.rotation === 90 || pde.rotation === 270) {
                truncationSize = spacing.axisSize.bottom - tickLength - labelsPad;
                if (pde.labelLength != null)
                    truncationSize = Math.min(truncationSize, pde.labelLength)
            } else
                truncationSize = panel.computedSize.width / xrange.length - 5;
        else if (mekkoData)
            if (pde.rotation == null || pde.rotation === 0 || pde.rotation === 180) {
                if (mekkoData)
                    labels = labels.map(function(el, idx) {
                        truncationSize = scale.computedSize.width * mekkoData.mekkoGroupSums[idx] / mekkoData.mekkoTotal - 5;
                        return chart.truncateLabel(el, axis.properties.labels.font, truncationSize)
                    })
            } else if (pde.rotation === 90) {
                var lblHeight = tdg.measureFont(axis.properties.labels.font).height * .8;
                for (i = 0; i < xrange.length - 1; i++)
                    if (xrange[i + 1] - xrange[i] < lblHeight)
                        break;
                if (i < labels.length - 1)
                    labels = labels.slice(0, i)
            }
        var labelProps = axis.properties.labels || {};
        var invert = axis.properties.invert;
        if (axis.properties.invert)
            labels = tdg.cloneObject(labels).reverse();
        if (labelProps.excludeMin && invert || labelProps.excludeMax && !invert)
            labels[labels.length - 1] = "";
        if (labelProps.excludeMin && !invert || labelProps.excludeMax && invert)
            labels[0] = "";
        if (pde.truncate)
            truncationSize = Math.min(truncationSize, pde.truncate) || pde.truncate;
        if (truncationSize && axis.properties.labelLayout && axis.properties.labelLayout.truncate !== false && !mekkoData)
            labels = labels.map(function(el) {
                return chart.truncateLabel(el, labelProps.font, truncationSize)
            });
        var rotation = 0;
        if (typeof pde.rotation === "number" || typeof labelProps.rotation === "number")
            rotation = typeof pde.rotation === "number" ? pde.rotation : labelProps.rotation;
        if (axis.properties.majorGrid.ticks.style === "inner")
            tickLength = 2;
        if (isVertical)
            if (axis.side === "left")
                tickLength += rotation === 90 || rotation === 270 ? 2 : 3;
            else
                tickLength += rotation === 90 || rotation === 270 ? 1 : 3;
        else if (axis.side === "bottom")
            tickLength += rotation === 90 || rotation === 270 ? 3 : 1;
        else
            tickLength += 2;
        var fontOverride = chart.cache.get("xAxisLabelsFont");
        var colorOverride = chart.cache.get("xAxisLabelsColor");
        var commonProps = {
            font: fontOverride && typeof fontOverride !== "function" ? fontOverride : labelProps.font,
            color: colorOverride && typeof colorOverride !== "function" ? colorOverride : labelProps.color
        };
        var labelGroup;
        if (tdgchart.tdgscene.isTDGSceneGroup(panel))
            labelGroup = panel.group(null, null, null, null, null, null, commonProps);
        else
            labelGroup = scene.group(panel, null, null, null, null, null, null, commonProps);
        var axisSideForLabelsPlacement = axis.side;
        var labelAlign;
        var anchorLookup;
        var opposite = {
            left: "right",
            right: "left",
            top: "bottom",
            bottom: "top",
            center: "center"
        };
        if (!rotation && labelProps.align)
            if (labelProps.align === "outside")
                labelAlign = axis.side;
            else if (labelProps.align === "inside")
                ;
            else {
                if (isVertical && (labelProps.align === "left" || labelProps.align === "right" || labelProps.align === "center"))
                    labelAlign = labelProps.align;
                if (!isVertical && (labelProps.align === "top" || labelProps.align === "bottom" || labelProps.align === "center"))
                    labelAlign = labelProps.align
            }
        if (labelAlign && labelAlign != "center")
            anchorLookup = chart.getLabelAngleConfig(opposite[labelAlign], 0);
        else
            anchorLookup = chart.getLabelAngleConfig(axis.side, rotation);
        var x, y;
        var offset = labelAlign && axis.side != opposite[labelAlign] ? 0 : tickLength + labelsPad;
        if (labelAlign === "center")
            x = panel.computedSize.width / 2;
        else if (labelAlign === "right" || !labelAlign && axis.side === "left")
            x = panel.computedSize.width - offset;
        else
            x = offset;
        if (labelAlign === "center")
            y = panel.computedSize.height / 2;
        else if (labelAlign === "bottom" || !labelAlign && axis.side === "top")
            y = panel.computedSize.height - offset;
        else
            y = offset;
        var labelStyle = {
            align: labelAlign === "center" && isVertical ? "center" : anchorLookup.align,
            valign: labelAlign === "center" && !isVertical ? "center" : anchorLookup.valign,
            translate: {
                x: x,
                y: y
            },
            rotation: anchorLookup.rotation,
            shift: -.15
        };
        var skipFactor = Math.max(pde.skip && !mekkoData ? pde.skip + 1 : 1, 1);
        for (i = 0; i < labels.length; i += skipFactor) {
            labelStyle.className = chart.buildClassName(axisClassName + "-labels", null, i, "groupLabel");
            if (isVertical) {
                labelStyle.translate.y = flatX[i] + labelInset;
                if (isNaN(labelStyle.translate.y))
                    continue
            } else {
                labelStyle.translate.x = flatX[i] + labelInset;
                if (isNaN(labelStyle.translate.x))
                    continue
            }
            if (typeof fontOverride === "function")
                labelStyle.font = fontOverride(null, i);
            if (typeof colorOverride === "function")
                labelStyle.color = colorOverride(null, i);
            if (labelProps.tooltip)
                labelStyle.title = labelProps.tooltip;
            labelGroup.label(0, 0, labels[i], labelStyle)
        }
        if (pde.stagger || axis.properties.intervalMode === "stagger") {
            var stagger = pde.offset ? pde.offset - chart.getPadding("label", "aveVert") : 0;
            for (i = 1; i < labelGroup.childs.length; i += 2)
                labelGroup.childs[i].props.attrs.translate.y += stagger
        }
    }
    function drawNestedLabels(chart, panel, axis, x, axisLayout, labels, centerLabels, tickLength) {
        var isVertical = axis.side === "left" || axis.side === "right";
        var descenderLength = axisLayout.descenderLength;
        var labelInset = centerLabels ? x.range().band / 2 : -(x.range()[0] / 2);
        var maxDepth = axisLayout.nestedDepth;
        var labelHeight = axisLayout.labelHeight;
        var i, currentLeaf = 0, childrenXPos = [];
        var scene = chart.cache.get("tdgscene");
        var groupCount = x.range().length;
        var nestPosList = isVertical ? [0].concat(tdg.accumulate(axisLayout.nestedColWidths)) : [];
        var labelProps = axis.properties.labels || {};
        var labelStyle = {
            align: isVertical ? "right" : "middle",
            valign: isVertical ? "middle" : "top",
            shift: -.15
        };
        var lineStyle = {
            className: "nestedGroupConnector",
            lineStyle: {
                width: axis.properties.labels.nestingLineStyle.width,
                color: axis.properties.labels.nestingLineStyle.color,
                dash: axis.properties.labels.nestingLineStyle.dash
            }
        };
        var commonStyle = {
            font: labelProps.font,
            color: labelProps.color,
            lineCap: "square",
            antialias: false
        };
        if (axis.properties.majorGrid.ticks.style === "inner")
            tickLength = 2;
        var lblCopy = [];
        lblCopy.nestedOrdAxisDepthList = [];
        for (i = 0; i < labels.length; i++) {
            lblCopy.push(labels[i]);
            lblCopy.nestedOrdAxisDepthList.push(labels.nestedOrdAxisDepthList[i]);
            var delta = labels.nestedOrdAxisDepthList[i] - labels.nestedOrdAxisDepthList[i + 1];
            if (delta > 1 && i < labels.length - 1)
                for (var j = 1; j < delta; j++) {
                    lblCopy.push(null);
                    lblCopy.nestedOrdAxisDepthList.push(labels.nestedOrdAxisDepthList[i] - j)
                }
        }
        labels = lblCopy;
        var groupWidth = isVertical ? 0 : panel.computedSize.width / groupCount - 5;
        var labelGroup;
        if (tdgchart.tdgscene.isTDGSceneGroup(panel))
            labelGroup = panel.group(null, null, null, null, null, null, commonStyle);
        else
            labelGroup = scene.group(panel, null, null, null, null, null, null, commonStyle);
        for (i = 0; i < labels.length; i++) {
            var label = labels[i]
              , depth = labels.nestedOrdAxisDepthList[i];
            var ypos, xpos;
            if (isVertical)
                ypos = nestPosList[depth] + (depth - 1) * (descenderLength + 5) + 5;
            else
                ypos = tickLength + (maxDepth - depth) * (labelHeight + descenderLength + 2);
            if (depth === maxDepth) {
                xpos = x(currentLeaf) + labelInset;
                currentLeaf += 1
            } else if (childrenXPos[depth]) {
                if (depth < maxDepth && label && childrenXPos[depth].min !== childrenXPos[depth].max)
                    if (isVertical)
                        labelGroup.line(ypos + 2, childrenXPos[depth].min, ypos + 2, childrenXPos[depth].max, lineStyle);
                    else
                        labelGroup.line(childrenXPos[depth].min, ypos - 2, childrenXPos[depth].max, ypos - 2, lineStyle);
                xpos = (childrenXPos[depth].min + childrenXPos[depth].max) / 2;
                childrenXPos[depth] = {
                    min: Infinity,
                    max: -Infinity
                }
            }
            if (depth > 1 && label && descenderLength > 0)
                if (isVertical) {
                    var y2pos = nestPosList[depth - 1] + (depth - 1) * (descenderLength + 5) + 5;
                    labelGroup.line(y2pos - 2, xpos, y2pos - 2 - descenderLength, xpos, lineStyle)
                } else
                    labelGroup.line(xpos, ypos + labelHeight, xpos, ypos + labelHeight + descenderLength, lineStyle);
            var child = childrenXPos[depth - 1] = childrenXPos[depth - 1] || {
                min: Infinity,
                max: -Infinity
            };
            child.min = Math.min(child.min, xpos);
            child.max = Math.max(child.max, xpos);
            labelStyle.translate = isVertical ? {
                x: ypos,
                y: xpos
            } : {
                x: xpos,
                y: ypos
            };
            if (label) {
                if (isVertical)
                    label = chart.truncateLabel(label, labelProps.font, axisLayout.nestedColWidths[depth - 1]);
                else if (!isVertical && depth === maxDepth)
                    label = chart.truncateLabel(label, labelProps.font, groupWidth);
                labelStyle.className = chart.buildClassName(chart.axisNameToClassName(axis.name) + "-labels", null, i, "groupLabel");
                labelGroup.label(0, 0, label, labelStyle)
            }
        }
    }
    function drawOrdinalTitle(chart, panel, axis) {
        var isVertical = axis.side === "left" || axis.side === "right";
        var title = tdg.clone(axis.properties.title);
        title.text = chart.applyTemplate(title.text, null, null, null);
        if (chart.isOrthogonalAxis(axis)) {
            var titleSize = chart.measureLabel(title);
            var padY = chart.getPadding("label", "aveVert");
            chart.drawTitle(panel, title, "xaxisOrdinal-title", -titleSize.width / 2, -titleSize.height - padY, "top", 0, axis.side)
        } else if (isVertical) {
            var angle = axis.properties.title.position !== "flip" ? 90 : -90;
            var baseline = axis.properties.title.position !== "flip" ? "left" : "right";
            chart.drawTruncatedTitle(panel, title, "xaxisOrdinal-title", 0, axis.layout.titleHeight / 2, baseline, angle, panel.computedSize.height)
        } else
            chart.drawTruncatedTitle(panel, title, "xaxisOrdinal-title", 0, 0, "bottom")
    }
    tdgchart.prototype.drawOrdinalAxis3d = function(panel, x, titleLayout, drawOnGroups) {
        var chart = this;
        var groupCount = this.visibleGroupCount();
        var labels = this.getGroupLabels(groupCount);
        var xGrid = this.xaxis.majorGrid;
        var band = x.range().band / 2;
        var gapWidth = band / (this._internalData || this.data).length;
        var pw = panel.computedSize.width;
        var ph = panel.computedSize.height;
        var tickLength = xGrid.ticks.length;
        if (!xGrid.ticks.visible)
            tickLength = this.getPadding("label", "aveVert");
        var fixed_x = x;
        if (this.blaProperties.orientation === "horizontal") {
            var scale = pw / ph;
            fixed_x = function(d) {
                return scale * x(d)
            }
            ;
            band *= scale;
            gapWidth *= scale
        }
        function gridInRange(d) {
            var dx = drawOnGroups ? fixed_x(d) + band : fixed_x(d + 1) - gapWidth - 1;
            var size = pw;
            return dx > 0 && dx < size
        }
        if (xGrid.visible) {
            var xGridLinesB = panel.add(pv.Rule3d).className(function() {
                return chart.buildClassName("xaxisOrdinal-majorGrid", null, null, this.index)
            }).data(tdg.range(drawOnGroups ? groupCount : groupCount - 1)).visible(gridInRange).lineStyle(xGrid.lineStyle);
            if (drawOnGroups)
                xGridLinesB.left(function(d) {
                    return fixed_x(d) + band
                });
            else
                xGridLinesB.left(function(d) {
                    return fixed_x(d + 1)
                });
            xGridLinesB.back(0).bottom(0).top(0);
            var xGridLines = panel.add(pv.Rule3d).className(function() {
                return chart.buildClassName("xaxisOrdinal-majorGrid", null, null, this.index)
            }).data(tdg.range(drawOnGroups ? groupCount : groupCount - 1)).visible(gridInRange).lineStyle(xGrid.lineStyle);
            if (drawOnGroups)
                xGridLines.left(function(d) {
                    return fixed_x(d) + band
                });
            else
                xGridLines.left(function(d) {
                    return fixed_x(d + 1)
                });
            xGridLines.front(0).back(0).bottom(0)
        }
        function tickInRange(d) {
            var dx = fixed_x(d) + band;
            var size = pw;
            return dx > 0 && dx < size
        }
        var xTicks = panel.add(pv.Rule3d).className(function() {
            return chart.buildClassName("xaxisOrdinal-majorGrid-ticks", null, null, this.index)
        }).data(labels).visible(tickInRange).strokeStyle(xGrid.ticks.visible ? xGrid.ticks.lineStyle.color : "transparent").lineWidth(xGrid.ticks.lineStyle.width);
        xTicks.left(function() {
            return fixed_x(this.index) + band
        });
        switch (xGrid.ticks.style) {
        case "outer":
            xTicks.top(ph).bottom(-tickLength);
            break;
        case "span":
            xTicks.top(ph - tickLength).bottom(-tickLength);
            break;
        case "inner":
            xTicks.top(ph - tickLength).bottom(0);
            break
        }
        if (this.xaxis.labels.visible)
            xTicks.add(pv.Label3d).className(function() {
                return chart.buildClassName("xaxisOrdinal-labels", null, null, this.index)
            }).front(-7).textAlign("right").textBaseline("middle").textAngle(-Math.PI / 4).text(function(d) {
                return d
            }).font(this.xaxis.labels.font).textStyle(this.xaxis.labels.color);
        if (this.xaxis.bodyLineStyle.color !== "transparent")
            this.drawAxisBodyLine3d(panel, "xaxisOrdinal", this.xaxis.side, this.xaxis.bodyLineStyle)
    }
    ;
    tdgchart.prototype.drawSeriesOrdinalAxis3d = function(panel, z, titleLayout, drawOnGroups) {
        var chart = this;
        var seriesCount = this.seriesCount();
        var labels = this.getSeriesLabels(seriesCount);
        var zGrid = this.zaxis.majorGrid;
        var band = z.range().band / 2;
        var gapWidth = band / this.visibleGroupCount();
        var pw = panel.computedSize.width;
        var pd = panel.computedSize.depth;
        var tickLength = zGrid.ticks.length;
        if (!zGrid.ticks.visible)
            tickLength = this.getPadding("label", "aveVert");
        function gridInRange(d) {
            var dx = drawOnGroups ? z(d) + band : z(d + 1) - gapWidth - 1;
            var size = pw;
            return dx > 0 && dx < size
        }
        if (zGrid.visible) {
            var zGridLinesB = panel.add(pv.Rule3d).className(function() {
                return chart.buildClassName("zaxisOrdinal-majorGrid", null, null, this.index)
            }).data(tdg.range(drawOnGroups ? seriesCount : seriesCount - 1)).visible(gridInRange).lineStyle(zGrid.lineStyle);
            if (drawOnGroups)
                zGridLinesB.front(function(d) {
                    return z(d) + band
                });
            else
                zGridLinesB.front(function(d) {
                    return z(d + 1)
                });
            zGridLinesB.left(0).bottom(0).top(0);
            var zGridLines = panel.add(pv.Rule3d).className(function() {
                return chart.buildClassName("zaxisOrdinal-majorGrid", null, null, this.index)
            }).data(tdg.range(drawOnGroups ? seriesCount : seriesCount - 1)).visible(gridInRange).lineStyle(zGrid.lineStyle);
            if (drawOnGroups)
                zGridLines.front(function(d) {
                    return z(d) + band
                });
            else
                zGridLines.front(function(d) {
                    return z(d + 1)
                });
            zGridLines.bottom(0).left(0).right(0)
        }
        function tickInRange(d) {
            var dx = z(d) + band;
            var size = pd;
            return dx > 0 && dx < size
        }
        var zTicks = panel.add(pv.Rule3d).className(function() {
            return chart.buildClassName("zaxisOrdinal-majorGrid-ticks", null, null, this.index)
        }).data(labels).visible(tickInRange).bottom(0).strokeStyle(zGrid.ticks.visible ? zGrid.ticks.lineStyle.color : "transparent").lineWidth(zGrid.ticks.lineStyle.width);
        var reversed_order = false;
        if (reversed_order)
            zTicks.front(function() {
                return z(this.index) + band
            });
        else
            zTicks.back(function() {
                return z(this.index) + band
            });
        switch (zGrid.ticks.style) {
        case "outer":
            zTicks.left(pw).right(-tickLength);
            break;
        case "span":
            zTicks.left(pw - tickLength).right(-tickLength);
            break;
        case "inner":
            zTicks.left(pw - tickLength).right(0);
            break
        }
        if (this.zaxis.labels.visible)
            zTicks.add(pv.Label3d).className(function() {
                return chart.buildClassName("zaxisOrdinal-labels", null, null, this.index)
            }).bottom(-7).textAlign("left").textBaseline("middle").textAngle(Math.PI / 4).text(function(d) {
                return d
            }).font(this.zaxis.labels.font).textStyle(this.zaxis.labels.color);
        if (this.zaxis.bodyLineStyle.color !== "transparent")
            this.drawAxisBodyLine3d(panel, "zaxisOrdinal", this.zaxis.side, this.zaxis.bodyLineStyle)
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    function radialGrid(chart, group, radius, gridProps, groupCount) {
        var lineStyle = {
            color: gridProps.visible ? gridProps.lineStyle.color : "transparent",
            width: gridProps.lineStyle.width,
            dash: gridProps.lineStyle.dash
        };
        var gridStyle = {
            lineStyle: lineStyle
        };
        var angle = 2 * Math.PI / groupCount;
        for (var g = 0; g < groupCount; g++) {
            var ca = Math.cos(-Math.PI / 2 + g * angle);
            var sa = Math.sin(-Math.PI / 2 + g * angle);
            gridStyle.className = chart.buildClassName("xaxis-majorGrid", undefined, undefined, g);
            group.line(0, 0, R10(ca * radius), R10(sa * radius), gridStyle)
        }
    }
    function radialLabels(chart, group, radius, labels, axisProperties, axisMode, groupCount) {
        var formatFn;
        if (axisMode === "numeric") {
            var config = {
                min: labels[0],
                max: labels[labels.length - 1]
            };
            formatFn = function(d) {
                return chart.formatNumber(d, axisProperties.numberFormat, config)
            }
        } else
            formatFn = function(d) {
                return d
            }
            ;
        var style = {
            font: axisProperties.labels.font,
            color: axisProperties.labels.color,
            shift: -.15
        };
        var angle = 2 * Math.PI / groupCount;
        var margin = chart.getPadding("label", "top");
        for (var g = 0; g < groupCount; g++) {
            var ca = Math.cos(-Math.PI / 2 + g * angle);
            var sa = Math.sin(-Math.PI / 2 + g * angle);
            var xmargin = 0
              , ymargin = 0;
            style.className = chart.buildClassName("xaxis-labels", undefined, undefined, g);
            if (g == 0) {
                style.align = "center";
                style.valign = "bottom";
                ymargin = -margin * 3 / 4
            } else if (g < groupCount / 2) {
                style.align = "left";
                style.valign = "middle";
                xmargin = margin
            } else if (g == groupCount / 2) {
                style.align = "center";
                style.valign = "top";
                ymargin = margin / 2
            } else {
                style.align = "right";
                style.valign = "middle";
                xmargin = -margin
            }
            group.label(R10(ca * radius) + xmargin, R10(sa * radius) + ymargin, formatFn(labels[g]), style)
        }
    }
    function radialTitle(chart, group, radius, labelProps) {
        var style = {
            font: labelProps.font,
            color: labelProps.color,
            className: "xaxis-title",
            align: "center",
            valign: "bottom",
            shift: -.15
        };
        var margin = chart.getPadding("label", "top");
        group.label(0, -radius - margin * 3 / 4, labelProps.text, style)
    }
    tdgchart.prototype.drawRadialAxis = function(rootGroup, radius, groupCount, labels, axisProperties, axisName) {
        var chart = this;
        var group = rootGroup.group("radialAxis", rootGroup.w / 2, rootGroup.h / 2);
        var angle = 2 * Math.PI / groupCount;
        if (axisProperties.majorGrid.visible)
            radialGrid(chart, group.group("xaxis-majorGrid"), radius, axisProperties.majorGrid, groupCount);
        var labelRadius = radius + 3;
        if (axisProperties.labels.visible) {
            var axisMode = chart.cache.get("axisModes", {})[axisName];
            radialLabels(chart, group.group("xaxis-majorGrid-labels"), labelRadius, labels, axisProperties, axisMode, groupCount)
        }
        if (axisProperties.title.visible) {
            var labelsHeight = !axisProperties.labels.visible ? 0 : tdg.measureFont(axisProperties.labels.font).height + chart.getPadding("label", "top");
            radialTitle(chart, group.group("xaxis-majorGrid-title"), labelRadius + labelsHeight, axisProperties.title)
        }
    }
    ;
    function getExtrudeOffset(chart, scale, axis, radius, width) {
        var offset = 0;
        if (chart.polarProperties.extrudeAxisLabels) {
            offset = radius * 1.2;
            if (chart.chartType === "radar" && axis.properties.labels.visible) {
                var groupLabelSizes = chart.getGroupLabels().map(function(el) {
                    return chart.measureLabel(el, axis.properties.labels.font)
                });
                var numericLabelWidth = chart.measureLabel(scale.grid[scale.grid.length - 1], axis.properties.labels.font).width;
                var maxOffset = width / 2 - numericLabelWidth - chart.getPadding("label", "maxHorz") - radius;
                var maxGroupLabel = tdg.max(groupLabelSizes, "width");
                maxGroupLabel = Math.max(radius * .2, Math.min(maxGroupLabel, maxOffset));
                offset = radius + maxGroupLabel
            }
        }
        return offset
    }
    tdgchart.prototype.drawNumericAxisCircular = function(rootGroup, externalTitlePanel, radius, scale, axis, groupCount) {
        var chart = this;
        var group = rootGroup.group("circularAxis", rootGroup.w / 2, rootGroup.h / 2);
        var gridData = scale.grid;
        var extrudeOffset = getExtrudeOffset(chart, scale, axis, radius, rootGroup.w);
        circularGrid(chart, group.group("yaxis-majorGrid"), scale, axis, groupCount, extrudeOffset);
        if (axis.properties.labels.visible)
            circularLabels(chart, group.group("yaxis-majorGrid-labels"), scale, axis, groupCount, extrudeOffset);
        if (axis.properties.title.visible && externalTitlePanel !== null)
            circularTitle(chart, group.group("yaxis-majorGrid-title"), radius, scale, axis, groupCount, extrudeOffset, externalTitlePanel, rootGroup.h)
    }
    ;
    function R10(v) {
        return Math.round(v * 10) / 10
    }
    function circularGrid(chart, group, scale, axis, groupCount, extrudeOffset) {
        var gridRadius = scale.grid.map(scale).map(R10);
        var lineStyle = {
            color: axis.properties.majorGrid.visible ? axis.properties.majorGrid.lineStyle.color : "transparent",
            width: axis.properties.majorGrid.lineStyle.width,
            dash: axis.properties.majorGrid.lineStyle.dash
        };
        var gridStyle = {
            lineStyle: lineStyle
        };
        if (chart.polarProperties.straightGridLines) {
            var angle = 2 * Math.PI / groupCount;
            var paths = [];
            for (var g = 0; g < groupCount; g++) {
                var ca = Math.cos(-Math.PI / 2 + g * angle);
                var sa = Math.sin(-Math.PI / 2 + g * angle);
                for (var i = 0; i < scale.grid.length; i++) {
                    var pt = {
                        x: R10(ca * gridRadius[i]),
                        y: R10(sa * gridRadius[i])
                    };
                    if (!g) {
                        paths[i] = new tdgchart.tdgscene.path;
                        paths[i].moveTo(pt.x, pt.y)
                    } else {
                        if (gridRadius[i])
                            paths[i].lineTo(pt.x, pt.y);
                        if (g == groupCount - 1)
                            paths[i].closePath()
                    }
                }
            }
        }
        for (var i = 0; i < scale.grid.length; i++) {
            gridStyle.className = chart.buildClassName("yaxis-majorGrid", undefined, undefined, i);
            if (chart.polarProperties.straightGridLines)
                group.path(0, 0, paths[i], gridStyle);
            else
                group.circle(0, 0, gridRadius[i], gridStyle);
            if (extrudeOffset) {
                gridStyle.className = chart.buildClassName("yaxis-majorGridFeeler", undefined, undefined, i);
                group.line(0, -gridRadius[i], -extrudeOffset, -gridRadius[i], gridStyle)
            }
        }
    }
    function circularLabels(chart, group, scale, axis, groupCount, extrudeOffset) {
        var gridRadius = scale.grid.map(scale).map(R10);
        var axisFormatConfig = {
            islog: axis.properties.bIsLog,
            min: scale.grid[0],
            max: scale.grid[scale.grid.length - 1]
        };
        var padding = chart.getPadding("label", "top");
        var offset = 0;
        var style = {
            font: axis.properties.labels.font,
            color: axis.properties.labels.color,
            align: "right",
            valign: "middle",
            shift: -.15
        };
        for (var i = 0; i < gridRadius.length; i++) {
            var text = chart.formatNumber(scale.grid[i], axis.properties.numberFormat, axisFormatConfig);
            style.className = chart.buildClassName("yaxis-labels", undefined, undefined, i);
            group.label(-padding - extrudeOffset, -gridRadius[i], text, style)
        }
    }
    function circularTitle(chart, group, radius, scale, axis, groupCount, extrudeOffset, externalTitlePanel, externalTitlePanelHeight) {
        var leftPos = 0
          , yOffset = -radius / 2
          , valign = "bottom";
        if (externalTitlePanel) {
            var scene = chart.cache.get("tdgscene");
            group = scene.group(externalTitlePanel, "gg");
            leftPos = 0;
            yOffset = externalTitlePanelHeight / 2;
            valign = "top"
        } else {
            var labelPad = 0;
            if (axis.properties.labels.visible) {
                var axisFormatConfig = {
                    islog: axis.properties.bIsLog,
                    min: scale.grid[0],
                    max: scale.grid[scale.grid.length - 1]
                };
                var labelSizes = scale.grid.map(function(el) {
                    return chart.measureLabel(chart.formatNumber(el, axis.properties.numberFormat, axisFormatConfig), axis.properties.labels.font)
                });
                labelPad = Math.max(0, tdg.max(labelSizes, "width")) + chart.getPadding("label", "top")
            }
            leftPos = extrudeOffset + labelPad + chart.getPadding("label", "left")
        }
        var style = {
            className: "yaxis-title",
            rotation: -90,
            font: axis.properties.title.font,
            color: axis.properties.title.color,
            align: "center",
            valign: valign,
            shift: -.15
        };
        group.group(undefined, -leftPos, yOffset).label(0, 0, axis.properties.title.text, style)
    }
    function getRangeAngles(colorBand, scale, groupCount, groupLabels) {
        var twoPi = Math.PI * 2;
        var angles = {};
        var sStr = typeof colorBand.start === "string";
        var eStr = typeof colorBand.stop === "string";
        if (scale) {
            angles.start = sStr ? parseFloat(colorBand.start) / 100 : scale(colorBand.start) / twoPi;
            angles.end = eStr ? parseFloat(colorBand.stop) / 100 : scale(colorBand.stop) / twoPi
        } else {
            angles.start = sStr ? groupLabels.indexOf(colorBand.start) / groupCount : colorBand.start;
            angles.end = eStr ? groupLabels.indexOf(colorBand.stop) / groupCount : colorBand.stop
        }
        angles.start = 90 - 360 * angles.start;
        angles.end = 90 - 360 * angles.end;
        return angles
    }
    function getRangeRadius(colorBand, scale, radius) {
        var sStr = typeof colorBand.start === "string";
        var eStr = typeof colorBand.stop === "string";
        var r = {};
        r.i = sStr ? Math.min(radius, radius * parseFloat(colorBand.start) / 100) : Math.min(scale.range()[1], scale(colorBand.start));
        r.o = eStr ? Math.min(radius, radius * parseFloat(colorBand.stop) / 100) : Math.min(scale.range()[1], scale(colorBand.stop));
        return r
    }
    tdgchart.prototype.drawCircularAxisColorRanges = function(rootGroup, radius, scale, axis, isRadial, groupCount, groupLabels) {
        if (!axis.properties.colorBands || !axis.properties.colorBands.length)
            return;
        var chart = this;
        var group = rootGroup.group("radialBand", rootGroup.w / 2, rootGroup.h / 2);
        for (var cb = 0; cb < axis.properties.colorBands.length; cb++) {
            var colorBand = axis.properties.colorBands[cb];
            var angles = isRadial ? getRangeAngles(colorBand, scale, groupCount, groupLabels) : {
                start: 0,
                end: 360
            };
            var r = isRadial ? {
                i: 0,
                o: radius
            } : getRangeRadius(colorBand, scale, radius);
            var attrs = {
                className: chart.buildClassName("axisRange", undefined, undefined, cb),
                color: colorBand.color
            };
            if (!chart.polarProperties.straightGridLines)
                group.wedge(0, 0, r.o, r.i, angles.end, angles.start, attrs);
            else {
                if (!groupCount)
                    return;
                var p = new tdgchart.tdgscene.path;
                if (isRadial) {
                    var firstIndex = groupLabels.indexOf(colorBand.start);
                    var lastIndex = groupLabels.indexOf(colorBand.stop);
                    if (firstIndex == -1 && tdg.isANumber(colorBand.start))
                        firstIndex = Math.round(colorBand.start * groupLabels.length) % groupLabels.length;
                    if (lastIndex == -1 && tdg.isANumber(colorBand.stop))
                        lastIndex = Math.round(colorBand.stop * groupLabels.length) % groupLabels.length;
                    if (!scale && firstIndex != -1 && lastIndex != -1 && firstIndex != lastIndex) {
                        var angle = 2 * Math.PI / groupCount;
                        p.moveTo(0, 0);
                        var idx = firstIndex;
                        do {
                            var a = -Math.PI / 2 + angle * idx;
                            p.lineTo(R10(radius * Math.cos(a)), R10(radius * Math.sin(a)))
                        } while (idx++ % groupCount != lastIndex);
                        p.closePath()
                    }
                } else {
                    var angle = 2 * Math.PI / groupCount;
                    for (var i = 0; i < groupCount; i++) {
                        var a = -Math.PI / 2 + angle * i;
                        if (i == 0)
                            p.moveTo(R10(r.o * Math.cos(a)), R10(r.o * Math.sin(a)));
                        else
                            p.lineTo(R10(r.o * Math.cos(a)), R10(r.o * Math.sin(a)))
                    }
                    if (r.i <= 0)
                        p.closePath();
                    else {
                        for (var i = groupCount - 1; i >= 0; i--) {
                            var a = -Math.PI / 2 + angle * i;
                            if (i == groupCount - 1)
                                p.moveTo(R10(r.i * Math.cos(a)), R10(r.i * Math.sin(a)));
                            else
                                p.lineTo(R10(r.i * Math.cos(a)), R10(r.i * Math.sin(a)))
                        }
                        p.closePath()
                    }
                }
                group.path(0, 0, p, attrs)
            }
        }
    }
}
)();
(function() {
    tdgchart.prototype.drawPieChart = drawPieChart;
    tdgchart.prototype.getOtherSliceIndices = getOtherSliceIndices;
    tdgchart.prototype.getPieLabelClassName = getPieLabelClassName;
    var tdg = tdgchart.util;
    var feelerLength = 15;
    var feelerTipLength = 10;
    var outsideLblHeight = 0;
    tdgchart.prototype.isPieLike = function() {
        var chart = this;
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        return chartType === "pie" || chartType === "funnel" || chartType === "gauge"
    }
    ;
    function drawPieChartLabel(chart, groupLabels, panel, left) {
        panel.anchor("bottom").add(pv.Label).className(chart.getPieLabelClassName("pieLabel")).text(function() {
            return groupLabels[this.parent.parent.index]
        }).textMargin(chart.getPadding("label", "aveHorz")).left(function(d) {
            return left.call(this, null, d)
        }).font(chart.pieProperties.label.font).textStyle(chart.pieProperties.label.color)
    }
    function drawPieChartTotalLabel(chart, label, panel, top, left, holeRadius) {
        var font = label.font;
        if (label.fontSize) {
            var fontParts = tdg.fontToFontParts(font);
            fontParts.fontSize = label.fontSize;
            font = fontParts.toString()
        } else if (holeRadius)
            font = function(d, data) {
                var r = typeof holeRadius === "function" ? holeRadius.call(this, d, data) : holeRadius;
                return r ? tdg.scaleFontToBox(this.text(), label.font, r) : label.font
            }
            ;
        var content = label.content
          , text = label.content;
        if (text === "auto")
            text = function(d) {
                return d.total == null ? null : chart.formatNumber(d.total, label.numberFormat, "totalLabel")
            }
            ;
        else if (tdgchart.templateEngine.isTemplateString(text))
            text = function(d, data) {
                d = (data || [])[0];
                var ids = chart.getMarkSeriesAndGroupID(this, d);
                return chart.parseTemplate(content, d, data, ids)
            }
            ;
        panel.anchor("center").add(pv.Label).className(chart.getPieLabelClassName("totalLabel")).text(text).top(function(d) {
            return top.call(this, null, d)
        }).left(function(d) {
            return left.call(this, null, d)
        }).font(font).textStyle(label.color)
    }
    function getPieLabelClassName(objectID) {
        var chart = this;
        return function(d) {
            var g = 0;
            if (this && this.parent && this.parent.parent)
                g = this.parent.parent.index;
            else if (d && d[0] && d[0]._g != null)
                g = d[0]._g;
            return chart.buildClassName(objectID, null, g, objectID)
        }
    }
    function addOtherDrillDown(chart) {
        if (chart.interaction.click !== "otherSliceDrillDown" || chart.groupCount() > 1)
            return;
        var drillDown = function(cbo) {
            var chart = this;
            var pieData = chart.cache.get("pieData", []);
            var data = pieData[cbo.group] || [];
            var d = data[data.length - 1];
            if (!d || !d.isOtherSlice)
                return;
            if (chart.pieDrillDataStack == null) {
                chart.pieDrillDataStack = [];
                chart.pieDrillSeriesMap = []
            }
            var newData = []
              , seriesMap = [];
            for (var i = 0; i < data.length; i++)
                if (data[i].actualValue != null) {
                    newData.push(data[i].actualValue);
                    if (chart.pieDrillSeriesMap.length > 0)
                        seriesMap.push(chart.pieDrillSeriesMap[chart.pieDrillSeriesMap.length - 1][i]);
                    else
                        seriesMap.push(i)
                }
            chart.pieDrillDataStack.push(chart.data);
            chart.pieDrillSeriesMap.push(seriesMap);
            chart.data = chart.swapData ? newData.map(function(el) {
                return [el]
            }) : [newData];
            chart.redraw()
        };
        chart.registerEvent(drillDown, "click", "riser", null, null, null, "other");
        chart.registerEvent(drillDown, "touchend", "riser", null, null, null, "other")
    }
    function addDrillDownArrow(chart, panel) {
        var addArrow = function(panel, radius, left, color, callback) {
            panel.add(pv.Dot).antialias(false).shape("arrow").radius(radius).bottom(radius).left(left).fillStyle(color).strokeStyle(null).cursor("pointer").event("click", callback).event("touchend", callback)
        };
        var drillUp = function() {
            chart.data = chart.pieDrillDataStack.pop();
            chart.pieDrillSeriesMap.pop();
            chart.redraw()
        };
        var restoreDrill = function() {
            chart.data = chart.pieDrillDataStack[0];
            chart.pieDrillDataStack = undefined;
            chart.pieDrillSeriesMap = undefined;
            chart.redraw()
        };
        var size = 11;
        addArrow(panel, size, size, "#0969A2", restoreDrill);
        if (chart.pieDrillDataStack.length > 1)
            addArrow(panel, size - 1.5, size * 2.75, "#3D9AD1", drillUp)
    }
    tdgchart.translateStrToObject = function(origin) {
        if (!origin)
            return undefined;
        var match = origin.match(/translate\(([-.0-9]+(e-?[0-9]+)?),?\s?([-.0-9]+(e-?[0-9]+)?)\)\s?(.*)/);
        if (match && match.length >= 2)
            return {
                x: parseFloat(match[1]),
                y: parseFloat(match[3]),
                remainder: match[5] || ""
            };
        return undefined
    }
    ;
    function addExplodeClick(chart) {
        if (!chart.pieProperties.explodeClick.enabled || chart.getColorMode() === "byMetric" || typeof chart.depth === "number" && chart.depth)
            return;
        if (chart.data.filter(function(el) {
            return el.length > 1
        }).length < 1)
            return;
        var needInitialization = true;
        var root = tdgchart.d3.select("#" + chart.documentRoot);
        var pieOrigin, selectionOrigin;
        function selectionOriginToOrigin(target) {
            var o = tdgchart.translateStrToObject(pieOrigin);
            var s = tdgchart.translateStrToObject(selectionOrigin);
            var l = tdgchart.translateStrToObject(target.selectionOrigin);
            return "translate(" + (l.x - s.x + o.x) + ", " + (l.y - s.y + o.y) + ")"
        }
        function getExplodeOrigin(target) {
            var angle = parseFloat(target.getAttribute("tdg:angle"));
            if (isNaN(angle)) {
                var sel = target.getAttribute("class").includes("Selection") ? "Selection" : "";
                var slice = root.select('path[class="riser!s' + target.sid + "!g" + target.gid + "!mwedge" + sel + '!"]').node();
                if (slice == null)
                    slice = root.select('path[class="riser!s' + target.sid + "!g" + target.gid + "!mother" + sel + '!"]').node();
                if (slice == null)
                    return undefined;
                angle = parseFloat(slice.getAttribute("tdg:angle"));
                if (isNaN(angle))
                    return undefined
            }
            var displacement = chart.pieProperties.explodeClick.distance;
            var dx = Math.cos(angle) * displacement;
            var dy = Math.sin(angle) * displacement;
            var wo = tdgchart.translateStrToObject(target.origin);
            return "translate(" + (dx + wo.x) + ", " + (dy + wo.y) + ")"
        }
        function addOrigin(target) {
            var className = target.getAttribute("class");
            var isText = target.tagName === "text";
            var isFeeler = className.includes("feeler");
            if (className.includes("Selection")) {
                target.selectionOrigin = isFeeler ? "translate(0.001, 0.001)" : target.getAttribute("transform");
                target.origin = isText || isFeeler ? selectionOriginToOrigin(target) : pieOrigin
            } else if (isFeeler)
                target.origin = "translate(0.001, 0.001)";
            else if (target.hasAttribute("transform"))
                target.origin = target.getAttribute("transform");
            if (!target.origin && useSceneEngine(chart)) {
                target.setAttribute("transform", "translate(0.001, 0.001)");
                target.origin = "translate(0.001, 0.001)"
            }
            if (target.origin)
                target.explodeOrigin = getExplodeOrigin(target)
        }
        function addClassIDs(target) {
            var ids = chart.classNameToIds(target.getAttribute("class"));
            target.sid = ids.series;
            target.gid = ids.group
        }
        function initNodes() {
            pieOrigin = root.select("path[class^=riser][class*=mwedge]").node().getAttribute("transform");
            var node = root.select('path[class="riser!s0!g0!mwedgeSelection!"]').node();
            if (node)
                selectionOrigin = node.getAttribute("transform");
            root.selectAll("path[class^=riser], text[class^=dataLabels], path[class^=feeler]").each(function() {
                if (this.getAttribute("class").includes("feeler"))
                    this.setAttribute("transform", "translate(0.001, 0.001)");
                addClassIDs(this);
                addOrigin(this)
            });
            root.select('path[class="hoverFill"]').each(function() {
                addClassIDs(this);
                addOrigin(this)
            })
        }
        function addTransition(target, isClicked, translate) {
            target.each(function() {
                this.isTDGClicked = isClicked
            }).transition().duration(chart.pieProperties.explodeClick.duration).ease("back-out").attr("transform", function() {
                if (this.origin == null)
                    addOrigin(this);
                return translate || (isClicked ? this.explodeOrigin : this.origin)
            }).each("end", function() {
                if (this.getAttribute("class") === "hoverFill")
                    this.isAnimating = false
            })
        }
        function setHoverExplode(target) {
            root.select('path[class="hoverFill"]').each(function() {
                var ctm = target.parentNode.getCTM();
                var t = tdgchart.translateStrToObject(target.explodeOrigin);
                this.explodeOrigin = "translate(" + (t.x + ctm.e) + "," + (t.y + ctm.f) + ")";
                this.isAnimating = true
            })
        }
        function addWedgeTransition(target, isClicked) {
            var sel = ["wedge", "other", "bevel", "wedgeSelection", "bevelSelection"].map(function(el) {
                return 'path[class="riser!s' + target.sid + "!g" + target.gid + "!m" + el + '!"]'
            }).join(", ");
            sel += ', path[class="hoverFill"]';
            setHoverExplode(target);
            addTransition(root.selectAll(sel), isClicked)
        }
        function addLblTransition(s, g, isClicked) {
            var lblSel = root.selectAll('text[class^="dataLabels!s' + s + "!g" + g + '!mdataLabels"]');
            if (lblSel.node())
                addTransition(lblSel, isClicked)
        }
        function addFeelerTransition(s, g, isClicked) {
            var feelerSel = root.selectAll('path[class^="feeler!s' + s + "!g" + g + '!mfeeler"]');
            if (feelerSel.node())
                addTransition(feelerSel, isClicked)
        }
        function slideIn(target) {
            addWedgeTransition(target, false);
            addLblTransition(target.sid, target.gid, false);
            addFeelerTransition(target.sid, target.gid, false)
        }
        function slideOut(target) {
            if (target.sid == undefined)
                return;
            addWedgeTransition(target, true);
            addLblTransition(target.sid, target.gid, true);
            addFeelerTransition(target.sid, target.gid, true)
        }
        function slideSelectionIn() {
            root.selectAll("path[class^=riser][class$=Selection], text[class^=dataLabels][class$=Selection], path[class^=feeler][class$=Selection]").each(function() {
                addTransition(tdgchart.d3.select(this), false, this.origin)
            })
        }
        function slideSelectionOut() {
            var outCount = root.selectAll('path[class^=riser][class*="!mwedge"]').filter(function() {
                return this.hasOwnProperty("isTDGClicked") && this.isTDGClicked
            })[0].length;
            if (outCount === 0)
                root.selectAll("path[class^=riser][class$=Selection], text[class^=dataLabels][class$=Selection], path[class^=feeler][class$=Selection]").each(function() {
                    addTransition(tdgchart.d3.select(this), false, this.selectionOrigin)
                })
        }
        function sliceClick(obj) {
            var wedgeSVG = obj.svgElement;
            if (needInitialization) {
                initNodes();
                needInitialization = false
            }
            if (wedgeSVG.hasOwnProperty("isTDGClicked") && wedgeSVG.isTDGClicked) {
                slideIn(wedgeSVG);
                slideSelectionOut()
            } else {
                if (chart.pieProperties.explodeClick.limitExplodeCount || chart.pieProperties.groupPiesBySelection)
                    root.selectAll('path[class^=riser][class*="!mwedge"], path[class^=riser][class*="!mother"]').filter(function() {
                        return this.hasOwnProperty("isTDGClicked") && this.isTDGClicked && this !== wedgeSVG ? this : null
                    }).each(function() {
                        slideIn(this)
                    });
                slideSelectionIn();
                slideOut(wedgeSVG)
            }
        }
        chart.registerEvent(sliceClick, "click.explodeSlice", "riser", undefined, undefined, undefined, "!hoverFill")
    }
    function drawLabelsInAndOut(chart, wedge) {
        var labels = chart.doDataLabels(wedge, "center");
        var textLookup = labels.$properties.filter(function(el) {
            return el.name === "text"
        })[0].value;
        labels.text(function(d) {
            var text = textLookup.apply(this, arguments);
            var labelFont = chart.getSeriesAndGroupProperty(d._s, d._s, "dataLabels.font");
            var labelSize = chart.measureLabel(text, labelFont);
            var wedge = this.anchorTarget();
            if (labelExceeds(wedge.innerRadius(), wedge.outerRadius(), wedge.startAngle(), wedge.angle(), labelSize))
                return "";
            return text
        })
    }
    function labelExceeds(innerRadius, outerRadius, startAngle, angle, labelSize) {
        var lblAngle = startAngle + angle / 2;
        var lblRadius = innerRadius + (outerRadius - innerRadius) / 2;
        var x = Math.cos(lblAngle) * lblRadius;
        var y = Math.sin(lblAngle) * lblRadius;
        var dx = Math.abs(x) - labelSize.width / 2;
        var dy = Math.abs(y) - labelSize.height / 2;
        var r = Math.sqrt(dx * dx + dy * dy);
        if (r < innerRadius)
            return true;
        dx = x - labelSize.width / 2;
        dy = y - labelSize.height / 2;
        var t = Math.atan2(dy, dx);
        if (t < -(Math.PI / 2))
            t += Math.PI + Math.PI;
        if (t < startAngle || t > startAngle + angle)
            return true;
        return false
    }
    function drawLabelsOutside(chart, wedge, radius, vInset, hInset, explodeOffset, explodeSelectedAngle, extraPad) {
        var seriesCount = chart.seriesCount();
        function onLeftSide(angle) {
            while (angle > 2 * Math.PI)
                angle -= 2 * Math.PI;
            while (angle < 0)
                angle += 2 * Math.PI;
            return angle >= Math.PI / 2 && angle < Math.PI * 3 / 2
        }
        function leftWrapper(offset) {
            return function(d, data) {
                var innerRadius = radius;
                if (d.noLabel != null && d.noLabel)
                    return null;
                if (typeof radius === "function") {
                    innerRadius = data.radius;
                    vInset = data.vInset
                }
                var angle = this.anchorTarget().midAngle();
                var res = Math.cos(angle) * (innerRadius + offset);
                if (explodeSelectedAngle && this.index < seriesCount)
                    return res + vInset + innerRadius + explodeOffset(this.anchorTarget(), d, Math.cos) + 15 * Math.sin(explodeSelectedAngle);
                return res + vInset + innerRadius + explodeOffset(this.anchorTarget(), d, Math.cos)
            }
        }
        function prevSibling(idx, scene) {
            for (var i = idx - 1; i >= 0; i--)
                if (!scene[i].data.noLabel)
                    return scene[i];
            return null
        }
        function nextSibling(idx, scene) {
            for (var i = idx + 1; i < scene.length; i++)
                if (!scene[i].data.noLabel)
                    return scene[i];
            return null
        }
        function bumpOneLabel(target, prevTarget, offset) {
            target.top = prevTarget.top + offset;
            target.y1 = prevTarget.y1 + offset;
            target.y2 = prevTarget.y2 + offset
        }
        function reverse(a) {
            var res = [];
            for (var i = a.length - 1; i >= 0; i--)
                res.push(a[i]);
            return res
        }
        function checkLabelForOverlap(target, prevTarget, bottomQ, topQ, prop) {
            if (!target || !prevTarget)
                return;
            var a = tdg.boundAngle(tdg.degrees(target.midAngle) + 90, "degrees");
            if (bottomQ === "q2" && a >= 90 && a < 180 || bottomQ === "q3" && a >= 180 && a < 270) {
                if (target[prop] - prevTarget[prop] < outsideLblHeight)
                    bumpOneLabel(target, prevTarget, outsideLblHeight)
            } else if (topQ === "q1" && a < 90 || topQ === "q4" && a >= 270)
                if (prevTarget[prop] - target[prop] < outsideLblHeight)
                    bumpOneLabel(target, prevTarget, -outsideLblHeight)
        }
        function adjustForOverlap(scene, pieRotation, prop) {
            if (pieRotation < 0)
                scene = reverse(scene);
            for (var i = 1; i < scene.length; i++)
                checkLabelForOverlap(scene[i], prevSibling(i, scene), "q2", "q4", prop);
            for (var j = scene.length - 2; j >= 0; j--)
                checkLabelForOverlap(scene[j], nextSibling(j, scene), "q3", "q1", prop)
        }
        function topWrapper(offset) {
            return function(d, data) {
                if (d.noLabel != null && d.noLabel)
                    return null;
                var innerRadius = radius;
                if (typeof radius === "function") {
                    innerRadius = data.radius;
                    hInset = data.hInset
                }
                var scene = this.scene;
                var prop = this instanceof pv.Label ? "top" : "y1";
                var angle = scene[this.index].midAngle = this.anchorTarget().midAngle();
                var dy = Math.sin(angle) * (innerRadius + offset) + hInset + innerRadius + explodeOffset(this.anchorTarget(), d, Math.sin);
                if (offset > 0 && this.index === scene.length - 1) {
                    tdg.mergeObjects({
                        top: dy,
                        y1: dy,
                        y2: dy
                    }, scene[this.index]);
                    adjustForOverlap(scene, chart.pieProperties.rotation, prop);
                    return scene[this.index][prop]
                }
                return dy
            }
        }
        var labelLeft = leftWrapper(feelerLength);
        var labelTop = topWrapper(feelerLength);
        function textAlign() {
            var angle = this.anchorTarget().midAngle();
            return onLeftSide(angle) ? "right" : "left"
        }
        function tipEnd(d, data) {
            var angle = this.anchorTarget().midAngle();
            return labelLeft.call(this, d, data) + (onLeftSide(angle) ? -feelerTipLength : feelerTipLength)
        }
        var labelProperties = {
            textAlign: textAlign,
            textBaseline: "middle",
            textMargin: feelerTipLength + 2 + extraPad,
            left: labelLeft,
            top: labelTop
        };
        var labels = chart.doDataLabels(wedge, "outer", labelProperties);
        if (!labels)
            return undefined;
        if (chart.getSeriesProperty("dataLabels.feelerLine").some(tdg.isNotEmpty)) {
            var feeler = wedge.anchor("outer").add(pv.FeelerLine).visible(chart.dataLabelVisibleLookup()).className(chart.classNameLookup("feeler", "feeler")).textAlign(textAlign).x0(leftWrapper(0)).y0(topWrapper(0)).x1(labelLeft).y1(labelTop).x2(tipEnd).y2(function() {
                return this.y1()
            }).lineStyle(chart.seriesPropertyLookup("dataLabels.feelerLine"));
            var mode = chart.getColorMode();
            if ((mode === "byMetric" || mode === "bySeriesSelection" || mode === "byGroupSelection") && chart.pieProperties.groupPiesBySelection) {
                var classNameSelectedLookup = function(mid, oid) {
                    var classNameLookup = chart.classNameLookup(mid, oid);
                    return function() {
                        var res = classNameLookup.call(this);
                        return this.index < seriesCount ? res + "Selection" : res
                    }
                };
                feeler.className(classNameSelectedLookup("feeler", "feeler"))
            }
        }
        return labels
    }
    function calculateMaxOffset(angleList, w, h, r, labelSize) {
        var hInset = (h - r - r) / 2;
        var q4Space, q2Space;
        var i, a, dx, dy, labelAngle, maxSpace;
        for (i = 0; i < angleList.length; i++) {
            labelAngle = angleList[i];
            a = tdg.radians(labelAngle - 90);
            dy = Math.sin(a) * (r + feelerLength) + hInset + r;
            if (labelAngle >= 90 && labelAngle < 180)
                if (q2Space != null && dy - q2Space < labelSize.height)
                    q2Space += labelSize.height;
                else
                    q2Space = dy;
            else if (labelAngle >= 270)
                if (q4Space != null && q4Space - dy < labelSize.height)
                    q4Space -= labelSize.height;
                else
                    q4Space = dy
        }
        var q1Space, q3Space;
        for (i = angleList.length - 1; i >= 0; i--) {
            labelAngle = angleList[i];
            a = tdg.radians(labelAngle - 90);
            dy = Math.sin(a) * (r + feelerLength) + hInset + r;
            if (labelAngle < 90)
                if (q1Space != null && q1Space - dy < labelSize.height)
                    q1Space -= labelSize.height;
                else
                    q1Space = dy;
            else if (labelAngle >= 180 && labelAngle < 270)
                if (q3Space != null && dy - q3Space < labelSize.height)
                    q3Space += labelSize.height;
                else
                    q3Space = dy
        }
        q1Space = Math.max(q1Space * -1, 0) + 5 || 0;
        q2Space = q2Space - h + 5 || 0;
        q3Space = q3Space - h + 5 || 0;
        q4Space = Math.max(q4Space * -1, 0) + 5 || 0;
        maxSpace = Math.max(q1Space, q2Space, q3Space, q4Space);
        maxSpace += Math.max(0, labelSize.height / 2 * .85 - 5);
        dx = r + r + labelSize.width + labelSize.width;
        dy = r + r + maxSpace + maxSpace;
        if (dx - w > dy - h && dx - w > maxSpace && dx > w)
            return labelSize.width - (w - r - r) / 2;
        else if (maxSpace > 0)
            return maxSpace;
        return 0
    }
    function tallestFont(fontList) {
        var fontObj = tdg.max(fontList, function(el) {
            el = tdg.fontToFontParts(el);
            return parseFloat(el.fontSize) || 0
        }, "key");
        return fontObj == null ? "10px sans-serif" : fontObj.toString()
    }
    function sortPieData(chart, data) {
        return chart.sortData(data, chart.pieProperties.sort)
    }
    function zeroPieWrapper(lookup, nullValue, nullDeleteValue) {
        return function(d) {
            if (d.zeroPie)
                return nullValue;
            return d.isDeleted || d.noLabel ? nullDeleteValue : lookup.call(this, d)
        }
    }
    function allLabelSize(chart, data, dataLabelFont) {
        var fonts = chart.getSeriesProperty("dataLabels.font");
        var dataLabelFont = tallestFont(fonts);
        var labelSize = {
            width: -Infinity,
            height: -Infinity
        };
        var sizes = [];
        for (var i = 0; i < data.length; i++) {
            sizes[i] = [];
            for (var j = 0; j < data[i].length; j++) {
                var lbl = chart.resolveDataLabelContent(data[i][j], data[i], {
                    series: j,
                    group: i
                });
                sizes[i][j] = chart.measureLabel(lbl, fonts[j] || dataLabelFont);
                if (sizes[i][j].width > labelSize.width)
                    labelSize.width = sizes[i][j].width;
                if (sizes[i][j].height > labelSize.height)
                    labelSize.height = sizes[i][j].height
            }
        }
        labelSize.dataLabelFont = dataLabelFont;
        labelSize.sizes = sizes;
        return labelSize
    }
    function maxLabelSize(chart, data, dataLabelFont) {
        var dataLabelFont = tallestFont(chart.getSeriesProperty("dataLabels.font"));
        var labelSize = {
            width: -Infinity,
            height: -Infinity
        };
        for (var i = 0; i < data.length; i++)
            for (var j = 0; j < data[i].length; j++) {
                var lbl = chart.resolveDataLabelContent(data[i][j], data[i], {
                    series: j,
                    group: i
                });
                lbl = chart.measureLabel(lbl, dataLabelFont);
                if (lbl.width > labelSize.width)
                    labelSize.width = lbl.width;
                if (lbl.height > labelSize.height)
                    labelSize.height = lbl.height
            }
        labelSize.dataLabelFont = dataLabelFont;
        return labelSize
    }
    function getExtrapad(chart, data, font) {
        var labelPadLookup = chart.seriesPropertyLookup("dataLabels.pad");
        var extraPad = labelPadLookup.call(this, {
            series: 0
        }, data) || 0;
        if (tdg.isPercentString(extraPad))
            extraPad = tdg.applyNumOrPercent(extraPad, parseFloat(tdg.fontToFontParts(font).fontSize), 0, 100) || 0;
        return extraPad
    }
    function reduceRadiusForOutsideLabels(chart, data, r, w, h, adjustedH, extraPad, labelSize) {
        var pieProps = chart.pieProperties;
        var pieRotation = pieProps.rotation || 0;
        r = Math.max(r, Math.min(w, h) * .2);
        hInset = (adjustedH - r - r) / 2;
        labelSize.width += feelerTipLength + feelerLength + extraPad;
        outsideLblHeight = labelSize.height;
        var res, outsideSpace = 0;
        for (i = 0; i < data.length; i++) {
            var angleSum = pieRotation
              , angleList = [];
            for (j = 0; j < data[i].length; j++)
                if (!data[i][j].noLabel) {
                    res = tdg.degrees(angle(data[i][j], data[i], pieRotation));
                    angleList.push(tdg.boundAngle(angleSum + res / 2, "degrees"));
                    angleSum += res
                }
            var maxSpace = 0
              , currentR = r;
            res = adjustedH;
            for (j = 0; j < 5 && res > outsideLblHeight; j++) {
                res = calculateMaxOffset(angleList, w, adjustedH, currentR, labelSize);
                maxSpace += res;
                currentR -= res
            }
            outsideSpace = Math.max(outsideSpace, maxSpace)
        }
        if (pieProps.label.visible)
            outsideSpace += 5;
        r -= outsideSpace;
        return r
    }
    function reduceRadiusForExplode(chart, r, seriesCount) {
        var explodeSize = 0;
        if (seriesCount > 1)
            explodeSize = tdg.max(chart.series, function(el) {
                return tdg.applyNumOrPercent(el.explodeSlice || 0, r)
            });
        if (explodeSize > 0)
            r = Math.max(r - explodeSize, 10);
        return r
    }
    function angle(d, data, pieRotation) {
        var direction = pieRotation < 0 ? -1 : 1;
        if (d.zeroPie)
            return Math.PI * 2;
        var a = data.scale(d.value * direction);
        if (a > Math.PI * 1.999 && a < Math.PI * 2)
            return Math.PI * 1.999;
        return a
    }
    function holeSizeFromRadius(chart, r, isRoundRing) {
        var pieProps = chart.pieProperties;
        var size = pieProps.holeSize || 0;
        if (isRoundRing && tdg.applyNumOrPercent(size, 100) < 80)
            size = "80%";
        var holeSize = tdg.applyNumOrPercent(size, r);
        return Math.min(r - 1, Math.max(holeSize, 0))
    }
    function offsetInsideTopLabel(w, h, radius, angle) {
        var dx = Math.cos(angle) * radius;
        var dy = Math.sin(angle) * radius;
        var quadrant = tdg.geom.quadrant(angle + Math.PI / 2) - 1;
        var s = [[1, -1], [1, 1], [-1, 1], [-1, -1]][quadrant];
        var dt = dy / dx;
        var a = 1 + dt * dt;
        var b = s[0] * w + s[1] * h * dt;
        var c = w / 2 * (w / 2) + h / 2 * (h / 2) - radius * radius;
        var x = (-b + s[0] * Math.sqrt(b * b - 4 * a * c)) / (2 * a);
        var y = dt * x;
        return {
            left: x,
            top: y
        }
    }
    function drawOnePieChart(chart, panel, w, h, data, minMaxPieSize) {
        var seriesCount = chart.seriesCount();
        var colorMode = chart.getColorMode();
        var colorBySelection = colorMode === "bySeriesSelection" || colorMode === "byGroupSelection";
        var cdepth = chart.computeddepth25d();
        var pieProps = chart.pieProperties;
        var pieRotation = pieProps.rotation || 0;
        var i, j, vInset, hInset;
        data = sortPieData(chart, data);
        var groupLabels, labelHeight = 0;
        if (pieProps.label.visible) {
            groupLabels = chart.getGroupLabels();
            for (i = 0; i < groupLabels.length; i++) {
                groupLabels[i] = chart.applyWrapAndTruncate(groupLabels[i], pieProps.label.font, pieProps.label.wrap, "title", w - 5);
                labelHeight = Math.max(labelHeight, chart.measureLabel(groupLabels[i], pieProps.label.font).height)
            }
        }
        var adjustedH = h - labelHeight - cdepth;
        var fullRadius = Math.min(w, adjustedH) / 2 - chart.getPadding("label", "aveHorz");
        var r = fullRadius;
        for (i = 0; i < data.length; i++)
            if (!data[i].length) {
                data[i] = [{
                    value: 0,
                    isDeleted: true,
                    noLabel: true,
                    zeroPie: true,
                    _s: 0,
                    _g: i
                }];
                data[i].size = 0
            } else {
                var filter = data[i].filter(function(el) {
                    return !el.noLabel
                });
                if (filter.length <= 0 || filter.every(function(el) {
                    return tdg.eq(el.value, 0)
                })) {
                    data[i] = [{
                        value: 0,
                        isDeleted: true,
                        noLabel: true,
                        zeroPie: true,
                        _s: 0,
                        _g: i
                    }];
                    data[i].size = 0
                }
            }
        var needSizeScale = minMaxPieSize != null;
        r = reduceRadiusForExplode(chart, r, seriesCount);
        if (chart.areDataLabelsOutside() && !pieProps.multiRing) {
            var labelSize = maxLabelSize(chart, data);
            var extraPad = getExtrapad(chart, data, labelSize.dataLabelFont);
            r = reduceRadiusForOutsideLabels(chart, data, r, w, h, adjustedH, extraPad, labelSize)
        }
        r = Math.max(r, Math.min(w, h) * .2);
        function getRadius() {
            if (needSizeScale) {
                var sizeData = chart.chartType === "matrix" ? data : undefined;
                var radiusRange = {
                    min: undefined,
                    max: Math.max(r, Math.min(w, h) * .2)
                };
                var valueRange = {
                    min: minMaxPieSize.min,
                    max: minMaxPieSize.max
                };
                r = chart.dataDrivenMarkerSize(undefined, radiusRange, valueRange, sizeData);
                return r
            }
            return r
        }
        vInset = (w - r - r) / 2;
        hInset = (adjustedH - r - r) / 2;
        var explodeOffset = function() {
            return 0
        };
        if (seriesCount > 1) {
            var explodeLookup = chart.seriesPropertyLookup("explodeSlice");
            explodeOffset = function(mark, d, angleFx) {
                var v = explodeLookup.call(mark, d);
                v = tdg.applyNumOrPercent(v, fullRadius);
                return v > 0 ? v * angleFx(mark.startAngle() + mark.angle() / 2) : 0
            }
        }
        var explodeSelectedAngle;
        if (chart.pieProperties.groupPiesBySelection && colorBySelection) {
            var dataSum = data[0].total - tdg.sum(data[0].slice(seriesCount), "value");
            var direction = pieRotation < 0 ? -1 : 1;
            explodeSelectedAngle = data[0].scale(dataSum * direction) / 2 - Math.PI / 2
        }
        function top(d, data) {
            var explode = d != null ? explodeOffset(this, d, Math.sin) : 0;
            if (explodeSelectedAngle && this.index < seriesCount)
                return hInset + r + explode + 15 * Math.sin(explodeSelectedAngle);
            if (needSizeScale) {
                hInset = (adjustedH - 2 * data.radius) / 2;
                data.hInset = hInset;
                return hInset + data.radius + explode
            }
            return hInset + r + explode
        }
        function left(d, data) {
            var explode = d != null ? explodeOffset(this, d, Math.cos) : 0;
            if (explodeSelectedAngle && this.index < seriesCount)
                return vInset + r + explode + 15 * Math.cos(explodeSelectedAngle);
            if (needSizeScale) {
                vInset = (w - 2 * data.radius) / 2;
                data.vInset = vInset;
                return vInset + data.radius + explode
            }
            return vInset + r + explode
        }
        function startAngle() {
            var s = this.sibling();
            return s ? s.endAngle : -Math.PI / 2 + tdg.radians(pieRotation)
        }
        function deleteWrapper(lookup, nullValue) {
            return function() {
                var d = arguments[0] || {};
                return d.isDeleted ? nullValue : lookup.apply(this, arguments)
            }
        }
        var classNameLookup = chart.classNameLookup("wedge", "riser");
        function classNameWrapper(d) {
            var res = classNameLookup.call(this, d);
            if (d.zeroPie) {
                var ids = chart.classNameToIds(res);
                ids.series = ids.group = null;
                return chart.buildClassName(ids)
            }
            return d.isOtherSlice ? res.replace("wedge", "other") : res
        }
        function classNameSelectedLookup(mid, oid) {
            var classNameLookup = chart.classNameLookup(mid, oid);
            return function() {
                var res = classNameLookup.call(this);
                return this.index < seriesCount ? res + "Selection" : res
            }
        }
        var innerRadius;
        var depth = chart.depth25d();
        var wedge = panel.add(depth ? pv.Wedge25d : pv.Wedge).className(classNameWrapper).shadow(function(d) {
            if (d.value && d.noLabel)
                return null;
            return chart.riserShadow ? "parent" : null
        }).data(function(d) {
            return d
        }).includeAngles(chart.pieProperties.explodeClick.enabled || chart.needHTMLToolTip()).includeRadius(chart.needHTMLToolTip()).fillStyle(zeroPieWrapper(chart.seriesColorLookup(), pieProps.zeroStyle.color, "transparent")).lineWidth(zeroPieWrapper(chart.seriesPropertyLookup("border.width"), pieProps.zeroStyle.border.width, 0)).strokeStyle(zeroPieWrapper(chart.seriesPropertyLookup("border.color"), pieProps.zeroStyle.border.color, "transparent")).dashStyle(deleteWrapper(chart.seriesPropertyLookup("border.dash"), pieProps.zeroStyle.border.dash)).title(deleteWrapper(chart.seriesToolTipLookup(), ""));
        if (pieProps.multiRing) {
            var pieTotal = panel.total;
            innerRadius = function() {
                var s = this.sibling();
                return s ? s.outerRadius : 0
            }
            ;
            var outerRadius = function(d, data) {
                return r * d.value / data.total + this.innerRadius()
            };
            var multiAngle = function(d, data) {
                return Math.PI * 2 * tdg.sum(data, "value") / pieTotal
            };
            var multiStartAngle = function() {
                var s = this.cousin();
                return s ? s.endAngle : -Math.PI / 2 + tdg.radians(pieRotation)
            };
            wedge.innerRadius(innerRadius).outerRadius(outerRadius).startAngle(multiStartAngle).angle(multiAngle).top(top).left(left)
        } else {
            var rAngle = function(d, data) {
                return angle(d, data, pieRotation)
            };
            if (needSizeScale)
                innerRadius = function(d, data) {
                    return holeSizeFromRadius(chart, data.radius)
                }
                ;
            else
                innerRadius = holeSizeFromRadius(chart, r);
            wedge.def("shape", "pie").outerRadius(getRadius()).innerRadius(innerRadius).startAngle(startAngle).angle(rAngle).top(top).left(left);
            if (colorBySelection)
                if (chart.pieProperties.groupPiesBySelection)
                    wedge.className(classNameSelectedLookup("wedge", "riser")).add(pv.Wedge).visible(function(d) {
                        return d._isSelection
                    }).fillStyle(chart.dataSelection.unselectedColor || "black");
                else {
                    var childWedge = wedge.add(pv.Wedge);
                    var border = chart.dataSelection.unselectedBorder || {
                        width: 0,
                        color: "transparent",
                        dash: ""
                    };
                    var getParent = function(el) {
                        return el.parent.children[el.childIndex - 1]
                    };
                    var childData = chart.getColorMetricData().map(function(el) {
                        return el[1] == null || el[1].value == null ? {
                            value: 0
                        } : el[1]
                    });
                    childWedge.data(childData).startAngle(function() {
                        return getParent(this).endAngle() - this.angle()
                    }).outerRadius(function() {
                        return getParent(this).outerRadius() * .9
                    }).left(function() {
                        return getParent(this).left()
                    }).top(function() {
                        return getParent(this).top()
                    }).fillStyle(chart.dataSelection.unselectedColor || "black").lineStyle(border)
                }
            else if (colorMode === "byMetric")
                wedge.add(pv.Panel).data(chart.getColorMetricData()).strokeStyle(null).fillStyle(null).top(null).left(null).add(pv.Wedge).data(function(d) {
                    return d
                }).startAngle(function() {
                    var s = this.sibling();
                    return s ? s.endAngle : wedge.scene[this.parent.index].startAngle
                }).angle(function(d) {
                    var direction = pieRotation < 0 ? -1 : 1;
                    return data[0].scale(d.value * direction)
                }).left(function() {
                    return wedge.scene[this.parent.index].left
                }).top(function() {
                    return wedge.scene[this.parent.index].top
                }).fillStyle(function(d, metricData) {
                    if (this.index === metricData.length - 1)
                        return chart.dataSelection.unselectedColor || "grey";
                    return chart.colorMode.colorList[this.index] || "black"
                }).strokeStyle(function() {
                    return (chart.getSeries(this.parent.index) || {
                        color: "black"
                    }).color
                }).lineWidth(chart.seriesPropertyLookup("border.width")).dashStyle(chart.seriesPropertyLookup("border.dash")).outerRadius(r)
        }
        if (depth)
            wedge.depth(depth).skew(chart.pieProperties.skew);
        addOtherDrillDown(chart);
        var bevel = chart.addBevel(wedge);
        if (bevel) {
            bevel.events("none");
            if (chart.pieProperties.groupPiesBySelection && colorBySelection)
                bevel.className(classNameSelectedLookup("bevel", "riser"))
        }
        addExplodeClick(chart);
        function offsetInsideTop(target, side, d) {
            var mark = target.anchorTarget();
            var angle = mark.startAngle() + mark.angle() / 2;
            var radius = mark.outerRadius();
            var font = chart.getSeriesAndGroupProperty(d._s, d._g, "dataLabels.font");
            var labelSize = tdgchart.measureLabel(target.text(), font);
            var offset = offsetInsideTopLabel(labelSize.width + 5, labelSize.height + 5, radius, angle);
            return offset[side] + mark[side]()
        }
        function dataLabelPosition(pos) {
            return chart.getSeriesProperty("dataLabels.position").some(function(el) {
                return el === pos
            })
        }
        var labels;
        if (chart.areDataLabelsVisible()) {
            if (dataLabelPosition("outside") && !pieProps.multiRing)
                labels = drawLabelsOutside(chart, wedge, r, vInset, hInset, explodeOffset, explodeSelectedAngle, extraPad);
            else if (dataLabelPosition("outsideAuto"))
                labels = drawLabelsInAndOut(chart, wedge);
            else if (dataLabelPosition("insideTop"))
                labels = chart.doDataLabels(wedge, "outer", {
                    textAlign: "center",
                    textBaseline: "middle",
                    left: function(d) {
                        return offsetInsideTop(this, "left", d)
                    },
                    top: function(d) {
                        return offsetInsideTop(this, "top", d)
                    }
                });
            else
                labels = chart.doDataLabels(wedge, "center");
            if (labels && chart.pieProperties.groupPiesBySelection && colorBySelection)
                labels.className(classNameSelectedLookup("dataLabels", "dataLabels"))
        }
        if (pieProps.label.visible)
            drawPieChartLabel(chart, groupLabels, panel, left);
        if (pieProps.totalLabel.visible)
            drawPieChartTotalLabel(chart, chart.pieProperties.totalLabel, panel, top, left, innerRadius);
        if (chart.pieDrillDataStack != null)
            addDrillDownArrow(chart, panel);
        chart.drawChartAnnotations(panel, data.length)
    }
    function normCos(a) {
        if (tdg.eq(a % 360, 0) || tdg.eq(a % 360, 180) || tdg.eq(a % 360, 360))
            return 0;
        else if (tdg.eq(a % 360, 90))
            return 1;
        else if (tdg.eq(a % 360, 270))
            return -1;
        return Math.cos(tdg.radians(a - 90))
    }
    function normSin(a) {
        if (tdg.eq(a % 360, 90) || tdg.eq(a % 360, 270))
            return 0;
        else if (tdg.eq(a % 360, 180))
            return 1;
        else if (tdg.eq(a % 360, 0) || tdg.eq(a % 360, 360))
            return -1;
        return Math.sin(tdg.radians(a - 90))
    }
    function normCosSin(a) {
        return {
            x: normCos(a),
            y: normSin(a)
        }
    }
    function roundN(v, n) {
        if (!isNaN(parseFloat(v)) && isFinite(v))
            return Math.round(v * n) / n;
        else
            return v
    }
    function round0(v) {
        return roundN(v, 1)
    }
    function round1(v) {
        return roundN(v, 10)
    }
    function round2(v) {
        return roundN(v, 100)
    }
    function wedgePath(as, ae, ri, ro, zeroPie) {
        var fullRing = ae - as >= 360;
        var largeRing = ae - as > 180 ? 1 : 0;
        var ps = normCosSin(as);
        var pe = normCosSin(ae);
        var p = new tdgchart.tdgscene.path;
        if (!ri)
            if (zeroPie || fullRing) {
                p.moveTo(ro, 0);
                p.arcTo(ro, ro, 0, 0, 1, -ro, 0);
                p.arcTo(ro, ro, 0, 0, 1, ro, 0)
            } else {
                p.moveTo(0, 0);
                p.lineTo(ro * ps.x, ro * ps.y);
                p.arcTo(ro, ro, 0, largeRing, 1, ro * pe.x, ro * pe.y);
                p.closePath()
            }
        else if (zeroPie || fullRing) {
            p.moveTo(ro, 0);
            p.arcTo(ro, ro, 0, 0, 1, -ro, 0);
            p.arcTo(ro, ro, 0, 0, 1, ro, 0);
            p.moveTo(ri, 0);
            p.arcTo(ri, ri, 0, 0, 0, -ri, 0);
            p.arcTo(ri, ri, 0, 0, 0, ri, 0)
        } else {
            p.moveTo(ro * ps.x, ro * ps.y);
            p.arcTo(ro, ro, 0, largeRing, 1, ro * pe.x, ro * pe.y);
            p.lineTo(ri * pe.x, ri * pe.y);
            p.arcTo(ri, ri, 0, largeRing, 0, ri * ps.x, ri * ps.y);
            p.closePath()
        }
        return p
    }
    function roundedWedgePath(as, ae, ri, ro, zeroPie) {
        var p = new tdgchart.tdgscene.path;
        as = as || 0;
        ae = ae || 0;
        var rio = (ri + ro) / 2;
        var rr = (ro - ri) / 2;
        if (as > ae) {
            as = -as;
            ae = -ae
        }
        var fullRing = ae - as >= 360;
        if (!fullRing && !zeroPie) {
            as += .2;
            ae -= .2
        }
        var ps = normCosSin(as);
        if (fullRing || zeroPie) {
            var pm = normCosSin(as + 180);
            p.moveTo(ro * ps.x, ro * ps.y);
            p.arcTo(ro, ro, 0, 0, 1, ro * pm.x, ro * pm.y);
            p.arcTo(ro, ro, 0, 0, 1, ro * ps.x, ro * ps.y);
            p.moveTo(ri * ps.x, ri * ps.y);
            p.arcTo(ri, ri, 0, 0, 0, ri * pm.x, ri * pm.y);
            p.arcTo(ri, ri, 0, 0, 0, ri * ps.x, ri * ps.y);
            p.moveTo(ro * ps.x, ro * ps.y);
            return p
        }
        var pe = normCosSin(ae);
        var ad = Math.min(rr / tdg.radians(rio), (ae - as) / 2);
        var arclen = tdg.radians(ae - as) * rio;
        if (arclen < 2 * rr) {
            var pse = normCosSin((as + ae) / 2);
            p.moveTo(rio * ps.x, rio * ps.y);
            p.arcTo(arclen / 2, rr, (ae + as) / 2, 0, 1, ro * pse.x, ro * pse.y);
            p.arcTo(arclen / 2, rr, (ae + as) / 2, 0, 1, rio * pe.x, rio * pe.y);
            p.arcTo(arclen / 2, rr, (ae + as) / 2, 0, 1, ri * pse.x, ri * pse.y);
            p.arcTo(arclen / 2, rr, (ae + as) / 2, 0, 1, rio * ps.x, rio * ps.y);
            p.closePath();
            return p
        }
        var pps = normCosSin(as + ad);
        var ppe = normCosSin(ae - ad);
        var large = ae - as - 2 * ad > 180 ? 1 : 0;
        var p = new tdgchart.tdgscene.path;
        p.moveTo(rio * ps.x, rio * ps.y);
        p.arcTo(rr, rr, 0, 0, 1, ro * pps.x, ro * pps.y);
        p.arcTo(ro, ro, 0, large, 1, ro * ppe.x, ro * ppe.y);
        p.arcTo(rr, rr, 0, 0, 1, rio * pe.x, rio * pe.y);
        p.arcTo(rr, rr, 0, 0, 1, ri * ppe.x, ri * ppe.y);
        p.arcTo(ri, ri, 0, large, 0, ri * pps.x, ri * pps.y);
        p.arcTo(rr, rr, 0, 0, 1, rio * ps.x, rio * ps.y);
        p.closePath();
        return p
    }
    function createEmptyPies(chart, data, node) {
        for (var i = 0; i < data.length; i++) {
            var allEmpty;
            if (!data[i].length)
                allEmpty = true;
            else {
                var dataWithLabels = data[i].filter(function(el) {
                    return !el.noLabel
                });
                allEmpty = dataWithLabels.length <= 0 || dataWithLabels.every(function(el) {
                    return tdg.eq(el.value, 0)
                })
            }
            if (!allEmpty)
                continue;
            var zeroPieRiserData = {
                value: 0,
                isDeleted: true,
                noLabel: true,
                zeroPie: true,
                _s: 0,
                _g: i
            };
            if (chart.chartType === "matrix")
                if (data[i][0] && data[i][0]._c != undefined) {
                    zeroPieRiserData._c = data[i][0]._c;
                    zeroPieRiserData._r = data[i][0]._r
                } else {
                    var rowCol = chart.getMatrixRowCol(node);
                    zeroPieRiserData._c = rowCol.col;
                    zeroPieRiserData._r = rowCol.row
                }
            data[i] = [zeroPieRiserData];
            data[i].size = 0
        }
    }
    function getSelectedExplode(chart, data, seriesCount, direction, colorBySelection) {
        if (chart.pieProperties.groupPiesBySelection && colorBySelection) {
            var dataSum = data[0].total - tdg.sum(data[0].slice(seriesCount), "value");
            explodeSelectedAngle = data[0].scale(dataSum * direction) / 2 - Math.PI / 2;
            return {
                angle: explodeSelectedAngle,
                x: Math.cos(explodeSelectedAngle),
                y: Math.sin(explodeSelectedAngle)
            }
        }
        return null
    }
    function getExplode(chart, d, explodeSelected, midangle, r, arc) {
        var e = {
            x: 0,
            y: 0
        };
        if (Math.abs(arc) < 360) {
            if (d._isSelection && explodeSelected) {
                e.x += explodeSelected.x * 15;
                e.y += explodeSelected.y * 15
            }
            var explodedRadius = tdg.applyNumOrPercent(chart.getSerDepProperty("explodeSlice", d), r);
            if (explodedRadius) {
                e.x += midangle.x * explodedRadius;
                e.y += midangle.y * explodedRadius
            }
        }
        return e
    }
    function drawPieScene(chart, panel, w, h, data, sizeScale) {
        var pieProps = chart.pieProperties;
        var isRoundRing = pieProps.effect === "roundRing";
        var wedgeFn = isRoundRing ? roundedWedgePath : wedgePath;
        var scene = chart.cache.get("tdgscene");
        var groupPanel = scene.group(panel.parent, "groupPanel");
        var colorLookup = zeroPieWrapper(chart.seriesColorLookup({
            width: w,
            height: h,
            isScene: true
        }), pieProps.zeroStyle.color, "transparent");
        var lineStyleLookup = zeroPieWrapper(chart.seriesPropertyLookup("border"), pieProps.zeroStyle.border, {
            width: 0,
            color: "transparent"
        });
        var tooltipLookup = chart.seriesToolTipLookup();
        var seriesCount = chart.seriesCount();
        var pieRotation = pieProps.rotation || 0;
        var direction = pieRotation < 0 ? -1 : 1;
        data = sortPieData(chart, data);
        createEmptyPies(chart, data, groupPanel);
        var groupLabels, labelHeight = 0;
        if (pieProps.label.visible) {
            groupLabels = chart.getGroupLabels().map(function(label) {
                return chart.applyWrapAndTruncate(label, pieProps.label.font, pieProps.label.wrap, "title", w - 5)
            });
            labelHeight = tdg.max(groupLabels.map(function(label) {
                return chart.measureLabel(label, pieProps.label.font).height
            }))
        }
        var cdepth = 0;
        var adjustedH = h - labelHeight - cdepth;
        var fullRadius = Math.min(w, adjustedH) / 2 - chart.getPadding("label", "aveHorz");
        var cols = chart.chartsPerRow > 0 ? Math.min(Math.round(chart.chartsPerRow), chart.groupCount()) : Math.ceil(Math.sqrt(data.length));
        var riserList = [];
        var labelsOutside = chart.areDataLabelsOutside() && !pieProps.multiRing;
        var labelsOutsideAuto = !labelsOutside && chart.areDataLabelsAt("outsideAuto");
        var labelsInsideTop = !labelsOutside && !labelsOutsideAuto && chart.areDataLabelsAt("insideTop");
        var labelSize;
        var r = reduceRadiusForExplode(chart, fullRadius, seriesCount);
        var radiusFn;
        if (sizeScale) {
            var sizeData = chart.chartType === "matrix" ? data : undefined;
            var radiusRange = {
                min: undefined,
                max: Math.max(r, Math.min(w, h) * .2)
            };
            var valueRange = {
                min: sizeScale.min,
                max: sizeScale.max
            };
            radiusFn = chart.dataDrivenMarkerSize(undefined, radiusRange, valueRange, sizeData)
        }
        var isLabelsVisible = chart.areDataLabelsVisible();
        if (labelsOutside || labelsOutsideAuto || labelsInsideTop)
            labelSize = allLabelSize(chart, data);
        if (labelsOutside) {
            var extraPad = getExtrapad(chart, data, labelSize.dataLabelFont);
            r = reduceRadiusForOutsideLabels(chart, data, r, w, h, adjustedH, extraPad, labelSize)
        }
        r = Math.max(r, Math.min(w, h) * .2);
        var colorMode = chart.getColorMode();
        var colorBySelection = colorMode === "bySeriesSelection" || colorMode === "byGroupSelection";
        var explodeSelected = getSelectedExplode(chart, data, seriesCount, direction, colorBySelection);
        var pieContainers = [], pieLabelsContainers = [], riser;
        for (var g = 0; g < data.length; g++) {
            var pieRisers = [];
            var start = pieRotation;
            var total = tdg.sum(data[g], "value");
            var pieContainer = groupPanel.group(undefined, w * (g % cols) + w / 2, h * Math.floor(g / cols) + adjustedH / 2);
            pieContainers.push(pieContainer);
            var pieRisersContainer = pieContainer.group("risers");
            var ro = !sizeScale ? r : radiusFn.call({
                engine: "pie"
            }, r, data[g], data);
            var ri = holeSizeFromRadius(chart, ro, isRoundRing);
            if (colorBySelection || colorMode === "byMetric")
                var childRiserContainer = pieContainer.group("childRisers");
            pieLabelsContainers.push(pieContainer.group("labels"));
            for (var s = 0; s < data[g].length; s++) {
                var d = data[g][s];
                var arc = !total ? 360 : 360 * (d.value / total) * direction;
                if ((d.isDeleted || d.noLabel) && !d.zeroPie) {
                    start += arc;
                    continue
                }
                var midRadians = tdg.radians(tdg.boundAngle(start + arc / 2 + 270, "degrees"));
                var pse = {
                    x: Math.cos(midRadians),
                    y: Math.sin(midRadians)
                };
                var explode = getExplode(chart, d, explodeSelected, pse, fullRadius, arc);
                var astart = Math.min(start, start + arc)
                  , aend = Math.max(start, start + arc);
                var p = wedgeFn(astart, aend, ri, ro, d.zeroPie);
                var className = chart.getRiserClassName(pieContainer, d, "riser", d.isOtherSlice ? "other" : "wedge");
                riserList[s] = riserList[s] || [];
                riser = riserList[s][g] = pieRisers[s] = {
                    d: d,
                    data: data[g],
                    type: "wedge",
                    riserShape: "wedge",
                    ignoreLabel: !isLabelsVisible || d.noLabel || !chart.getSerDepProperty("dataLabels.visible", d),
                    props: {
                        x: explode.x,
                        y: explode.y,
                        w: 0,
                        h: 0
                    }
                };
                riser.element = pieRisersContainer.path(riser.props.x, riser.props.y, p, {
                    color: colorLookup(d),
                    lineStyle: lineStyleLookup(d),
                    "class": className,
                    title: tooltipLookup(d, data[g]),
                    attributes: {
                        "tdg:angle": isNaN(midRadians) ? undefined : midRadians,
                        "tdg:wedge": [pieContainer.x + riser.props.x, pieContainer.y + riser.props.y, round2(astart), round2(aend), round2(ri), round2(ro), d.zeroPie ? 1 : 0].join(" ")
                    }
                });
                riser.element.props.ro = ro;
                riser.element.props.ri = ri;
                start += arc;
                var bevel = chart.addBevel(riser.element, pieRisersContainer, "wedge");
                if (!riser.ignoreLabel) {
                    riser.anchorPos = {
                        x: pse.x * ro,
                        y: pse.y * ro,
                        explode: explode,
                        a: midRadians,
                        xParam: pse.x,
                        yParam: pse.y
                    };
                    if (!labelsOutside) {
                        riser.labelPosition = "center";
                        if (Math.abs(arc) >= 360 && !ri)
                            riser.labelAnchorOffset = {
                                x: 0,
                                y: 0
                            };
                        else if (labelsOutsideAuto)
                            if (labelExceeds(ri, ro, tdg.radians(astart - 90), tdg.radians(aend - astart), labelSize.sizes[g][s]))
                                riser.ignoreLabel = true;
                            else
                                riser.labelAnchorOffset = {
                                    x: pse.x * (ri + ro) / 2,
                                    y: pse.y * (ri + ro) / 2
                                };
                        else if (labelsInsideTop) {
                            var offset = offsetInsideTopLabel(labelSize.sizes[g][s].width + 5, labelSize.sizes[g][s].height + 5, ro, midRadians);
                            riser.labelAnchorOffset = {
                                x: offset.left,
                                y: offset.top
                            }
                        } else
                            riser.labelAnchorOffset = {
                                x: pse.x * (ri + ro) / 2,
                                y: pse.y * (ri + ro) / 2
                            }
                    } else {
                        var labelsOnRight = midRadians >= Math.PI / 2 && midRadians < 3 * Math.PI / 2;
                        var sideSign = labelsOnRight ? -1 : 1;
                        riser.labelPosition = labelsOnRight ? "left" : "right",
                        riser.anchorPos.feelerMid = {
                            x: feelerLength * riser.anchorPos.xParam,
                            y: feelerLength * riser.anchorPos.yParam
                        };
                        riser.anchorPos.feelerTip = {
                            x: feelerTipLength * sideSign,
                            y: 0
                        };
                        riser.labelAnchorOffset = {
                            x: riser.anchorPos.x + riser.anchorPos.feelerMid.x + riser.anchorPos.feelerTip.x - 1 * sideSign,
                            y: riser.anchorPos.y + riser.anchorPos.feelerMid.y + riser.anchorPos.feelerTip.y
                        }
                    }
                }
                if (colorBySelection)
                    if (chart.pieProperties.groupPiesBySelection) {
                        if (d._isSelection) {
                            riser.element["class"] += "Selection";
                            var p = wedgePath(astart, aend, ri, ro);
                            childRiserContainer.path(riser.props.x, riser.props.y, p, {
                                color: chart.dataSelection.unselectedColor || "black"
                            })
                        }
                    } else {
                        var childData = childData || chart.getColorMetricData().map(function(el) {
                            return el[1] == null || el[1].value == null ? {
                                value: 0
                            } : el[1]
                        });
                        var angle = 360 * (childData[s].value / total) * direction;
                        var p = wedgePath(aend - angle, aend, ri, ro * .9);
                        childRiserContainer.path(riser.props.x, riser.props.y, p, {
                            color: chart.dataSelection.unselectedColor || "black",
                            lineStyle: chart.dataSelection.unselectedBorder || {
                                width: 0,
                                color: "transparent",
                                dash: ""
                            }
                        })
                    }
                else {
                    var childData = childData || chart.getColorMetricData();
                    if (colorMode === "byMetric" && childData && childData[s]) {
                        var cstart = astart;
                        for (var cs = 0; cs < childData[s].length; cs++) {
                            if (isNaN(childData[s][cs].value))
                                continue;
                            var cangle = 360 * (Math.abs(childData[s][cs].value) / total) * direction;
                            var p = wedgePath(cstart, cstart + cangle, ri, ro);
                            var lineStyle = lineStyleLookup(childData[s][cs]) || {
                                width: 1,
                                dash: ""
                            };
                            childRiserContainer.path(riser.props.x, riser.props.y, p, {
                                color: cs == childData[s].length - 1 ? chart.dataSelection.unselectedColor || "grey" : chart.colorMode.colorList[cs] || "black",
                                lineStyle: {
                                    color: (chart.getSeries(s) || {
                                        color: "black"
                                    }).color,
                                    width: lineStyle.width,
                                    dash: lineStyle.dash
                                }
                            });
                            cstart += cangle
                        }
                    }
                }
            }
            if (labelsOutside)
                adjustOutsideLabels(chart, data[g], g, pieRisers, labelSize, ro, direction, w > h)
        }
        addOtherDrillDown(chart);
        addExplodeClick(chart);
        if (labelsOutside)
            drawFeelers(chart, pieLabelsContainers, 0, 0, riserList);
        var labels = chart.doDataLabelsScene(pieLabelsContainers, riserList);
        if (pieProps.totalLabel.visible)
            drawPieChartTotalLabelScene(chart, data, chart.pieProperties.totalLabel, pieContainers, 0, 0, ri);
        if (pieProps.label.visible)
            drawPieChartLabelScene(chart, groupLabels, pieContainers, 0, -adjustedH / 2 + h);
        if (chart.pieDrillDataStack != null)
            addDrillDownArrow(chart, panel);
        chart.drawChartAnnotations(panel, data.length)
    }
    function drawMultiringScene(chart, panel, w, h, data, overallTotal) {
        var pieProps = chart.pieProperties;
        var scene = chart.cache.get("tdgscene");
        var groupPanel = scene.group(panel, "groupPanel");
        var colorLookup = zeroPieWrapper(chart.seriesColorLookup({
            width: w,
            height: h,
            isScene: true
        }), pieProps.zeroStyle.color, "transparent");
        var lineStyleLookup = zeroPieWrapper(chart.seriesPropertyLookup("border"), pieProps.zeroStyle.border, {
            width: 0,
            color: "transparent"
        });
        var seriesCount = chart.seriesCount();
        var pieRotation = pieProps.rotation || 0;
        var direction = pieRotation < 0 ? -1 : 1;
        data = sortPieData(chart, data);
        createEmptyPies(chart, data, groupPanel);
        var groupLabels, labelHeight = 0;
        if (pieProps.label.visible) {
            groupLabels = chart.getGroupLabels().map(function(label) {
                return chart.applyWrapAndTruncate(label, pieProps.label.font, pieProps.label.wrap, "title", w - 5)
            });
            labelHeight = tdg.max(groupLabels.map(function(label) {
                return chart.measureLabel(label, pieProps.label.font).height
            }))
        }
        var cdepth = 0;
        var adjustedH = h - labelHeight - cdepth;
        var fullRadius = Math.min(w, adjustedH) / 2 - chart.getPadding("label", "aveHorz");
        var riserList = [];
        var r = reduceRadiusForExplode(chart, fullRadius, seriesCount);
        var isLabelsVisible = chart.areDataLabelsVisible();
        r = Math.max(r, Math.min(w, h) * .2);
        var pieLabelsContainers = [], riser;
        var start = pieRotation;
        var multiTotal = tdg.sum(data.map(function(dg) {
            return Math.abs(dg.total)
        }));
        var pieContainer = groupPanel.group(undefined, w / 2, adjustedH / 2);
        for (var g = 0; g < data.length; g++) {
            var pieRisersContainer = pieContainer.group("risers");
            pieLabelsContainers.push(pieContainer.group("labels"));
            var arc = 360 * (Math.abs(data[g].total) / multiTotal) * direction;
            var astart = Math.min(start, start + arc)
              , aend = Math.max(start, start + arc);
            for (var s = 0, sum = 0, ro = 0; s < data[g].length; s++) {
                var slicexoff = 0
                  , sliceyoff = 0;
                var d = data[g][s];
                var midRadians = tdg.radians(tdg.boundAngle(start + arc / 2 + 270, "degrees"));
                var pse = {
                    x: Math.cos(midRadians),
                    y: Math.sin(midRadians)
                };
                var explodedRadius = Math.abs(arc) < 360 && tdg.applyNumOrPercent(chart.getSerDepProperty("explodeSlice", d), r);
                if (explodedRadius) {
                    slicexoff += pse.x * explodedRadius;
                    sliceyoff += pse.y * explodedRadius
                }
                sum += d.value;
                ri = ro;
                ro = Math.abs(sum / data[g].total) * r;
                var p = wedgePath(astart, aend, ri, ro, d.zeroPie);
                var className = chart.getRiserClassName(pieContainer, d, "riser", d.isOtherSlice ? "other" : "wedge");
                riserList[s] = riserList[s] || [];
                riser = riserList[s][g] = {
                    d: d,
                    data: data[g],
                    type: "wedge",
                    riserShape: "wedge",
                    ignoreLabel: !isLabelsVisible || d.noLabel || !chart.getSerDepProperty("dataLabels.visible", d),
                    props: {
                        x: slicexoff,
                        y: sliceyoff,
                        w: 0,
                        h: 0
                    }
                };
                riser.element = pieRisersContainer.path(slicexoff, sliceyoff, p, {
                    color: colorLookup(d),
                    lineStyle: lineStyleLookup(d),
                    "class": className,
                    title: chart.getSerDepProperty("tooltip", d),
                    attributes: {
                        "tdg:wedge": [pieContainer.x + riser.props.x, pieContainer.y + riser.props.y, round2(astart), round2(aend), round2(ri), round2(ro), d.zeroPie ? 1 : 0].join(" ")
                    }
                });
                riser.element.props.ro = ro;
                riser.element.props.ri = ri;
                var bevel = chart.addBevel(riser.element, pieRisersContainer, "wedge");
                if (!riser.ignoreLabel) {
                    riser.labelPosition = "center";
                    if (Math.abs(arc) >= 360 && !ri)
                        riser.labelAnchorOffset = {
                            x: 0,
                            y: 0
                        };
                    else
                        riser.labelAnchorOffset = {
                            x: pse.x * (ri + ro) / 2,
                            y: pse.y * (ri + ro) / 2
                        }
                }
            }
            start += arc
        }
        var labels = chart.doDataLabelsScene(pieLabelsContainers, riserList);
        if (pieProps.totalLabel.visible) {
            var tData = [[data[0][0]]];
            tData[0].total = overallTotal;
            drawPieChartTotalLabelScene(chart, tData, chart.pieProperties.totalLabel, [groupPanel], w / 2, adjustedH / 2, null)
        }
        if (pieProps.label.visible)
            drawPieChartLabelScene(chart, groupLabels, [pieContainer], 0, -adjustedH / 2 + h)
    }
    function getFeelerLookups(chart) {
        var seriesCount = chart.seriesCount();
        var lookups = {};
        lookups.feelerStyleLookup = chart.seriesPropertyLookup("dataLabels.feelerLine");
        var mode = chart.getColorMode();
        if ((mode === "byMetric" || mode === "bySeriesSelection" || mode === "byGroupSelection") && chart.pieProperties.groupPiesBySelection)
            lookups.feelerClassLookup = function(mid, oid) {
                var classNameLookup = chart.classNameLookup(mid, oid);
                return function() {
                    var res = classNameLookup.call(this);
                    return this.index < seriesCount ? res + "Selection" : res
                }
            }
            ;
        else
            lookups.feelerClassLookup = chart.classNameLookup("feeler", "feeler");
        return lookups
    }
    function adjustOutsideLabels(chart, groupData, g, pieRisers, labelSize, ro, direction, horizontalContainer) {
        var quartersCheckOrder = direction > 0 ? [2, 1, 4, 3] : [1, 2, 3, 4];
        var neighborCheckOrder = direction > 0 ? [null, null, 1, 2] : [null, null, 2, 1];
        function quarter(a, d, isLast) {
            if (a < Math.PI / 2)
                return 1;
            else if (a < Math.PI)
                return 2;
            else if (a < 3 * Math.PI / 2)
                return 3;
            return 4
        }
        var quarters = pieRisers.map(function(r, i) {
            return r.ignoreLabel || r.anchorPos.feelerTip == undefined ? 0 : quarter(r.anchorPos.a, r.d, i == pieRisers.length - 1)
        });
        function adjustPair(index, next, checkQuarter, checkNeighbour, moveUpwards) {
            if (!quarters[index] || !quarters[next])
                return;
            if (quarters[index] != checkQuarter)
                return;
            if (quarters[next] != checkQuarter && quarters[next] != checkNeighbour)
                return;
            var movedLabel = pieRisers[index];
            var fixedlabel = pieRisers[next];
            var height = (labelSize.sizes[g][index].height + labelSize.sizes[g][next].height) / 2;
            if (moveUpwards) {
                if (fixedlabel.labelAnchorOffset.y - movedLabel.labelAnchorOffset.y < height) {
                    movedLabel.anchorPos.feelerMid.y -= height - (fixedlabel.labelAnchorOffset.y - movedLabel.labelAnchorOffset.y);
                    movedLabel.labelAnchorOffset.y = movedLabel.anchorPos.y + movedLabel.anchorPos.feelerMid.y + movedLabel.anchorPos.feelerTip.y
                }
            } else if (movedLabel.labelAnchorOffset.y - fixedlabel.labelAnchorOffset.y < height) {
                movedLabel.anchorPos.feelerMid.y += height - (movedLabel.labelAnchorOffset.y - fixedlabel.labelAnchorOffset.y);
                movedLabel.labelAnchorOffset.y = movedLabel.anchorPos.y + movedLabel.anchorPos.feelerMid.y + movedLabel.anchorPos.feelerTip.y
            }
        }
        function labelToPieDecollision() {
            var collisionSide = [{
                isLeft: true,
                isTop: true
            }, {
                isLeft: false,
                isTop: true
            }, {
                isLeft: false,
                isTop: false
            }, {
                isLeft: true,
                isTop: false
            }];
            for (var s = 0; s < groupData.length; s++) {
                if (!quarters[s])
                    continue;
                var movedLabel = pieRisers[s];
                var cornerPos = {
                    x: 0,
                    y: 0 + (collisionSide[quarters[s] - 1].isTop ? -1 : 1) * labelSize.sizes[g][s].height / 2
                };
                var lx = movedLabel.labelAnchorOffset.x + cornerPos.x;
                var ly = movedLabel.labelAnchorOffset.y + cornerPos.y;
                if (lx * lx + ly * ly < ro * ro) {
                    movedLabel.labelAnchorOffset.cornerPos = cornerPos;
                    if (horizontalContainer) {
                        var nx = Math.sqrt(ro * ro - ly * ly);
                        var xd = movedLabel.labelAnchorOffset.x > 0 ? movedLabel.labelAnchorOffset.x - nx : movedLabel.labelAnchorOffset.x + nx;
                        movedLabel.labelAnchorOffset.x -= xd;
                        movedLabel.anchorPos.feelerTip.x -= xd
                    } else {
                        var ny = Math.sqrt(ro * ro - lx * lx);
                        var yd = movedLabel.labelAnchorOffset.y > 0 ? movedLabel.labelAnchorOffset.y - ny : movedLabel.labelAnchorOffset.y + ny;
                        movedLabel.labelAnchorOffset.y -= yd + cornerPos.y;
                        movedLabel.anchorPos.feelerMid.y -= yd + cornerPos.y
                    }
                }
            }
        }
        function labelToLabelDecollision() {
            if (groupData.length < 2)
                return;
            for (var i = 0; i < 4; i++) {
                var checkQuarter = quartersCheckOrder[i];
                var checkNeighbour = neighborCheckOrder[i];
                var reverse = i == 0 || i == 2;
                var s;
                if (reverse)
                    for (s = groupData.length - 1; s >= 0; s--)
                        adjustPair(s, (s + 1) % groupData.length, checkQuarter, checkNeighbour, i == 2 || i == 3);
                else
                    for (s = 0; s < groupData.length; s++)
                        adjustPair(s, (s - 1 + groupData.length) % groupData.length, checkQuarter, checkNeighbour, i == 2 || i == 3)
            }
        }
        labelToPieDecollision();
        labelToLabelDecollision()
    }
    function drawFeelers(chart, pieLabelsContainers, x, y, riserList) {
        var lookups = getFeelerLookups(chart);
        for (var s = 0; s < riserList.length; s++) {
            if (!riserList[s])
                continue;
            for (var g = 0; g < riserList[s].length; g++) {
                var riser = riserList[s][g];
                if (!riser || riser.ignoreLabel)
                    continue;
                var fpath = new tdgchart.tdgscene.path;
                fpath.moveTo(riser.anchorPos.x + riser.anchorPos.explode.x, riser.anchorPos.y + riser.anchorPos.explode.y);
                fpath.lineTo(riser.anchorPos.feelerMid.x, riser.anchorPos.feelerMid.y, true);
                fpath.lineTo(riser.anchorPos.feelerTip.x, riser.anchorPos.feelerTip.y, true);
                var feeler = pieLabelsContainers[g].path(x, y, fpath, {
                    lineStyle: lookups.feelerStyleLookup(riser.d),
                    "class": lookups.feelerClassLookup(riser.d)
                })
            }
        }
    }
    function drawPieChartLabelScene(chart, groupLabels, groups, x, y) {
        var o;
        for (var g = 0; g < groups.length; g++) {
            var group = groups[g].group();
            var labelStyle = {};
            labelStyle.className = chart.buildClassName("pieLabel", null, g, "pieLabel");
            labelStyle.align = "center";
            labelStyle.valign = "bottom";
            if (tdg.textContainsHTML(groupLabels[g])) {
                labelStyle.shift = -.65;
                o = 0
            } else {
                labelStyle.shift = undefined;
                o = chart.getPadding("label", "aveHorz")
            }
            labelStyle.color = chart.pieProperties.label.color;
            labelStyle.font = chart.pieProperties.label.font;
            labelStyle.translate = {
                x: x,
                y: y - o
            };
            group.label(0, 0, groupLabels[g], labelStyle)
        }
        return
    }
    function drawPieChartTotalLabelScene(chart, data, label, groups, x, y, holeRadius) {
        var font = label.font;
        var content = label.content
          , text = label.content;
        if (text === "auto")
            text = function(d, data) {
                return chart.formatNumber(data.total || 0, label.numberFormat, "totalLabel")
            }
            ;
        else if (tdgchart.templateEngine.isTemplateString(text))
            text = function(d, data) {
                d = (data || [])[0];
                var ids = chart.getMarkSeriesAndGroupID(this, d);
                return chart.parseTemplate(content, d, data, ids)
            }
            ;
        else if (typeof text != "function") {
            var statictext = text;
            text = function(d, data) {
                return statictext
            }
        }
        if (label.fontSize) {
            var fontParts = tdg.fontToFontParts(font);
            fontParts.fontSize = label.fontSize;
            font = fontParts.toString()
        } else if (holeRadius)
            font = function(d, data) {
                var r = typeof holeRadius === "function" ? holeRadius.call(this, d, data) : holeRadius;
                return r ? tdg.scaleFontToBox(text(data[g], data), label.font, r) : label.font
            }
            ;
        var labelStyle = {};
        labelStyle.className = chart.buildClassName("totalLabel", null, g, "totalLabel");
        labelStyle.align = "center";
        labelStyle.valign = "center";
        labelStyle.shift = -.15;
        labelStyle.color = label.color;
        labelStyle.font = font;
        for (var g = 0; g < groups.length; g++) {
            if (typeof font == "function")
                labelStyle.font = font(data[g][0], data[g]);
            labelStyle.translate = {
                x: x,
                y: y
            };
            var group = groups[g].group();
            group.label(0, 0, text(data[g][0], data[g]) || "", labelStyle)
        }
    }
    function getOtherSliceIndices(index, pieData) {
        index = index || 0;
        pieData = pieData || this.data;
        var threshold = getOtherSliceThreshold(this, index, pieData);
        if (!threshold)
            return [];
        var otherSeriesIndices = [];
        var i, data = pieData[index].slice(0);
        var sliceCount = data.length;
        for (i = 0; i < data.length; i++)
            if (data[i].value == null)
                data[i].value = 0;
        for (i = 0; i < data.length; i++)
            if (data[i].value < threshold.value) {
                otherSeriesIndices.push(i);
                sliceCount -= 1
            }
        if (threshold.type === "topX" && sliceCount > threshold.topX)
            for (i = data.length - 1; i >= 0; i--) {
                if (Math.abs(data[i].value - threshold.value) < 1E-4) {
                    otherSeriesIndices.push(i);
                    sliceCount -= 1
                }
                if (sliceCount <= threshold.topX)
                    break
            }
        return otherSeriesIndices
    }
    function getOtherSliceThreshold(chart, index, data) {
        var threshold = chart.get("pieProperties.otherSlice.threshold");
        if (threshold != null)
            if (typeof threshold === "string")
                if (threshold.trim().slice(0, 3).toLowerCase() === "top") {
                    var topX = parseInt(threshold.trim().slice(3).trim(), 10);
                    data = (data[index] || []).slice(0);
                    for (var i = 0; i < data.length; i++)
                        if (data[i].value == null)
                            data[i].value = 0;
                    threshold = {
                        type: "topX",
                        value: data.sort(function(d, e) {
                            return d.value - e.value
                        }).slice(-topX)[0].value,
                        topX: topX
                    }
                } else
                    threshold = {
                        type: "value",
                        value: tdg.sum(data[index], "value") * tdg.parsePercent(threshold)
                    };
            else {
                if (typeof threshold === "number")
                    threshold = {
                        type: "value",
                        value: threshold
                    }
            }
        else
            threshold = false;
        return threshold
    }
    function drawColorByMetricChart(chart, chartLayout, panel, pieData, metricData) {
        if (chart.colorMode.mode !== "byMetric" || chart.data.length !== 1)
            return undefined;
        pieData = pieData || chart.data;
        metricData = metricData || chart.data;
        metricData = chart.getColorMetricData(pieData, metricData);
        var originalData = pieData;
        chart.data = metricData;
        chart.drawPieChart(panel, chartLayout, metricData);
        chart.data = originalData;
        return undefined
    }
    function useSceneEngine(chart) {
        var newEngine = !chart.computeddepth25d();
        return newEngine
    }
    function drawPieChart(panel, chartLayout, pieData, metricData, minMax) {
        var chart = this;
        pieData = pieData || chart._internalData;
        metricData = metricData || chart.colorMode.data;
        var mode = this.getColorMode();
        if (mode === "byMetric" && chart.pieProperties.multiRing && !chart.colorMode.hasOwnProperty("isProcessed")) {
            chart.colorMode.isProcessed = true;
            drawColorByMetricChart(chart, chartLayout, panel, pieData, metricData);
            delete chart.colorMode.isProcessed;
            return undefined
        } else if ((mode === "bySeriesSelection" || mode === "byGroupSelection") && chart.pieProperties.groupPiesBySelection) {
            metricData = chart.getColorMetricData();
            pieData = chart.normalizeData([metricData.map(function(el) {
                return el[1].value
            }).concat(metricData.map(function(el) {
                return el[0].value
            }).reverse())]);
            pieData[0].forEach(function(el) {
                if (el._s >= metricData.length)
                    el._s = pieData[0].length - el._s - 1;
                else
                    el._isSelection = true
            })
        }
        var pieTotal = 0;
        var overallTotal = 0;
        var data = [];
        var sizeByPie = [], minMaxPieSize;
        for (var i = 0; i < pieData.length; i++) {
            var otherIndices = chart.getOtherSliceIndices(i, pieData);
            var others = {
                value: 0,
                _g: i
            };
            data.push([]);
            sizeByPie[i] = 0;
            for (var j = 0; j < pieData[i].length; j++) {
                var d = pieData[i][j];
                var val = d != null ? d.value : undefined;
                var n = tdg.cloneObject(d);
                n.value = Math.abs(val || 0);
                if (val == null)
                    n.noLabel = true;
                if (chart.getSeriesAndGroupProperty(j, null, "deleteSlice")) {
                    n.isDeleted = true;
                    n.noLabel = true
                }
                pieTotal += n.isDeleted || n.noLabel ? 0 : val;
                sizeByPie[i] += d != null && d.size != null ? d.size : 0;
                n.isNeg = val < 0;
                if (otherIndices.includes(j)) {
                    if (d != null)
                        d.noLabel = true;
                    others.value += n.value;
                    n = {
                        _s: n._s,
                        _g: n._g,
                        value: 0,
                        noLabel: true,
                        actualValue: val
                    }
                }
                data[i].push(n)
            }
            if (others.value > 0) {
                others._s = data[i].length;
                others.isOtherSlice = true;
                data[i].push(others)
            }
            data[i].scale = pv.Scale.linear(0, tdg.sum(data[i], "value")).range(0, 2 * Math.PI);
            data[i].total = pieTotal;
            data[i].size = sizeByPie[i];
            overallTotal += pieTotal;
            pieTotal = 0
        }
        data = data.slice(chart.dataSubset.startGroup || 0, chart.dataSubset.stopGroup || data.length);
        if (chart.needHTMLToolTip())
            panel.add(pv.Panel).className("eventPanel").events("all");
        if (chart.dataObjHasProp(pieData, "size") && !minMax) {
            minMaxPieSize = {
                min: Math.min.apply(null, sizeByPie),
                max: Math.max.apply(null, sizeByPie)
            };
            minMaxPieSize = typeof minMaxPieSize.min === "number" && typeof minMaxPieSize.max === "number" ? minMaxPieSize : undefined
        }
        chart.cache.set("pieData", data);
        if (useSceneEngine(chart))
            if (chart.pieProperties.multiRing)
                drawMultiringScene(chart, panel, panel.computedSize.width, panel.computedSize.height, data, overallTotal);
            else {
                var layout = chart.gridLayout(panel, data);
                drawPieScene(chart, layout.panel, layout.w, layout.h, data, minMaxPieSize || minMax)
            }
        else {
            if (chart.pieProperties.multiRing) {
                var dataPanel = panel.add(pv.Panel).data(data);
                dataPanel.total = overallTotal;
                drawOnePieChart(chart, dataPanel, panel.computedSize.width, panel.computedSize.height, data)
            } else {
                var layout = chart.gridLayout(panel, data);
                drawOnePieChart(chart, layout.panel, layout.w, layout.h, data, minMaxPieSize || minMax)
            }
            panel.shadow(chart.riserShadow)
        }
        return undefined
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.isXYChart = function() {
        var chart = this;
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        return chartType === "bubble" || chartType === "scatter"
    }
    ;
    tdgchart.prototype.havePieMarkers = function() {
        var chart = this;
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        if (chartType === "bubble" || chartType === "scatter")
            return chart.series.some(function(el) {
                return el && el.marker && el.marker.shape && el.marker.shape === "pie"
            });
        return false
    }
    ;
    function haveMultiRingData(data) {
        return data && Array.isArray(data) && data.length >= 1 && Array.isArray(data[0]) && Array.isArray(data[0][0])
    }
    function drawColorByMetricChart(chart, chartPanels, chartLayout) {
        if (chart.colorMode.mode !== "byMetric" || chart._internalData.length !== 1)
            return;
        var originalData = chart._internalData;
        var colorModeData = chart.colorMode.data;
        chart.series.forEach(function(el) {
            el.marker = el.marker || {};
            el.marker.originalShape = el.marker.shape;
            el.marker.shape = "pie"
        });
        if (!haveMultiRingData(chart.colorMode.data)) {
            var metricData = chart.getColorMetricData();
            chart.transposeIDs(metricData);
            chart._internalData = chart._internalData.map(function(el) {
                return el.map(function(el2, idx) {
                    var n = {};
                    for (var prop in el2)
                        if (el2.hasOwnProperty(prop))
                            n[prop] = el2[prop];
                    n.size = metricData[idx];
                    return n
                })
            })
        }
        chart.colorMode.data = null;
        chart.drawXYChart(chartPanels, chartLayout);
        chart._internalData = originalData;
        chart.colorMode.data = colorModeData;
        chart.series.forEach(function(el) {
            if (el.marker && el.marker.hasOwnProperty("originalShape")) {
                el.marker.shape = el.marker.originalShape;
                delete el.marker.originalShape
            }
        })
    }
    function getGroupLabelsFromArray(arr, idx) {
        var groupLabels = [];
        for (var i = 0; i < arr.length; i++)
            if (Array.isArray(arr[i])) {
                var res = getGroupLabelsFromArray(arr[i], idx);
                groupLabels = groupLabels.concat(res)
            } else if (arr[i][idx] != null)
                groupLabels.push(arr[i][idx]);
        return groupLabels
    }
    tdgchart.prototype.getXYOrdAxisLabels = function(idx) {
        var chart = this;
        var res = [];
        var labelsInData = getGroupLabelsFromArray(chart._internalData, idx);
        idx = idx === "x" ? 0 : 1;
        var groupLabels = Array.isArray(chart.groupLabels[idx]) ? chart.groupLabels[idx] : chart.groupLabels;
        for (var i = 0; i < groupLabels.length; i++)
            if (labelsInData.indexOf(groupLabels[i]) >= 0)
                res.push(groupLabels[i]);
        return res
    }
    ;
    function drawOneGrid(chart, panel, scale, axis) {
        var depth = chart.depth25d() && axis.name !== "colorScale";
        var gridPanel = depth || !axis.properties.majorGrid.aboveRisers ? panel.bg : panel.fg;
        if (!gridPanel)
            return;
        var grid = axis.properties.majorGrid;
        var gridData = scale.grid;
        var axisClassName = chart.axisNameToClassName(axis.name);
        chart.drawGridlines(gridPanel, scale, axis.side, gridData, grid, axisClassName + "-majorGrid");
        var minorData, minorGrid = axis.properties.minorGrid || {};
        if (minorGrid.visible && minorGrid.count !== 0 || minorGrid.ticks.visible)
            minorData = chart.getMinorGridlinesData(minorGrid, gridData);
        if (minorData && gridPanel)
            chart.drawGridlines(gridPanel, scale, axis.side, minorData, minorGrid, axisClassName + "-minorGrid")
    }
    function drawAxes(chart, chartPanels, axisLayout, haveOrdX, haveOrdY) {
        var titleLayout = axisLayout.spacing;
        var x = axisLayout.xScalesList[0];
        var y = axisLayout.yScalesList[0];
        var xaxis = axisLayout.xAxisList[0];
        var yaxis = axisLayout.yAxisList[0];
        chart.drawAltFrameFill(chartPanels.riser.bg, x, xaxis);
        chart.drawAltFrameFill(chartPanels.riser.bg, y, yaxis);
        chart.drawAxisColorRanges(chartPanels.riser.bg, x, xaxis);
        chart.drawAxisColorRanges(chartPanels.riser.bg, y, yaxis);
        for (var a in chartPanels.axis)
            if (chartPanels.axis.hasOwnProperty(a)) {
                if (a && a.toLowerCase().startsWith("x") && haveOrdX)
                    continue;
                else if (a && a.toLowerCase().startsWith("y") && haveOrdY)
                    continue;
                delete chartPanels.axis[a].bg;
                delete chartPanels.axis[a].fg
            }
        if (haveOrdY)
            chart.drawOrdinalAxis(chartPanels, y, yaxis, titleLayout, true);
        else
            chart.drawNumericAxis(chartPanels, axisLayout.yScalesList, axisLayout.yAxisList, axisLayout.spacing);
        if (haveOrdX)
            chart.drawOrdinalAxis(chartPanels, x, xaxis, titleLayout, true);
        else
            chart.drawNumericAxis(chartPanels, axisLayout.xScalesList, axisLayout.xAxisList, axisLayout.spacing);
        for (var xIdx = 0; xIdx < axisLayout.xScalesList.length; xIdx++) {
            var xAxis = axisLayout.xAxisList[xIdx];
            var xScale = axisLayout.xScalesList[xIdx];
            var xName = axisLayout.xScalesList.length > 1 ? xAxis.name : "";
            for (var yIdx = 0; yIdx < axisLayout.yScalesList.length; yIdx++) {
                var yAxis = axisLayout.yAxisList[yIdx];
                var yScale = axisLayout.yScalesList[yIdx];
                var drawPanel = chartPanels.risers[xName + yAxis.name];
                if (drawPanel) {
                    if (!haveOrdY)
                        drawOneGrid(chart, drawPanel, yScale, yAxis);
                    if (!haveOrdX)
                        drawOneGrid(chart, drawPanel, xScale, xAxis);
                    if (drawPanel.fg) {
                        chart.drawNumericBaseline(drawPanel.fg, xScale, xAxis);
                        chart.drawNumericBaseline(drawPanel.fg, yScale, yAxis)
                    }
                }
            }
        }
    }
    tdgchart.prototype.layoutXYChart = function(overallChartSize) {
        var chart = this;
        var chartLayout = chart.layoutDefaultChart(overallChartSize);
        var splitProps = chart.splitNumericAxis;
        chartLayout.xyDataInfo = splitProps.splitX.enabled || splitProps.splitY.enabled ? chart.preprocessXYChartData() : {};
        chartLayout.axisLayout = chart.getXYAxisLayout(chartLayout.chartSize, chartLayout.xyDataInfo.minMaxList);
        chartLayout.chartSize = chart.updateSizeAxisLayout(chartLayout.chartSize, chartLayout.axisLayout.spacing);
        return chartLayout
    }
    ;
    function pushDataSeries(dataByAxis, dataByRowCol, seriesData, splitX, splitY, xi, yi, chartType) {
        if (splitX) {
            if (!dataByAxis[xi]) {
                dataByAxis[xi] = {};
                dataByAxis[xi][chartType] = []
            }
            dataByAxis[xi][chartType].push(seriesData)
        }
        if (splitY) {
            if (!dataByAxis[yi]) {
                dataByAxis[yi] = {};
                dataByAxis[yi][chartType] = []
            }
            dataByAxis[yi][chartType].push(seriesData)
        }
        dataByRowCol[xi] = dataByRowCol[xi] || {};
        dataByRowCol[xi][yi] = dataByRowCol[xi][yi] || [];
        dataByRowCol[xi][yi].push(seriesData)
    }
    function rearrangeXYData(chart, rawDataSet) {
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        var splitX = chart.splitNumericAxis.splitX.enabled;
        var splitY = chart.splitNumericAxis.splitY.enabled;
        var dataByAxis = {}
          , dataByRowCol = {};
        var dynamicAxes;
        if (Array.isArray(chart.dataArrayMap)) {
            dynamicAxes = {
                x: [],
                y: []
            };
            chart.dataArrayMap.forEach(function(el) {
                var match = el.match(/^([xy])[2-9]+$/);
                if (match && match.length > 1)
                    dynamicAxes[match[1]].push(match[0]);
                else if (el === "x" || el === "y")
                    dynamicAxes[el].push(el + "1")
            })
        }
        if (!splitX) {
            dataByAxis.x1 = {};
            dataByAxis.x1[chartType] = rawDataSet
        }
        if (!splitY) {
            dataByAxis.y1 = {};
            dataByAxis.y1[chartType] = rawDataSet
        }
        if (dynamicAxes) {
            if (tdg.isEmpty(dynamicAxes.x))
                dynamicAxes.x.push("x1");
            if (tdg.isEmpty(dynamicAxes.y))
                dynamicAxes.y.push("y1")
        }
        for (var i = 0; i < rawDataSet.length; i++) {
            var seriesData = rawDataSet[i] || [];
            var series = chart.getSeries(i) || {};
            var chosenXAxis = series.xAxisAssignment
              , chosenYAxis = series.yAxisAssignment;
            var assignedXAxis = typeof chosenXAxis === "number" && splitX ? "x" + chosenXAxis : "x1";
            var assignedYAxis = typeof chosenYAxis === "number" && splitY ? "y" + chosenYAxis : "y1";
            if (dynamicAxes && (dynamicAxes.x.length > 1 || dynamicAxes.y.length > 1))
                for (var j = 0; j < seriesData.length; j++) {
                    var d = seriesData[j] || {};
                    if (d.x1 == null && d.x != null)
                        d.x1 = d.x;
                    if (d.y1 == null && d.y != null)
                        d.y1 = d.y;
                    for (var xIdx = 0; xIdx < dynamicAxes.x.length; xIdx++) {
                        var xi = dynamicAxes.x[xIdx];
                        for (var yIdx = 0; yIdx < dynamicAxes.y.length; yIdx++) {
                            var yi = dynamicAxes.y[yIdx];
                            if (d[xi] != null && d[yi] != null) {
                                var newD = tdg.clone(d);
                                newD.x = newD[xi];
                                newD.y = newD[yi];
                                pushDataSeries(dataByAxis, dataByRowCol, [newD], splitX, splitY, xi, yi, chartType)
                            }
                        }
                    }
                }
            else
                pushDataSeries(dataByAxis, dataByRowCol, seriesData, splitX, splitY, assignedXAxis, assignedYAxis, chartType)
        }
        return {
            dataByRowCol: dataByRowCol,
            dataByAxis: dataByAxis
        }
    }
    tdgchart.prototype.preprocessXYChartData = function(data) {
        var chart = this;
        var dataObj = rearrangeXYData(chart, data || chart._internalData);
        return {
            dataByRowCol: dataObj.dataByRowCol,
            minMaxList: chart.getSplitAxesMinMaxList(dataObj.dataByAxis)
        }
    }
    ;
    function drawXYRisers(chart, panel, sizeScale, data, haveOrdX, haveOrdY, x, y, xName, yName) {
        if (tdg.isEmpty(data))
            return;
        var scene = chart.cache.get("tdgscene");
        scene.group(panel, "eventPanel");
        var group = scene.group(panel, "groupPanel", 0, 0, panel.computedSize.width, panel.computedSize.height, true);
        var connectLineGroup, markerGroup = group.group("markers");
        var fillLookup = chart.markerFillStyle();
        var dynamicMarkerSize = chart.isDataDrivenMarkerSize();
        var includeRadius = chart.mouseOverIndicator.enabled || chart.needHTMLToolTip();
        var markerStrokeStyle, haveColorScale = chart.colorScale && chart.cache.hasKey("colorAxis");
        var selData, riserList = [];
        var radiusLookup;
        if (sizeScale)
            radiusLookup = sizeScale;
        else if (dynamicMarkerSize)
            radiusLookup = chart.dataDrivenMarkerSize();
        else
            radiusLookup = function(d, seriesStyle) {
                var r = seriesStyle.radius;
                if (tdg.isPercentString(r)) {
                    var frame = chart._computedChartFrame || {
                        width: chart.width,
                        height: chart.height
                    };
                    r = tdg.applyNumOrPercent(r, Math.min(frame.width, frame.height))
                }
                return r / 2
            }
            ;
        var colorMode = chart.getColorMode();
        if (colorMode === "bySeriesSelection" || colorMode === "byGroupSelection") {
            selData = chart.getColorMetricData();
            selData = selData.map(function(el) {
                return el.map(function(el2) {
                    return {
                        size: el2.value
                    }
                })
            })
        }
        var mergeDistance;
        if (typeof chart.get("dataMerge.mergePixelDistance") === "number")
            mergeDistance = chart.dataMerge.mergePixelDistance;
        for (var i = 0; i < data.length; i++) {
            var seriesData = data[i] || [];
            var s = seriesData.filter(function(el) {
                return el != null && el.hasOwnProperty("_s")
            });
            if (tdg.isEmpty(s))
                continue;
            s = s[0]._s;
            if (haveColorScale) {
                var fillEffect = chart.getSeriesAndGroupFillEffect(s, null);
                if (fillEffect === "seriesHollow" || fillEffect === "seriesWhite")
                    markerStrokeStyle = chart.markerStrokeStyle()
            }
            var mergedPoints = [];
            var seriesStyle = {
                border: chart.getSeriesAndGroupMarkerStrokeStyle(s, null),
                radius: chart.getSeriesAndGroupProperty(s, null, "marker.size"),
                shape: chart.getSeriesAndGroupProperty(s, null, "marker.shape"),
                lineWidth: chart.getSeriesAndGroupProperty(s, null, "marker.border.width"),
                dash: chart.getSeriesAndGroupProperty(s, null, "marker.border.dash")
            };
            var seriesGroup = markerGroup.group(null, null, null, null, null, null, seriesStyle);
            riserList[s] = [];
            var connectLineStyle = null
              , connectLinePoints = [];
            if (chart.getSeriesAndGroupProperty(s, null, "connectMarkers") === true) {
                connectLineStyle = {
                    lineStyle: chart.getSeriesAndGroupProperty(s, null, "border")
                };
                connectLineGroup = connectLineGroup || group.group("connectLines")
            }
            for (var j = 0; j < seriesData.length; j++) {
                var d = seriesData[j];
                if (d.x == null || d.y == null || d._g == null)
                    continue;
                var g = d._g;
                var dx = haveOrdX ? x.ordPos(d.x) + x.range().band / 2 : x(d.x);
                var dy = haveOrdY ? y.ordPos(d.y) + y.range().band / 2 : panel.computedSize.height - y(d.y);
                var radius = radiusLookup(d, seriesStyle);
                if (!tdg.isANumber(dx) || !tdg.isANumber(dy) || !tdg.isANumber(radius))
                    continue;
                if (connectLineStyle)
                    connectLinePoints.push({
                        x: dx,
                        y: dy
                    });
                if (mergeDistance != null) {
                    var shouldMerge = false;
                    for (var pointIdx = 0; pointIdx < mergedPoints.length; pointIdx++) {
                        var pt = mergedPoints[pointIdx];
                        if (Math.abs(dx - pt[0]) <= mergeDistance && Math.abs(dy - pt[1]) <= mergeDistance) {
                            shouldMerge = true;
                            break
                        }
                    }
                    if (shouldMerge)
                        continue;
                    else
                        mergedPoints.push([dx, dy])
                }
                var exceptionalStyle = {
                    marker: {
                        shape: chart.getExceptionalSerDepProperty("marker.shape", d),
                        border: {
                            color: chart.getExceptionalSerDepProperty("marker.border.color", d),
                            width: chart.getExceptionalSerDepProperty("marker.border.width", d),
                            dash: chart.getExceptionalSerDepProperty("marker.border.dash", d)
                        }
                    }
                };
                if (markerStrokeStyle) {
                    exceptionalStyle.marker.border.color = markerStrokeStyle(d);
                    exceptionalStyle.marker.border.width = seriesStyle.lineWidth
                }
                var markerShape = seriesStyle.shape;
                if (d.shape != null)
                    if (typeof d.shape === "string")
                        markerShape = d.shape;
                    else {
                        if (typeof d.shape === "number")
                            markerShape = chart.markerShapeList[d.shape]
                    }
                else if (exceptionalStyle.marker && exceptionalStyle.marker.shape)
                    markerShape = exceptionalStyle.marker.shape;
                var ids = {
                    series: s,
                    group: g,
                    object: "riser",
                    misc: "marker"
                };
                markerShape = chart.applyTemplate(markerShape, d, seriesData, ids);
                var rotation = markerShape && markerShape !== "circle" ? chart.getSeriesAndGroupProperty(s, g, "marker.rotation") : null;
                var axisName = xName && yName ? xName + "-" + yName : null;
                var antialias = !tdg.isEmpty(rotation) || pv.SvgScene.shapeRequiresAntiAlias(markerShape);
                var markerStyle = {
                    className: chart.getRiserClassName(seriesGroup, d, "riser", "marker", axisName),
                    color: fillLookup.call({}, d),
                    rotation: rotation,
                    title: chart.getSeriesAndGroupProperty(s, g, "tooltip"),
                    antialias: antialias === true ? null : antialias,
                    includeRadius: includeRadius && markerShape && markerShape !== "circle" ? radius : null
                };
                if (exceptionalStyle.marker && exceptionalStyle.marker.border) {
                    if (exceptionalStyle.marker.border.color)
                        markerStyle.border = exceptionalStyle.marker.border.color;
                    if (exceptionalStyle.marker.border.width)
                        markerStyle.lineWidth = exceptionalStyle.marker.border.width;
                    if (exceptionalStyle.marker.border.dash)
                        markerStyle.dash = exceptionalStyle.marker.border.dash
                }
                var dot = seriesGroup.dot(dx, dy, radius * 2, markerShape, markerStyle);
                dot.d = d;
                dot.data = seriesData;
                riserList[s].push(dot);
                if (selData) {
                    dot.props.attrs.color = chart.dataSelection.unselectedColor;
                    seriesGroup.dot(dx, dy, radiusLookup(selData[g][0], seriesStyle) * 2, markerShape, markerStyle)
                }
            }
            if (connectLineStyle) {
                var p = new tdgchart.tdgscene.path(connectLinePoints);
                connectLineStyle.className = chart.buildClassName("connectLines", s);
                connectLineGroup.path(0, 0, p, connectLineStyle)
            }
        }
        chart.doDataLabelsScene(group.group("datalabels"), riserList);
        chart.addBevel(riserList, markerGroup);
        chart.doErrorBars(group, x, y, data)
    }
    tdgchart.prototype.drawXYChart = function(chartPanels, chartLayout, data, sizeScale) {
        var chart = this;
        var axisLayout = chartLayout.axisLayout;
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        var i;
        if (chart.colorMode.mode === "byMetric" && !chart.colorMode.hasOwnProperty("isProcessed")) {
            chart.colorMode.isProcessed = true;
            drawColorByMetricChart(chart, chartPanels, chartLayout);
            if (!haveMultiRingData(chart.colorMode.data))
                delete chart.colorMode.isProcessed;
            return
        }
        if (haveMultiRingData(chart.colorMode.data))
            delete chart.colorMode.isProcessed;
        var haveOrdX = chart.cache.get("axisModes", {}).x1 === "ordinal";
        var haveOrdY = chart.cache.get("axisModes", {}).y1 === "ordinal";
        data = data || chart._internalData;
        var x = axisLayout.xScalesList[0];
        var y = axisLayout.yScalesList[0];
        var xaxis = axisLayout.xAxisList[0];
        var yaxis = axisLayout.yAxisList[0];
        chart.addChartFrame(chartPanels.riser.bg);
        if (this.mouseOverIndicator.enabled || this.needHTMLToolTip())
            chartPanels.riser.panel.add(pv.Panel).className("eventPanel").events("all");
        drawAxes(chart, chartPanels, axisLayout, haveOrdX, haveOrdY);
        chart.drawReferenceLines(chartPanels.riser, axisLayout, axisLayout.spacing);
        var trScalesList = {
            x: [x],
            y: [y]
        };
        if (chart.havePieMarkers()) {
            var groupPanel = chartPanels.riser.panel.add(pv.Panel).className("groupPanel").overflow("hidden").add(pv.Panel).data(data).shadow(chart.riserShadow);
            groupPanel.computedSize = chartPanels.riser.panel.computedSize;
            var pieData = data[0].map(function(el, g) {
                var pie = el.pie != null ? el.pie : el.size;
                if (typeof pie === "number")
                    return [{
                        value: pie
                    }];
                return pie.map(function(d, s) {
                    return typeof d === "object" ? d : {
                        value: d,
                        _s: s,
                        _g: g
                    }
                })
            });
            var xyzData = data[0].map(function(el) {
                var pie = el.pie != null ? el.pie : el.size;
                if (Array.isArray(pie))
                    pie = tdg.sum(pie, function(el) {
                        return el && el.hasOwnProperty("value") ? el.value : el
                    });
                return {
                    x: el.x,
                    y: el.y,
                    size: pie
                }
            });
            var maxBubble = chart.maxBubbleSize([xyzData]);
            var markerSize = chart.bubbleMarkerRadius();
            var markerSizes = [];
            for (i = 0; i < pieData.length; i++)
                if (chartType === "bubble")
                    markerSizes[i] = markerSize * Math.sqrt(Math.abs((tdg.sum(pieData[i], "value") || 0) / maxBubble)) + chart.getPadding("label", "width");
                else
                    markerSizes[i] = markerSize + chart.getPadding("label", "width");
            var left = function(index) {
                return function() {
                    return x(xyzData[index].x) - this.width() / 2
                }
            };
            var bottom = function(index) {
                return function() {
                    return y(xyzData[index].y) - this.height() / 2
                }
            };
            for (i = 0; i < pieData.length; i++) {
                var metricData = (chart.colorMode.data || [])[i];
                var ms = markerSizes[i];
                var piePanel = groupPanel.add(pv.Panel).def("parentIndex", [i]).data([pieData[i]]).shape("pie").width(ms).height(ms).left(left(i)).bottom(bottom(i));
                piePanel.computedSize = {
                    width: ms,
                    height: ms
                };
                chart.drawPieChart(piePanel, chartLayout, [pieData[i]], metricData);
                var props = {
                    textBaseline: "top",
                    textMargin: -4
                };
                chart.doDataLabels(piePanel, "top", props)
            }
        } else if (axisLayout.hasSplitAxes && (chart.splitNumericAxis.splitX.enabled || chart.splitNumericAxis.splitY.enabled)) {
            for (var xIdx = 0; xIdx < axisLayout.xScalesList.length; xIdx++)
                for (var yIdx = 0; yIdx < axisLayout.yScalesList.length; yIdx++) {
                    var xaxisS = axisLayout.xAxisList[xIdx];
                    var yaxisS = axisLayout.yAxisList[yIdx];
                    var xName = xaxisS.name;
                    var xPanelName = axisLayout.xAxisList.length > 1 ? xName : "";
                    var yName = yaxisS.name;
                    var axisData = chartLayout.xyDataInfo.dataByRowCol[xName][yName];
                    drawXYRisers(chart, chartPanels.risers[xPanelName + yName].panel, sizeScale, axisData, haveOrdX, haveOrdY, axisLayout.xScalesList[xIdx], axisLayout.yScalesList[yIdx], xName, yName)
                }
            trScalesList.x = axisLayout.xScalesList;
            trScalesList.y = axisLayout.yScalesList
        } else
            drawXYRisers(chart, chartPanels.riser.panel, sizeScale, data, haveOrdX, haveOrdY, x, y);
        chart.doTrendline(chartPanels.risers, null, data, trScalesList.x, trScalesList.y, undefined, xaxis.labels, yaxis.labels);
        chart.drawChartFrameAnnotations(chartPanels, x, y, yaxis.side)
    }
}
)();
(function() {
    var MAX_LEGNED_WIDTH_PCT = .5;
    var tdg = tdgchart.util;
    tdgchart.prototype.padWithMargin = function(labelHeight, pad) {
        return labelHeight > 0 ? labelHeight + pad : 0
    }
    ;
    function legendTitleSize(chart, type) {
        if (["legend", "colorScale", "zaxis"].indexOf(type) < 0)
            type = "legend";
        var title = chart[type].title;
        if (chart.hasLegendTitle(type)) {
            var lblSize = chart.measureLabel(title.text, title.font);
            return {
                height: lblSize.height + chart.getPadding("label", "top"),
                width: lblSize.width + chart.getPadding("label", "width")
            }
        }
        return {
            width: 0,
            height: 0
        }
    }
    tdgchart.prototype.hasLegendTitle = function(type) {
        var chart = this;
        var title = chart[type].title || {};
        return title.visible && title.text && title.text.length > 0
    }
    ;
    function fixLegendTitle(chart, type, orient, maxWidth) {
        if (chart.isSizeLegendVisible() && chart.isLegendVisible() && orient === "horizontal")
            maxWidth = maxWidth / 2 - 2 * chart.getPadding("lable", "averHorz");
        type = type === "colorScale" || type === "zaxis" ? type : "legend";
        var target = chart[type];
        if (target && target.title && target.title.visible && !tdg.isEmpty(target.title.text)) {
            var title = target.title;
            title.text = chart.applyWrapAndTruncate(title.text, title.font, title.wrap, "legend", maxWidth)
        }
    }
    function getFutureBubbleRadius(chart, isLegendVertical, maxLegendWidth, computedSize, dim) {
        var layout = chart.getOverallLayout(true);
        if (computedSize) {
            layout.chart.width = computedSize.width;
            layout.chart.height = computedSize.height
        }
        var padWidth = chart.getPadding("label", "aveHorz");
        var padHeight = chart.getPadding("label", "aveVert");
        var borderSize = chart.legend.lineStyle.width || 0;
        var titleSize = legendTitleSize(chart, "zaxis");
        var totalTitleWidth = Math.min(titleSize.width, maxLegendWidth) + chart.getPadding("label", "width");
        var size = layout.chart;
        var axisList = [{
            name: "x1",
            side: chart.axisList.x1.swapChartSide ? "top" : "bottom",
            properties: chart.axisList.x1
        }, {
            name: "y1",
            side: chart.axisList.y1.swapChartSide ? "right" : "left",
            properties: chart.axisList.y1
        }];
        if (chart.chartType !== "map") {
            var mapLayout = chart.layoutAxis(size, axisList);
            size = chart.updateSizeAxisLayout(size, mapLayout)
        }
        var bubbleMaxSize = chart.zaxis.marker.maxSize;
        bubbleMaxSize = bubbleMaxSize == null ? "30%" : bubbleMaxSize;
        var ratio = 1 + tdg.applyNumOrPercent(bubbleMaxSize, 1);
        if (isLegendVertical) {
            var chartPanelWidth = (size.width - padWidth - 2 * borderSize) / ratio;
            var sizeLegendWidth = size.width - chartPanelWidth - padWidth - 2 * borderSize;
            size.width = totalTitleWidth > sizeLegendWidth / (dim ? dim.col : 1) ? size.width - totalTitleWidth - padWidth - 2 * borderSize : chartPanelWidth
        } else {
            var chartPanelHeight = (size.height - 4 * padHeight - 2 * borderSize - titleSize.height) / ratio;
            size.height = computedSize ? (computedSize.height + chartPanelHeight) / 2 : chartPanelHeight
        }
        return chart.bubbleMarkerRadius(size) / 2
    }
    function getFuturePieRadius(chart, isLegendVertical, maxLegendWidth, hasCircle, possibleLegendRect) {
        var frameInset = chart.border.width || 0;
        var padWidth = chart.getPadding("label", "aveHorz");
        var padHeight = chart.getPadding("label", "aveVert");
        var borderSize = chart.legend.lineStyle.width || 0;
        var titleSize = legendTitleSize(chart, "zaxis");
        var totalTitleWidth = Math.min(titleSize.width, maxLegendWidth) + chart.getPadding("label", "width");
        var seriesCount = chart.data.length;
        var chartsPerRow = chart.chartsPerRow;
        var numRows, numCols;
        if (chartsPerRow == null || chartsPerRow <= 0)
            numCols = Math.ceil(Math.sqrt(seriesCount));
        else
            numCols = Math.min(Math.round(chartsPerRow), seriesCount);
        numRows = Math.ceil(seriesCount / numCols);
        var cellDim = {};
        if (hasCircle) {
            cellDim = {
                width: (possibleLegendRect.w - padWidth - 2 * frameInset - 2 * borderSize) / (numCols + (isLegendVertical ? 1 : 0)),
                height: (possibleLegendRect.h - 2 * padHeight) / (numRows + (!isLegendVertical ? 1 : 0))
            };
            if (totalTitleWidth > cellDim.width)
                cellDim.width = (possibleLegendRect.w - totalTitleWidth - padWidth - 2 * frameInset - 2 * borderSize) / numCols;
            return Math.min(cellDim.width, cellDim.height) / 2 - padWidth
        } else {
            cellDim.height = (possibleLegendRect.h - 2 * padHeight) / numRows;
            cellDim.width = 2 * (possibleLegendRect.w - padWidth - 2 * frameInset - 2 * borderSize) / (2 * numCols + 1);
            if (totalTitleWidth > cellDim.width)
                cellDim.width = (possibleLegendRect.w - totalTitleWidth - padWidth - 2 * frameInset - 2 * borderSize) / numCols;
            return Math.min(cellDim.width, cellDim.height) / 2 - padWidth
        }
    }
    function getFutureMatrixChartMarkerRadius(chart, isLegendVertical, possibleLegendRect, maxLegendWidth) {
        function iterateRadiusApprox(rad) {
            var minSizeLegend = chart.getSizeLegendDim(possibleLegendRect, maxLegendWidth, false, rad || 0);
            var size = {
                width: chart.width,
                height: chart.height
            };
            if (isLegendVertical)
                size.width -= minSizeLegend.width;
            else
                size.height -= minSizeLegend.height;
            var chartLayout = chart.layoutMatrixChart(size, chart.data);
            var dim = chartLayout.matrixLayout.dim;
            var cellWidth = dim.cellsInfo.totalWidth / dim.cellsInfo.ww.length;
            var cellHeight = dim.cellsInfo.totalHeight / dim.cellsInfo.hh.length;
            switch (chart.matrixProperties.chartType) {
            case "marker":
                {
                    rad = Math.min(cellWidth, cellHeight) / 2;
                    var visible = chart.getSeriesAndGroupProperty(0, null, "dataLabels.visible");
                    var position = chart.getSeriesAndGroupProperty(0, null, "dataLabels.position");
                    if (visible && (position == "top" || position == "bottom")) {
                        var font = chart.getSeriesAndGroupProperty(0, null, "dataLabels.font");
                        var padHeight = 5;
                        var lblSize = chart.measureLabel("W", font);
                        rad = Math.min(rad - lblSize.height - padHeight, rad * .9)
                    } else
                        rad *= .9;
                    break
                }
            case "polar":
            case "bubble":
                {
                    rad = chart.bubbleMarkerRadius({
                        width: cellWidth,
                        height: cellHeight
                    }) / 2;
                    break
                }
            case "pie":
                {
                    var pieCount = 1;
                    for (var r = 0; r < chart.data.length; r++)
                        for (var c = 0; c < chart.data[r].length; c++)
                            pieCount = Math.max(pieCount, chart.data[r][c].length || 0);
                    var numCols;
                    if (chart.chartsPerRow == null || chart.chartsPerRow <= 0)
                        numCols = Math.ceil(Math.sqrt(pieCount));
                    else
                        numCols = Math.min(Math.round(chart.chartsPerRow), pieCount);
                    var numRows = Math.ceil(pieCount / numCols);
                    rad = Math.min(cellWidth / numCols, cellHeight / numRows) / 2 - chart.getPadding("label", "aveHorz");
                    break
                }
            }
            return rad
        }
        return iterateRadiusApprox(iterateRadiusApprox(iterateRadiusApprox()))
    }
    function maxLblSize(chart, data) {
        function keyLookup(d) {
            return d.size == null ? d.value : d.size
        }
        function hasKey(d) {
            return d.size != null || d.value != null
        }
        function sumLookup(ser) {
            var serf = ser.filter(hasKey);
            return tdg.sum(serf, keyLookup)
        }
        var minMax;
        if (chart.chartType === "matrix" && chart.matrixProperties.chartType === "pie")
            minMax = tdg.minMax(data, function(r) {
                return tdg.min(r, sumLookup)
            }, function(r) {
                return tdg.max(r, sumLookup)
            });
        else if (chart.chartType === "matrix" || chart.chartType === "bubble" || chart.chartType === "map")
            minMax = tdg.minMaxR(data, keyLookup);
        else
            minMax = tdg.minMax(data, sumLookup);
        var lblSize = [minMax.min, (minMax.min + minMax.max) / 2, minMax.max].map(function(el) {
            return chart.measureLabel(chart.formatNumber(el, chart.zaxis.numberFormat, minMax), chart.legend.labels.font)
        });
        return {
            width: tdg.max(lblSize, "width"),
            height: tdg.max(lblSize, "height")
        }
    }
    tdgchart.prototype.getSizeLegendDim = function(possibleLegendRect, maxLegendWidth, ignoreTitle, fakeRadius) {
        var chart = this;
        chart.legend.sizeLegend = chart.legend.sizeLegend || {
            lineStyle: {}
        };
        chart.legend.sizeLegend.layout = chart.legend.sizeLegend.layout || "circle";
        var w, h, r = 0;
        var isLegendVertical = chart.hasVerticalLegend();
        var padWidth = chart.getPadding("label", "aveHorz");
        var padHeight = chart.getPadding("label", "aveVert");
        var borderSize = chart.legend.lineStyle.width || 0;
        fixLegendTitle(chart, "zaxis", isLegendVertical ? "vertical" : "horizontal", maxLegendWidth - borderSize);
        var titleSize = ignoreTitle ? {
            height: 0,
            width: 0
        } : legendTitleSize(chart, "zaxis");
        var lblSize = maxLblSize(chart, chart.data);
        var lblHeight = lblSize.height * .9;
        var hasCircle = chart.legend.sizeLegend.layout === "circle";
        if (fakeRadius == null)
            if (chart.chartType === "pie")
                r = getFuturePieRadius(chart, isLegendVertical, maxLegendWidth, hasCircle, possibleLegendRect);
            else if (chart.chartType === "matrix")
                r = getFutureMatrixChartMarkerRadius(chart, isLegendVertical, possibleLegendRect, maxLegendWidth);
            else if (chart.chartType === "bubble" || chart.chartType === "map" || chart.chartType === "polar")
                r = getFutureBubbleRadius(chart, isLegendVertical, maxLegendWidth);
            else {
                if (tdgchart.extensionManager.isExtension(chart.chartType) && tdgchart.extensionManager.requiresModule(chart.chartType, "legend") && tdgchart.extensionManager.getModuleProperty(chart, "legend", "sizeMode") === "size")
                    if (chart._sizeLegendMarkersInfo)
                        r = chart._sizeLegendMarkersInfo[0].r;
                    else
                        r = chart.bubbleMarkerRadius() / 2
            }
        else
            r = fakeRadius;
        if (hasCircle) {
            w = r + r + (ignoreTitle ? 0 : 2 * padWidth);
            h = titleSize.height + lblHeight + r + r + (ignoreTitle ? 0 : 2 * padHeight)
        } else {
            w = r + lblSize.width + padWidth + (ignoreTitle ? 0 : 2 * padWidth);
            h = r + (ignoreTitle ? 0 : 2 * padHeight) + lblHeight / 2 + titleSize.height
        }
        if (!isLegendVertical)
            maxLegendWidth /= 2;
        chart.cache.set("sizeLegendMaxRadius", r);
        w = Math.max(titleSize.width, lblSize.width, w);
        w = Math.min(w, maxLegendWidth);
        return {
            width: w,
            height: h,
            lblSize: lblSize,
            titleSize: titleSize
        }
    }
    ;
    tdgchart.prototype.getFixedLegendSeriesLabels = function(chart, entries) {
        var labels = chart.getSeriesLabels(entries);
        if (chart.legend.labels.content)
            labels = labels.map(function(l, i) {
                if (l && (l.visible === false || l.isOtherSlice))
                    return l;
                if (chart.isPieLike())
                    return chart.applyTemplate(chart.legend.labels.content, chart.data[0][i], chart.data[0], {
                        group: 0,
                        series: i
                    });
                else
                    return chart.applyTemplate(chart.legend.labels.content)
            });
        var cachedLabels = chart.cache.get("cachedLegendLabelsMap");
        if (!cachedLabels) {
            var maxWidth = chart.width * MAX_LEGNED_WIDTH_PCT - 2 * chart.getPadding("label", "aveHorz") - chart.measureLabel("a", chart.legend.labels.font).width;
            var temp, map = {}, prop = chart.legend.labels;
            labels.forEach(function(el, i) {
                temp = new String(chart.applyWrapAndTruncate(labels[i].toString(), prop.font, prop.wrap, "legend-labels", maxWidth));
                temp._original = labels[i].toString();
                if (labels[i].isOtherSlice === true)
                    temp.isOtherSlice = labels[i].isOtherSlice;
                if (labels[i].visible === false)
                    temp.visible = labels[i].visible;
                map[labels[i]] = temp;
                labels[i] = temp
            });
            chart.cache.set("cachedLegendLabelsMap", map)
        } else
            labels = labels.map(function(str) {
                return cachedLabels[str] || str
            });
        return labels
    }
    ;
    tdgchart.prototype.hasVerticalLegend = function() {
        var chart = this;
        if (chart.legend.orientation != null && chart.legend.orientation !== "auto")
            return chart.legend.orientation === "vertical";
        var side = chart.getLegendSide();
        if (side === "bottom" || side === "top")
            return false;
        return true
    }
    ;
    tdgchart.prototype.isLegendVisible = function() {
        var chart = this;
        if (tdgchart.extensionManager.isExtension(chart.chartType))
            if (!tdgchart.extensionManager.requiresModule(chart.chartType, "legend"))
                return false;
        if (chart.chartType === "tagcloud" || chart.chartType === "datagrid")
            return false;
        if (chart.isNarrativeTextChartHidden())
            return false;
        if (chart.hasColorScale() || chart.chartType === "pareto" || chart.chartType === "gantt")
            return chart.legend.visible;
        if (chart.chartType === "treemap")
            return chart.legend.visible && chart.treemapHasSeriesLegend();
        return chart.legend.visible
    }
    ;
    tdgchart.prototype.markerShape = function(chart) {
        var riserLookup = chart.seriesPropertyLookup("riserShape");
        var shapelookup = chart.seriesPropertyLookup("marker.shape");
        return function(d) {
            var matrixType = chart.matrixProperties.chartType;
            if (chart.chartType === "pie" && !chart.legend.matchSeriesMarkers)
                return "square";
            if (chart.chartType === "matrix" && (matrixType === "bar" || matrixType === "pie") && !chart.legend.matchSeriesMarkers)
                return "square";
            if (chart.chartType === "matrix" && matrixType === "area")
                return "square";
            var riserShape = riserLookup.call(this, d) || chart.chartType;
            if (riserShape === "bar" && !chart.legend.matchSeriesMarkers)
                return "square";
            if (riserShape === "area" || riserShape === "streamgraph")
                return "square";
            return shapelookup.call(this, d)
        }
    }
    ;
    tdgchart.prototype.isSizeLegendVisible = function() {
        var chart = this;
        if (!chart.legend.visible)
            return false;
        if (tdgchart.extensionManager.isExtension(chart.chartType) && tdgchart.extensionManager.requiresModule(chart.chartType, "legend")) {
            var legendColorMode = tdgchart.extensionManager.getModuleProperty(chart, "legend", "sizeMode");
            return legendColorMode === "size"
        }
        var chartType = chart.chartType;
        var matrixType = chart.matrixProperties.chartType;
        var sizeInDataArrayMap = Array.isArray(chart.dataArrayMap) ? chart.dataArrayMap.includes("size") : false;
        var haveSizeData = sizeInDataArrayMap;
        if (!haveSizeData) {
            var isSize = function(data) {
                return Array.isArray(data) ? data.some(isSize) : data ? data.hasOwnProperty("size") : false
            };
            haveSizeData = isSize(chart.data)
        }
        if (chartType !== "map" && !haveSizeData)
            return false;
        if (chartType === "matrix")
            if (matrixType === "marker" || matrixType === "bubble" || matrixType == "polar") {
                var temp, equal = true;
                var traverse = function(data) {
                    if (equal === false)
                        return;
                    if (Array.isArray(data))
                        data.forEach(traverse);
                    else if (data && typeof data === "object")
                        if (temp == null)
                            temp = data.size;
                        else
                            equal = temp === data.size
                };
                traverse(chart.data);
                return !equal
            } else if (matrixType === "pie") {
                if (Array.isArray(chart.data) && chart.data.length > 1)
                    return true;
                for (var r = 0; r < chart.data.length; r++)
                    if (Array.isArray(chart.data[r])) {
                        if (chart.data[r].length > 1)
                            return true;
                        for (var c = 0; c < chart.data[r].length; c++)
                            if (Array.isArray(chart.data[r][c]) && chart.data[r][c].length > 1)
                                return true
                    }
                return false
            }
        if (chartType == "polar" && haveSizeData)
            return true;
        if (chartType !== "bubble" && chartType !== "pie" && chartType !== "map")
            return false;
        var dataLengthPass = chartType === "pie" ? chart.data.length > 1 : chart.data.some(function(ser) {
            return ser.length > 0
        });
        if (chart.dataArrayMap && dataLengthPass) {
            if (chartType === "map") {
                var overlays = chart.mapProperties.leaflet.overlayLayers;
                var markerType = overlays && overlays[0] && overlays[0].markerType ? overlays[0].markerType : chart.mapProperties.markerType;
                if (markerType === "bubble")
                    return haveSizeData || chart.dataArrayMap.includes("value")
            }
            return sizeInDataArrayMap
        }
        return false
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    var LEGEND_LINE_MARKER_LENGTH = 2.5;
    tdgchart.prototype.layoutLegend = function(titleHeight, subtitleHeight, footnoteHeight, sliderHeight, narrativeTextLayout) {
        var chart = this;
        var res = {
            leftDisplacement: 0,
            bottomDisplacement: 0,
            rightDisplacement: 0,
            topDisplacement: 0
        };
        if (!chart.isLegendVisible())
            return res;
        var disable = {};
        var legendBoundaries = getLegendBoundaries(chart, titleHeight, subtitleHeight, footnoteHeight, sliderHeight, narrativeTextLayout);
        var legendDefinition = defineLegend(chart, legendBoundaries, null, disable);
        var legendDrawInfo = buildLegend(chart, legendDefinition, legendBoundaries);
        if (chart.isSizeLegendVisible() && (legendDrawInfo.w > legendBoundaries.width || legendDrawInfo.h > legendBoundaries.height)) {
            disable.disableSizeLegend = true;
            legendDefinition = defineLegend(chart, legendBoundaries, null, disable);
            legendDrawInfo = buildLegend(chart, legendDefinition, legendBoundaries)
        }
        if (chart.chartType === "legend") {
            var free_space = {
                w: legendBoundaries.width - legendDrawInfo.w,
                h: legendBoundaries.height - legendDrawInfo.h,
                cols: legendDrawInfo.legendLabelsInfo.cols,
                rows: legendDrawInfo.legendLabelsInfo.rows
            };
            legendDefinition = defineLegend(chart, legendBoundaries, free_space, disable);
            legendDrawInfo = buildLegend(chart, legendDefinition, legendBoundaries);
            legendDrawInfo = inflateBorderPad(legendDrawInfo, legendBoundaries)
        }
        legendDrawInfo.pos = getLegendPosition(chart, legendDrawInfo, legendBoundaries.possibleLegendRect, legendBoundaries.margin);
        var side = chart.getLegendSide();
        var fixedLegendSize = chart.get("legend.fixedSize");
        if (fixedLegendSize && side) {
            var isVerticalLegend = chart.hasVerticalLegend();
            var shift = 0;
            if (isVerticalLegend) {
                if (legendDrawInfo.width < legendBoundaries.width) {
                    switch (chart.get("legend.fixedSizeAlign")) {
                    case "inside":
                        shift = legendBoundaries.width - legendDrawInfo.width;
                        break;
                    case "middle":
                        shift = (legendBoundaries.width - legendDrawInfo.width) / 2;
                        break;
                    default:
                    }
                    legendDrawInfo.pos.x += side == "right" ? -shift : shift;
                    legendDrawInfo.width = legendBoundaries.width
                }
            } else if (legendDrawInfo.height < legendBoundaries.height) {
                switch (chart.get("legend.fixedSizeAlign")) {
                case "inside":
                    shift = legendBoundaries.height - legendDrawInfo.height;
                    break;
                case "middle":
                    shift = (legendBoundaries.height - legendDrawInfo.height) / 2;
                    break;
                default:
                }
                legendDrawInfo.pos.y += side == "top" ? shift : -shift;
                legendDrawInfo.height = legendBoundaries.height
            }
        }
        if (chart.legend.dock.enabled && !tdgchart.extensionManager.isExtension(chart.chartType))
            legendDrawInfo = layoutLegendDock(chart, legendBoundaries, legendDrawInfo);
        legendDrawInfo.width += legendBoundaries.margin.left + legendBoundaries.margin.right;
        legendDrawInfo.height += legendBoundaries.margin.top + legendBoundaries.margin.bottom;
        if (!chart.legend.position || chart.legend.position.excludeFromLayout === false || chart.legend.position.excludeFromLayout == null && side != null)
            switch (side) {
            case "left":
                res.leftDisplacement = legendDrawInfo.width;
                break;
            case "right":
                res.rightDisplacement = legendDrawInfo.width;
                break;
            case "top":
                res.topDisplacement = legendDrawInfo.height;
                break;
            case "bottom":
                res.bottomDisplacement = legendDrawInfo.height;
                break
            }
        res.legendDrawInfo = legendDrawInfo;
        return res
    }
    ;
    function inflateBorderPad(legendDrawInfo, legendBoundaries) {
        if (legendDrawInfo.h < legendBoundaries.height) {
            legendDrawInfo.borderPad.top += (legendBoundaries.height - legendDrawInfo.h) / 2;
            legendDrawInfo.borderPad.bottom += (legendBoundaries.height - legendDrawInfo.h) / 2;
            legendDrawInfo.h = legendBoundaries.height
        }
        if (legendDrawInfo.w < legendBoundaries.width) {
            legendDrawInfo.borderPad.left += (legendBoundaries.width - legendDrawInfo.w) / 2;
            legendDrawInfo.borderPad.right += (legendBoundaries.width - legendDrawInfo.w) / 2;
            legendDrawInfo.w = legendBoundaries.width
        }
        return legendDrawInfo
    }
    function layoutLegendDock(chart, legendBoundaries, legendDrawInfo) {
        legendDrawInfo.dock.pos = getLegendPosition(chart, legendDrawInfo.dock, legendBoundaries.possibleLegendRect, legendBoundaries.margin);
        if (chart.legend.dock.showMarkers) {
            var free_space;
            var legendDockBoundaries = tdg.cloneObject(legendBoundaries);
            var legendDockDefinition = defineDock(chart);
            if (chart.hasVerticalLegend()) {
                legendDockBoundaries.height = Math.min(legendDockBoundaries.height, legendDrawInfo.h);
                legendDrawInfo.dock.info = buildLegend(chart, legendDockDefinition, legendDockBoundaries);
                if (legendDrawInfo.dock.w > legendDrawInfo.dock.info.w) {
                    free_space = {
                        w: Math.max(0, legendDrawInfo.dock.w - legendDrawInfo.dock.info.w),
                        h: Math.max(0, legendDrawInfo.h - legendDrawInfo.dock.info.h),
                        cols: legendDrawInfo.dock.info.legendLabelsInfo.cols,
                        rows: legendDrawInfo.dock.info.legendLabelsInfo.rows
                    };
                    legendDockDefinition = defineDock(chart, free_space);
                    legendDrawInfo.dock.info = buildLegend(chart, legendDockDefinition, legendDockBoundaries)
                }
                legendDrawInfo.dock.pos.y = legendDrawInfo.pos.y
            } else {
                legendDockBoundaries.width = Math.min(legendDockBoundaries.width, legendDrawInfo.w);
                legendDrawInfo.dock.info = buildLegend(chart, legendDockDefinition, legendDockBoundaries);
                if (legendDrawInfo.dock.h > legendDrawInfo.dock.info.h) {
                    free_space = {
                        w: Math.max(0, legendDrawInfo.w - legendDrawInfo.dock.info.w),
                        h: Math.max(0, legendDrawInfo.dock.h - legendDrawInfo.dock.info.h),
                        cols: legendDrawInfo.dock.info.legendLabelsInfo.cols,
                        rows: legendDrawInfo.dock.info.legendLabelsInfo.rows
                    };
                    legendDockDefinition = defineDock(chart, free_space);
                    legendDrawInfo.dock.info = buildLegend(chart, legendDockDefinition, legendDockBoundaries)
                }
                legendDrawInfo.dock.pos.x = legendDrawInfo.pos.x
            }
        } else if (!chart.legend.dock.sideControls)
            if (chart.hasVerticalLegend()) {
                legendDrawInfo.dock.h = legendDrawInfo.h;
                legendDrawInfo.dock.pos.y = legendDrawInfo.pos.y
            } else {
                legendDrawInfo.dock.w = legendDrawInfo.w;
                legendDrawInfo.dock.pos.x = legendDrawInfo.pos.x
            }
        if (!chart.getLegendSide()) {
            var offset = chart.legendDockOffset(legendDrawInfo, legendDrawInfo.dock, reverseSide(chart.legend.dock.expandDirection) || "right");
            legendDrawInfo.pos.x -= offset.x;
            legendDrawInfo.pos.y -= offset.y
        }
        return legendDrawInfo
    }
    function buildLegend(chart, legendDefinition, legendBoundaries) {
        var borderSize = chart.legend.lineStyle.width || 0;
        var borderPad = legendDefinition.borderPad;
        var dockMargin = {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
        };
        var position = chart.getLegendSide(true);
        if (chart.legend.dock.enabled && !tdgchart.extensionManager.isExtension(chart.chartType)) {
            var leftOrRight = position !== "top" && position !== "bottom";
            if (!chart.legend.dock.sideControls)
                dockMargin[leftOrRight ? "top" : "left"] = leftOrRight ? legendBoundaries.dock.h + chart.getPadding("label", "top") : legendBoundaries.dock.w;
            else
                dockMargin[position] = leftOrRight ? legendBoundaries.dock.w : legendBoundaries.dock.h
        }
        var maxAllowedLegendWidth = legendBoundaries.width - 2 * borderSize - borderPad.left - borderPad.right - dockMargin.left - dockMargin.right;
        var maxAllowedLegendHeight = legendBoundaries.height - 2 * borderSize - borderPad.top - borderPad.bottom - dockMargin.top - dockMargin.bottom;
        var defaultHPad = 0;
        var defaultVPad = 0;
        var legendDrawInfo;
        var maxLabelWidth = maxAllowedLegendWidth;
        if (legendDefinition.parts && legendDefinition.orientation === "horizontal")
            maxLabelWidth = maxLabelWidth / legendDefinition.parts - (legendDefinition.parts > 1 ? defaultHPad : 0);
        truncateTexts(chart, legendDefinition, maxLabelWidth, defaultHPad);
        if (!legendDefinition.legendLabels)
            legendDrawInfo = computeLegend(legendDefinition, maxAllowedLegendWidth, defaultHPad, defaultVPad);
        else if (legendDefinition.orientation !== "horizontal")
            legendDrawInfo = solveVerticalLegend(chart, legendDefinition, maxAllowedLegendWidth, maxAllowedLegendHeight, defaultHPad, defaultVPad);
        else
            legendDrawInfo = solveHorizontalLegend(chart, legendDefinition, maxAllowedLegendWidth, maxAllowedLegendHeight, defaultHPad, defaultVPad);
        if (legendDrawInfo.fillW && legendDrawInfo.w < maxAllowedLegendWidth || legendDrawInfo.fillH && legendDrawInfo.h < maxAllowedLegendHeight) {
            var fillW = Math.max(0, maxAllowedLegendWidth - legendDrawInfo.w);
            var fillH = Math.max(0, maxAllowedLegendHeight - legendDrawInfo.h);
            legendDrawInfo = computeLegend(legendDefinition, maxAllowedLegendWidth, defaultHPad, defaultVPad, fillW, fillH)
        }
        legendDrawInfo.borderSize = borderSize;
        legendDrawInfo.borderPad = tdg.cloneObject(legendDefinition.borderPad);
        legendDrawInfo.w += 2 * borderSize + legendDefinition.borderPad.left + legendDefinition.borderPad.right + dockMargin.left + dockMargin.right;
        legendDrawInfo.h += 2 * borderSize + legendDefinition.borderPad.top + legendDefinition.borderPad.bottom + dockMargin.top + dockMargin.bottom;
        if (chart.legend.dock.enabled && !tdgchart.extensionManager.isExtension(chart.chartType)) {
            if (chart.legend.dock.resizeFrame && !chart.legend.dock.minimized) {
                legendDrawInfo.width = legendDrawInfo.w;
                legendDrawInfo.height = legendDrawInfo.h
            } else {
                legendDrawInfo.width = legendBoundaries.dock.w + 2 * borderSize + legendDefinition.borderPad.left + legendDefinition.borderPad.right;
                legendDrawInfo.height = legendBoundaries.dock.h + 2 * borderSize + legendDefinition.borderPad.top + legendDefinition.borderPad.bottom
            }
            legendDrawInfo.dock = tdg.cloneObject(legendBoundaries.dock);
            legendDrawInfo.dock.w += 2 * borderSize + legendDefinition.borderPad.left + legendDefinition.borderPad.right;
            legendDrawInfo.dock.h += 2 * borderSize + legendDefinition.borderPad.top + legendDefinition.borderPad.bottom;
            legendDrawInfo.dock.borderPad = tdg.cloneObject(legendDefinition.borderPad);
            ["left", "right", "top", "bottom"].forEach(function(p) {
                legendDrawInfo.borderPad[p] += dockMargin[p]
            })
        } else {
            legendDrawInfo.width = legendDrawInfo.w;
            legendDrawInfo.height = legendDrawInfo.h
        }
        return legendDrawInfo
    }
    function solveVerticalLegend(chart, legendDefinition, maxAllowedLegendWidth, maxAllowedLegendHeight, defaultHPad, defaultVPad) {
        function fit(legendDrawInfo) {
            return legendDrawInfo.h <= maxAllowedLegendHeight + .99 && legendDrawInfo.w <= maxAllowedLegendWidth + .99
        }
        function tooWide(legendDrawInfo) {
            return legendDrawInfo.w > maxAllowedLegendWidth
        }
        legendDefinition.legendLabels.maxColumns = 1;
        var legend = computeLegend(legendDefinition, maxAllowedLegendWidth, defaultHPad, defaultVPad);
        var canScroll = chart.legend.scroll.enabled && !legendDefinition.legendLabels.forbidScroll;
        if (fit(legend))
            return legend;
        if (!tooWide(legend)) {
            if (canScroll) {
                truncateTexts(chart, legendDefinition, maxAllowedLegendWidth - chart.legend.scroll.size, defaultHPad);
                legendDefinition.legendLabels.haveScroll = {
                    size: chart.legend.scroll.size,
                    direction: "vertical"
                };
                legend = computeLegend(legendDefinition, maxAllowedLegendWidth, defaultHPad, defaultVPad);
                legendDefinition.legendLabels.haveScroll = {
                    size: chart.legend.scroll.size,
                    direction: "vertical",
                    reduceHeight: legend.h - maxAllowedLegendHeight
                };
                legend = computeLegend(legendDefinition, maxAllowedLegendWidth, defaultHPad, defaultVPad);
                return legend
            }
            legendDefinition.legendLabels.maxColumns = null;
            legend = computeLegend(legendDefinition, maxAllowedLegendWidth, defaultHPad, defaultVPad);
            if (fit(legend)) {
                legendDefinition.legendLabels.maxColumns = legend.legendLabelsInfo.cols;
                while (--legendDefinition.legendLabels.maxColumns > 1) {
                    var tryLegend = computeLegend(legendDefinition, maxAllowedLegendWidth, defaultHPad, defaultVPad);
                    if (!fit(tryLegend))
                        break;
                    legend = tryLegend
                }
                return legend
            }
            if (1) {
                truncateTexts(chart, legendDefinition, maxAllowedLegendWidth, defaultHPad, 1);
                legend = computeLegend(legendDefinition, maxAllowedLegendWidth, defaultHPad, defaultVPad);
                if (fit(legend))
                    return legend
            }
        } else {
            truncateTexts(legendDefinition, maxAllowedLegendWidth, defaultHPad);
            legend = computeLegend(legendDefinition, maxAllowedLegendWidth, defaultHPad, defaultVPad);
            if (fit(legend))
                return legend;
            else if (tooWide(legend)) {
                legend = computeLegend(legendDefinition, maxAllowedLegendWidth, defaultHPad, defaultVPad);
                if (fit(legend))
                    return legend;
                else if (tooWide(legend)) {
                    legend = computeLegend(legendDefinition, maxAllowedLegendWidth, defaultHPad, defaultVPad);
                    return legend
                }
            }
            if (canScroll) {
                legendDefinition.legendLabels.haveScroll = {
                    size: chart.legend.scroll.size,
                    direction: "vertical",
                    reduceHeight: legend.h - maxAllowedLegendHeight
                };
                legend = computeLegend(legendDefinition, maxAllowedLegendWidth, defaultHPad, defaultVPad);
                return legend
            }
        }
        var count = Math.min(legendDefinition.legendLabels.array.length, legendDefinition.legendLabels.maxEntries || legendDefinition.legendLabels.array.length);
        while (count > 0 && !fit(legend)) {
            legendDefinition.legendLabels.maxEntries = --count;
            legend = computeLegend(legendDefinition, maxAllowedLegendWidth, defaultHPad, defaultVPad)
        }
        return legend
    }
    function solveHorizontalLegend(chart, legendDefinition, maxAllowedLegendWidth, maxAllowedLegendHeight, defaultHPad, defaultVPad) {
        function fit(legendDrawInfo) {
            return legendDrawInfo.h <= maxAllowedLegendHeight && legendDrawInfo.w <= maxAllowedLegendWidth
        }
        var tryLegend;
        var legend = computeLegend(legendDefinition, maxAllowedLegendWidth, defaultHPad, defaultVPad);
        if (fit(legend)) {
            if (legend.legendLabelsInfo.cols > 1) {
                legendDefinition.legendLabels.maxColumns = legend.legendLabelsInfo.cols;
                while (--legendDefinition.legendLabels.maxColumns > 1) {
                    tryLegend = computeLegend(legendDefinition, maxAllowedLegendWidth, defaultHPad, defaultVPad);
                    if (tryLegend.h > legend.h)
                        break;
                    legend = tryLegend
                }
            }
            return legend
        }
        var canScroll = chart.legend.scroll.enabled && !legendDefinition.legendLabels.forbidScroll;
        if (canScroll) {
            legend = computeLegend(legendDefinition, null, defaultHPad, defaultVPad);
            legendDefinition.legendLabels.maxColumns = legend.legendLabelsInfo.cols;
            while (--legendDefinition.legendLabels.maxColumns > 1) {
                tryLegend = computeLegend(legendDefinition, null, defaultHPad, defaultVPad);
                if (tryLegend.h > legend.h) {
                    legendDefinition.legendLabels.maxColumns++;
                    break
                }
                legend = tryLegend
            }
            legendDefinition.legendLabels.haveScroll = {
                size: chart.legend.scroll.size,
                direction: "horizontal",
                reduceWidth: maxAllowedLegendWidth - legend.w
            };
            legend = computeLegend(legendDefinition, maxAllowedLegendWidth, defaultHPad, defaultVPad);
            return legend
        }
        var count = Math.min(legendDefinition.legendLabels.array.length, legendDefinition.legendLabels.maxEntries || legendDefinition.legendLabels.array.length);
        while (count > 0 && !fit(legend)) {
            legendDefinition.legendLabels.maxEntries = --count;
            legend = computeLegend(legendDefinition, maxAllowedLegendWidth, defaultHPad, defaultVPad)
        }
        return legend
    }
    tdgchart.prototype.getLegendSide = function(guessFreeFloatingLegend) {
        var sides = ["left", "right", "top", "bottom"];
        var chart = this;
        var position = chart.legend.position;
        if (!position)
            return "right";
        else if (typeof position === "string" && sides.indexOf(position) !== -1)
            return position;
        else if (position.side && sides.indexOf(position.side) !== -1)
            return position.side;
        else if (position.left == null && position.right == null && position.top == null && position.bottom == null)
            return "right";
        if (guessFreeFloatingLegend)
            return reverseSide(chart.legend.dock && chart.legend.dock.expandDirection) || "right";
        return null
    }
    ;
    function getLegendPosition(chart, legendDrawInfo, chartFrame, margin) {
        if (chart.chartType === "legend")
            return {
                x: chartFrame.x + Math.floor((chartFrame.w - legendDrawInfo.w) / 2),
                y: chartFrame.y + Math.floor((chartFrame.h - legendDrawInfo.h) / 2)
            };
        var x, y;
        var position = chart.legend.position || {};
        var side = chart.getLegendSide();
        var anchoredObject;
        if (position.anchor === "chartBackground" || position.anchor == null && !side)
            anchoredObject = {
                x: 0,
                y: 0,
                w: chart.width,
                h: chart.height
            };
        else if (position.anchor === "chartAxisFrame")
            anchoredObject = chartFrame;
        else
            anchoredObject = chartFrame;
        var refObject = anchoredObject;
        if (!side)
            margin = {
                top: tdg.applyNumOrPercent(position.top, anchoredObject.h),
                bottom: tdg.applyNumOrPercent(position.bottom, anchoredObject.h),
                left: tdg.applyNumOrPercent(position.left, anchoredObject.w),
                right: tdg.applyNumOrPercent(position.right, anchoredObject.w)
            };
        else {
            margin = tdg.clone(margin);
            refObject = tdg.clone(anchoredObject);
            if (side === "left" || side === "right") {
                if (position.top != null)
                    margin.top = tdg.applyNumOrPercent(position.top, anchoredObject.h);
                else if (position.bottom != null)
                    margin.bottom = tdg.applyNumOrPercent(position.bottom, anchoredObject.h);
                if (!position.excludeFromLayout) {
                    refObject.x = chartFrame.x;
                    refObject.w = chartFrame.w
                }
            } else if (side === "top" || side === "bottom") {
                if (position.left != null)
                    margin.left = tdg.applyNumOrPercent(position.left, anchoredObject.w);
                else if (position.right != null)
                    margin.right = tdg.applyNumOrPercent(position.right, anchoredObject.w);
                if (!position.excludeFromLayout) {
                    refObject.y = chartFrame.y;
                    refObject.h = chartFrame.h
                }
            }
        }
        var horizontalAlign = "middle";
        var verticalAlign = "middle";
        if (side === "left" || side === "right")
            horizontalAlign = side;
        else if (position.left != null)
            horizontalAlign = "left";
        else if (position.right != null)
            horizontalAlign = "right";
        else if (position.align === "left" || position.align === "start")
            horizontalAlign = "left";
        else if (position.align === "right" || position.align === "end")
            horizontalAlign = "right";
        if (side === "top" || side === "bottom")
            verticalAlign = side;
        else if (position.top != null)
            verticalAlign = "top";
        else if (position.bottom != null)
            verticalAlign = "bottom";
        else if (position.align === "top" || position.align === "start")
            verticalAlign = "top";
        else if (position.align === "bottom" || position.align === "end")
            verticalAlign = "bottom";
        x = refObject.x;
        switch (horizontalAlign) {
        case "left":
            x += margin.left;
            break;
        case "right":
            x += refObject.w - legendDrawInfo.w - margin.right;
            x -= chart.border.width;
            break;
        case "middle":
        default:
            x += Math.floor((refObject.w - legendDrawInfo.w) / 2);
            break
        }
        if ((side === "top" || side === "bottom") && (position.excludeFromLayout == null || !position.excludeFromLayout))
            y = chartFrame.y;
        else
            y = refObject.y;
        switch (verticalAlign) {
        case "top":
            y += margin.top;
            break;
        case "bottom":
            y += Math.floor(refObject.h - legendDrawInfo.h) - margin.bottom;
            break;
        case "middle":
        default:
            y += Math.floor((refObject.h - legendDrawInfo.h) / 2);
            break
        }
        return {
            x: x,
            y: y
        }
    }
    function getLegendBoundaries(chart, titleHeight, subtitleHeight, footnoteHeight, sliderHeight, narrativeTextLayout) {
        var isVerticalLegend = chart.hasVerticalLegend();
        var padHeight = chart.getPadding("label", isVerticalLegend ? "top" : "aveVert");
        var paddedTitleHeight = chart.padWithMargin(titleHeight, padHeight);
        var paddedSubtitleHeight = chart.padWithMargin(subtitleHeight, padHeight);
        var paddedFootnoteHeight = chart.padWithMargin(footnoteHeight, padHeight);
        var margin = {
            top: 5,
            bottom: 5,
            left: 5,
            right: 5
        };
        var borderSize = chart.legend.lineStyle.width || 0;
        sliderHeight = isVerticalLegend && sliderHeight > 0 ? sliderHeight + padHeight + padHeight : 0;
        var legendSide = chart.getLegendSide(true);
        if (chart.chartType !== "matrix")
            margin[reverseSide(legendSide)] = 0;
        if (chart.chartType === "legend")
            return {
                width: chart.width - 2 * chart.border.width,
                height: chart.height - 2 * chart.border.width,
                possibleLegendRect: {
                    x: 0,
                    y: 0,
                    w: chart.width,
                    h: chart.height
                },
                margin: {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0
                }
            };
        var possibleLegendRect = {
            x: 0,
            y: chart.border.width + paddedTitleHeight + paddedSubtitleHeight + sliderHeight,
            w: chart.width,
            h: chart.height - 2 * chart.border.width - paddedTitleHeight - paddedSubtitleHeight - sliderHeight - paddedFootnoteHeight
        };
        if (narrativeTextLayout)
            if (narrativeTextLayout.position === "right" && legendSide === "right")
                possibleLegendRect.x -= narrativeTextLayout.rightDisplacement;
            else if (narrativeTextLayout.position === "left" && legendSide === "left")
                possibleLegendRect.x += narrativeTextLayout.leftDisplacement;
            else if (narrativeTextLayout.position === "bottom")
                possibleLegendRect.h -= narrativeTextLayout.bottomDisplacement;
            else {
                possibleLegendRect.h -= narrativeTextLayout.topDisplacement;
                possibleLegendRect.y += narrativeTextLayout.topDisplacement
            }
        var docksize = {};
        if (chart.legend.dock.enabled && !tdgchart.extensionManager.isExtension(chart.chartType)) {
            var size = (chart.legend.dock.button.size === "auto" ? chart.legend.markerSize : chart.legend.dock.button.size) || 30;
            docksize = {
                size: size,
                w: size,
                h: size
            };
            margin[legendSide] = 0;
            if (chart.legend.dock.resizeFrame === false)
                return {
                    dock: docksize,
                    width: possibleLegendRect.w - (isVerticalLegend ? docksize.w : 0),
                    height: possibleLegendRect.h - (isVerticalLegend ? 0 : docksize.h),
                    possibleLegendRect: possibleLegendRect,
                    margin: margin
                }
        }
        var maxWidth = chart.width - chart.border.width - chart.border.width - margin.left - margin.right;
        var maxHeight = possibleLegendRect.h - margin.top - margin.bottom;
        var maxAllowedLegendHeight, maxAllowedLegendWidth;
        var maxLegendPercent = tdg.applyNumOrPercent(chart.get("legend.maxSize", .5), 1);
        var fixedLegendSize = chart.get("legend.fixedSize");
        if (isVerticalLegend) {
            if (fixedLegendSize)
                maxAllowedLegendWidth = tdg.applyNumOrPercent(fixedLegendSize, chart.width - chart.border.width) - margin.left - margin.right;
            else
                maxAllowedLegendWidth = (chart.width - chart.border.width) * maxLegendPercent - margin.left - margin.right;
            maxAllowedLegendHeight = chart.height - chart.border.width - chart.border.width - margin.top - margin.bottom
        } else {
            maxAllowedLegendWidth = chart.width - chart.border.width - margin.left - margin.right;
            if (fixedLegendSize)
                maxAllowedLegendHeight = tdg.applyNumOrPercent(fixedLegendSize, chart.height - chart.border.width) - margin.top - margin.bottom;
            else
                maxAllowedLegendHeight = (chart.height - chart.border.width) * maxLegendPercent - margin.top - margin.bottom
        }
        maxWidth = Math.min(maxWidth, maxAllowedLegendWidth);
        maxHeight = Math.min(maxHeight, maxAllowedLegendHeight);
        return {
            dock: docksize,
            width: maxWidth,
            height: maxHeight,
            possibleLegendRect: possibleLegendRect,
            margin: margin,
            innerWidth: maxWidth - 2 * borderSize,
            innerHeight: maxHeight - 2 * borderSize
        }
    }
    function defineLegend(chart, legendBoundaries, free_space, disable) {
        var isVerticalLegend = chart.hasVerticalLegend();
        var legend = {
            array: [],
            alignH: "center",
            alignV: "center"
        };
        var legendTitle, legendLabels, sizeLegend;
        var borderPad = {
            top: chart.getPadding("frame", "top"),
            right: chart.getPadding("frame", "right"),
            bottom: chart.getPadding("frame", "bottom"),
            left: chart.getPadding("frame", "left")
        };
        if (chart.isSizeLegendVisible() && !(disable && disable.disableSizeLegend)) {
            sizeLegend = {
                array: [],
                alignH: "center",
                alignV: "center"
            };
            sizeLegend.array.push(getLegendTitle(chart, "zaxis"));
            sizeLegend.array.push(getSizeLegend(chart, legendBoundaries));
            if (isVerticalLegend)
                sizeLegend.theOnly = true
        }
        if (chart.hasColorScale()) {
            legendTitle = getLegendTitle(chart, "colorScale");
            legend.array.push(legendTitle);
            if (chart.colorScale.colorMode === "bin") {
                legendLabels = getColorBinLegendEntries(chart, free_space);
                legend.array.push(legendLabels)
            } else
                legend.array.push(getColorScaleLegendLayout(chart, legendBoundaries, legendTitle, sizeLegend))
        } else if (!(disable && disable.disableLegendLabels) && !chart.cache.get("legend_hide_labels")) {
            legendTitle = getLegendTitle(chart, "legend");
            legend.array.push(legendTitle);
            legendLabels = getSeriesLegendEntries(chart, free_space);
            legend.array.push(legendLabels)
        }
        if (chart.isSizeLegendVisible() && !(disable && disable.disableSizeLegend)) {
            legend = {
                array: [legend, sizeLegend]
            };
            legend.alignH = "center";
            legend.parts = 2
        }
        legend.legendLabels = legendLabels;
        legend.orientation = chart.hasVerticalLegend() ? "vertical" : "horizontal";
        legend.borderPad = borderPad;
        if (chart.chartType === "legend" && free_space) {
            if (!legendTitle)
                legend.borderPad.top = Math.floor(free_space.h / (free_space.rows + 1));
            legend.borderPad.bottom = Math.floor(free_space.h / (free_space.rows + 1));
            legend.borderPad.left = legend.borderPad.right = Math.floor(free_space.w / (free_space.cols + 1))
        }
        return legend
    }
    function defineDock(chart, free_space) {
        var isVerticalLegend = chart.hasVerticalLegend();
        var legend = {
            array: [],
            alignH: "center",
            alignV: "center"
        };
        var borderPad = {
            top: chart.getPadding("frame", "top"),
            right: chart.getPadding("frame", "right"),
            bottom: chart.getPadding("frame", "bottom"),
            left: chart.getPadding("frame", "left")
        };
        var markers = getLegendMarkers(chart, free_space);
        legend.array.push(markers);
        legend.legendLabels = markers;
        legend.legendLabels.forbidScroll = true;
        legend.orientation = isVerticalLegend ? "vertical" : "horizontal";
        legend.borderPad = borderPad;
        if (free_space) {
            var h = free_space.h - (free_space.rows - 1) * Math.floor(free_space.h / (free_space.rows + 1));
            legend.borderPad.top += Math.floor(h / 2);
            legend.borderPad.bottom += Math.ceil(h / 2);
            var w = free_space.w - (free_space.cols - 1) * Math.floor(free_space.w / (free_space.cols + 1));
            legend.borderPad.left += Math.floor(w / 2);
            legend.borderPad.right += Math.ceil(w / 2)
        }
        return legend
    }
    function getColorScaleLegendLayout(chart, legendBoundaries, legendTitle, sizeLegend) {
        var colorAxis = chart.cache.get("colorAxis");
        var scaleThickness = 25;
        var isVerticalLegend = chart.hasVerticalLegend();
        var borderSize = chart.legend.lineStyle.width || 0;
        var titleHeight = legendTitle ? legendTitle.h + legendTitle.padTop : 0;
        var padHeight = chart.getPadding("label", isVerticalLegend ? "top" : "aveVert");
        var axisLabelHeight = tdg.measureFont(colorAxis.properties.labels.font).height;
        var sizeLegendSize = {
            width: sizeLegend ? legendBoundaries.innerWidth / 2 : 0,
            height: sizeLegend ? tdg.sum(sizeLegend.array, "h") : 0
        };
        var scale = chart.getNumericScale(legendBoundaries, colorAxis, colorAxis.minMax);
        var labels = chart.getGridLabels(scale, colorAxis);
        var axisWidth = chart.axisWidth(colorAxis, null, labels);
        var csl = {
            type: "colorScaleLegend",
            colorAxis: colorAxis,
            padTop: titleHeight ? padHeight : chart.getPadding("label", "top"),
            direction: (isVerticalLegend ? 90 : 0) + (colorAxis.properties.invert ? 180 : 0),
            scaleX: 0,
            scaleY: padHeight
        };
        if (isVerticalLegend) {
            csl.padRight = 20;
            csl.padLeft = 0;
            csl.w = scaleThickness + axisWidth.size - chart.getPadding("label", "aveHorz");
            csl.h = (legendBoundaries.height - borderSize * 2 - titleHeight - sizeLegendSize.height - padHeight * 2) * .7;
            csl.scaleHeight = csl.h - axisLabelHeight;
            csl.scaleWidth = scaleThickness;
            csl.scaleY = axisLabelHeight / 2
        } else {
            csl.w = (legendBoundaries.innerWidth - sizeLegendSize.width) * .75;
            csl.h = padHeight + scaleThickness + axisWidth.size;
            csl.scaleWidth = csl.w - axisWidth.halfLabel * 2;
            csl.scaleHeight = scaleThickness;
            csl.scaleX = axisWidth.halfLabel
        }
        return csl
    }
    function getSizeLegend(chart, legendBoundaries) {
        var sizeLegend = chart.getSizeLegendDim(legendBoundaries.possibleLegendRect, legendBoundaries.innerWidth, true);
        return {
            type: "sizeLegend",
            padLeft: 5,
            padRight: 5,
            padTop: 5,
            padBottom: 5,
            w: sizeLegend.width,
            h: sizeLegend.height,
            color: chart.legend.sizeLegend.lineStyle.color,
            lineWidth: chart.legend.sizeLegend.lineStyle.width || 1,
            layout: chart.legend.sizeLegend.layout,
            getMarkersInfo: function() {
                return chart._sizeLegendMarkersInfo
            },
            formatNumber: function(v, minMax) {
                return chart.formatNumber(v, chart.zaxis.numberFormat, minMax)
            },
            font: chart.legend.labels.font,
            fontcolor: chart.legend.labels.color,
            lblSize: sizeLegend.lblSize,
            hpad: chart.getPadding("label", "aveHorz")
        }
    }
    function getLegendTitle(chart, type, maxWidth) {
        if (!chart.hasLegendTitle(type))
            return null;
        var title = chart[type].title;
        var className = {
            legend: "legend-title",
            zaxis: "sizeLegend-title",
            colorScale: "colorScaleLegend-title"
        }[type];
        var text = chart.applyTemplate(title.text, null, null, null);
        if (maxWidth)
            text = chart.applyWrapAndTruncate(text, title.font, title.wrap, "legend", maxWidth);
        var lblSize = chart.measureLabel(text, title.font);
        var tooltipLookup = chart.resolveToolTipTitleContent(title.tooltip);
        return {
            type: "label",
            t: text,
            wrap: title.wrap,
            w: lblSize.width,
            h: lblSize.height,
            padTop: chart.getPadding("label", "top"),
            padRight: chart.getPadding("label", "width"),
            padLeft: chart.getPadding("label", "width"),
            title: typeof tooltipLookup === "function" ? tooltipLookup.call({}, text.toString()) : tooltipLookup,
            color: title.color,
            font: title.font,
            theOnly: true,
            alignH: "center",
            className: className
        }
    }
    function getMarkers(chart, labels) {
        var _internalData = chart._internalData;
        chart._internalData = null;
        var markerSize = chart.legend.markerSize || 0;
        var markerVisible = chart.seriesPropertyLookup("marker.visible");
        var shapeLookup = chart.markerShape(chart);
        var rotationLookup = chart.markerRotationLookup();
        var fillLookup = chart.markerFillStyle();
        var strokeLookup = chart.markerStrokeStyle();
        var lineWidthLookup = chart.seriesPropertyLookup("marker.border.width");
        var lineDashLookup = chart.seriesPropertyLookup("marker.border.dash");
        var defaultLineColor = chart.seriesColorLookup();
        var defaultLineDash = chart.seriesPropertyLookup("border.dash");
        var defaultLineWidth = chart.seriesPropertyLookup("border.width");
        chart._internalData = _internalData;
        var map = chart._internalData.seriesMap || [];
        var markers = [];
        var defaultSeries = chart.getDefaultSeries();
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        var defaultShape = defaultSeries == null ? chartType : defaultSeries.riserShape || chartType || "bar";
        var riserShapesHasLine = chart.getSeriesProperty("riserShape").indexOf("line") !== -1;
        labels.forEach(function(label, i) {
            if (label.hasOwnProperty("visible") && !label.visible)
                return;
            var index = map[i] != null ? map[i] : i;
            var pseudoProtovisContext = {
                data: function() {
                    return label
                }
            };
            label._s = index;
            label._g = null;
            var title = chart.legend.labels.tooltip;
            if (!markerSize)
                markers[i] = {
                    title: title
                };
            else {
                var drawMarker = true
                  , drawLine = false
                  , alignToLineWidth = false;
                if (chart.legend.matchSeriesMarkers) {
                    var riserShape = chart.getSeriesAndGroupProperty(label._s, null, "riserShape") || defaultShape;
                    if (riserShape === "line") {
                        drawMarker = markerVisible.call(pseudoProtovisContext, label);
                        drawLine = true
                    } else if (riserShapesHasLine)
                        alignToLineWidth = true
                }
                markers[i] = {
                    type: "dot",
                    shape: drawMarker ? shapeLookup.call(pseudoProtovisContext, label) || "circle" : null,
                    size: chart.legend.markerSize,
                    w: chart.legend.markerSize,
                    h: chart.legend.markerSize,
                    alignV: "center",
                    color: fillLookup.call(pseudoProtovisContext, label),
                    border: strokeLookup.call(pseudoProtovisContext, label),
                    lineWidth: lineWidthLookup.call(pseudoProtovisContext, label),
                    lineDash: lineDashLookup.call(pseudoProtovisContext, label),
                    angle: rotationLookup.call(pseudoProtovisContext, label) * 180 / Math.PI,
                    className: tdgchart.buildClassName("legend-markers", i),
                    title: title
                };
                if (drawLine) {
                    markers[i].type = "dotline";
                    markers[i].markerLineWidth = defaultLineWidth.call(pseudoProtovisContext, label) || 0;
                    markers[i].markerLineLength = chart.legend.markerSize * LEGEND_LINE_MARKER_LENGTH;
                    markers[i].markerLineColor = defaultLineColor.call(pseudoProtovisContext, label);
                    markers[i].markerLineDash = defaultLineDash.call(pseudoProtovisContext, label);
                    markers[i].w = Math.max(markers[i].w, markers[i].markerLineLength);
                    markers[i].h = Math.max(markers[i].h, markers[i].markerLineWidth)
                }
                if (alignToLineWidth) {
                    markers[i].w = Math.max(markers[i].w, chart.legend.markerSize * LEGEND_LINE_MARKER_LENGTH);
                    markers[i].alignH = "center"
                }
            }
        });
        return markers
    }
    function getColorBinLegendEntries(chart, free_space) {
        var colorAxis = chart.cache.get("colorAxis", {});
        var markerStyle = chart.get("colorScale.binMarkers", {});
        var concatSymbol = chart.get("colorScale.binMarkers.concatSymbol", "...");
        var fmt = chart.get("colorScale.numberFormat", "auto");
        var ticks = colorAxis.tickMarks || [];
        var minMax = tdg.minMax(ticks);
        var tickLabels = ticks.map(function(el) {
            return chart.formatNumber(el, fmt, minMax)
        });
        var labels = []
          , markers = [];
        for (var i = 1; i < ticks.length; i++) {
            labels.push(tickLabels[i - 1] + concatSymbol + tickLabels[i]);
            if (markerStyle.visible)
                markers.push({
                    type: "dot",
                    shape: chart.get("colorScale.binMarkers.shape", "square"),
                    alignV: "center",
                    size: markerStyle.size || 0,
                    w: markerStyle.size || 0,
                    h: markerStyle.size || 0,
                    color: colorAxis.scale(ticks[i - 1] + 1E-8),
                    border: tdg.get("border.color", markerStyle, "black"),
                    lineWidth: tdg.get("border.width", markerStyle, 1)
                })
        }
        return getLegendLines(chart, free_space, labels, markers, chart.colorScale.labels, chart.colorScale.binMarkers.position)
    }
    function getSeriesLegendEntries(chart, free_space) {
        var labels = chart.getFixedLegendSeriesLabels(chart);
        if (!labels)
            return null;
        var markers = getMarkers(chart, labels);
        return getLegendLines(chart, free_space, labels, markers, chart.legend.labels, chart.legend.markerPosition)
    }
    function getLegendLines(chart, free_space, labels, markers, labelProps, markerPosition) {
        var alignH;
        var entries = [];
        labels.forEach(function(label, i) {
            if (label.hasOwnProperty("visible") && !label.visible)
                return;
            var lblSize = chart.measureLabel(label, labelProps.font);
            label = {
                type: "label",
                t: label,
                _original: {
                    t: label._original
                },
                wrap: labelProps.wrap,
                w: lblSize.width,
                h: lblSize.height,
                color: labelProps.color,
                font: labelProps.font,
                className: tdgchart.buildClassName("legend-labels", i),
                title: markers && markers[i] ? markers[i].title : null
            };
            if (!markers[i] || !markers[i].size)
                entries.push(label);
            else {
                var marker = markers[i];
                var side = chart.getLegendSide();
                var leftOrRight = side !== "top" && side !== "bottom";
                var labelEntry;
                var labelMarkerPad = 0;
                if (chart.legend.labelMarkerPad)
                    if (tdg.isPercentString(chart.legend.labelMarkerPad))
                        labelMarkerPad = tdg.applyNumOrPercent(chart.legend.labelMarkerPad, lblSize.height, 0, 100) || 0;
                    else
                        labelMarkerPad = chart.legend.labelMarkerPad || 0;
                switch (markerPosition) {
                case "top":
                    marker.theOnly = true;
                    marker.padBottom = Math.max(labelMarkerPad, chart.getPadding("label", "aveVert"));
                    labelEntry = {
                        array: [marker, label],
                        alignH: "center"
                    };
                    break;
                case "bottom":
                    label.theOnly = true;
                    marker.padTop = Math.max(labelMarkerPad, chart.getPadding("label", "aveVert"));
                    labelEntry = {
                        array: [label, marker],
                        alignH: "center"
                    };
                    alignH = "center";
                    break;
                case "right":
                    marker.padLeft = Math.max(labelMarkerPad, chart.getPadding("label", "aveHorz"));
                    label.markerMargin = marker.w + marker.padLeft;
                    label.alignV = "center";
                    labelEntry = {
                        array: [label, marker],
                        alignH: leftOrRight ? "right" : "center"
                    };
                    break;
                default:
                case "left":
                    marker.padRight = Math.max(labelMarkerPad, chart.getPadding("label", "aveHorz"));
                    label.markerMargin = marker.w + marker.padRight;
                    label.alignV = "center";
                    labelEntry = {
                        array: [marker, label]
                    };
                    break
                }
                var labelLabelPad = 0;
                if (chart.legend.labelLabelPad)
                    if (tdg.isPercentString(chart.legend.labelLabelPad))
                        labelLabelPad = tdg.applyNumOrPercent(chart.legend.labelLabelPad, lblSize.height, 0, 100) || 0;
                    else
                        labelLabelPad = chart.legend.labelLabelPad || 0;
                labelEntry.padTop = Math.max(chart.getPadding("label", "top"), leftOrRight && labelLabelPad);
                labelEntry.padLeft = Math.max(chart.getPadding("label", "left"), !leftOrRight && labelLabelPad);
                labelEntry.padRight = Math.max(chart.getPadding("label", "right"), !leftOrRight && labelLabelPad);
                labelEntry.padBottom = Math.max(chart.getPadding("label", "bottom"), leftOrRight && labelLabelPad);
                if (chart.chartType === "legend" && free_space) {
                    labelEntry.padTop = labelEntry.padBottom = Math.floor(free_space.h / (free_space.rows + 1));
                    labelEntry.padLeft = labelEntry.padRight = Math.floor(free_space.w / (free_space.cols + 1))
                }
                entries.push(labelEntry)
            }
        });
        var res = {
            array: entries,
            syncWidth: true
        };
        if (shouldReverseLegend(chart))
            res.array.reverse();
        if (alignH)
            res.alignH = alignH;
        if (chart.legend.maxEntries)
            res.maxEntries = chart.legend.maxEntries;
        return res
    }
    function shouldReverseLegend(chart) {
        if (chart.hasColorScale() && chart.get("colorScale.colorMode") === "bin")
            return !!chart.get("colorScale.invert");
        return chart.legend.reverseOrder
    }
    function getLegendMarkers(chart, free_space) {
        var isVerticalLegend = chart.hasVerticalLegend();
        var labels = chart.getFixedLegendSeriesLabels(chart);
        var markerSize = chart.legend.markerSize || 0;
        if (!labels || !markerSize)
            return null;
        var markers = getMarkers(chart, labels);
        labels.forEach(function(label, i) {
            if (label.hasOwnProperty("visible") && !label.visible)
                return;
            if (!markers[i] || !markers[i].size)
                return;
            var marker = markers[i];
            if (isVerticalLegend)
                marker.theOnly = true;
            marker.padTop = chart.getPadding("label", "top");
            marker.padLeft = chart.getPadding("label", "left");
            marker.padRight = chart.getPadding("label", "right");
            marker.padBottom = chart.getPadding("label", "bottom");
            if (free_space) {
                marker.padTop += Math.floor(free_space.h / (free_space.rows + 1));
                marker.padBottom += Math.floor(free_space.h / (free_space.rows + 1));
                marker.padLeft += Math.floor(free_space.w / (free_space.cols + 1));
                marker.padRight += Math.floor(free_space.w / (free_space.cols + 1))
            }
        });
        var res = {
            array: markers,
            syncWidth: true
        };
        if (shouldReverseLegend(chart))
            res.array.reverse();
        if (chart.legend.maxEntries)
            res.maxEntries = chart.legend.maxEntries;
        return res
    }
    function computeLegend(legend, widthLimit, defaultHPad, defaultVPad, fillW, fillH) {
        function getWidthLimit(baseLimit, elementLimit) {
            if (elementLimit && elementLimit >= 1)
                return elementLimit;
            else if (elementLimit && elementLimit > 0)
                return elementLimit * baseLimit;
            else
                return baseLimit
        }
        function computeElementsMaxWidth(objectsArray, widthLimit) {
            var maxWidth;
            for (var i = 0; i < objectsArray.length; i++) {
                var element = objectsArray[i];
                if (!element || element.ignore)
                    continue;
                if (Array.isArray(element) || element.array) {
                    var res = computeRecursive(element, widthLimit);
                    maxWidth = Math.max(maxWidth || 0, res.w)
                } else
                    maxWidth = Math.max(maxWidth || 0, element.w)
            }
            return maxWidth
        }
        function computeRecursive(objects, widthLimit, syncToWidth) {
            var objectsArray = objects.array || objects;
            widthLimit = getWidthLimit(widthLimit, objects.widthLimit);
            var maxColumns = objects.maxColumns;
            var syncWidth = objects.syncWidth;
            var haveScroll = objects.haveScroll;
            var line = {
                y: 0,
                w: 0,
                h: 0,
                elements: []
            };
            var lines = {
                type: "array",
                array: [line],
                w: 0,
                h: 0,
                padRight: 0,
                padLeft: 0,
                padTop: 0,
                padBottom: 0
            };
            var pos = 0;
            var reqLineHeightWithPad = 0;
            var totalLineWidthWithPad = 0;
            var reqHorizPad = 0;
            var reqVertPad = 0;
            objects._actualLines = 0;
            objects._actualColumns = 0;
            if (haveScroll)
                if (haveScroll.direction === "vertical") {
                    lines.scroll = {
                        direction: "vertical",
                        width: haveScroll.size,
                        height: 50
                    };
                    widthLimit -= haveScroll.size
                } else if (haveScroll.direction === "horizontal") {
                    lines.scroll = {
                        direction: "horizontal",
                        width: 50,
                        height: haveScroll.size
                    };
                    widthLimit += haveScroll.reduceWidth || 0
                }
            function doneWithLine(line) {
                objects._actualLines = (objects._actualLines || 0) + 1;
                lines.w = Math.max(lines.w, line.w);
                if (line === lines.array[0])
                    lines.padTop = reqVertPad;
                else
                    line.y += reqVertPad;
                for (var i = 0; i < line.elements.length; i++)
                    if (line.elements[i].e.alignV === "center")
                        line.elements[i].yoff = Math.floor((line.h - line.elements[i].e.h) / 2);
                    else if (line.elements[i].e.alignV === "bottom")
                        line.elements[i].yoff = Math.floor(line.h - line.elements[i].e.h)
            }
            function maximizeElements(lines, width) {
                for (var l = 0; l < lines.array.length; l++) {
                    var line = lines.array[l];
                    if (line.maximize) {
                        var dw = Math.max(0, width - line.w);
                        line.elements[0].w += dw;
                        line.w += dw
                    }
                }
            }
            function alignHorizontally(align, lines, width, syncToWidth) {
                if (align !== "right" && align !== "center")
                    return;
                var alignWidth = Math.max(width, syncToWidth || 0);
                for (var l = 0; l < lines.array.length; l++) {
                    var line = lines.array[l];
                    line.xoff = align === "right" ? alignWidth - line.w : Math.floor((alignWidth - line.w) / 2)
                }
            }
            var maxWidth;
            if (syncWidth)
                maxWidth = computeElementsMaxWidth(objectsArray, widthLimit);
            var wrapLineLater = false;
            var elementsInLine = 0;
            var anyMaximize = false;
            var count = Math.min(objectsArray.length, objects.maxEntries || objectsArray.length);
            for (var i = 0; i < count; i++) {
                if (!objectsArray[i] || objectsArray[i].ignore)
                    continue;
                var element = objectsArray[i];
                var isArrayElement = Array.isArray(element) || element.array != null;
                var needfillW = element.fillW;
                var needfillH = element.fillH;
                if (isArrayElement)
                    element = computeRecursive(element, widthLimit, syncWidth ? maxWidth : null);
                var pad = Math.max(reqHorizPad, element.padLeft || defaultHPad || 0);
                var width = syncWidth ? maxWidth : element.w;
                var height = element.h;
                if (needfillW && fillW)
                    width += fillW;
                if (needfillH && fillH)
                    height += fillH;
                var wrapLine = wrapLineLater || element.maximize || element.theOnly || pos + pad + width > widthLimit || maxColumns && elementsInLine >= maxColumns;
                wrapLineLater = element.maximize || element.theOnly;
                if (pos !== 0 && !wrapLine)
                    pos += pad;
                else
                    lines.padLeft = Math.max(lines.padLeft || defaultHPad || 0, pad);
                if (pos !== 0 && wrapLine) {
                    doneWithLine(line);
                    objects._actualColumns = Math.max(objects._actualColumns || 0, elementsInLine);
                    var newline = {
                        y: line.y + line.h,
                        w: 0,
                        h: 0,
                        elements: [],
                        maximize: element.maximize
                    };
                    totalLineWidthWithPad = Math.max(totalLineWidthWithPad, line.w + reqHorizPad);
                    reqVertPad = reqLineHeightWithPad - line.h;
                    pos = 0;
                    elementsInLine = 0;
                    reqLineHeightWithPad = 0;
                    reqHorizPad = 0;
                    anyMaximize = anyMaximize || newline.maximize;
                    lines.array.push(newline);
                    line = newline
                }
                reqLineHeightWithPad = Math.max(reqLineHeightWithPad, height + (element.padBottom || defaultVPad || 0));
                line.h = Math.max(line.h, height);
                line.w = pos + width;
                line.elements.push({
                    e: element,
                    x: pos,
                    w: width,
                    h: height
                });
                reqVertPad = Math.max(reqVertPad, element.padTop || defaultVPad || 0);
                pos += width;
                reqHorizPad = element.padRight || defaultHPad || 0;
                elementsInLine++;
                lines.fillW = lines.fillW || element.fillW || needfillW;
                lines.fillH = lines.fillH || element.fillH || needfillH
            }
            doneWithLine(line);
            objects._actualColumns = Math.max(objects._actualColumns || 0, elementsInLine);
            lines.h = line.y + line.h;
            if (haveScroll)
                if (lines.scroll.direction === "vertical") {
                    lines.h -= haveScroll.reduceHeight || 0;
                    lines.w += haveScroll.size + 2;
                    lines.scroll.reduceHeight = haveScroll.reduceHeight;
                    lines.scroll.h = lines.h
                } else {
                    lines.w -= haveScroll.reduceWidth || 0;
                    lines.h += haveScroll.size + 2;
                    lines.scroll.reduceWidth = haveScroll.reduceWidth;
                    lines.scroll.w = lines.w
                }
            lines.padBottom = reqLineHeightWithPad - line.h;
            lines.padRight = totalLineWidthWithPad - lines.w;
            if (anyMaximize)
                maximizeElements(lines, lines.w);
            alignHorizontally(objects.alignH, lines, lines.w, syncToWidth);
            lines.maximize = objects.maximize;
            lines.alignV = objects.alignV;
            lines.theOnly = objects.theOnly;
            lines.padTop = Math.max(lines.padTop, objects.padTop || 0);
            lines.padBottom = Math.max(lines.padBottom, objects.padBottom || 0);
            lines.padLeft = Math.max(lines.padLeft, objects.padLeft || 0);
            lines.padRight = Math.max(lines.padRight, objects.padRight || 0);
            return lines
        }
        var legendDrawInfo = computeRecursive(legend, widthLimit);
        if (legend.legendLabels)
            legendDrawInfo.legendLabelsInfo = {
                rows: legend.legendLabels._actualLines,
                cols: legend.legendLabels._actualColumns
            };
        return legendDrawInfo
    }
    function reverseSide(side) {
        var rev = {
            left: "right",
            right: "left",
            top: "bottom",
            bottom: "top"
        };
        return rev[side]
    }
    function truncateTexts(chart, array, maxWidth, defaultHPad, maxWrap) {
        maxWidth -= 2;
        if (array.array)
            array = array.array;
        for (var i = 0; i < array.length; i++) {
            var lblSize, e = array[i];
            if (!e)
                continue;
            if (Array.isArray(e) || e.array)
                truncateTexts(chart, e, maxWidth, defaultHPad, maxWrap);
            else if (e.type === "label") {
                if (!e._original)
                    e._original = {
                        t: e.t,
                        w: e.w,
                        h: e.h
                    };
                if (!e._original.w || !e._original.h) {
                    lblSize = chart.measureLabel(e._original.t, e.font);
                    e._original.w = lblSize.width;
                    e._original.h = lblSize.height
                }
                if (e._original.w > maxWidth) {
                    var wrap = maxWrap ? Math.min(maxWrap, e.wrap) : e.wrap;
                    e.t = chart.applyWrapAndTruncate(e._original.t, e.font, wrap, "legend", maxWidth - (e.markerMargin || 0));
                    lblSize = chart.measureLabel(e.t, e.font);
                    e.w = lblSize.width;
                    e.h = lblSize.height
                }
            }
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.drawLegend = function(panel, legendLayout) {
        var chart = this;
        if (!chart.isLegendVisible())
            return;
        var legendGroup;
        var legendDrawInfo = legendLayout.legendDrawInfo;
        var scene = chart.cache.get("tdgscene");
        if (chart.dataArrayMap && chart.isLeaflet())
            chart.cacheLeafletBubbleMarkerSize();
        var aria = chart.needAccessibility() ? {
            attributes: {
                "aria-hidden": true
            }
        } : null;
        if (!chart.legend.dock.enabled || tdgchart.extensionManager.isExtension(chart.chartType)) {
            legendGroup = scene.group(panel, "legend", legendDrawInfo.pos.x, legendDrawInfo.pos.y, legendDrawInfo.w, legendDrawInfo.h, true, aria);
            chart.drawLegendFrame(legendGroup, legendDrawInfo, legendDrawInfo.borderSize);
            drawLegendRecursive(chart, legendGroup, legendDrawInfo.borderSize + legendDrawInfo.borderPad.left, legendDrawInfo.borderSize + legendDrawInfo.borderPad.top, legendDrawInfo)
        } else {
            var dockCtrlGroup = scene.group(panel, "legend-dock", legendDrawInfo.dock.pos.x, legendDrawInfo.dock.pos.y, undefined, undefined, false, aria);
            var clipLegendGroup = scene.group(panel, "legend-clip", legendDrawInfo.pos.x, legendDrawInfo.pos.y, legendDrawInfo.w, legendDrawInfo.h, true, aria);
            legendGroup = clipLegendGroup.group("legend");
            chart.drawLegendFrame(legendGroup, legendDrawInfo, legendDrawInfo.borderSize, chart.getLegendSide(true));
            drawLegendRecursive(chart, legendGroup, legendDrawInfo.borderSize + legendDrawInfo.borderPad.left, legendDrawInfo.borderSize + legendDrawInfo.borderPad.top, legendDrawInfo);
            if (chart.legend.dock.showMarkers) {
                chart.drawLegendFrame(dockCtrlGroup, legendDrawInfo.dock.info, legendDrawInfo.borderSize, chart.getLegendSide(true));
                drawLegendRecursive(chart, dockCtrlGroup, legendDrawInfo.borderSize + legendDrawInfo.dock.info.borderPad.left, legendDrawInfo.borderSize + legendDrawInfo.dock.info.borderPad.top, legendDrawInfo.dock.info)
            }
            chart.addLegendDockControls(chart, legendGroup, dockCtrlGroup, legendDrawInfo)
        }
    }
    ;
    function drawLegendRecursive(chart, parent, x, y, lines) {
        var group = parent.group(undefined, x, y);
        if (lines.scroll)
            group = chart.drawLegendScroll(chart, group, lines);
        for (var l = 0; l < lines.array.length; l++) {
            var line = lines.array[l];
            var line_y = line.y;
            var line_xoff = line.xoff || 0;
            for (var i = 0; i < line.elements.length; i++) {
                var element = line.elements[i];
                x = line_xoff + element.x;
                y = line_y + (element.yoff || 0);
                var width = element.w || element.e.w;
                var height = element.h || element.e.h;
                var d, path;
                switch (element.e.type) {
                case "array":
                    drawLegendRecursive(chart, group, x, y, element.e);
                    break;
                case "dot":
                    var m = element.e.alignH === "center" ? Math.max(0, (width - element.e.size) / 2) : 0;
                    d = group.dot(x + m + element.e.size / 2 + .5, y + element.e.size / 2 + .5, element.e.size, element.e.shape, {
                        color: element.e.color,
                        border: element.e.border,
                        lineWidth: element.e.lineWidth,
                        title: element.e.title,
                        className: element.e.className,
                        rotation: element.e.angle,
                        antialias: element.e.shape === "square" && (!element.e.angle || element.e.angle % 90 === 0) ? false : undefined
                    });
                    chart.addBevel(d, group);
                    break;
                case "dotline":
                    path = new tdgchart.tdgscene.path;
                    path.moveTo(0, 0);
                    path.lineTo(0 + element.e.markerLineLength, 0);
                    d = group.group(element.e["class"], x, y + 1, undefined, undefined, undefined, undefined, {
                        title: element.e.title
                    });
                    d.path(0, element.e.size / 2, path, {
                        border: element.e.markerLineColor,
                        lineWidth: element.e.markerLineWidth || 0,
                        dash: element.e.markerLineDash,
                        antialias: false
                    });
                    if (element.e.shape) {
                        var dot = d.dot(element.e.w / 2 + .5, element.e.h / 2 + .5, element.e.size, element.e.shape, {
                            color: element.e.color,
                            border: element.e.border,
                            lineWidth: element.e.lineWidth,
                            rotate: element.e.angle,
                            antialias: element.e.shape === "square" && (!element.e.angle || element.e.angle % 90 === 0) ? false : undefined
                        });
                        chart.addBevel(dot, d)
                    }
                    break;
                case "label":
                    var w = element.e.alignH === "center" ? width / 2 : element.e.alignH === "right" ? width : 0;
                    group.label(x + w, y, element.e.t.toString(), {
                        font: element.e.font,
                        color: element.e.color,
                        align: element.e.alignH,
                        valign: "top",
                        title: element.e.title,
                        className: element.e.className
                    });
                    break;
                case "sizeLegend":
                    drawSizeLegend(group, line_xoff + element.x, line_y, element.e);
                    break;
                case "colorScaleLegend":
                    drawColorScaleLegend(chart, group, line_xoff + element.x, line_y, width, height, element.e);
                    break;
                default:
                    group.rect(x, y, width, height, {
                        lineWidth: element.e.lineWidth || "1px",
                        border: element.e.color || "brown"
                    });
                    break
                }
            }
        }
        return group
    }
    function drawColorScaleLegend(chart, parent, x, y, width, height, colorScaleLayout) {
        var isVerticalLegend = chart.hasVerticalLegend();
        var colorAxis = colorScaleLayout.colorAxis;
        width = colorScaleLayout.scaleWidth;
        height = colorScaleLayout.scaleHeight;
        var group = parent.group("colorScale", x + colorScaleLayout.scaleX, y + colorScaleLayout.scaleY);
        var size = {
            width: width,
            height: height
        };
        group.computedSize = size;
        var stops = colorAxis.stops;
        group.rect(0, 0, width, height, {
            lineWidth: colorScaleLayout.lineWidth,
            border: colorScaleLayout.color,
            color: {
                type: "linear",
                angle: colorScaleLayout.direction,
                stops: stops
            },
            className: "legendColorScale"
        });
        var tickX = isVerticalLegend ? width : 0;
        var tickY = isVerticalLegend ? 0 : height;
        var tickGroup = group.group(null, tickX, tickY);
        tickGroup.computedSize = size;
        var groups = {
            chartSize: size,
            axis: {
                colorScale: {
                    fg: group,
                    axis: tickGroup
                }
            }
        };
        var legendScale = chart.getNumericScale(size, colorAxis, colorAxis.minMax);
        legendScale.side = isVerticalLegend ? "right" : "bottom";
        chart.drawNumericAxis(groups, legendScale, colorAxis)
    }
    function drawSizeLegend(parent, x, y, sizeLegend) {
        var markers = sizeLegend.getMarkersInfo();
        if (!markers)
            return;
        var biggest = markers[0];
        var minMax = tdg.minMax(markers, "value");
        if (tdg.eq(minMax.min, minMax.max)) {
            var v = minMax.min;
            minMax.min = v * .98;
            minMax.max = v * 1.02
        }
        var realheight = sizeLegend.layout === "circle" ? 2 * biggest.r + sizeLegend.lblSize.height : biggest.r + sizeLegend.lblSize.height / 2;
        y -= Math.max(0, (sizeLegend.h - realheight) / 2);
        var lastr;
        for (var i = 0; i < markers.length; i++) {
            var r = markers[i].r;
            if (r === 1 && markers[i].value === 0)
                continue;
            var text = sizeLegend.formatNumber(markers[i].value, minMax);
            if (sizeLegend.layout === "circle") {
                if (lastr && 2 * Math.abs(lastr - r) < sizeLegend.lblSize.height * .88)
                    continue;
                parent.circle(x + sizeLegend.w / 2, y + sizeLegend.h - r, r, {
                    lineWidth: sizeLegend.lineWidth,
                    border: sizeLegend.color,
                    className: tdgchart.buildClassName("sizeLegend-markers", i)
                });
                parent.label(x + sizeLegend.w / 2, y + sizeLegend.h - 2 * r - 2, text, {
                    font: sizeLegend.font,
                    color: sizeLegend.fontcolor,
                    align: "middle",
                    valign: "bottom",
                    className: tdgchart.buildClassName("sizeLegend-labels", i)
                })
            } else {
                if (lastr && Math.abs(lastr - r) < sizeLegend.lblSize.height * .69)
                    continue;
                var margin = Math.max(0, sizeLegend.w - biggest.r - sizeLegend.lblSize.width - sizeLegend.hpad) / 2;
                parent.arc(x + margin + biggest.r, y + sizeLegend.h, r, 90, 180, {
                    lineWidth: sizeLegend.lineWidth,
                    border: sizeLegend.color,
                    className: tdgchart.buildClassName("sizeLegend-markers", i)
                });
                parent.label(x + margin + biggest.r + sizeLegend.hpad, y + sizeLegend.h - r - 2, text, {
                    font: sizeLegend.font,
                    color: sizeLegend.fontcolor,
                    valign: "middle",
                    className: tdgchart.buildClassName("sizeLegend-labels", i)
                })
            }
            lastr = r
        }
    }
    tdgchart.prototype.drawLegendFrame = function(group, legend, borderSize, dockSide) {
        var chart = this;
        var x = borderSize / 2;
        var y = borderSize / 2;
        var w = legend.w - borderSize;
        var h = legend.h - borderSize;
        var attrs = {
            lineWidth: borderSize,
            border: chart.legend.lineStyle.color,
            dash: chart.legend.lineStyle.dash,
            color: chart.legend.backgroundcolor,
            className: "legend-background"
        };
        var r = 5;
        if (!dockSide || 2 * r > w || 2 * r > h)
            group.rect(x, y, w, h, attrs);
        else {
            var p = new tdgchart.tdgscene.path;
            switch (dockSide) {
            case "right":
                p.moveTo(x + w, y);
                p.lineTo(x + r, y);
                p.arcTo(r, r, 0, 0, 0, x, y + r);
                p.lineTo(x, y + h - r);
                p.arcTo(r, r, 0, 0, 0, x + r, y + h);
                p.lineTo(x + w, y + h);
                break;
            case "left":
                p.moveTo(x, y);
                p.lineTo(x + w - r, y);
                p.arcTo(r, r, 0, 0, 1, x + w, y + r);
                p.lineTo(x + w, y + h - r);
                p.arcTo(r, r, 0, 0, 1, x + w - r, y + h);
                p.lineTo(x, y + h);
                break;
            case "top":
                p.moveTo(x, y);
                p.lineTo(x, y + h - r);
                p.arcTo(r, r, 0, 0, 0, x + r, y + h);
                p.lineTo(x + w - r, y + h);
                p.arcTo(r, r, 0, 0, 0, x + w, y + h - r);
                p.lineTo(x + w, y);
                break;
            case "bottom":
                p.moveTo(x, y + h);
                p.lineTo(x, y + r);
                p.arcTo(r, r, 0, 0, 1, x + r, y);
                p.lineTo(x + w - r, y);
                p.arcTo(r, r, 0, 0, 1, x + w, y + r);
                p.lineTo(x + w, y + h);
                break
            }
            group.path(0, 0, p, attrs)
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.addLegendDockControls = function(chart, legendGroup, dockCtrlGroup, legendDrawInfo) {
        var side = chart.getLegendSide(true);
        var len;
        switch (side) {
        case "top":
            len = -(legendDrawInfo.h - legendDrawInfo.dock.h);
            break;
        case "bottom":
            len = legendDrawInfo.h - legendDrawInfo.dock.h;
            break;
        case "left":
            len = -(legendDrawInfo.w - legendDrawInfo.dock.w);
            break;
        default:
        case "right":
            len = legendDrawInfo.w - legendDrawInfo.dock.w;
            break
        }
        var open;
        if (chart.legend.dock.showMarkers)
            open = drawLegendDockControl(chart, dockCtrlGroup, "legend-dock-open", legendDrawInfo.dock.info, true, false);
        else
            open = drawLegendDockControl(chart, dockCtrlGroup, "legend-dock-open", legendDrawInfo);
        var close = drawLegendDockControl(chart, legendGroup, "legend-dock-close", legendDrawInfo, true, true);
        var isExpanded = !chart.legend.dock.minimized;
        if (isExpanded)
            dockCtrlGroup.visible(false);
        else
            legendGroup.visible(false);
        function openEvent() {
            dockCtrlGroup.visible(false);
            slideGroup(chart, legendGroup, len, side === "left" || side === "right", false, chart.legend.dock.animate);
            if (chart.getLegendSide() && chart.legend.dock.resizeFrame)
                resizeChartFrameAndRedraw(chart, true, side, Math.abs(len))
        }
        function closeEvent() {
            slideGroup(chart, legendGroup, len, side === "left" || side === "right", true, chart.legend.dock.animate, function() {
                dockCtrlGroup.visible(true)
            });
            if (chart.getLegendSide() && chart.legend.dock.resizeFrame)
                resizeChartFrameAndRedraw(chart, false, side, Math.abs(len))
        }
        open.click.interaction.events.click = openEvent;
        open.click.interaction.events.touchend = openEvent;
        close.click.interaction.events.click = closeEvent;
        close.click.interaction.events.touchend = closeEvent;
        function mouseOver() {
            open.hover.color(chart.legend.dock.button.hoverColor);
            close.hover.color(chart.legend.dock.button.hoverColor)
        }
        function mouseOut() {
            open.hover.color(chart.legend.dock.button.color);
            close.hover.color(chart.legend.dock.button.color)
        }
        if (chart.legend.dock.button.hoverColor) {
            open.hover.interaction.events.mouseover = mouseOver;
            close.hover.interaction.events.mouseover = mouseOver;
            open.hover.interaction.events.mouseout = mouseOut;
            close.hover.interaction.events.mouseout = mouseOut
        }
    }
    ;
    function slideGroup(chart, group, width, horizontal, reverse, animate, after) {
        var root = chart.cache.get_or_set("root", tdgchart.d3.select("#" + chart.documentRoot));
        var gr = root.select("." + group.className);
        if (!gr.node())
            return;
        var translate = gr.attr("transform");
        var x = 0
          , y = 0;
        if (translate) {
            var a = translate.split(/[(),]/);
            x = parseInt(a[1], 10);
            y = parseInt(a[2], 10)
        } else
            translate = "translate(0,0)";
        if (!reverse)
            if (!animate) {
                gr.style("display", null);
                if (after)
                    after()
            } else
                gr.attr("transform", "translate(" + (x + (horizontal ? width : 0)) + "," + (y + (horizontal ? 0 : width)) + ")").style("display", null).transition().duration(500).attr("transform", translate).each("end", function() {
                    if (after)
                        after()
                });
        else if (!animate) {
            gr.style("display", "none");
            if (after)
                after()
        } else
            gr.transition().duration(500).attr("transform", "translate(" + (x + (horizontal ? width : 0)) + "," + (y + (horizontal ? 0 : width)) + ")").each("end", function() {
                tdgchart.d3.select(this).style("display", "none").attr("transform", translate);
                if (after)
                    after()
            })
    }
    function resizeChartFrameAndRedraw(chart, expand, side, diff) {
        var redraw = function() {
            chart.legend.dock.minimized = !expand;
            chart.redraw()
        };
        var root = chart.cache.get_or_set("root", tdgchart.d3.select("#" + chart.documentRoot));
        var chartPanel = root.select(".chartPanel");
        if (!chartPanel.node())
            return;
        if (!chart.legend.dock.animate) {
            redraw();
            return
        }
        var isVerticalLegend = chart.hasVerticalLegend();
        var isExpanded = !chart.legend.dock.minimized;
        var chartPanelRect = chartPanel.node().getBoundingClientRect();
        var size = chartPanelRect[isVerticalLegend ? "width" : "height"];
        var ratio = expand ? isExpanded ? 1 : (size - diff) / size : isExpanded ? (size + diff) / size : 1;
        var x = 0
          , y = 0;
        switch (side) {
        case "top":
            y = chartPanel.node().getBoundingClientRect().bottom;
            break;
        case "bottom":
            y = chartPanel.node().getBoundingClientRect().top;
            break;
        case "left":
            x = chartPanel.node().getBoundingClientRect().right;
            break;
        default:
        case "right":
            x = chartPanel.node().getBoundingClientRect().left;
            break
        }
        var start = "translate( " + x + "," + y + ") " + "scale(1,1) " + "translate( " + -x + "," + -y + ")";
        var transform = "translate( " + x + "," + y + ") " + "scale(" + (isVerticalLegend ? ratio : 1) + "," + (isVerticalLegend ? 1 : ratio) + ") " + "translate( " + -x + "," + -y + ")";
        if (!chartPanel.attr("transform"))
            chartPanel.attr("transform", start);
        chartPanel.transition().duration(500).attr("transform", transform).each("end", redraw)
    }
    function drawLegendDockControl(chart, parent, className, legendDrawInfo, internal, close) {
        function direction(position, rev) {
            var d;
            var reverse = {
                r: "l",
                l: "r",
                u: "d",
                d: "u"
            };
            switch (position) {
            case "top":
                d = "d";
                break;
            case "bottom":
                d = "u";
                break;
            case "left":
                d = "r";
                break;
            case "right":
                d = "l";
                break
            }
            return rev ? reverse[d] || "r" : d || "l"
        }
        var group = parent.group(undefined, legendDrawInfo.borderSize / 2, legendDrawInfo.borderSize / 2);
        var pad = {
            x: chart.getPadding("frame", "left"),
            y: chart.getPadding("frame", "top")
        };
        var offset = tdg.cloneObject(pad);
        var position = chart.getLegendSide(true);
        if (internal)
            offset = chart.legendDockOffset(legendDrawInfo, {
                w: legendDrawInfo.dock.size,
                h: legendDrawInfo.dock.size
            }, position);
        if (!internal)
            chart.drawLegendFrame(group, legendDrawInfo.dock, legendDrawInfo.borderSize, position);
        var x = offset.x + legendDrawInfo.borderSize;
        var y = offset.y + legendDrawInfo.borderSize;
        var props = {
            color: chart.legend.dock.button.color || "red",
            border: chart.legend.dock.button.border.color || "transparent",
            lineWidth: chart.legend.dock.button.border.width || 0,
            className: className
        };
        group.rect(offset.x - pad.x, 0, pad.x + legendDrawInfo.dock.size + pad.x, y + legendDrawInfo.dock.size + pad.y, {
            color: "transparent"
        });
        var button = group.dot(x + legendDrawInfo.dock.size / 2, y + legendDrawInfo.dock.size / 2, legendDrawInfo.dock.size, "triangle-" + direction(position, close), props);
        return {
            click: group,
            hover: button
        }
    }
    tdgchart.prototype.legendDockOffset = function(legendDrawInfo, dock, position) {
        var chart = this;
        var x = 0
          , y = 0;
        if (chart.legend.dock.sideControls)
            switch (position) {
            case "top":
                x = legendDrawInfo.w / 2 - dock.w / 2;
                break;
            case "bottom":
                x = legendDrawInfo.w / 2 - dock.w / 2;
                y = legendDrawInfo.h - dock.h;
                break;
            case "left":
                y = legendDrawInfo.h / 2 - dock.h / 2;
                break;
            case "right":
                x = legendDrawInfo.w - dock.w;
                y = legendDrawInfo.h / 2 - dock.h / 2;
                break
            }
        else
            switch (position) {
            case "top":
                x = 0;
                break;
            case "bottom":
                x = 0;
                y = legendDrawInfo.h - dock.h;
                break;
            case "left":
                y = 0;
                break;
            case "right":
                x = legendDrawInfo.w - dock.w;
                y = 0;
                break
            }
        switch (position) {
        case "top":
            x += !chart.legend.dock.sideControls ? chart.getPadding("frame", "left") : 0;
            y += chart.getPadding("frame", "top") + legendDrawInfo.borderSize;
            break;
        case "bottom":
            x += !chart.legend.dock.sideControls ? chart.getPadding("frame", "left") : 0;
            y -= chart.getPadding("frame", "bottom") + legendDrawInfo.borderSize;
            break;
        case "left":
            x += chart.getPadding("frame", "left") + legendDrawInfo.borderSize;
            y += !chart.legend.dock.sideControls ? chart.getPadding("frame", "top") : 0;
            break;
        case "right":
            x -= chart.getPadding("frame", "right") + legendDrawInfo.borderSize;
            y += !chart.legend.dock.sideControls ? chart.getPadding("frame", "top") : 0;
            break
        }
        return {
            x: x,
            y: y
        }
    }
    ;
    tdgchart.prototype.drawLegendScroll = function(chart, group, lines) {
        var scrollGroup = {
            name: "legendLabels",
            x: 0,
            y: 0,
            w: lines.w,
            h: lines.h,
            virt_w: lines.w + (lines.scroll.reduceWidth || 0),
            virt_h: lines.h + (lines.scroll.reduceHeight || 0),
            scroll_h: lines.scroll.direction === "vertical" ? 0 : 1,
            scroll_v: lines.scroll.direction === "vertical" ? 1 : 0,
            clip: true,
            className: "scrollLegendLabels",
            debugColor: "rgba(0,255,0, 0.3)"
        };
        scrollGroup.g = chart.addScrollGroup(group, scrollGroup);
        var colors = {
            space: chart.legend.scroll.color,
            bar: chart.legend.scroll.handle.color,
            hoverBar: chart.legend.scroll.handle.hoverColor,
            barborder: chart.legend.scroll.handle.border.color,
            barborderwidth: chart.legend.scroll.handle.border.width
        };
        if (lines.scroll.direction === "vertical") {
            var x = lines.w - lines.scroll.width + 1;
            chart.addScrollBar(group, "legendLabels-v", {
                x: x,
                y: 0
            }, lines.h, lines.scroll.width, scrollGroup, colors)
        } else {
            var y = lines.h - lines.scroll.height + 1;
            chart.addScrollBar(group, "legendLabels-h", {
                x: 0,
                y: y
            }, lines.w, lines.scroll.height, scrollGroup, colors)
        }
        return scrollGroup.g
    }
}
)();
(function() {
    function pythag(a, b) {
        var at = Math.abs(a);
        var bt = Math.abs(b);
        var ct;
        var result;
        if (at > bt) {
            ct = bt / at;
            result = at * Math.sqrt(1 + ct * ct)
        } else if (bt != 0) {
            ct = at / bt;
            result = bt * Math.sqrt(1 + ct * ct)
        } else
            result = 0;
        return result
    }
    function backsub(u, w, v, m, n, b, x) {
        var j;
        var s;
        var tmp = [];
        for (j = 1; j <= n; j++) {
            s = 0;
            if (w[j] != 0) {
                for (var i = 1; i <= m; i++)
                    s += u[i][j] * b[i];
                s /= w[j]
            }
            tmp[j] = s
        }
        for (j = 1; j <= n; j++) {
            s = 0;
            for (var jj = 1; jj <= n; jj++)
                s += v[j][jj] * tmp[jj];
            x[j] = s
        }
    }
    function decomp(a, m, n, w, v) {
        var i, its, j, jj, k, l, nm = 0;
        var c, f, h, s, x, y, z, temp;
        var anorm = 0;
        var g = 0;
        var scale = 0;
        var rv1;
        var bFlag;
        var o = {
            status: false,
            message: ""
        };
        if (n < 1) {
            o.message = "Not enough columns: " + n;
            return o
        }
        l = 0;
        rv1 = [];
        for (i = 1; i <= n; i++) {
            l = i + 1;
            rv1[i] = scale * g;
            g = s = scale = 0;
            if (i <= m) {
                for (k = i; k <= m; k++)
                    scale += Math.abs(a[k][i]);
                if (scale != 0) {
                    for (k = i; k <= m; k++) {
                        a[k][i] /= scale;
                        s += a[k][i] * a[k][i]
                    }
                    f = a[i][i];
                    g = Math.sqrt(s);
                    if (f >= 0)
                        g *= -1;
                    h = f * g - s;
                    a[i][i] = f - g;
                    if (i != n)
                        for (j = l; j <= n; j++) {
                            s = 0;
                            for (k = i; k <= m; k++)
                                s += a[k][i] * a[k][j];
                            f = s / h;
                            for (k = i; k <= m; k++)
                                a[k][j] += f * a[k][i]
                        }
                    for (k = i; k <= m; k++)
                        a[k][i] *= scale
                }
            }
            w[i] = scale * g;
            g = 0;
            s = 0;
            scale = 0;
            if (i <= m && i != n) {
                for (k = l; k <= n; k++)
                    scale += Math.abs(a[i][k]);
                if (scale != 0) {
                    for (k = l; k <= n; k++) {
                        a[i][k] /= scale;
                        s += a[i][k] * a[i][k]
                    }
                    f = a[i][l];
                    g = Math.sqrt(s);
                    if (f >= 0)
                        g *= -1;
                    h = f * g - s;
                    a[i][l] = f - g;
                    for (k = l; k <= n; k++)
                        rv1[k] = a[i][k] / h;
                    if (i != m)
                        for (j = l; j <= m; j++) {
                            s = 0;
                            for (k = l; k <= n; k++)
                                s += a[j][k] * a[i][k];
                            for (k = l; k <= n; k++)
                                a[j][k] += s * rv1[k]
                        }
                    for (k = l; k <= n; k++)
                        a[i][k] *= scale
                }
            }
            anorm = Math.max(anorm, Math.abs(w[i]) + Math.abs(rv1[i]))
        }
        for (i = n; i >= 1; i--) {
            if (i < n) {
                if (g != 0) {
                    for (j = l; j <= n; j++)
                        v[j][i] = a[i][j] / a[i][l] / g;
                    for (j = l; j <= n; j++) {
                        s = 0;
                        for (k = l; k <= n; k++)
                            s += a[i][k] * v[k][j];
                        for (k = l; k <= n; k++)
                            v[k][j] += s * v[k][i]
                    }
                }
                for (j = l; j <= n; j++)
                    v[i][j] = v[j][i] = 0
            }
            v[i][i] = 1;
            g = rv1[i];
            l = i
        }
        for (i = n; i >= 1; i--) {
            l = i + 1;
            g = w[i];
            if (i < n)
                for (j = l; j <= n; j++)
                    a[i][j] = 0;
            if (g != 0) {
                g = 1 / g;
                if (i != n)
                    for (j = l; j <= n; j++) {
                        s = 0;
                        for (k = l; k <= m; k++)
                            s += a[k][i] * a[k][j];
                        f = s / a[i][i] * g;
                        for (k = i; k <= m; k++)
                            a[k][j] += f * a[k][i]
                    }
                for (j = i; j <= m; j++)
                    a[j][i] *= g
            } else
                for (j = i; j <= m; j++)
                    a[j][i] = 0;
            ++a[i][i]
        }
        var FP = {
            equal: function(a, b) {
                return Math.abs(a - b) < Number.EPSILON
            }
        };
        for (k = n; k >= 1; k--)
            for (its = 1; its <= 30; its++) {
                bFlag = true;
                for (l = k; l >= 1; l--) {
                    nm = l - 1;
                    if (FP.equal(Math.abs(rv1[l]) + anorm, anorm)) {
                        bFlag = false;
                        break
                    }
                    if (FP.equal(w[nm] + anorm, anorm))
                        break
                }
                if (bFlag) {
                    c = 0;
                    s = 1;
                    for (i = l; i <= k; i++) {
                        f = s * rv1[i];
                        rv1[i] = c * rv1[i];
                        if (FP.equal(f + anorm, anorm))
                            break;
                        g = w[i];
                        h = pythag(f, g);
                        w[i] = h;
                        h = 1 / h;
                        c = g * h;
                        s = -f * h;
                        for (j = 1; j <= m; j++) {
                            y = a[j][nm];
                            z = a[j][i];
                            a[j][nm] = y * c + z * s;
                            a[j][i] = z * c - y * s
                        }
                    }
                }
                z = w[k];
                if (l == k) {
                    if (z < 0) {
                        w[k] = -z;
                        for (j = 1; j <= n; j++)
                            v[j][k] = -v[j][k]
                    }
                    break
                }
                if (its == 30) {
                    o.message = "SVD did not converge, iterations= " + its;
                    return o
                }
                x = w[l];
                nm = k - 1;
                y = w[nm];
                g = rv1[nm];
                h = rv1[k];
                f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2 * h * y);
                g = pythag(f, 1);
                temp = f >= 0 ? g : -g;
                f = ((x - z) * (x + z) + h * (y / (f + temp) - h)) / x;
                c = s = 1;
                for (j = l; j <= nm; j++) {
                    i = j + 1;
                    g = rv1[i];
                    y = w[i];
                    h = s * g;
                    g = c * g;
                    z = pythag(f, h);
                    rv1[j] = z;
                    c = f / z;
                    s = h / z;
                    f = x * c + g * s;
                    g = g * c - x * s;
                    h = y * s;
                    y = y * c;
                    for (jj = 1; jj <= n; jj++) {
                        x = v[jj][j];
                        z = v[jj][i];
                        v[jj][j] = x * c + z * s;
                        v[jj][i] = z * c - x * s
                    }
                    z = pythag(f, h);
                    w[j] = z;
                    if (z != 0) {
                        z = 1 / z;
                        c = f * z;
                        s = h * z
                    }
                    f = c * g + s * y;
                    x = c * y - s * g;
                    for (jj = 1; jj <= m; jj++) {
                        y = a[jj][j];
                        z = a[jj][i];
                        a[jj][j] = y * c + z * s;
                        a[jj][i] = z * c - y * s
                    }
                }
                rv1[l] = 0;
                rv1[k] = f;
                w[k] = x
            }
        o.status = true;
        return o
    }
    tdgchart.prototype.svdfit = function(curve, xyRaw, sig) {
        var o = {
            status: false,
            message: "",
            a: [],
            chisq: 0
        };
        if (!curve.hasOwnProperty("numCoeffs") || !curve.hasOwnProperty("evaluate") || !curve.hasOwnProperty("transformY") || !curve.hasOwnProperty("invTransformCoeff")) {
            o.message = "curve lacks required method(s)";
            return o
        }
        var a = [];
        var chisq = 0
          , sstot = 0
          , sserr = 0;
        var nData = xyRaw.length;
        var nCoeffs = curve.numCoeffs;
        var xRaw = [];
        var yRaw = [];
        var i, j;
        for (i = 0; i < nData; i++) {
            var xyPair = xyRaw[i];
            xRaw[i + 1] = xyPair.x;
            yRaw[i + 1] = xyPair.y
        }
        var afunc = [];
        var xTemp = [];
        var yTemp = [];
        var iPoint = 0;
        for (i = 1; i <= nData; i++) {
            curve.evaluate(xRaw[i], afunc);
            var yTemp2 = curve.transformY(yRaw[i]);
            if (!isNaN(yTemp2) && yTemp2 != null) {
                iPoint++;
                xTemp[iPoint] = xRaw[i];
                yTemp[iPoint] = yTemp2
            }
        }
        var nValid = iPoint;
        if (nValid < nCoeffs) {
            o.message = "Too few valid data points = " + iPoint;
            return o
        }
        var x = [];
        var y = [];
        var ysum = 0
          , xsum = 0;
        for (i = 1; i <= nValid; i++) {
            x[i] = xTemp[i];
            y[i] = yTemp[i];
            ysum += y[i];
            xsum += x[i]
        }
        var ymean = ysum / nValid;
        var xmean = xsum / nValid;
        var b = [];
        var u = [];
        var v = [];
        var w = [];
        for (i = 1; i <= nValid; i++) {
            u[i] = [];
            v[i] = [];
            w[i] = []
        }
        for (i = 1; i <= nValid; i++) {
            curve.evaluate(x[i], afunc);
            var tmp = sig == null ? 1 : 1 / sig[i];
            for (j = 1; j <= nCoeffs; j++)
                u[i][j] = afunc[j] * tmp;
            b[i] = y[i] * tmp
        }
        var decompStatus = decomp(u, nValid, nCoeffs, w, v);
        if (decompStatus.message !== "")
            o.message = decompStatus.message + "\n" + o.message;
        var wMax = 0;
        for (j = 1; j <= nCoeffs; j++)
            if (w[j] > wMax)
                wMax = w[j];
        var TOL = 1E-15;
        var thresh = TOL * wMax;
        for (j = 1; j <= nCoeffs; j++)
            if (w[j] < thresh)
                w[j] = 0;
        backsub(u, w, v, nValid, nCoeffs, b, a);
        chisq = 0;
        sstot = 0;
        sserr = 0;
        var sx = 0
          , sy = 0
          , sxy = 0
          , sxx = 0
          , syy = 0;
        for (i = 1; i <= nValid; i++) {
            curve.evaluate(x[i], afunc);
            var yExpected = 0;
            for (j = 1; j <= nCoeffs; j++)
                yExpected += a[j] * afunc[j];
            sstot += (yExpected - ymean) * (yExpected - ymean);
            sserr += (y[i] - yExpected) * (y[i] - yExpected);
            chisq += sserr / yExpected;
            if (curve.mode === "linear") {
                var Y = y[i] - ymean;
                var X = x[i] - xmean;
                sxy += X * Y;
                sx += X;
                sy += Y;
                sxx += X * X;
                syy += Y * Y
            }
        }
        var r;
        if (curve.mode === "linear")
            r = (nValid * sxy - sx * sy) / Math.sqrt((nValid * sxx - sx * sx) * (nValid * syy - sy * sy));
        var r2 = 1 - sserr / sstot;
        for (j = 1; j <= nCoeffs; j++)
            a[j] = curve.invTransformCoeff(j, a[j]);
        o.status = true;
        o.message = "";
        o.a = a;
        if (curve.mode === "linear")
            o.r = r;
        o.r2 = r2;
        o.chisq = chisq;
        return o
    }
}
)();
(function() {
    var NUM_CURVE_POINTS_PLOTTED = 50;
    var tdg = tdgchart.util;
    function haveGlobalBLAtrendline(chart) {
        return chart.isBLA() && chart.trendline.enabled && chart.blaProperties.seriesLayout != "percent"
    }
    function haveGlobalXYtrendline(chart) {
        return chart.isXYChart() && chart.trendline.enabled
    }
    function getScalesCfg(chart, xScalesList, yScalesList, xlabels, ylabels) {
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        var isXY = chartType === "scatter" || chartType === "bubble";
        var axisModes = chart.cache.get("axisModes", {});
        var timeInfo = chart.cache.get("xaxis_time_scale");
        var timeLabels = timeInfo && (timeInfo.compressedLabels || chart.getGroupLabels());
        var xCfg = xScalesList.map(function(x, i) {
            var n = x.axisName || "x" + (i + 1);
            var field = !isXY || i == 0 ? "x" : n;
            var ord = axisModes[n] === "ordinal";
            var scale;
            if (timeLabels)
                scale = pv.Scale.linear(0, timeLabels.length).range(x.range()[0], x.range()[x.range().length - 1]);
            else
                scale = ordinalScaleToNumeric(x);
            scale.range().band = x.range().band;
            return {
                name: n,
                scale: scale,
                info: {
                    isOrd: ord,
                    labels: xlabels,
                    field: field
                }
            }
        });
        var yCfg = yScalesList.map(function(y, i) {
            var n = y.axisName || "y" + (i + 1);
            var field = !isXY || i == 0 ? "y" : n;
            var ord = axisModes[n] === "ordinal";
            var scale = ordinalScaleToNumeric(y);
            if (ord && isXY)
                scale = scale.range(scale.range().reverse());
            return {
                name: n,
                isOrd: ord,
                scale: scale,
                info: {
                    isOrd: ord,
                    labels: ylabels,
                    field: field
                }
            }
        });
        return {
            x: xCfg,
            y: yCfg
        }
    }
    tdgchart.prototype.doTrendline = function(riserPanels, blaData, data, xScalesList, yScalesList, singleYidx, xlabels, ylabels) {
        var chart = this;
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        var trendlinesToDraw = {};
        data = data || chart.data;
        var xyData;
        if (haveGlobalBLAtrendline(chart))
            createTrendlineBLA(chart, trendlinesToDraw, riserPanels, blaData, data, xScalesList, yScalesList, xlabels, ylabels);
        else if (haveGlobalXYtrendline(chart)) {
            xyData = chart.preprocessXYChartData(data);
            createTrendlineXY(chart, trendlinesToDraw, riserPanels, xyData, data, xScalesList, yScalesList, xlabels, ylabels)
        }
        var seriesTrendline = (chart.getSeriesPropertyList("trendline") || []).some(function(el) {
            return el != null
        });
        var isXY = chartType === "scatter" || chartType === "bubble";
        if (seriesTrendline)
            if (isXY) {
                xyData = xyData || chart.preprocessXYChartData(data);
                createTrendlineXYSeries(chart, trendlinesToDraw, riserPanels, xyData, data, xScalesList, yScalesList, xlabels, ylabels)
            } else
                createTrendlineBLASeries(chart, trendlinesToDraw, riserPanels, blaData, data, xScalesList, yScalesList, xlabels, ylabels);
        for (riserPanelName in trendlinesToDraw)
            if (trendlinesToDraw.hasOwnProperty(riserPanelName))
                drawTrendlineList(chart, riserPanels[riserPanelName].fg, trendlinesToDraw[riserPanelName], trendlinesToDraw[riserPanelName].xScale, trendlinesToDraw[riserPanelName].yScale)
    }
    ;
    function createTrendlineBLA(chart, trendlinesToDraw, riserPanels, blaData, data, xScalesList, yScalesList, xlabels, ylabels) {
        var cfg = getScalesCfg(chart, xScalesList, yScalesList, xlabels, ylabels);
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        var gdata;
        var assignments = chart.getAxisAssignment(data);
        function onAxis(assignment) {
            return function(series, idx) {
                return assignments[idx] == assignment
            }
        }
        var ix = 0;
        for (var iy = 0; iy < yScalesList.length; iy++) {
            var currentAxisName = cfg.y[iy].name;
            var as_data;
            var needBarSeriesCheck = false;
            if (blaData && blaData[currentAxisName])
                if (blaData[currentAxisName].bar.length)
                    as_data = blaData[currentAxisName].bar;
                else {
                    as_data = blaData[currentAxisName].line;
                    as_data = as_data.concat(blaData[currentAxisName].area)
                }
            else {
                as_data = data.filter(onAxis(iy));
                needBarSeriesCheck = true
            }
            if (!as_data.length)
                continue;
            var isStacked = chart.getRiserSeriesLayout("bar") == "stacked";
            if (isStacked)
                gdata = setupData(chart, chartType, [sumBarData(as_data, needBarSeriesCheck)], cfg.x[ix].info, cfg.y[iy].info)[0];
            else
                gdata = pv.blend(setupData(chart, chartType, barSeriesIfAnyBars(as_data, needBarSeriesCheck), cfg.x[ix].info, cfg.y[iy].info));
            if (gdata && gdata.length) {
                var gminmax = getMinMax(gdata);
                prepTrendlineData(chart, trendlinesToDraw, currentAxisName, chart.trendline, "globalAtAxis" + (iy + 1), cfg.x[ix].scale, cfg.y[iy].scale, gdata, gminmax, "black")
            }
        }
        function barSeriesIfAnyBars(data, needBarSeriesCheck) {
            if (!needBarSeriesCheck)
                return data;
            var getShape = function(s) {
                return chart.getSeriesAndGroupProperty(s, null, "riserShape") || chartType
            };
            var barData = data.filter(function(d, i) {
                var shape = getShape(i);
                return shape != "line" && shape != "area"
            });
            if (barData.length == 0)
                barData = data;
            return barData
        }
        function sumBarData(data, needBarSeriesCheck) {
            var gdata = [];
            data = barSeriesIfAnyBars(data, needBarSeriesCheck);
            var lengths = tdg.max(data.map(function(series) {
                return series.length
            }));
            for (var g = 0; g < lengths; g++) {
                var sum = tdg.sum(data.map(function(series) {
                    return series[g]
                }), "value");
                gdata[g] = {
                    y: sum,
                    value: sum
                }
            }
            return gdata
        }
    }
    function createTrendlineXY(chart, trendlinesToDraw, riserPanels, xyData, data, xScalesList, yScalesList, xlabels, ylabels) {
        var cfg = getScalesCfg(chart, xScalesList, yScalesList, xlabels, ylabels);
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        for (var ix = 0; ix < xScalesList.length; ix++)
            for (var iy = 0; iy < yScalesList.length; iy++) {
                xySplitData = xyData.dataByRowCol[cfg.x[ix].name][cfg.y[iy].name];
                xySplitData = pv.blend(setupData(chart, chartType, xySplitData, cfg.x[ix].info, cfg.y[iy].info));
                xySplitData = xySplitData.filter(function(d) {
                    return d.x != undefined && d.y != undefined
                });
                xySplitData = xySplitData.sort(function(a, b) {
                    return a.x < b.x ? -1 : a.x > b.x ? 1 : 0
                });
                if (!xySplitData.length)
                    continue;
                var gminmax = getMinMax(xySplitData);
                var riserPanelName = (xScalesList.length > 1 ? cfg.x[ix].name : "") + cfg.y[iy].name;
                prepTrendlineData(chart, trendlinesToDraw, riserPanelName, chart.trendline, "globalAtAxis-" + cfg.x[ix].name + "-" + cfg.y[iy].name, cfg.x[ix].scale, cfg.y[iy].scale, xySplitData, gminmax, "black")
            }
    }
    function createTrendlineBLASeries(chart, trendlinesToDraw, riserPanels, blaData, data, xScalesList, yScalesList, xlabels, ylabels) {
        var cfg = getScalesCfg(chart, xScalesList, yScalesList, xlabels, ylabels);
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        function name(xc, yc) {
            return (xScalesList.length > 1 ? xc.name : "") + yc.name
        }
        data = setupData(chart, chartType, data, cfg.x[0].info, cfg.y[0].info);
        var minmax = getMinMaxArray(data);
        if (!data.length)
            return;
        var ix = 0;
        for (var s = 0; s < data.length; s++) {
            var seriesObj = chart.getSeries(s);
            if (seriesObj && seriesObj.trendline) {
                var iy = seriesObj.yAxisAssignment ? seriesObj.yAxisAssignment - 1 : 0;
                prepTrendlineData(chart, trendlinesToDraw, name(cfg.x[ix], cfg.y[iy]), seriesObj.trendline, s, cfg.x[ix].scale, cfg.y[iy].scale, data[s], minmax[s], seriesObj.color)
            }
        }
    }
    function createTrendlineXYSeries(chart, trendlinesToDraw, riserPanels, xyData, data, xScalesList, yScalesList, xlabels, ylabels) {
        var cfg = getScalesCfg(chart, xScalesList, yScalesList, xlabels, ylabels);
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        function name(xc, yc) {
            return (xScalesList.length > 1 ? xc.name : "") + yc.name
        }
        for (var ix = 0; ix < xScalesList.length; ix++)
            for (var iy = 0; iy < yScalesList.length; iy++) {
                var tmpdata = setupData(chart, chartType, data, cfg.x[ix].info, cfg.y[iy].info);
                var minmax = getMinMaxArray(tmpdata);
                for (var s = 0; s < data.length; s++) {
                    var seriesObj = chart.getSeries(s);
                    if (seriesObj && seriesObj.trendline) {
                        var sorteddata = tmpdata[s].sort(function(a, b) {
                            return a.x < b.x ? -1 : a.x > b.x ? 1 : 0
                        });
                        prepTrendlineData(chart, trendlinesToDraw, name(cfg.x[ix], cfg.y[iy]), seriesObj.trendline, s, cfg.x[ix].scale, cfg.y[iy].scale, sorteddata, minmax[s], seriesObj.color)
                    }
                }
            }
    }
    function getMinMax(data) {
        var dataArray = pv.blend(data);
        var len = dataArray.length;
        var xMin = dataArray[0].x;
        var xMax = xMin;
        for (var i = 1; i < len; i++) {
            var d = dataArray[i].x;
            if (xMin == undefined || d < xMin)
                xMin = d;
            if (xMax == undefined || d > xMax)
                xMax = d
        }
        return {
            min: xMin,
            max: xMax
        }
    }
    function getMinMaxArray(data) {
        var minmaxArray = [];
        for (var s = 0; s < data.length; s++) {
            var minmax = getMinMax(data[s]);
            minmaxArray.push(minmax)
        }
        return minmaxArray
    }
    function prepTrendlineData(chart, trendlinesToDraw, riserPanelName, trendlineList, s, xScale, yScale, data, minmax, fallbackColor) {
        var i, t, curve;
        var trendline;
        var stats = chart.cache.get("stats");
        if (!trendlinesToDraw[riserPanelName])
            trendlinesToDraw[riserPanelName] = {
                curves: [],
                lines: [],
                xScale: xScale,
                yScale: yScale
            };
        if (!Array.isArray(trendlineList))
            trendlineList = [trendlineList];
        for (t = 0; t < trendlineList.length; t++) {
            if (!trendlineList[t].enabled)
                continue;
            trendline = tdg.clone(trendlineList[t]);
            if (["max", "min", "mean", "stddev", "ucl", "lcl"].includes(trendline.mode)) {
                var newLine = makeStatLine(chart, stats, yScale, s, data, trendline, fallbackColor, t);
                if (newLine)
                    for (i = 0; i < newLine.length; i++)
                        trendlinesToDraw[riserPanelName].lines.push(newLine[i])
            } else {
                curve = makeCurve(trendline, s);
                curve.yScale = yScale;
                if (curve.mode !== "none")
                    calcCoeffs(curve, data);
                calcCurvePoints(curve, minmax);
                trendlinesToDraw[riserPanelName].curves.push(curve)
            }
        }
        function makeCurve(seriesElement, s) {
            var curve = {
                s: s,
                mode: "none"
            };
            if (!seriesElement || !seriesElement.enabled)
                return curve;
            var curveType = seriesElement.mode || "linear";
            if (typeof curveBuilders[curveType] !== "function")
                return curve;
            seriesElement.lineStyle = seriesElement.lineStyle || {};
            seriesElement.equationLabel = seriesElement.equationLabel || {};
            var seriesColor = chart.getSeriesAndGroupProperty(s, null, "color");
            var color = seriesElement.lineStyle.color || seriesColor || "black";
            curve = curveBuilders[curveType](s, null, color);
            if (curveType === "polynomial") {
                var order = parseInt(seriesElement.order, 10) || 3;
                curve.numCoeffs = order + 1
            }
            curve.dash = seriesElement.lineStyle.dash || "";
            curve.width = seriesElement.lineStyle.width || 1;
            curve.showEquation = seriesElement.equationLabel.visible || false;
            curve.highOrderFirst = seriesElement.equationLabel.highOrderFirst || chart.trendline.equationLabel.highOrderFirst || false;
            curve.eqColor = seriesElement.equationLabel.color || "black";
            curve.eqFont = seriesElement.equationLabel.font || "8pt Sans-Serif";
            if (!tdg.isEmpty(seriesElement.equationLabel.content) && seriesElement.equationLabel.content !== "auto") {
                curve.equationMode = "template";
                curve.equationContent = seriesElement.equationLabel.content
            } else
                curve.equationMode = seriesElement.equationLabel.mode || "equation";
            return curve
        }
        function calcCoeffs(curve, data) {
            var svdObj = chart.svdfit(curve, data, null);
            var coeffs = [];
            for (var i = 0; i < svdObj.a.length; i++)
                coeffs[i] = svdObj.a[i];
            curve.coeffs = coeffs;
            if (svdObj.r != undefined)
                curve.r = svdObj.r;
            curve.r2 = svdObj.r2;
            curve.status = svdObj.status
        }
        function calcCurvePoints(curve, minmax) {
            curve.points = [];
            if (!curve.status)
                return;
            var xMin = minmax.min;
            var xMax = minmax.max;
            if (curve.mode === "linear") {
                var yMin = curve.compute(xMin);
                var yMax = curve.compute(xMax);
                curve.points[0] = [xMin, yMin];
                curve.points[1] = [xMax, yMax]
            } else if (curve.mode !== "none") {
                var nPlottedPoints = NUM_CURVE_POINTS_PLOTTED;
                var xIncr = (xMax - xMin) / (nPlottedPoints - 1);
                for (var i = 0; i < nPlottedPoints; i++) {
                    var xp = xMin + i * xIncr;
                    var yp = curve.compute(xp);
                    curve.points[i] = [xp, yp]
                }
            }
        }
    }
    function drawTrendlineList(chart, rootPanel, trendlinesToDraw, x, y) {
        var groupWidth = x.range().band;
        function isVisible() {
            var s = this.parent.index;
            var curve = trendlinesToDraw.curves[s] || {
                mode: "none"
            };
            return curve.mode !== "none"
        }
        function isEquationVisible() {
            var s = this.parent.index;
            var g = this.index;
            var curve = trendlinesToDraw.curves[s];
            if (!curve)
                return false;
            return curve.showEquation !== false && g === 0
        }
        function equationColor() {
            var eqColor = "black";
            var s = this.parent.index;
            var curve = trendlinesToDraw.curves[s];
            if (curve)
                eqColor = curve.eqColor;
            return eqColor
        }
        function equationFont() {
            var eqFont = "8pt Sans-Serif";
            var s = this.parent.index;
            var curve = trendlinesToDraw.curves[s];
            if (curve)
                eqFont = curve.eqFont;
            return eqFont
        }
        function trendlineLineStyle() {
            var curve = trendlinesToDraw.curves[this.parent.index] || {};
            curve.width = curve.width == null ? 1 : curve.width;
            curve.color = curve.color || "black";
            curve.dash = curve.dash || "";
            return curve
        }
        function left(d) {
            var val = d[0];
            if (extendToFrameEdge)
                val += .5;
            var xc = x(val);
            return xc
        }
        function bottom(d) {
            var s = this.parent.index;
            var curve = trendlinesToDraw.curves[s] || {
                mode: "none"
            };
            if (curve.mode !== "none")
                return curve.yScale(d[1]);
            return NaN
        }
        function equationLeft(d) {
            var s = this.parent.index;
            var curve = trendlinesToDraw.curves[s] || {
                mode: "none"
            };
            var val = d[0];
            if (curve.mode !== "none") {
                var points = curve.points;
                var last = points[points.length - 1];
                val = last[0]
            }
            var xc = x(val);
            if (this.rootComputedSize() && this.rootComputedSize().width) {
                var lblSize = chart.measureLabel(this.text(), this.font());
                var w = this.rootComputedSize().width;
                var maxX = w - this.textMargin();
                if (xc + lblSize.width > maxX)
                    xc = maxX - lblSize.width
            }
            return xc
        }
        function equationBottom(d) {
            var s = this.parent.index;
            var curve = trendlinesToDraw.curves[s] || {
                mode: "none"
            };
            var val = d[0];
            if (curve.mode !== "none") {
                var points = curve.points;
                var last = points[points.length - 1];
                val = last[1]
            }
            var yc = y(val);
            return yc + 18
        }
        function equationText() {
            var lineIdx = this.parent.index;
            var curve = trendlinesToDraw.curves[lineIdx] || {
                mode: "none"
            };
            var text = "";
            if (curve.mode !== "none") {
                var mode = curve.equationMode;
                if (mode === "r") {
                    if (curve.r != undefined)
                        text = "r = " + curve.r.toFixed(2)
                } else if (mode === "template" && curve.equationContent)
                    if (curve.mode == "linear")
                        text = chart.applyTemplate(curve.equationContent, {
                            r: curve.r,
                            m: curve.coeffs[2],
                            b: curve.coeffs[1],
                            x: curve.coeffs[1],
                            0: curve.coeffs[0],
                            1: curve.coeffs[1],
                            2: curve.coeffs[2]
                        }, null, {
                            series: null,
                            group: null,
                            trendline: null
                        });
                    else
                        text = chart.applyTemplate(curve.equationContent, curve.coeffs, [], {
                            series: curve.series,
                            group: null,
                            trendline: lineIdx
                        });
                else
                    text = curve.createEquation(curve.highOrderFirst, false)
            }
            return text
        }
        var basePanel = rootPanel.add(pv.Panel).className("trendlinesPanel").overflow("hidden");
        var panel = basePanel.add(pv.Panel);
        var s, curveData = [[]];
        for (var s = 0; s < trendlinesToDraw.curves.length; s++) {
            var curve = trendlinesToDraw.curves[s] || {
                s: s,
                mode: "none"
            };
            if (curve.mode !== "none" && curve.points)
                curveData[s] = curve.points
        }
        panel.data(curveData);
        var extendToFrameEdge = chart.blaProperties.extendToFrameEdge;
        var lineMark = panel.add(pv.Line).className(chart.classNameLookup("trendline")).data(function(d) {
            return d
        }).visible(isVisible).lineStyle(trendlineLineStyle).antialias(true);
        if (chart.isBLA() && chart.blaProperties.orientation === "horizontal")
            lineMark.left(bottom).top(left);
        else
            lineMark.left(left).bottom(bottom);
        var eq = chart.trendline.equationLabel || {
            visible: false
        };
        panel.add(pv.Label).def("rootComputedSize", rootPanel.computedSize).bottom(equationBottom).text(equationText).textAlign("left").textBaseline("top").textMargin(chart.getPadding("label", "aveHorz") * 2).visible(isEquationVisible).font(equationFont).left(equationLeft).textStyle(equationColor);
        var topLabelOffset = 5;
        var ticks_style = chart.yaxis.majorGrid.ticks.style;
        for (s = 0; s < trendlinesToDraw.lines.length; s++) {
            var line = trendlinesToDraw.lines[s];
            var labelProp = line.prop.equationLabel;
            if (Array.isArray(line.yPos)) {
                var points = [];
                line.yPos.forEach(function(el, idx) {
                    points.push([idx * groupWidth, el]);
                    points.push([(idx + 1) * groupWidth, el])
                });
                trendline = panel.add(pv.Line).lineStyle(line.prop.lineStyle).antialias(false).data(points).left(function(d) {
                    return d[0]
                }).bottom(function(d) {
                    return d[1]
                })
            } else {
                trendline = panel.add(pv.Rule).lineStyle(line.prop.lineStyle);
                if (!chart.isBLA() || chart.blaProperties.orientation === "vertical")
                    trendline.bottom(line.yPos);
                else
                    trendline.left(line.yPos)
            }
            var label = trendline.add(pv.Label).text(line.label).visible(Array.isArray(line.yPos) ? function() {
                if (labelProp.visible) {
                    var targetIdx = labelProp.position === "end" ? line.yPos.length * 2 - 1 : 0;
                    return targetIdx === this.index
                }
                return false
            }
            : labelProp.visible).font(labelProp.font).textStyle(labelProp.color);
            if (!chart.isBLA() || chart.blaProperties.orientation === "vertical")
                if (labelProp.position === "end")
                    label.textAlign("right").right(5);
                else
                    label.textAlign("left").left(["inner", "span"].includes(ticks_style) ? chart.yaxis.majorGrid.ticks.length : 5);
            else
                label.top(topLabelOffset).textBaseline("top");
            topLabelOffset += 20
        }
    }
    function makeStatLine(chart, stats, y, s, seriesDataSet, trendLineProp, fallbackColor, trendlineIdx) {
        if (!trendLineProp.enabled)
            return null;
        trendLineProp.lineStyle = trendLineProp.lineStyle || {};
        trendLineProp.lineStyle.color = trendLineProp.lineStyle.color || fallbackColor;
        trendLineProp.lineStyle.width = trendLineProp.lineStyle.width || 1;
        trendLineProp.equationLabel = trendLineProp.equationLabel || {};
        trendLineProp.equationLabel.color = trendLineProp.equationLabel.color || fallbackColor;
        trendLineProp.equationLabel.font = trendLineProp.equationLabel.font || "8pt Sans-Serif";
        var lineYCoordinate;
        var label = trendLineProp.mode;
        if (trendLineProp.mode === "min")
            lineYCoordinate = tdg.minR(seriesDataSet, "y");
        else if (trendLineProp.mode === "max")
            lineYCoordinate = tdg.maxR(seriesDataSet, "y");
        else if (trendLineProp.mode === "mean")
            lineYCoordinate = stats[s].mean;
        else if (trendLineProp.mode === "stddev") {
            lineYCoordinate = stats[s].stddev * trendLineProp.order;
            label = trendLineProp.order + label
        } else if (trendLineProp.mode === "ucl") {
            if (trendLineProp.order !== 3)
                label = "+" + trendLineProp.order + " \u03c3";
            if (stats[s].uclPoints == null)
                lineYCoordinate = stats[s].mean + stats[s].clDeviation * trendLineProp.order;
            else
                lineYCoordinate = stats[s].uclPoints.map(function(el) {
                    return stats[s].mean + trendLineProp.order * el
                })
        } else if (trendLineProp.mode === "lcl") {
            if (trendLineProp.order !== 3)
                label = "-" + trendLineProp.order + " \u03c3";
            if (stats[s].lclPoints == null)
                lineYCoordinate = Math.max(0, stats[s].mean - stats[s].clDeviation * trendLineProp.order);
            else
                lineYCoordinate = stats[s].lclPoints.map(function(el) {
                    return Math.max(0, stats[s].mean - trendLineProp.order * el)
                })
        }
        function buildLabel(value) {
            if (!tdg.isEmpty(trendLineProp.equationLabel.content) && trendLineProp.equationLabel.content !== "auto")
                return chart.applyTemplate(trendLineProp.equationLabel.content, {
                    trendline_value: value
                }, seriesDataSet, {
                    series: s,
                    group: null,
                    trendline: trendlineIdx
                });
            if (trendLineProp.equationLabel.mode === "label")
                return label;
            var domain = y.domain();
            var fmt = chart.getSeriesAndGroupProperty(s, 0, "dataLabels.numberFormat") || "auto";
            value = chart.formatNumber(value, fmt, {
                min: domain[0],
                max: domain[1]
            });
            if (trendLineProp.equationLabel.mode === "value")
                return value;
            return label + ": " + value
        }
        if (trendLineProp.mode.includes("stddev")) {
            var mean = stats[s].mean;
            if (tdg.eq(y.domain()[0], 0) && mean - lineYCoordinate < 0)
                return [{
                    label: buildLabel(mean + lineYCoordinate),
                    prop: trendLineProp,
                    yPos: y(mean + lineYCoordinate)
                }];
            return [{
                label: buildLabel(mean + lineYCoordinate),
                prop: trendLineProp,
                yPos: y(mean + lineYCoordinate)
            }, {
                label: buildLabel(mean - lineYCoordinate),
                prop: trendLineProp,
                yPos: y(mean - lineYCoordinate)
            }]
        } else if (Array.isArray(lineYCoordinate))
            return [{
                label: buildLabel(lineYCoordinate[lineYCoordinate.length - 1]),
                prop: trendLineProp,
                yPos: lineYCoordinate.map(y)
            }];
        else
            return [{
                label: buildLabel(lineYCoordinate),
                prop: trendLineProp,
                yPos: y(lineYCoordinate)
            }]
    }
    function calcOneLineStat(chart, data, line, s, res, yAxisAssignment) {
        res[s] = res[s] || {};
        if (Array.isArray(line))
            line.forEach(function(el) {
                calcOneLineStat(chart, data, el, s, res, yAxisAssignment)
            });
        else if (line && line.enabled && typeof line.mode === "string") {
            if (yAxisAssignment != null)
                res[s].yAxisAssignment = yAxisAssignment;
            var chartType = chart.chartType;
            var controlMode = chart.get("controlProperties.mode");
            var field = chartType === "scatter" || chartType === "bubble" ? "y" : "value";
            if (line.mode === "mean" && res[s].mean == null)
                if (chartType === "control")
                    if (controlMode === "u" || controlMode === "p")
                        res[s].mean = tdg.sum(data, "value") / tdg.sum(data, "sampleSize");
                    else
                        res[s].mean = tdg.mean(data, "y");
                else
                    res[s].mean = tdg.mean(data, field);
            else if (line.mode.includes("stddev") && res[s].stddev == null) {
                res[s].mean = res[s].mean || tdg.mean(data, field);
                res[s].stddev = tdg.deviation(data, field)
            } else if ((line.mode === "ucl" || line.mode === "lcl") && res[s].ucl == null && chartType === "control")
                if (controlMode === "u" || controlMode === "p") {
                    res[s].mean = res[s].mean || tdg.sum(data, field) / tdg.sum(data, "sampleSize");
                    res[s].uclPoints = [];
                    res[s].lclPoints = [];
                    data.forEach(function(el) {
                        var mean = controlMode === "p" ? res[s].mean * (1 - res[s].mean) : res[s].mean;
                        var dev = Math.sqrt(mean / el.sampleSize);
                        res[s].uclPoints.push(dev);
                        res[s].lclPoints.push(Math.max(0, dev))
                    });
                    res[s].lclMin = Math.max(0, res[s].mean - 3 * tdg.min(res[s].lclPoints));
                    res[s].uclMax = res[s].mean + 3 * tdg.max(res[s].uclPoints)
                } else {
                    res[s].mean = res[s].mean || tdg.mean(data, "y");
                    res[s].clDeviation = Math.sqrt(res[s].mean);
                    res[s].lclMin = Math.max(0, res[s].mean - 3 * res[s].clDeviation);
                    res[s].uclMax = res[s].mean + 3 * res[s].clDeviation
                }
        }
    }
    tdgchart.prototype.cacheStats = function(data) {
        var chart = this;
        if (chart.chartType === "control")
            chart.addControlLines();
        else if (chart.chartType === "boxplot")
            chart.calculateBoxplotStats();
        var res = {};
        calcOneLineStat(chart, data, chart.trendline, "global", res);
        var lengths = tdg.max(data.map(function(series) {
            return series.length
        }));
        if (haveGlobalBLAtrendline(chart)) {
            var onAxis = function(a) {
                return function(series, idx) {
                    return assignments[idx] == uniqueAssignments[a]
                }
            };
            var isStacked = chart.getRiserSeriesLayout("bar") == "stacked";
            var assignments = chart.getAxisAssignment(data);
            var uniqueAssignments = assignments.filter(function(assignment, idx, arr) {
                return arr.indexOf(assignment) === idx
            });
            for (var a = 0; a < uniqueAssignments.length; a++) {
                var as_data = data.filter(onAxis(a));
                if (!as_data.length)
                    continue;
                var sums = [];
                if (isStacked)
                    for (var g = 0; g < lengths; g++)
                        sums[g] = {
                            value: tdg.sum(as_data.map(function(series) {
                                return series[g]
                            }), "value")
                        };
                else
                    for (var g = 0; g < lengths; g++)
                        sums = pv.blend(as_data);
                calcOneLineStat(chart, sums, chart.trendline, "globalAtAxis" + uniqueAssignments[a], res)
            }
        } else if (haveGlobalXYtrendline(chart)) {
            var xyData = chart.preprocessXYChartData(data);
            for (var xa in xyData.dataByRowCol)
                if (xyData.dataByRowCol.hasOwnProperty(xa))
                    for (var ya in xyData.dataByRowCol[xa])
                        if (xyData.dataByRowCol[xa].hasOwnProperty(ya)) {
                            var xySplitData = xyData.dataByRowCol[xa][ya];
                            var sums = pv.blend(xySplitData);
                            calcOneLineStat(chart, sums, chart.trendline, "globalAtAxis-" + xa + "-" + ya, res)
                        }
        }
        chart.series.forEach(function(s) {
            if (s && s.trendline)
                calcOneLineStat(chart, data[s.series], s.trendline, s.series + "", res, s.yAxisAssignment)
        });
        chart.cache.set("stats", res)
    }
    ;
    function timeScaleToNumeric(timeInfo) {
        var axis = timeInfo.scale;
        var range = axis.range();
        var domain = [0, timeInfo.compressedLabels.length];
        return pv.Scale.linear(0, domain.length - 1).range(range[0], range[range.length - 1])
    }
    function ordinalScaleToNumeric(axisRaw) {
        var axis = axisRaw;
        if (axisRaw.splitBanded) {
            var domain = axisRaw.domain();
            var range = axisRaw.range();
            if (domain.length >= 2 && range.length >= 2)
                axis = pv.Scale.linear(0, domain.length - 1).range(range[0], range[range.length - 1]);
            axis.band = range.band
        }
        return axis
    }
    function makeDatum(chart, chartType, g, d, xInfo, yInfo) {
        var datum = null;
        if (d && (chartType === "scatter" || chartType === "bubble")) {
            var xval = d[xInfo.field] == undefined ? d.x : d[xInfo.field];
            var yval = d[yInfo.field] == undefined ? d.y : d[yInfo.field];
            datum = {
                x: xInfo.isOrd ? xInfo.labels.indexOf(xval) + .5 : xval,
                y: yInfo.isOrd ? yInfo.labels.indexOf(yval) - .5 : yval
            }
        } else if (d && tdg.isANumber(d.value))
            datum = {
                x: g + .5,
                y: d.value
            };
        return datum
    }
    function setupData(chart, chartType, data, xInfo, yInfo) {
        var newData = [];
        for (var s = 0; s < data.length; s++) {
            var series = [];
            for (var g = 0; g < data[s].length; g++) {
                var datum = makeDatum(chart, chartType, g, data[s][g], xInfo, yInfo);
                if (datum != null)
                    series.push(datum)
            }
            if (series.length > 0)
                newData.push(series)
        }
        return newData
    }
    function makeCurveExponential(s, coeffs, c) {
        return {
            series: s,
            mode: "exponential",
            numCoeffs: 2,
            coeffs: coeffs,
            color: c,
            compute: function compute(x) {
                return this.coeffs[1] * Math.pow(this.coeffs[2], x)
            },
            transformY: function transformY(y) {
                return Math.log(y)
            },
            invTransformCoeff: function invTransformCoeff(ia, a) {
                return Math.exp(a)
            },
            evaluate: function evaluate(x, terms) {
                terms[1] = 1;
                terms[2] = x;
                return [null, terms[1], terms[2]]
            },
            createEquation: function createEquation(bHighOrderFirst, bIncludeY) {
                var strTerm1 = this.coeffs[1].toFixed(2);
                var strTerm2 = this.coeffs[2].toFixed(2) + "^x";
                var str = strTerm1 + " * " + strTerm2;
                return bIncludeY ? "y = " + str : str
            }
        }
    }
    function makeCurveGeometric(s, coeffs, c) {
        return {
            series: s,
            mode: "geometric",
            numCoeffs: 2,
            coeffs: coeffs,
            color: c,
            compute: function compute(x) {
                return this.coeffs[1] * Math.pow(x, this.coeffs[2])
            },
            transformY: function transformY(y) {
                return Math.log(y)
            },
            invTransformCoeff: function invTransformCoeff(ia, a) {
                return ia === 1 ? Math.exp(a) : a
            },
            evaluate: function evaluate(x, terms) {
                terms[1] = 1;
                terms[2] = Math.log(x);
                return [null, terms[1], terms[2]]
            },
            createEquation: function createEquation(bHighOrderFirst, bIncludeY) {
                var strTerm1 = this.coeffs[1].toFixed(2);
                var strTerm2 = "x^" + this.coeffs[2].toFixed(2);
                var str = strTerm1 + " * " + strTerm2;
                return bIncludeY ? "y = " + str : str
            }
        }
    }
    function makeCurveHyperbolic(s, coeffs, c) {
        return {
            series: s,
            mode: "hyperbolic",
            numCoeffs: 2,
            coeffs: coeffs,
            color: c,
            compute: function compute(x) {
                return this.coeffs[1] + this.coeffs[2] / x
            },
            transformY: function transformY(y) {
                return y
            },
            invTransformCoeff: function invTransformCoeff(ia, a) {
                return a
            },
            evaluate: function evaluate(x, terms) {
                terms[1] = 1;
                terms[2] = 1 / x;
                return [null, terms[1], terms[2]]
            },
            createEquation: function createEquation(bHighOrderFirst, bIncludeY) {
                var strTerm1 = this.coeffs[1].toFixed(2);
                var strTerm2 = this.coeffs[2].toFixed(2) + " / x";
                var str = strTerm1 + " + " + strTerm2;
                if (bHighOrderFirst)
                    str = strTerm2 + " + " + strTerm1;
                return bIncludeY ? "y = " + str : str
            }
        }
    }
    function makeCurveLinear(s, coeffs, c) {
        return {
            series: s,
            mode: "linear",
            numCoeffs: 2,
            coeffs: coeffs,
            color: c,
            compute: function compute(x) {
                return this.coeffs[1] + this.coeffs[2] * x
            },
            transformY: function transformY(y) {
                return y
            },
            invTransformCoeff: function invTransformCoeff(ia, a) {
                return a
            },
            evaluate: function evaluate(x, terms) {
                terms[1] = 1;
                terms[2] = x;
                return [null, terms[1], terms[2]]
            },
            createEquation: function createEquation(bHighOrderFirst, bIncludeY) {
                var strTerm1 = this.coeffs[1].toFixed(2);
                var strTerm2 = this.coeffs[2].toFixed(2) + " * x";
                var str = strTerm1 + " + " + strTerm2;
                if (bHighOrderFirst)
                    str = strTerm2 + " + " + strTerm1;
                return bIncludeY ? "y = " + str : str
            }
        }
    }
    function makeCurveLogarithmic(s, coeffs, c) {
        return {
            series: s,
            mode: "logarithmic",
            numCoeffs: 2,
            coeffs: coeffs,
            color: c,
            compute: function compute(x) {
                return this.coeffs[1] + this.coeffs[2] * Math.log(x)
            },
            transformY: function transformY(y) {
                return y
            },
            invTransformCoeff: function invTransformCoeff(ia, a) {
                return a
            },
            evaluate: function evaluate(x, terms) {
                terms[1] = 1;
                terms[2] = Math.log(x);
                return [null, terms[1], terms[2]]
            },
            createEquation: function createEquation(bHighOrderFirst, bIncludeY) {
                var strTerm1 = this.coeffs[1].toFixed(2);
                var strTerm2 = this.coeffs[2].toFixed(2) + " * log(x)";
                var str = strTerm1 + " + " + strTerm2;
                if (bHighOrderFirst)
                    str = strTerm2 + " + " + strTerm1;
                return bIncludeY ? "y = " + str : str
            }
        }
    }
    function makeCurveLogQuadratic(s, coeffs, c) {
        return {
            series: s,
            mode: "logQuadratic",
            numCoeffs: 3,
            coeffs: coeffs,
            color: c,
            compute: function compute(x) {
                return Math.exp(this.coeffs[1] + this.coeffs[2] * x + this.coeffs[3] * x * x)
            },
            transformY: function transformY(y) {
                return Math.log(y)
            },
            invTransformCoeff: function invTransformCoeff(ia, a) {
                return a
            },
            evaluate: function evaluate(x, terms) {
                terms[1] = 1;
                terms[2] = x;
                terms[3] = x * x;
                return [null, terms[1], terms[2], terms[3]]
            },
            createEquation: function createEquation(bHighOrderFirst, bIncludeY) {
                var strTerm1 = this.coeffs[1].toFixed(2);
                var strTerm2 = this.coeffs[2].toFixed(2) + " * x";
                var strTerm3 = this.coeffs[3].toFixed(2) + " * x^2";
                var str = "exp(" + strTerm1 + " + " + strTerm2 + " + " + strTerm3 + ")";
                if (bHighOrderFirst)
                    str = "exp(" + strTerm3 + " + " + strTerm2 + " + " + strTerm1 + ")";
                return bIncludeY ? "y = " + str : str
            }
        }
    }
    function makeCurveModExponential(s, coeffs, c) {
        return {
            series: s,
            mode: "modExponential",
            numCoeffs: 2,
            coeffs: coeffs,
            color: c,
            compute: function compute(x) {
                var y = this.coeffs[1] * Math.exp(this.coeffs[2] / x);
                return y
            },
            transformY: function transformY(y) {
                return Math.log(y)
            },
            invTransformCoeff: function invTransformCoeff(ia, a) {
                return ia === 1 ? Math.exp(a) : a
            },
            evaluate: function evaluate(x, terms) {
                terms[1] = 1;
                terms[2] = 1 / x;
                return [null, terms[1], terms[2]]
            },
            createEquation: function createEquation(bHighOrderFirst, bIncludeY) {
                var strTerm1 = this.coeffs[1].toFixed(2);
                var strTerm2 = this.coeffs[2].toFixed(2) + " / x";
                var str = strTerm1 + " * exp(" + strTerm2 + ")";
                return bIncludeY ? "y = " + str : str
            }
        }
    }
    function makeCurveModHyperbolic(s, coeffs, c) {
        return {
            series: s,
            mode: "modHyperbolic",
            numCoeffs: 2,
            coeffs: coeffs,
            color: c,
            compute: function compute(x) {
                return 1 / (this.coeffs[1] + this.coeffs[2] * x)
            },
            transformY: function transformY(y) {
                return 1 / y
            },
            invTransformCoeff: function invTransformCoeff(ia, a) {
                return a
            },
            evaluate: function evaluate(x, terms) {
                terms[1] = 1;
                terms[2] = x;
                return [null, terms[1], terms[2]]
            },
            createEquation: function createEquation(bHighOrderFirst, bIncludeY) {
                var strTerm1 = this.coeffs[1].toFixed(2);
                var strTerm2 = this.coeffs[2].toFixed(2) + " * x";
                var str = "1 / (" + strTerm1 + " + " + strTerm2 + ")";
                if (bHighOrderFirst)
                    str = "1 / (" + strTerm2 + " + " + strTerm1 + ")";
                return bIncludeY ? "y = " + str : str
            }
        }
    }
    function makeCurvePolynomial(s, coeffs, c) {
        return {
            series: s,
            mode: "polynomial",
            coeffs: coeffs,
            color: c,
            compute: function compute(x) {
                var y = this.coeffs[1];
                for (var i = 1; i < this.numCoeffs; i++)
                    y += this.coeffs[i + 1] * Math.pow(x, i);
                return y
            },
            transformY: function transformY(y) {
                return y
            },
            invTransformCoeff: function invTransformCoeff(ia, a) {
                return a
            },
            evaluate: function evaluate(x, terms) {
                var product = 1;
                for (var i = 1; i <= this.numCoeffs; i++) {
                    terms[i] = product;
                    product *= x
                }
                return terms
            },
            createEquation: function createEquation(bHighOrderFirst, bIncludeY) {
                var i, str;
                if (bHighOrderFirst) {
                    str = this.coeffs[2].toFixed(2) + " * x + " + this.coeffs[1].toFixed(2);
                    for (i = 3; i <= this.numCoeffs; i++)
                        str = this.coeffs[i].toFixed(2) + " * x^" + (i - 1) + " + " + str
                } else {
                    str = this.coeffs[1].toFixed(2) + " + " + this.coeffs[2].toFixed(2) + " * x";
                    for (i = 3; i <= this.numCoeffs; i++)
                        str = str + " + " + this.coeffs[i].toFixed(2) + " * x^" + (i - 1)
                }
                return bIncludeY ? "y = " + str : str
            }
        }
    }
    function makeCurveQuadratic(s, coeffs, c) {
        return {
            series: s,
            mode: "quadratic",
            numCoeffs: 3,
            coeffs: coeffs,
            color: c,
            compute: function compute(x) {
                return this.coeffs[1] + this.coeffs[2] * x + this.coeffs[3] * x * x
            },
            transformY: function transformY(y) {
                return y
            },
            invTransformCoeff: function invTransformCoeff(ia, a) {
                return a
            },
            evaluate: function evaluate(x, terms) {
                terms[1] = 1;
                terms[2] = x;
                terms[3] = x * x;
                return [null, terms[1], terms[2], terms[3]]
            },
            createEquation: function createEquation(bHighOrderFirst, bIncludeY) {
                var strTerm1 = this.coeffs[1].toFixed(2);
                var strTerm2 = this.coeffs[2].toFixed(2) + " * x";
                var strTerm3 = this.coeffs[3].toFixed(2) + " * x^2";
                var str = strTerm1 + " + " + strTerm2 + " + " + strTerm3;
                if (bHighOrderFirst)
                    str = strTerm3 + " + " + strTerm2 + " + " + strTerm1;
                return bIncludeY ? "y = " + str : str
            }
        }
    }
    function makeCurveRational(s, coeffs, c) {
        return {
            series: s,
            mode: "rational",
            numCoeffs: 2,
            coeffs: coeffs,
            color: c,
            compute: function compute(x) {
                return x / (this.coeffs[2] + this.coeffs[1] * x)
            },
            transformY: function transformY(y) {
                return 1 / y
            },
            invTransformCoeff: function invTransformCoeff(ia, a) {
                return a
            },
            evaluate: function evaluate(x, terms) {
                terms[1] = 1;
                terms[2] = 1 / x;
                return [null, terms[1], terms[2]]
            },
            createEquation: function createEquation(bHighOrderFirst, bIncludeY) {
                var strTerm1 = this.coeffs[2].toFixed(2);
                var strTerm2 = this.coeffs[1].toFixed(2) + " * x";
                var str = "x / (" + strTerm2 + " + " + strTerm1 + ")";
                if (bHighOrderFirst)
                    str = "x / (" + strTerm1 + " + " + strTerm2 + ")";
                return bIncludeY ? "y = " + str : str
            }
        }
    }
    var curveBuilders = {
        linear: makeCurveLinear,
        exponential: makeCurveExponential,
        geometric: makeCurveGeometric,
        hyperbolic: makeCurveHyperbolic,
        logarithmic: makeCurveLogarithmic,
        logQuadratic: makeCurveLogQuadratic,
        modExponential: makeCurveModExponential,
        modHyperbolic: makeCurveModHyperbolic,
        polynomial: makeCurvePolynomial,
        quadratic: makeCurveQuadratic,
        rational: makeCurveRational
    }
}
)();
(function() {
    tdgchart.prototype.pfjParser = {};
    tdgchart.prototype.pfjParser.postProcessList = [];
    tdgchart.prototype.pfjParser.tempState = {};
    tdgchart.prototype.pfjParser.permanentState = {};
    tdgchart.prototype.pfjParser.argNames = [];
    tdgchart.prototype.pfjParser.chartType = 0;
    var tdg = tdgchart.util;
    var numberFormatMap = ["auto", "#", "#,#%", "#,#.#%", "#,#.##%", "$#,#.##", "$#,#", "#,K", "$#,K", "#,,M", "$#,,M", "#,,,B", "$#,,,B", "#,,,,T", "$#,,,,T", "#,K", "#,.##K", "$#", "#", "#", "#", "#", "#", "#", "[<0](#);#", "[<0](#);#", "[<0](#,K);#,K", "[<0](#,K);#,K", "#,#`%", "#.#`%", "#.##`%", , , "#,#", "#,#.##"];
    var apo = {
        mode: "ordinal",
        bodyLineStyle: {
            color: "#444"
        },
        majorGrid: {
            lineStyle: {
                color: "#666"
            },
            ticks: {
                visible: false
            }
        }
    };
    var ap = {
        bodyLineStyle: {
            color: "#444"
        },
        majorGrid: {
            lineStyle: {
                color: "#666"
            },
            ticks: {
                visible: false
            }
        }
    };
    var tdFrame = {
        border: {
            color: "black"
        },
        fill: {
            color: "lightgrey"
        }
    };
    var defaultPieDataLabels = {
        displayMode: "%",
        numberFormat: "#%",
        formatCallback: function(dataObj, s, g, data) {
            if (Math.abs(dataObj.value) < 1E-7) {
                dataObj.noLabel = true;
                return null
            }
            var d = dataObj.value;
            var total = data.total == null ? getPieSum(this, g, dataObj) : data.total;
            return this.formatNumber(d / total || 0, "#%")
        }
    };
    var chartTypeMap = {
        0: {
            chartType: "bar3d",
            chartFrame: tdFrame,
            xaxis: apo,
            yaxis: ap,
            zaxis: apo,
            interaction: {
                mousedrag: "rotate"
            }
        },
        1: {
            chartType: "bar3d",
            chartFrame: tdFrame,
            xaxis: apo,
            yaxis: ap,
            zaxis: apo,
            interaction: {
                mousedrag: "rotate"
            }
        },
        2: {
            chartType: "bar3d",
            chartFrame: tdFrame,
            xaxis: apo,
            yaxis: ap,
            zaxis: apo,
            interaction: {
                mousedrag: "rotate"
            }
        },
        3: {
            chartType: "bar3d",
            chartFrame: tdFrame,
            xaxis: apo,
            yaxis: ap,
            zaxis: apo,
            interaction: {
                mousedrag: "rotate"
            }
        },
        4: {
            chartType: "bar3d",
            chartFrame: tdFrame,
            xaxis: apo,
            yaxis: ap,
            zaxis: apo,
            interaction: {
                mousedrag: "rotate"
            }
        },
        5: {
            chartType: "bar3d",
            chartFrame: tdFrame,
            xaxis: apo,
            yaxis: ap,
            zaxis: apo,
            interaction: {
                mousedrag: "rotate"
            }
        },
        6: {
            chartType: "area3d",
            chartFrame: tdFrame,
            xaxis: apo,
            yaxis: ap,
            zaxis: apo,
            interaction: {
                mousedrag: "rotate"
            }
        },
        7: {
            chartType: "area3d",
            chartFrame: tdFrame,
            xaxis: apo,
            yaxis: ap,
            zaxis: apo,
            interaction: {
                mousedrag: "rotate"
            }
        },
        8: {
            chartType: "area3d",
            chartFrame: tdFrame,
            xaxis: apo,
            yaxis: ap,
            zaxis: apo,
            interaction: {
                mousedrag: "rotate"
            }
        },
        9: {
            chartType: "area3d",
            chartFrame: tdFrame,
            xaxis: apo,
            yaxis: ap,
            zaxis: apo,
            interaction: {
                mousedrag: "rotate"
            }
        },
        10: {
            chartType: "area3d",
            chartFrame: tdFrame,
            xaxis: apo,
            yaxis: ap,
            zaxis: apo,
            interaction: {
                mousedrag: "rotate"
            }
        },
        11: {
            chartType: "area3d",
            chartFrame: tdFrame,
            xaxis: apo,
            yaxis: ap,
            zaxis: apo,
            interaction: {
                mousedrag: "rotate"
            }
        },
        12: {
            chartType: "surface3d",
            chartFrame: tdFrame,
            xaxis: apo,
            yaxis: ap,
            zaxis: apo,
            interaction: {
                mousedrag: "rotate"
            }
        },
        13: {
            chartType: "surface3d",
            chartFrame: tdFrame,
            xaxis: apo,
            yaxis: ap,
            zaxis: apo,
            interaction: {
                mousedrag: "rotate"
            }
        },
        14: {
            chartType: "surface3d",
            chartFrame: tdFrame,
            xaxis: apo,
            yaxis: ap,
            zaxis: apo,
            interaction: {
                mousedrag: "rotate"
            }
        },
        15: {
            chartType: "surface3d",
            chartFrame: tdFrame,
            xaxis: apo,
            yaxis: ap,
            zaxis: apo,
            interaction: {
                mousedrag: "rotate"
            }
        },
        16: {
            chartType: "surface3d",
            chartFrame: tdFrame,
            xaxis: apo,
            yaxis: ap,
            zaxis: apo,
            interaction: {
                mousedrag: "rotate"
            }
        },
        17: {
            chartType: "bar",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "sideBySide"
            }
        },
        18: {
            chartType: "bar",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "stacked"
            },
            dataLabels: {
                displayMode: "cumulative"
            }
        },
        19: {
            chartType: "bar",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "sideBySide"
            }
        },
        20: {
            chartType: "bar",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "stacked"
            },
            dataLabels: {
                displayMode: "cumulative"
            }
        },
        21: {
            chartType: "bar",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "sideBySide"
            }
        },
        22: {
            chartType: "bar",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "stacked"
            },
            dataLabels: {
                displayMode: "cumulative"
            }
        },
        23: {
            chartType: "bar",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "percent"
            },
            yaxis: {
                numberFormat: "#`%"
            }
        },
        24: {
            chartType: "bar",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "sideBySide"
            }
        },
        25: {
            chartType: "bar",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "stacked"
            },
            dataLabels: {
                displayMode: "cumulative"
            }
        },
        26: {
            chartType: "bar",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "sideBySide"
            }
        },
        27: {
            chartType: "bar",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "stacked"
            },
            dataLabels: {
                displayMode: "cumulative"
            }
        },
        28: {
            chartType: "bar",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "sideBySide"
            }
        },
        29: {
            chartType: "bar",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "stacked"
            },
            dataLabels: {
                displayMode: "cumulative"
            }
        },
        30: {
            chartType: "bar",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "percent"
            },
            yaxis: {
                numberFormat: "#`%"
            }
        },
        31: {
            chartType: "area",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "absolute"
            }
        },
        32: {
            chartType: "area",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "stacked"
            },
            dataLabels: {
                displayMode: "cumulative"
            }
        },
        33: {
            chartType: "area",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "absolute"
            }
        },
        34: {
            chartType: "area",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "stacked"
            },
            dataLabels: {
                displayMode: "cumulative"
            }
        },
        35: {
            chartType: "area",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "percent"
            },
            yaxis: {
                numberFormat: "#`%"
            }
        },
        36: {
            chartType: "area",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "absolute"
            }
        },
        37: {
            chartType: "area",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "stacked"
            },
            dataLabels: {
                displayMode: "cumulative"
            }
        },
        38: {
            chartType: "area",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "absolute"
            }
        },
        39: {
            chartType: "area",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "stacked"
            },
            dataLabels: {
                displayMode: "cumulative"
            }
        },
        40: {
            chartType: "area",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "percent"
            },
            yaxis: {
                numberFormat: "#`%"
            }
        },
        41: {
            chartType: "line",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "absolute"
            }
        },
        42: {
            chartType: "line",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "stacked"
            },
            dataLabels: {
                displayMode: "cumulative"
            }
        },
        43: {
            chartType: "line",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "absolute"
            }
        },
        44: {
            chartType: "line",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "stacked"
            },
            dataLabels: {
                displayMode: "cumulative"
            }
        },
        45: {
            chartType: "line",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "absolute"
            }
        },
        46: {
            chartType: "line",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "stacked"
            },
            dataLabels: {
                displayMode: "cumulative"
            }
        },
        47: {
            chartType: "line",
            blaProperties: {
                orientation: "vertical",
                seriesLayout: "percent"
            },
            yaxis: {
                numberFormat: "#`%"
            }
        },
        48: {
            chartType: "line",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "absolute"
            }
        },
        49: {
            chartType: "line",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "stacked"
            },
            dataLabels: {
                displayMode: "cumulative"
            }
        },
        50: {
            chartType: "line",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "absolute"
            }
        },
        51: {
            chartType: "line",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "stacked"
            },
            dataLabels: {
                displayMode: "cumulative"
            }
        },
        52: {
            chartType: "line",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "absolute"
            }
        },
        53: {
            chartType: "line",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "stacked"
            },
            dataLabels: {
                displayMode: "cumulative"
            }
        },
        54: {
            chartType: "line",
            blaProperties: {
                orientation: "horizontal",
                seriesLayout: "percent"
            },
            yaxis: {
                numberFormat: "#`%"
            }
        },
        55: {
            chartType: "pie",
            swapData: true,
            dataLabels: defaultPieDataLabels
        },
        56: {
            chartType: "pie",
            swapData: true,
            dataLabels: defaultPieDataLabels,
            pieProperties: {
                holeSize: 25,
                totalLabel: {
                    visible: true
                }
            }
        },
        57: {
            chartType: "pie",
            swapData: true,
            dataLabels: defaultPieDataLabels
        },
        58: {
            chartType: "pie",
            swapData: true,
            dataLabels: defaultPieDataLabels,
            pieProperties: {
                holeSize: 25,
                totalLabel: {
                    visible: true
                }
            }
        },
        59: {
            chartType: "pie",
            swapData: true,
            dataLabels: defaultPieDataLabels
        },
        60: {
            chartType: "pie",
            swapData: true,
            dataLabels: defaultPieDataLabels,
            pieProperties: {
                holeSize: 25,
                totalLabel: {
                    visible: true
                }
            }
        },
        61: {
            chartType: "scatter"
        },
        62: {
            chartType: "scatter"
        },
        63: {
            chartType: "scatter",
            dataLabels: {
                visible: true,
                displayMode: "x"
            }
        },
        64: {
            chartType: "scatter",
            dataLabels: {
                visible: true,
                displayMode: "x"
            }
        },
        65: {
            chartType: "polar"
        },
        66: {
            chartType: "polar"
        },
        67: {
            chartType: "radar"
        },
        68: {
            chartType: "radar",
            polarProperties: {
                drawAsArea: true
            }
        },
        69: {
            chartType: "radar"
        },
        70: {
            chartType: "stock",
            legend: {
                visible: false
            }
        },
        71: {
            chartType: "bar"
        },
        72: {
            chartType: "bar"
        },
        73: {
            chartType: "bar"
        },
        74: {
            chartType: "bar"
        },
        75: {
            chartType: "bar"
        },
        76: {
            chartType: "bar"
        },
        77: {
            chartType: "bar"
        },
        78: {
            chartType: "bar"
        },
        79: {
            chartType: "bar"
        },
        80: {
            chartType: "bar"
        },
        81: {
            chartType: "bar"
        },
        82: {
            chartType: "bar"
        },
        83: {
            chartType: "bar"
        },
        84: {
            chartType: "bar"
        },
        85: {
            chartType: "histogram",
            blaProperties: {
                orientation: "vertical"
            }
        },
        86: {
            chartType: "histogram",
            blaProperties: {
                orientation: "horizontal"
            }
        },
        87: {
            chartType: "heatmap"
        },
        88: {
            chartType: "stock"
        },
        89: {
            chartType: "bubble",
            dataLabels: {
                visible: false,
                displayMode: "z"
            }
        },
        90: {
            chartType: "bubble",
            dataLabels: {
                visible: false,
                displayMode: "z"
            }
        },
        91: {
            chartType: "bubble"
        },
        92: {
            chartType: "bubble",
            dataLabels: {
                visible: false,
                displayMode: "z"
            }
        },
        93: {
            chartType: "pie",
            dataLabels: defaultPieDataLabels,
            swapData: true
        },
        94: {
            chartType: "pie",
            dataLabels: defaultPieDataLabels,
            swapData: true,
            pieProperties: {
                holeSize: 25,
                totalLabel: {
                    visible: true
                }
            }
        },
        95: {
            chartType: "bar",
            blaProperties: {
                orientation: "vertical"
            }
        },
        96: {
            chartType: "bar"
        },
        99: {
            chartType: "gantt"
        },
        100: {
            chartType: "waterfall",
            blaProperties: {
                orientation: "vertical"
            }
        },
        101: {
            chartType: "waterfall",
            blaProperties: {
                orientation: "horizontal"
            }
        },
        102: {
            chartType: "pareto",
            colorMode: "bySeries"
        },
        103: {
            chartType: "bar"
        },
        104: {
            chartType: "bar"
        },
        105: {
            chartType: "bar"
        },
        106: {
            chartType: "funnel",
            swapData: true,
            dataLabels: {
                position: "outside",
                formatCallback: function(d, s) {
                    return this.getSeriesLabel(s) + "\n" + this.formatNumber(d.value, this.dataLabels.numberFormat || "#", "dataLabels")
                }
            }
        },
        110: {
            chartType: "gauge",
            swapData: true,
            yaxis: {
                minorGrid: {
                    visible: true
                },
                colorBands: [{
                    start: "0%",
                    stop: "20%",
                    color: "red"
                }, {
                    start: "20%",
                    stop: "40%",
                    color: "yellow"
                }, {
                    start: "40%",
                    stop: "60%",
                    color: "green"
                }, {
                    start: "60%",
                    stop: "80%",
                    color: "yellow"
                }, {
                    start: "80%",
                    stop: "100%",
                    color: "red"
                }]
            }
        },
        111: {
            chartType: "funnel",
            swapData: true,
            dataLabels: {
                position: "outside",
                formatCallback: function(d, s) {
                    return this.getSeriesLabel(s) + "\n" + d.value
                }
            },
            funnelProperties: {
                topWidth: "0",
                baseWidth: "90%"
            }
        },
        121: {
            chartType: "bar",
            blaProperties: {
                orientation: "vertical"
            }
        },
        124: {
            chartType: "boxplot",
            legend: {
                visible: false
            },
            boxPlotProperties: {
                drawHatAsBox: true
            },
            blaProperties: {
                orientation: "vertical"
            }
        },
        128: {
            chartType: "gauge",
            swapData: true
        },
        130: {
            chartType: "boxplot",
            boxPlotProperties: {
                drawHatAsBox: true
            },
            blaProperties: {
                orientation: "horizontal"
            }
        },
        138: {
            chartType: "gauge",
            swapData: true
        }
    };
    function getOrCreateSeries(chart, s) {
        if (chart.series.indexOf(s) >= 0)
            return s;
        var idx;
        if (typeof s === "object" && s != null)
            idx = s.series;
        else
            idx = parseInt(s, 10);
        var res = chart.getSeries(idx);
        if (!res) {
            res = {
                series: idx
            };
            chart.series.push(res)
        }
        return res
    }
    function convertCDNMacroToChar(strIn, singleQuoteCharReplace) {
        var strOut = strIn.replace("[QUOTE]", singleQuoteCharReplace);
        strOut = strOut.replace("[DQUOTE]", '"');
        strOut = strOut.replace("[AMPER]", "&");
        strOut = strOut.replace("[PRCNT]", "%");
        strOut = strOut.replace("[SLASH]", "/");
        return strOut
    }
    function calcFullRadius(chart, w, h) {
        var cdepth = chart.computeddepth25d();
        var labelHeight = chart.pieProperties.label.visible ? tdg.measureFont(chart.pieProperties.label.font).height : 0;
        var adjustedH = h - labelHeight - cdepth;
        var fullRadius = Math.min(w, adjustedH) / 2 - chart.getPadding("label", "aveHorz");
        return fullRadius
    }
    function getAnnotationIndex(chart, idx) {
        var annotation = chart.annotations[idx];
        if (annotation == null) {
            var a = {
                position: {
                    x: "50%",
                    y: "10%"
                },
                marker: {
                    visible: false,
                    color: "transparent",
                    border: {
                        color: "transparent"
                    }
                },
                label: {
                    visible: false,
                    text: "empty text",
                    font: "14pt Times New Roman",
                    color: "black",
                    position: "center"
                }
            };
            chart.annotations[idx] = a;
            annotation = a
        }
        return annotation
    }
    function getAnnotation(chart, idx) {
        var annotation = chart.annotations[idx];
        if (annotation == null) {
            annotation = {
                position: {
                    x: null,
                    y: null,
                    parent: "chart"
                },
                marker: {
                    visible: false
                },
                label: {
                    visible: false
                },
                line: {}
            };
            chart.annotations.push(annotation)
        }
        return annotation
    }
    function setAnnotationPoint(annotation, idx, key, value) {
        annotation.position = annotation.position || {};
        annotation.position.x = annotation.position.y = null;
        annotation.position.points = annotation.position.points || [];
        annotation.position.points[idx] = annotation.position.points[idx] || {};
        annotation.position.points[idx][key] = parseFloat(value)
    }
    function getReferenceLine(chart, axis, idx) {
        var axisRefLines = chart.referenceLines.filter(function(el) {
            return el.axis === axis
        });
        var refLine = axisRefLines[idx];
        if (refLine == null) {
            refLine = {
                value: undefined,
                axis: axis,
                ordinalAlign: "center",
                line: {
                    color: "black",
                    width: 1,
                    dash: ""
                },
                label: {
                    text: "",
                    font: "7.5pt Sans-Serif",
                    color: "black"
                },
                anchor: "start",
                showValue: false
            };
            chart.referenceLines.push(refLine)
        }
        return refLine
    }
    function getTrendlineType(index) {
        switch (index) {
        case "0":
            return "none";
        case "1":
            return "linear";
        case "2":
            return "quadratic";
        case "3":
            return "polynomial";
        case "4":
            return "hyperbolic";
        case "5":
            return "logarithmic";
        case "6":
            return "modHyperbolic";
        case "7":
            return "rational";
        case "8":
            return "exponential";
        case "9":
            return "modExponential";
        case "10":
            return "logQuadratic";
        case "11":
            return "geometric";
        default:
            return "none"
        }
    }
    function setGridStyleInternal(t, v) {
        switch (v) {
        case "0":
            t.visible = true;
            t.ticks.visible = false;
            break;
        case "1":
            t.visible = true;
            t.ticks.visible = true;
            t.ticks.style = "outer";
            break;
        case "2":
            t.visible = false;
            t.ticks.visible = true;
            t.ticks.style = "inner";
            break;
        case "3":
            t.visible = false;
            t.ticks.visible = true;
            t.ticks.style = "outer";
            break;
        case "4":
            t.visible = false;
            t.ticks.visible = true;
            t.ticks.style = "span";
            break
        }
    }
    function setExcludeMinLabelInternal(t, v) {
        t.excludeMin = v
    }
    function setExcludeMaxLabelInternal(t, v) {
        t.excludeMax = v
    }
    function setLogScaleInternal(t, v) {
        t.bIsLog = parseBoolean(v)
    }
    function labelToAxis(chart, t) {
        if (t === chart.xaxis.labels)
            return chart.xaxis;
        else if (t === chart.yaxis.labels)
            return chart.yaxis;
        else if (t === chart.y2axis.labels)
            return chart.y2axis;
        return undefined
    }
    function axisToLabel(chart, t) {
        if (t === chart.xaxis)
            return "x";
        else if (t === chart.yaxis)
            return "y";
        else if (t === chart.y2axis)
            return "y2";
        return undefined
    }
    function getPFJColorTypeStruct() {
        return {
            clr: undefined,
            fillType: undefined,
            gradient: undefined,
            structAbove: undefined,
            location: undefined
        }
    }
    function getGradientStruct() {
        return {
            type: "linear",
            start: {
                x: 0,
                y: 0
            },
            end: {
                x: "100%",
                y: 0
            },
            isInverted: false,
            stops: []
        }
    }
    function addFillColor(f, above, loc) {
        if (f.pfjColorType == null)
            f.pfjColorType = getPFJColorTypeStruct();
        f.pfjColorType.structAbove = above;
        f.pfjColorType.location = loc
    }
    function addGradient(f, above, loc) {
        if (f.pfjColorType == null)
            f.pfjColorType = getPFJColorTypeStruct();
        if (f.pfjColorType.gradient == null)
            f.pfjColorType.gradient = getGradientStruct();
        f.pfjColorType.structAbove = above;
        f.pfjColorType.location = loc
    }
    function getFillGradientObj(chart, t) {
        var fillObj = null;
        if (t.hasOwnProperty("fill") && t.fill.hasOwnProperty("color")) {
            fillObj = t.fill;
            addGradient(fillObj)
        } else if (t.hasOwnProperty("backgroundcolor")) {
            fillObj = t;
            addGradient(fillObj, t, "backgroundcolor")
        } else if (t.hasOwnProperty("color")) {
            fillObj = t;
            addGradient(fillObj)
        }
        return fillObj
    }
    function setGradientPinPositionInternal(chart, t, v, i) {
        var defaultColors = ["rgb(255, 255, 255)", "rgb(128, 128, 128)", "rgb(255, 255, 255)"];
        i = parseInt(i, 10);
        v = parseFloat(v);
        var fillObj = getFillGradientObj(chart, t);
        if (fillObj && fillObj.pfjColorType && fillObj.pfjColorType.gradient) {
            var gradient = fillObj.pfjColorType.gradient;
            if (gradient.stops[i] == null)
                gradient.stops[i] = {
                    offset: v,
                    color: defaultColors[i]
                };
            else
                gradient.stops[i].offset = v
        }
    }
    function setGradientPinColor(chart, t, c, i) {
        i = parseInt(i, 10);
        var fillObj = getFillGradientObj(chart, t);
        if (fillObj && fillObj.pfjColorType && fillObj.pfjColorType.gradient) {
            var gradient = fillObj.pfjColorType.gradient;
            if (gradient.stops[i] == null)
                gradient.stops[i] = {
                    offset: 0,
                    color: c
                };
            else
                gradient.stops[i].color = c
        }
    }
    function getPieSum(chart, g, d) {
        function sumData(groupData) {
            if (!groupData || !groupData.length)
                return 1;
            var sum = 0;
            for (var i = 0; i < groupData.length; i++) {
                var gData = groupData[i];
                if (gData != null)
                    if (gData.value != null)
                        sum += Math.abs(gData.value)
            }
            return sum
        }
        var data = chart.data;
        if (chart.pfjParser.sceneType === "flash" && chart.swapData)
            data = tdg.transpose(chart.data);
        if (chart.chartType === "matrix")
            if (d && d._r != null && d._c != null)
                data = (data[d._r] || [])[d._c];
            else
                data = (data[0] || [])[0];
        return sumData(data[g])
    }
    function getTrendlineStruct() {
        return {
            enabled: false,
            mode: "none",
            equationLabel: {
                visible: false,
                color: "black"
            }
        }
    }
    function parseBoolean(v) {
        if (typeof v === "boolean")
            return v;
        if (typeof v === "string")
            return stringToBoolean(v);
        return false
    }
    function stringToBoolean(string) {
        switch (string.toLowerCase()) {
        case "true":
        case "1":
        case "yes":
            return true;
        case "false":
        case "0":
        case "no":
            return false
        }
        return Boolean(string)
    }
    function curveFitEquationDisplayOne(seriesObj, v) {
        if (seriesObj.trendline == null)
            seriesObj.trendline = getTrendlineStruct();
        seriesObj.trendline.equationLabel.visible = v
    }
    function curveFitPolynomialOrder(seriesObj, v) {
        if (seriesObj.trendline == null)
            seriesObj.trendline = getTrendlineStruct();
        seriesObj.trendline.order = v
    }
    function setRefLineXValueInternal(idx, v) {
        var refLine = getReferenceLine(this, "x", idx);
        var f = parseFloat(v);
        refLine.value = isNaN(f) ? v : f;
        refLine.ordinalAlign = "center"
    }
    function getAxisFromMajorGridArg(chart, majGridArg) {
        var axis;
        if (majGridArg != null)
            if (majGridArg.search("getY1MajorGrid") >= 0)
                axis = chart.yaxis;
            else if (majGridArg.search("getX1MajorGrid") >= 0)
                axis = chart.xaxis;
            else if (majGridArg.search("getO1MajorGrid") >= 0)
                axis = chart.xaxis;
            else if (majGridArg.search("getY2MajorGrid") >= 0)
                axis = chart.y2axis;
        return axis
    }
    function getIndivGaugeBand(colorbands, bandArg) {
        var theBand = colorbands[0];
        if (bandArg === "getGaugeBand1")
            theBand = colorbands[0];
        else if (bandArg === "getGaugeBand2")
            theBand = colorbands[1];
        else if (bandArg === "getGaugeBand3")
            theBand = colorbands[2];
        else if (bandArg === "getGaugeBand4")
            theBand = colorbands[3];
        else if (bandArg === "getGaugeBand5")
            theBand = colorbands[4];
        return theBand
    }
    function setPostProcessFill(chart, theFill) {
        if (chart.postFillList == null)
            chart.postFillList = [];
        chart.postFillList.push(theFill)
    }
    function setPostProcessTransparentFillColor(chart, theFill, trans) {
        theFill.postTransparentFill = trans;
        if (chart.postTransparentFillColorList == null)
            chart.postTransparentFillColorList = [];
        chart.postTransparentFillColorList.push(theFill)
    }
    function setPostProcessTransparentBorderColor(chart, theBorder, trans) {
        theBorder.postTransparentBorder = trans;
        if (chart.postTransparentBorderColorList == null)
            chart.postTransparentBorderColorList = [];
        chart.postTransparentBorderColorList.push(theBorder)
    }
    function setPostProcessCurrFormat(chart, theFmt) {
        if (chart.postCurrFormatList == null)
            chart.postCurrFormatList = [];
        chart.postCurrFormatList.push(theFmt)
    }
    function setPostProcessFormatPattern(chart, theFmt, pattern) {
        theFmt.postFormatPattern = pattern;
        if (chart.postFormatList == null)
            chart.postFormatList = [];
        chart.postFormatList.push(theFmt)
    }
    function setPostProcessFormatPreset(chart, theFmt, preset) {
        theFmt.postFormatPreset = preset;
        if (chart.postFormatList == null)
            chart.postFormatList = [];
        chart.postFormatList.push(theFmt)
    }
    function setPostProcessPieFeelerDoubleFormat(chart, attr, value) {
        if (chart.postPieFeelerDoubleFormatObj == null)
            chart.postPieFeelerDoubleFormatObj = {};
        if (typeof attr === "string")
            chart.postPieFeelerDoubleFormatObj[attr] = value
    }
    function setPostProcessTooltip(chart, theSeries) {
        if (chart.postTooltipList == null)
            chart.postTooltipList = [];
        chart.postTooltipList.push(theSeries)
    }
    function setPostProcessNonZeroBaseline(chart, nonZeroBaseline) {
        if (chart.postNonZeroBaselineList == null)
            chart.postNonZeroBaselineList = [];
        chart.postNonZeroBaselineList.push(nonZeroBaseline)
    }
    function getCustomDataTextBubbleScatter(d, s, g) {
        var chart = this;
        var dataText = "missing format";
        var format = chart.dataTextBubbleScatterFormat;
        if (format != null) {
            format = format.replace(" [R]", "");
            format = format.replace("[R]", "");
            format = format.replace("[SL]", chart.getSeriesLabel(s));
            format = format.replace("[GL]", chart.getGroupLabel(g));
            var xFmt = chart.formatNumber(d.x, chart.dataLabels.numberFormat, "dataLabels");
            var yFmt = chart.formatNumber(d.y, chart.dataLabels.numberFormat, "dataLabels");
            format = format.replace("[XV]", xFmt);
            format = format.replace("[YV]", yFmt);
            var chartType = this.chartType === "matrix" ? this.matrixProperties.chartType : this.chartType;
            if (chartType === "bubble") {
                var zFmt = chart.formatNumber(d.size, chart.dataLabels.numberFormat, "dataLabels");
                format = format.replace("[ZV]", zFmt)
            }
            dataText = format
        }
        return dataText
    }
    function setTextFormatPatternInternal(chart, t, pattern) {
        t = labelToAxis(chart, t) || t;
        t.numberFormat = pattern;
        setPostProcessCurrFormat(chart, t);
        setPostProcessFormatPattern(chart, t, pattern);
        if (t.name)
            setPostProcessPieFeelerDoubleFormat(chart, "setTextFormatPattern_" + t.name, pattern)
    }
    function setTextFormatPresetInternal(chart, t, preset) {
        preset = parseInt(preset, 10);
        if (preset >= 0) {
            t = labelToAxis(chart, t) || t;
            t.numberFormat = numberFormatMap[preset]
        }
        if (t === chart.dataLabels)
            chart.prePieFormatPreset = preset;
        setPostProcessCurrFormat(chart, t);
        if (preset === -2) {
            t = labelToAxis(chart, t) || t;
            setPostProcessFormatPreset(chart, t, preset)
        }
        if (t.name)
            setPostProcessPieFeelerDoubleFormat(chart, "setTextFormatPattern_" + t.name, numberFormatMap[preset])
    }
    function shouldCallTextFormat(chart, firstArg) {
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        var bDataTextArg = firstArg === "getDataText";
        var bPie = chartType === "pie";
        var bExcludePie = bPie && bDataTextArg;
        var bPieSliceLabelArg = firstArg === "getPieSliceLabel";
        var bExcludeOtherTypes = !bPie && bPieSliceLabelArg;
        var bExclude = bExcludePie || bExcludeOtherTypes;
        return !bExclude
    }
    tdgchart.prototype.pfjParser.methods = {
        setAltFmtFrameNumColors: function(cb, v) {
            function initColorBandArray(bandArray) {
                if (bandArray.length === 0)
                    for (var i = 0; i < 5; i++)
                        bandArray.push({
                            start: 0,
                            stop: 0,
                            index: i
                        })
            }
            function extendColorBandArray(bandArray, newLen) {
                var diff = newLen - bandArray.length;
                for (var i = 0; i < diff; i++)
                    bandArray.push({
                        start: 0,
                        stop: 0,
                        index: i
                    })
            }
            function truncColorBandArray(bandArray, newLen) {
                bandArray.length = newLen;
                if (bandArray[newLen - 1] && bandArray[newLen - 1].stop !== 0)
                    bandArray[newLen - 1].stop = "100%"
            }
            var newLength = parseInt(v, 10);
            initColorBandArray(cb);
            extendColorBandArray(cb, newLength);
            truncColorBandArray(cb, newLength)
        },
        setAltFmtFrameSeparator: function(o, v) {
            function initFmtSeparator(colorBand, start, stop) {
                if (colorBand !== undefined)
                    if (colorBand.start === 0 && colorBand.stop === 0) {
                        colorBand.start = start;
                        colorBand.stop = stop
                    }
            }
            function initFormatSeparators(bandArray) {
                initFmtSeparator(bandArray[0], 0, 10);
                initFmtSeparator(bandArray[1], 10, 20);
                initFmtSeparator(bandArray[2], 20, 30);
                initFmtSeparator(bandArray[3], 30, 40);
                initFmtSeparator(bandArray[4], 40, 50)
            }
            function setFmtSeparator(bandArray, index, sep) {
                bandArray[index].stop = sep;
                if (index + 1 <= bandArray.length)
                    bandArray[index + 1].start = sep
            }
            function initFirstLastSeparator(bandArray) {
                bandArray[0].start = 0;
                bandArray[bandArray.length - 1].stop = "100%"
            }
            var cb = this[o.axis].colorBands;
            var bandIndex = o.index;
            if (o.axis === "xaxis") {
                v = parseFloat(v) + .5;
                var groupID = Math.floor(v);
                cb[bandIndex].O1Stop = {
                    group: groupID,
                    offset: v - groupID
                }
            } else {
                initFormatSeparators(cb);
                setFmtSeparator(cb, bandIndex, parseFloat(v));
                initFirstLastSeparator(cb)
            }
        },
        setAltString: function(s, g, v) {
            s = parseInt(s, 10);
            g = parseInt(g, 10);
            var sg = this.getSeriesAndGroup(s, g);
            if (sg == null)
                this.series.push({
                    series: s,
                    group: g
                });
            sg = this.getSeriesAndGroup(s, g);
            if (sg) {
                var chart = this;
                sg.postTooltip = v;
                setPostProcessTooltip(chart, sg)
            }
        },
        setAutoColorGradientStartColor: function(v) {
            if (this.colorModeColors == null)
                this.colorModeColors = [];
            this.colorModeColors[0] = v
        },
        setAutoColorGradientEndColor: function(v) {
            if (this.colorModeColors == null)
                this.colorModeColors = [];
            this.colorModeColors[1] = v
        },
        setAutoColorLerpFactor: function(v) {
            this.riserCycleEndLightness = parseFloat(v)
        },
        setAutoSkip: function(t, v) {
            if (typeof t === "boolean" && v == null) {
                v = t;
                t = this.xaxis.labels
            }
            v = parseInt(v, 10);
            t = labelToAxis(this, t);
            if (v === 0)
                t.labelLayout.skip = 0;
            else if (v === 1)
                t.labelLayout.skip = "auto"
        },
        setAutoHideDataTextOnSmallRisers: function(v) {
            this.dataLabels.clipToContainer = parseBoolean(v)
        },
        setAxisAssignment: function(t, v) {
            var dualYCharts = [19, 20, 21, 22, 26, 27, 28, 29, 33, 34, 38, 39, 43, 44, 45, 46, 50, 51, 52, 53, 62, 64, 66, 69, 74, 75, 77, 78, 80, 81, 91, 92, 103, 104, 105];
            if (dualYCharts.indexOf(this.pfjParser.chartType) >= 0) {
                var seriesObj = getOrCreateSeries(this, t);
                if (!seriesObj)
                    return;
                seriesObj.yAxisAssignment = parseInt(v, 10) + 1
            }
        },
        setAxisDescending: function(t, v) {
            t.invert = v
        },
        setAxisSide: function(t, v) {
            var swap = v === "1";
            t.swapChartSide = swap
        },
        setBorderColor: function(t, v) {
            var border = null;
            if (t.hasOwnProperty("series")) {
                t.border = t.border || {
                    width: 1,
                    color: v
                };
                if (t.border.width == null)
                    t.border.width = 1;
                t.border.color = v;
                border = t.border;
                t.marker = {
                    border: t.border
                }
            } else if (this.pfjParser.argNames[0] === "getChartBackground") {
                this.border.color = v;
                if (this.border.width == null || this.border.width === 0)
                    this.border.width = 1;
                border = this.border
            } else if (t.hasOwnProperty("border")) {
                t.border.color = v;
                border = t.border
            } else if (t.hasOwnProperty("color") && t.hasOwnProperty("lineStyle")) {
                t.lineStyle.color = v;
                border = t.lineStyle
            } else if (t.hasOwnProperty("color")) {
                t.color = v;
                border = t
            } else if (t.hasOwnProperty("lineStyle")) {
                t.lineStyle.color = v;
                border = t.lineStyle
            } else if (t.hasOwnProperty("line")) {
                t.line.color = v;
                border = t.line
            }
            if (border)
                setPostProcessTransparentBorderColor(this, border, false)
        },
        setBoxPlotType: function(v) {
            v = parseInt(v, 10) === 0;
            this.boxPlotProperties.drawHatAsBox = v;
            this.boxPlotProperties.hatWidth = v ? "100%" : this.boxPlotProperties.hatWidth
        },
        setColorMode: function(v) {
            if (v === "0")
                this.colorMode = this.data.length > 1 ? "bySeries" : "byGroup";
            else if (v === "3")
                this.colorMode = "byHeight";
            else if (v === "5")
                this.colorMode = "byInterpolation";
            else
                this.colorMode = v === "2" ? "byGroup" : "bySeries"
        },
        setConnectLineMarkers: function(v) {
            if (!v)
                this.series.map(function(el) {
                    el.border = el.border || {};
                    el.border.width = 0
                })
        },
        setConnectParetoBars: function(v) {
            this.blaProperties.barGroupGapWidth = v ? 0 : this.blaProperties.barGroupGapWidth
        },
        setCurrencySymbolOverride: function(v) {
            this.pfjParser.permanentState.postOriginalCurrencySymbol = "$";
            this.pfjParser.permanentState.postCurrencySymbolOverride = v
        },
        setCurveFitType: function(s, v) {
            var trendTypeInt = parseInt(s, 10);
            if (!isNaN(trendTypeInt) && trendTypeInt >= 0 && trendTypeInt <= 11) {
                var seriesObj = getOrCreateSeries(this, s);
                if (!seriesObj)
                    return;
                if (seriesObj.trendline == null)
                    seriesObj.trendline = getTrendlineStruct();
                seriesObj.trendline.enabled = true;
                seriesObj.trendline.mode = getTrendlineType(v)
            }
        },
        setCurveFitEquationDisplayPerSeries: function(s, v) {
            var seriesObj = this.getSeries(parseInt(s, 10));
            curveFitEquationDisplayOne(seriesObj, v)
        },
        setCurveFitEquationDisplay: function(booleanOrSeries, v) {
            function curveFitEqDisplay(seriesObj, val) {
                if (seriesObj.trendline == null && !val)
                    return;
                if (seriesObj.trendline == null)
                    seriesObj.trendline = getTrendlineStruct();
                else if (seriesObj.trendline instanceof Array)
                    seriesObj.trendline = seriesObj.trendline[0];
                seriesObj.trendline.equationLabel.visible = val
            }
            if (typeof booleanOrSeries === "boolean")
                this.series.map(function(el) {
                    curveFitEqDisplay(el, booleanOrSeries)
                });
            else {
                var seriesObj = getOrCreateSeries(this, booleanOrSeries);
                if (!seriesObj)
                    return;
                curveFitEquationDisplayOne(seriesObj, v)
            }
        },
        setCurveFitHighOrderFirst: function(v) {
            this.trendline.equationLabel.highOrderFirst = v
        },
        setCurveFitPolynomialOrder: function(s, v) {
            var seriesObj = getOrCreateSeries(this, s);
            if (!seriesObj)
                return;
            curveFitPolynomialOrder(seriesObj, v)
        },
        setData: function(i, j, val) {
            var idx, ar;
            i = parseInt(i, 10);
            j = parseInt(j, 10);
            val = parseFloat(val);
            if (!Array.isArray(this.data))
                this.data = [];
            var data = this.data;
            if (this.dataPageSlider && this.dataPageSlider.hasOwnProperty("_internalPage"))
                data = this.data[this.dataPageSlider._internalPage];
            while (data.length <= i)
                data.push([]);
            switch (this.pfjParser.chartType) {
            case 61:
            case 65:
            case 66:
                idx = Math.floor(j / 2);
                data[i][idx] = data[i][idx] || [];
                data[i][idx][j % 2] = val;
                break;
            case 70:
                idx = Math.floor(j / 4);
                ar = data[i][idx] = data[i][idx] || [];
                switch (j % 4) {
                case 0:
                    ar[2] = val;
                    break;
                case 1:
                    ar[0] = val;
                    break;
                case 2:
                    ar[1] = val;
                    break;
                case 3:
                    ar[3] = val;
                    break
                }
                break;
            case 89:
            case 90:
            case 91:
            case 92:
                data[i][0] = data[i][0] || [];
                data[i][0][j] = val;
                break;
            case 121:
                idx = Math.floor(j / 3);
                this.errorBars.yData = this.errorBars.yData || [];
                if (j % 3 === 0)
                    data[i][idx] = val;
                else {
                    if (this.errorBars.yData.length <= i)
                        this.errorBars.yData.push([]);
                    if (this.errorBars.yData[i] && this.errorBars.yData[i].length <= idx)
                        this.errorBars.yData[i].push([]);
                    this.errorBars.yData[i] = this.errorBars.yData[i] || [];
                    this.errorBars.yData[i][idx] = this.errorBars.yData[i][idx] || [];
                    if (j % 3 === 1)
                        this.errorBars.yData[i][idx][1] = val;
                    else
                        this.errorBars.yData[i][idx][0] = val
                }
                break;
            case 124:
            case 130:
                if (j % 13 < 5) {
                    idx = Math.floor(j / 13);
                    ar = data[i][idx] = data[i][idx] || [];
                    ar.push(val);
                    ar.sort(function(a, b) {
                        return a < b ? -1 : a > b ? 1 : 0
                    })
                }
                break;
            default:
                data[i][j] = val;
                break
            }
        },
        setDataPage: function(v, l) {
            v = parseInt(v, 10);
            this.dataPageSlider.enabled = true;
            this.dataPageSlider._internalPage = v;
            this.dataPageSlider.labels[v] = l;
            if (!Array.isArray(this.data))
                this.data = [];
            if (!Array.isArray(this.data[v]))
                this.data[v] = []
        },
        setDataSeries: function() {
            var data = Array.prototype.slice.call(arguments);
            data = data.map(function(el) {
                return parseFloat(el)
            });
            switch (this.pfjParser.chartType) {
            case 55:
            case 56:
            case 106:
            case 111:
                this.data.push(data.slice(0, 1));
                break;
            case 65:
                var newData = [];
                for (var i = 0; i < data.length; i += 2)
                    newData.push([data[i], data[i + 1]]);
                this.data.push(newData);
                break;
            default:
                this.data.push(data);
                break
            }
            if (this.chartType === "bar" || this.chartType === "line" || this.chartType === "area") {
                this.colorMode = this.data.length === 1 ? "byGroup" : "bySeries";
                this.legend.visible = this.data.length !== 1
            }
        },
        setDataTextDisplay: function(v) {
            this.dataLabels.visible = v
        },
        setDataTextFormatPattern: function(v) {
            var chart = this;
            if (shouldCallTextFormat(chart, "dataText"))
                setTextFormatPatternInternal(chart, chart.dataLabels, v)
        },
        setDataTextFormatPreset: function(v) {
            var chart = this;
            if (shouldCallTextFormat(chart, "dataText"))
                setTextFormatPresetInternal(chart, chart.dataLabels, v)
        },
        setDataTextPosition: function(v) {
            this.dataLabels.position = ["center", "top", "top", "insideTop", "center", "insideBottom"][parseInt(v, 10)]
        },
        setDataTextTemplateBubble: function(v) {
            var chart = this;
            chart.dataTextBubbleScatterFormat = v;
            chart.dataLabels.formatCallback = getCustomDataTextBubbleScatter
        },
        setDataTextTemplateScatter: function(v) {
            var chart = this;
            chart.dataTextBubbleScatterFormat = v;
            chart.dataLabels.formatCallback = getCustomDataTextBubbleScatter
        },
        setDecimalSeparator: function(v) {
            var chart = this;
            var charQuoteReplace = chart.getDecimalCharToReplaceWithQuote();
            var strStrip = convertCDNMacroToChar(v, charQuoteReplace);
            chart.setDecimalSeparator(strStrip)
        },
        setDepthAngle: {},
        setDepthRadius: function(v) {
            var chartType = this.chartType === "matrix" ? this.matrixProperties.chartType : this.chartType;
            if (chartType === "bar" || chartType === "line" || chartType === "area")
                this.depth = parseInt(v, 10) * 1.5
        },
        setDisplay: function(t, v) {
            function initColorBandArray(bandArray) {
                if (bandArray.length === 0)
                    for (var i = 0; i < 5; i++)
                        bandArray.push({
                            start: 0,
                            stop: 0,
                            index: i
                        })
            }
            var arg1 = this.pfjParser.argNames[this.pfjParser.argNames.length - 1];
            if (arg1 === "getAnnotation")
                t.label.visible = v;
            else if (arg1.endsWith("AxisLine") && t.width != null)
                t.width = !v ? 0 : t.width;
            else if (arg1 === "getReferenceLineXY" && !v) {
                t.position = t.position || {};
                t.position.points = null
            } else if (arg1.search("getReferenceLineText") >= 0)
                t.text = v ? t.text : undefined;
            else if (arg1.search("getReferenceLine") >= 0 && !v)
                t.value = undefined;
            else if (arg1.search("getO1MajorGridColorBand1") >= 0) {
                t.altFrameColor1Visible = v;
                this.postO1MajorGridColorBand1Axis = t
            } else if (arg1.search("getGaugeBand") >= 0) {
                var band = getIndivGaugeBand(t, arg1);
                if (band)
                    if (!band.color)
                        band.color = v ? "black" : "transparent";
                    else {
                        color = tdg.color(band.color);
                        if (!v && color.a) {
                            color.a = color.opacity = 0;
                            band.color = color
                        } else if (v && !color.a) {
                            color.a = color.opacity = 1;
                            band.color = color
                        }
                    }
            } else if (arg1.search("getO1MajorGridColorBand2") >= 0) {
                t.altFrameColorVisible = v;
                this.postO1MajorGridColorBand2Axis = t
            } else if (arg1.search("getY1MajorGridColorBand1") >= 0) {
                t.altFrameColor1Visible = v;
                this.postY1MajorGridColorBand1Axis = t
            } else if (arg1.search("getY1MajorGridColorBand2") >= 0) {
                t.altFrameColorVisible = v;
                this.postY1MajorGridColorBand2Axis = t
            } else if (arg1.search("getY2MajorGridColorBand1") >= 0) {
                t.altFrameColor1Visible = v;
                this.postY2MajorGridColorBand1Axis = t
            } else if (arg1.search("getY2MajorGridColorBand2") >= 0) {
                t.altFrameColorVisible = v;
                this.postY2MajorGridColorBand2Axis = t
            } else if (arg1.search("getX1MajorGridColorBand1") >= 0) {
                t.altFrameColor1Visible = v;
                this.postX1MajorGridColorBand1Axis = t
            } else if (arg1.search("getX1MajorGridColorBand2") >= 0) {
                t.altFrameColorVisible = v;
                this.postX1MajorGridColorBand2Axis = t
            } else if (arg1.search("getO1AltFmtFrame") >= 0) {
                if (v) {
                    initColorBandArray(this.xaxis.colorBands);
                    this.postO1AltFmtFrameDefaults = this.xaxis.colorBands;
                    this.postO1AltFmtFrameSeparators = this.xaxis.colorBands
                } else if (t.index == null)
                    this.xaxis.colorBands.length = 0;
                t.visible = v
            } else if (arg1.search("getX1AltFmtFrame") >= 0) {
                if (v) {
                    initColorBandArray(this.xaxis.colorBands);
                    this.postX1AltFmtFrameDefaults = this.xaxis.colorBands
                } else if (t.index == null)
                    this.xaxis.colorBands.length = 0;
                t.visible = v
            } else if (arg1.search("getY1AltFmtFrame") >= 0) {
                if (v) {
                    initColorBandArray(this.yaxis.colorBands);
                    this.postY1AltFmtFrameDefaults = this.yaxis.colorBands
                } else if (t.index == null)
                    this.yaxis.colorBands.length = 0;
                t.visible = v
            } else if (arg1.search("getY2AltFmtFrame") >= 0) {
                if (v) {
                    initColorBandArray(this.y2axis.colorBands);
                    this.postY2AltFmtFrameDefaults = this.y2axis.colorBands
                } else if (t.index == null)
                    this.y2axis.colorBands.length = 0;
                t.visible = v
            } else if (arg1.search("getWaterfallLine") >= 0)
                t.width = v ? 1 : 0;
            else if (!t.hasOwnProperty("visible") && t.hasOwnProperty("width") && t.hasOwnProperty("color"))
                this.pfjParser.postProcessList.push(function() {
                    t.width = v ? t.width || 1 : 0
                });
            else
                t.visible = v
        },
        setDocumentHeight: function(v) {
            this.height = v
        },
        setDocumentWidth: function(v) {
            this.width = v
        },
        setExceptionalRiser: function(s, g) {
            s = parseInt(s, 10);
            g = parseInt(g, 10);
            if (this.getSeriesAndGroup(s, g) == null)
                this.series.push({
                    series: s,
                    group: g
                })
        },
        setExcludeMinLabel: function(t, v) {
            setExcludeMinLabelInternal(t, v)
        },
        setExcludeMaxLabel: function(t, v) {
            setExcludeMaxLabelInternal(t, v)
        },
        setExtendToFrameEdge: function(v) {
            this.blaProperties.extendToFrameEdge = v
        },
        setFillColor: function(t, color) {
            if (!t)
                return;
            function addColor(f, col, above, loc) {
                if (f.pfjColorType == null)
                    f.pfjColorType = getPFJColorTypeStruct();
                f.pfjColorType.fillType = 1;
                f.pfjColorType.clr = col;
                f.pfjColorType.structAbove = above;
                f.pfjColorType.location = loc
            }
            function setFillObj(chart, f, col) {
                var fObj = null;
                var arg1 = chart.pfjParser.argNames[0];
                if (arg1.search("MajorGridColorBand1") >= 0) {
                    if (f.altFrameColor1 == null || typeof f.altFrameColor1 !== "object")
                        f.altFrameColor1 = {};
                    fObj = f.altFrameColor1;
                    addColor(fObj, col, t, "altFrameColor1")
                } else if (arg1.search("MajorGridColorBand2") >= 0) {
                    if (f.altFrameColor == null || typeof f.altFrameColor !== "object")
                        f.altFrameColor = {};
                    fObj = f.altFrameColor;
                    addColor(fObj, col, f, "altFrameColor")
                } else if (arg1.search("getGaugeBand") >= 0) {
                    fObj = getIndivGaugeBand(f, arg1);
                    if (fObj)
                        addColor(fObj, col, undefined, undefined)
                } else if (f === chart.series)
                    chart.series.map(function(el) {
                        addColor(el, col, undefined, undefined);
                        setPostProcessFill(chart, el);
                        fObj = null
                    });
                else if (f.hasOwnProperty("fill")) {
                    fObj = f.fill;
                    addColor(fObj, col, undefined, undefined)
                } else if (f.hasOwnProperty("backgroundcolor")) {
                    fObj = f;
                    addColor(fObj, col, f, "backgroundcolor")
                } else {
                    if (!f.hasOwnProperty("color"))
                        f.color = {};
                    fObj = f;
                    addColor(fObj, col, undefined, undefined)
                }
                return fObj
            }
            var theFill = setFillObj(this, t, color);
            if (theFill != null)
                setPostProcessFill(this, theFill);
            setPostProcessTransparentFillColor(this, t, false)
        },
        setFillMissingData: function(v) {
            var missingDataMode, missingDataModePFJ = parseInt(v, 10);
            switch (missingDataModePFJ) {
            case 1:
                missingDataMode = "zero";
                break;
            case 2:
                missingDataMode = "curved";
                break;
            default:
                missingDataMode = "none";
                break
            }
            this.blaProperties.missingDataMode = missingDataMode
        },
        setFillType: function(t, type) {
            function addFillType(f, typeFill, above, loc) {
                switch (typeFill) {
                case 2:
                    addGradient(f, above, loc);
                    break;
                case 1:
                default:
                    addFillColor(f, above, loc);
                    break
                }
                if (f && f.pfjColorType)
                    f.pfjColorType.fillType = typeFill
            }
            function setFillTypeObj(chart, f, newType) {
                var fObj = null;
                if (f === chart.series)
                    chart.series.map(function(el) {
                        addFillType(el, newType);
                        setPostProcessFill(chart, el)
                    });
                else if (f.hasOwnProperty("fill")) {
                    fObj = f.fill;
                    addFillType(fObj, newType)
                } else if (f.hasOwnProperty("backgroundcolor")) {
                    fObj = f;
                    addFillType(fObj, newType, f, "backgroundcolor")
                } else {
                    if (!f.hasOwnProperty("color"))
                        f.color = {};
                    fObj = f;
                    addFillType(fObj, newType)
                }
                return fObj
            }
            var newType = parseInt(type, 10);
            if (newType === 4)
                newType = 2;
            var fillObj = setFillTypeObj(this, t, newType);
            if (fillObj != null)
                setPostProcessFill(this, fillObj)
        },
        setFontName: function(t, v) {
            if (t) {
                t.font = t.font || "10px sans-serif";
                var font = tdg.fontToFontParts(t.font);
                font.fontFamily = v;
                t.font = font.toString()
            }
        },
        setFontSize: function(t, v) {
            if (t) {
                t.font = t.font || "10px sans-serif";
                var font = tdg.fontToFontParts(t.font);
                font.fontSize = parseInt(v, 10) / 3 + "pt ";
                t.font = font.toString()
            }
        },
        setFontSizeAbsolute: {},
        setFontSizeInPoints: function(t, v) {
            if (t) {
                t.font = t.font || "10px sans-serif";
                var font = tdg.fontToFontParts(t.font);
                font.fontSize = parseInt(v, 10) + "pt";
                t.font = font.toString();
                var arg1 = this.pfjParser.argNames[this.pfjParser.argNames.length - 1];
                if (arg1 === "getLegendText")
                    this.legend.markerSize = parseInt(v, 10)
            }
        },
        setFontStyle: function(t, v) {
            if (t) {
                t.font = t.font || "10px sans-serif";
                var font = tdg.fontToFontParts(t.font);
                font.fontStyle = v === "1" || v === "3" || v === "5" || v === "7" ? "italic" : "";
                font.fontWeight = v === "2" || v === "3" || v === "6" || v === "7" ? "bold" : "";
                t.font = font.toString();
                if (v === "4" || v === "5" || v === "6" || v === "7") {
                    var fontText = t.font.replace(/"/g, "&quot;");
                    if (t.text) {
                        t.text = t.text.replace(/\r?\n/g, "<BR>");
                        t.text = '<span style="font:' + fontText + '"><u>' + t.text + "</u></span>"
                    }
                    this.pfjParser.postProcessList.push(function(t) {
                        return function() {
                            if (t && t.color && t.text && t.text.includes('<span style="font:'))
                                t.text = t.text.replace('<span style="', '<span style="color: ' + t.color + "; ")
                        }
                    }(t))
                }
            }
        },
        setFootnoteDisplay: function(v) {
            this.footnote.visible = v
        },
        setFootnoteString: function(v) {
            this.footnote.text = v;
            this.footnote.visible = v ? true : false
        },
        setForceSeriesAbsolute: function(t, v) {
            if (v)
                this.blaProperties.comboCharts.lineSeriesLayout = "absolute"
        },
        setFrameAutoShade: function(v) {
            this.postAutoShade = v
        },
        setFrameDisplay: function(v) {
            this.border.color = v ? "black" : "transparent"
        },
        setGanttData: function(s, g, v) {
            s = parseInt(s, 10);
            g = parseInt(g, 10);
            if (g === 0 || g === 3) {
                this.data[s] = this.data[s] || [];
                this.data[s][0] = this.data[s][0] || [];
                this.data[s][0][g === 3 ? 1 : 0] = parseFloat(v)
            }
        },
        setGaugeBandMin: function(t, v) {
            var chart = this;
            var arg1 = chart.pfjParser.argNames[0];
            var band = getIndivGaugeBand(t, arg1);
            if (band) {
                var fVal = parseFloat(v);
                band.start = fVal
            }
        },
        setGaugeBandMax: function(t, v) {
            var chart = this;
            var arg1 = chart.pfjParser.argNames[0];
            var band = getIndivGaugeBand(t, arg1);
            if (band) {
                var fVal = parseFloat(v);
                band.stop = fVal
            }
        },
        setGaugeDescending: function(v) {
            this.yaxis.invert = v
        },
        setGaugeMajorTickRelativeTickLength: function(v) {
            var jsValue = v / .5 * 100;
            this.gaugeProperties.axisTickLength = parseInt(jsValue, 10) + "%";
            this.yaxis.majorGrid.lineStyle.width = 2;
            this.yaxis.majorGrid.lineStyle.color = "black"
        },
        setGaugeMinorTickRelativeTickLength: function(v) {
            var jsValue = v / .5 * 100;
            this.gaugeProperties.axisMinorTickLength = parseInt(jsValue, 10) + "%";
            this.yaxis.minorGrid.lineStyle.width = 2;
            this.yaxis.minorGrid.lineStyle.color = "black"
        },
        setGaugeRelativeInnerRadius: function(v) {
            this.gaugeProperties.axisWidth = parseFloat(v) * 100 + "%"
        },
        setGaugeRelativeThickness: function(v) {
            this.gaugeProperties.outerBorder.width = parseFloat(v) * 100 + "%"
        },
        setGaugeStartAngle: function(v) {
            this.gaugeProperties.startAngle = parseInt(v, 10)
        },
        setGaugeStopAngle: function(v) {
            this.gaugeProperties.endAngle = parseInt(v, 10)
        },
        setGaugeTitlePosition: function(v) {
            var pos = parseInt(v, 10);
            switch (pos) {
            default:
            case 1:
                this.gaugeProperties.groupLabel.position = "bottom";
                break;
            case 2:
                this.gaugeProperties.groupLabel.position = "top";
                break;
            case 3:
                this.gaugeProperties.groupLabel.position = "center";
                break
            }
        },
        setGradientDirection: function(t, v) {
            var f = "100%"
              , c = "50%"
              , h = "70.7%"
              , h2 = "141.42%"
              , z = "0%"
              , ih = "30.3%";
            var s = [[0, 0, 0, 0], [0, 0, f, 0], [f, 0, 0, 0], [0, 0, 0, f], [0, f, 0, 0], [f, 0, 0, f], [f, f, 0, 0], [0, 0, f, f], [0, f, f, 0], [c, c, h], [z, z, h2], [f, z, h2], [z, f, h2], [f, f, h2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, ih], [0, 0, ih]];
            v = parseInt(v, 10);
            var g = s[v];
            var fillObj = getFillGradientObj(this, t);
            if (fillObj && fillObj.pfjColorType && fillObj.pfjColorType.gradient) {
                var gradient = fillObj.pfjColorType.gradient;
                if (gradient)
                    if (v < 9) {
                        gradient.type = "linear";
                        gradient.start = {
                            x: g[0],
                            y: g[1]
                        };
                        gradient.end = {
                            x: g[2],
                            y: g[3]
                        }
                    } else if (v < 18) {
                        gradient.type = "radial";
                        gradient.start = {
                            x: g[0],
                            y: g[1]
                        };
                        gradient.radius = g[2];
                        if (v === 17)
                            gradient.isInverted = true
                    }
            }
        },
        setGradientNumPins: function() {},
        setGradientPinLeftColor: function(t, v, i) {
            setGradientPinColor(this, t, v, i)
        },
        setGradientPinLeftColor0: function(t, v) {
            setGradientPinColor(this, t, v, 0)
        },
        setGradientPinLeftColor1: function(t, v) {
            setGradientPinColor(this, t, v, 1)
        },
        setGradientPinLeftColor2: function(t, v) {
            setGradientPinColor(this, t, v, 2)
        },
        setGradientPinLeftColor3: function(t, v) {
            setGradientPinColor(this, t, v, 3)
        },
        setGradientPinLeftColor4: function(t, v) {
            setGradientPinColor(this, t, v, 4)
        },
        setGradientPinLeftColor5: function(t, v) {
            setGradientPinColor(this, t, v, 5)
        },
        setGradientPinLeftColor6: function(t, v) {
            setGradientPinColor(this, t, v, 6)
        },
        setGradientPinLeftColor7: function(t, v) {
            setGradientPinColor(this, t, v, 7)
        },
        setGradientPinLeftColor8: function(t, v) {
            setGradientPinColor(this, t, v, 8)
        },
        setGradientPinLeftColor9: function(t, v) {
            setGradientPinColor(this, t, v, 9)
        },
        setGradientPinPosition: function(t, v, i) {
            setGradientPinPositionInternal(this, t, v, i)
        },
        setGradientPinPosition0: function(t, v) {
            setGradientPinPositionInternal(this, t, v, 0)
        },
        setGradientPinPosition1: function(t, v) {
            setGradientPinPositionInternal(this, t, v, 1)
        },
        setGradientPinPosition2: function(t, v) {
            setGradientPinPositionInternal(this, t, v, 2)
        },
        setGradientPinPosition3: function(t, v) {
            setGradientPinPositionInternal(this, t, v, 3)
        },
        setGradientPinPosition4: function(t, v) {
            setGradientPinPositionInternal(this, t, v, 4)
        },
        setGradientPinPosition5: function(t, v) {
            setGradientPinPositionInternal(this, t, v, 5)
        },
        setGradientPinPosition6: function(t, v) {
            setGradientPinPositionInternal(this, t, v, 6)
        },
        setGradientPinPosition7: function(t, v) {
            setGradientPinPositionInternal(this, t, v, 7)
        },
        setGradientPinPosition8: function(t, v) {
            setGradientPinPositionInternal(this, t, v, 8)
        },
        setGradientPinPosition9: function(t, v) {
            setGradientPinPositionInternal(this, t, v, 9)
        },
        setGradientPinRightColor: function(t, v, i) {
            setGradientPinColor(this, t, v, i)
        },
        setGradientPinRightColor0: function(t, v) {
            setGradientPinColor(this, t, v, 0)
        },
        setGradientPinRightColor1: function(t, v) {
            setGradientPinColor(this, t, v, 1)
        },
        setGradientPinRightColor2: function(t, v) {
            setGradientPinColor(this, t, v, 2)
        },
        setGradientPinRightColor3: function(t, v) {
            setGradientPinColor(this, t, v, 3)
        },
        setGradientPinRightColor4: function(t, v) {
            setGradientPinColor(this, t, v, 4)
        },
        setGradientPinRightColor5: function(t, v) {
            setGradientPinColor(this, t, v, 5)
        },
        setGradientPinRightColor6: function(t, v) {
            setGradientPinColor(this, t, v, 6)
        },
        setGradientPinRightColor7: function(t, v) {
            setGradientPinColor(this, t, v, 7)
        },
        setGradientPinRightColor8: function(t, v) {
            setGradientPinColor(this, t, v, 8)
        },
        setGradientPinRightColor9: function(t, v) {
            setGradientPinColor(this, t, v, 9)
        },
        setGraphType: function(chartType) {
            var props = chartTypeMap[chartType];
            if (props) {
                this.set(props);
                this.pfjParser.chartType = parseInt(chartType, 10)
            }
        },
        setGridStepAuto: function(t, v) {
            var chart = this;
            var arg1 = this.pfjParser.argNames[this.pfjParser.argNames.length - 1];
            var axis = getAxisFromMajorGridArg(chart, arg1);
            if (axis != null)
                if (v)
                    axis.intervalMode = undefined;
                else
                    axis.intervalMode = "interval"
        },
        setGridStep: function(t, v) {
            var chart = this;
            var arg1 = this.pfjParser.argNames[this.pfjParser.argNames.length - 1];
            var axis = getAxisFromMajorGridArg(chart, arg1);
            if (axis != null)
                axis.intervalValue = parseFloat(v)
        },
        setGroupingSeparator: function(v) {
            var chart = this;
            var charQuoteReplace = chart.getThousandCharToReplaceWithQuote();
            var strStrip = convertCDNMacroToChar(v, charQuoteReplace);
            chart.setThousandSeparator(strStrip)
        },
        setGroupLabel: function(idx, lbl) {
            this.groupLabels[parseInt(idx, 10)] = lbl
        },
        setGroupLabelArray: function() {
            this.groupLabels = [];
            var labels = Array.prototype.slice.call(arguments);
            for (var i = 0; i < labels.length; ++i) {
                var label = labels[i];
                if (typeof label !== "string")
                    label = "" + label;
                this.groupLabels.push(label)
            }
        },
        setIgnoreSeries: function(t, v) {
            var seriesObj = getOrCreateSeries(this, t);
            if (!seriesObj)
                return;
            seriesObj.visible = !v
        },
        setIntroAnimation: function(v) {
            this.introAnimation.enabled = v
        },
        setIntroAnimationDuration: function(v) {
            this.introAnimation.duration = parseInt(v, 10)
        },
        setLabelStagger: function(t, v) {
            if (typeof t === "boolean" && v == null) {
                v = t;
                t = this.xaxis.labels
            }
            t = labelToAxis(this, t);
            t.labelLayout.stagger = v;
            if (v)
                t.labels.rotation = 0
        },
        setLegendDisplay: function(v) {
            if (this.series.some(function(el) {
                return el.label != null && el.label
            }))
                this.legend.visible = v
        },
        setLegendMarkerPosition: function(v) {
            var markerPos = parseInt(v, 10);
            this.legend.markerPosition = ["left", "right", "top", "bottom", "inside"][markerPos]
        },
        setLegendPosition: function(v) {
            if (v === "-1") {
                this.legend.position = "free";
                this.legend.align = "middle"
            } else {
                this.legend.position = ["bottom", "bottom", "right", "left", "top", "right", "right", "left", "left", "bottom", "bottom", "top", "top"][parseInt(v, 10)];
                this.legend.align = ["middle", "middle", "middle", "middle", "middle", "start", "end", "start", "end", "start", "end", "start", "end"][parseInt(v, 10)]
            }
        },
        setLegendReverse: function(v) {
            this.legend.reverseOrder = v
        },
        setLineBasicStrokeType: function(t, v) {
            var ls = t;
            if (t.hasOwnProperty("lineStyle"))
                ls = t.lineStyle;
            else if (t.hasOwnProperty("line"))
                ls = t.line;
            else if (t.hasOwnProperty("series")) {
                if (t.border == null)
                    t.border = {
                        width: 1,
                        dash: ""
                    };
                ls = t.border
            }
            switch (v) {
            case "11":
                ls.dash = "10 0";
                break;
            case "12":
                ls.dash = "2 4";
                break;
            case "13":
                ls.dash = "2 2";
                break;
            case "14":
                ls.dash = "8 4";
                break;
            case "15":
                ls.dash = "8 4 2 4";
                break;
            case "16":
                ls.dash = "12 4";
                break;
            case "17":
                ls.dash = "12 4 6 4";
                break;
            default:
                ls.dash = "";
                break
            }
        },
        setLineWidth: function(t, v) {
            if (t.hasOwnProperty("lineStyle"))
                t.lineStyle.width = parseFloat(v);
            else if (t.hasOwnProperty("line"))
                t.line.width = parseFloat(v);
            else if (t.hasOwnProperty("series")) {
                if (t.border == null)
                    t.border = {
                        width: 1,
                        dash: ""
                    };
                t.border.width = parseFloat(v)
            } else
                t.width = parseFloat(v)
        },
        setLogScale: function(t, v) {
            setLogScaleInternal(t, v)
        },
        setGridStyle: function(t, v) {
            setGridStyleInternal(t, v)
        },
        setMarkerDisplay: function(v) {
            for (var i = this.series.length - 1; i >= 0; i--) {
                if (this.series[i].marker == null)
                    this.series[i].marker = {};
                this.series[i].marker.visible = v
            }
        },
        setMarkerShape: function(t, v) {
            var shape = [undefined, "square", "circle", "diamond", "plus", "triangle", "triangle", "pirateCross", "triangle", "triangle", "house", "hexagon", "thinPlus", "fiveStar", "sixStar", "hourglass", "hourglass", "rectangle", "rectangle"][parseInt(v, 10)];
            var rotation = [0, 0, 0, 0, 0, 0, 180, 0, 270, 90, 0, 0, 45, 0, 0, 0, 90, 0, 90][parseInt(v, 10)];
            function setMarker(series) {
                series.marker = series.marker || {};
                if (!shape)
                    series.marker.visible = false;
                else {
                    series.marker.visible = true;
                    series.marker.shape = shape;
                    series.marker.rotation = rotation;
                    series.marker.border = {
                        width: 1,
                        color: "black"
                    }
                }
            }
            if (t === this.series)
                this.series.map(setMarker);
            else
                setMarker(t)
        },
        setMarkerSizeDefault: function(v) {
            for (var i = this.series.length - 1; i >= 0; i--) {
                this.series[i].marker = this.series[i].marker || {};
                this.series[i].marker.size = v / 8
            }
        },
        setMarkerSizeUnit: function(v) {
            for (var i = this.series.length - 1; i >= 0; i--) {
                this.series[i].marker = this.series[i].marker || {};
                var adjustedSize = parseInt(v, 10) / (8 * 35);
                this.series[i].marker.size = adjustedSize
            }
        },
        setNestedO1Label: function(nestedId, v) {
            this.postNestedO1 = this.postNestedO1 || {};
            if (this.postNestedO1.nestedLabels == null) {
                this.postNestedO1.nestedLabels = [];
                for (var i = 0; i < 10; i++)
                    this.postNestedO1.nestedLabels[i] = []
            }
            this.postNestedO1.nestedLabels[nestedId.level].push(v)
        },
        setNestedO1GroupingOnLevel: function(nestedId, v) {
            this.postNestedO1 = this.postNestedO1 || {};
            if (this.postNestedO1.nestedGrp == null) {
                this.postNestedO1.nestedGrp = [];
                for (var i = 0; i < 10; i++)
                    this.postNestedO1.nestedGrp[i] = []
            }
            this.postNestedO1.nestedGrp[nestedId.level].push(v)
        },
        setNonZeroBaseline: function(t, v) {
            var chart = this;
            t.postDisplayNonZeroBaseline = v;
            setPostProcessNonZeroBaseline(chart, t)
        },
        setNonZeroBaselineValue: function(t, v) {
            var chart = this;
            t.postNonZeroBaselineValue = parseFloat(v);
            setPostProcessNonZeroBaseline(chart, t)
        },
        setO1MajorGridStyle: function(v) {
            setGridStyleInternal(this.xaxis.majorGrid, v)
        },
        setO1MinorGridStyle: function(v) {
            setGridStyleInternal(this.xaxis.minorGrid, v)
        },
        setO1TitleDisplay: function(v) {
            this.xaxis.title.visible = v ? true : false
        },
        setO1TitleString: function(v) {
            this.xaxis.title.text = v;
            this.xaxis.title.visible = v ? true : false
        },
        setO1ExcludeMinLabel: function(v) {
            setExcludeMinLabelInternal(this.xaxis.labels, v)
        },
        setO1ExcludeMaxLabel: function(v) {
            setExcludeMaxLabelInternal(this.xaxis.labels, v)
        },
        setO2MajorGridStyle: function(v) {
            setGridStyleInternal(this.zaxis.majorGrid, v)
        },
        setO2MinorGridStyle: function(v) {
            setGridStyleInternal(this.zaxis.minorGrid, v)
        },
        setO2TitleDisplay: function(v) {
            this.zaxis.title.visible = v
        },
        setO2TitleString: function(v) {
            this.zaxis.title.text = v;
            this.zaxis.title.visible = v ? true : false
        },
        setO2ExcludeMinLabel: function(v) {
            setExcludeMinLabelInternal(this.zaxis.labels, v)
        },
        setO2ExcludeMaxLabel: function(v) {
            setExcludeMaxLabelInternal(this.zaxis.labels, v)
        },
        setPieDepth: function(v) {
            var chartType = this.chartType === "matrix" ? this.matrixProperties.chartType : this.chartType;
            if (chartType === "pie")
                this.depth = parseInt(v, 10) / 3
        },
        setPieFeelerTextDisplay: function(v) {
            var chartType = this.chartType === "matrix" ? this.matrixProperties.chartType : this.chartType;
            if (chartType !== "pie" && chartType !== "funnel")
                return;
            this.dataLabels = this.dataLabels || {};
            this.dataLabels.visible = v !== "0";
            var addFormat = true;
            if (this.prePieFormatPreset != null)
                addFormat = false;
            if (addFormat)
                if (chartType === "funnel") {
                    this.dataLabels.displayMode = "value";
                    this.dataLabels.numberFormat = "auto"
                } else {
                    this.dataLabels.displayMode = "%";
                    this.dataLabels.numberFormat = "#%";
                    if (this.prePieLabelDisplayDefined == null)
                        this.dataLabels.formatCallback = function(d, s, g, data) {
                            if (Math.abs(d.value) < 1E-7) {
                                d.noLabel = true;
                                return null
                            }
                            if (d.noLabel)
                                return null;
                            var pieSum = data.hasOwnProperty("total") ? data.total : getPieSum(this, g, d);
                            var fraction = d.value / pieSum;
                            fraction *= d.isNeg ? -1 : 1;
                            return this.formatNumber(fraction, this.dataLabels.numberFormat, "dataLabels")
                        }
                }
            switch (v) {
            case "1":
                this.pfjParser.tempState.feerLineVisibility = true;
                this.dataLabels.position = "outside";
                break;
            case "2":
                this.pfjParser.tempState.feerLineVisibility = false;
                this.dataLabels.position = "outside";
                break;
            case "3":
                this.dataLabels.position = "center";
                break
            }
            this.pfjParser.postProcessList.push(function() {
                if (this.pfjParser.tempState.feerLineVisibility === false)
                    this.dataLabels.feelerLine.width = 0
            });
            setPostProcessCurrFormat(this, this.dataLabels)
        },
        setPieFeelerTextFormat: function(v) {
            this.dataLabels.numberFormat = numberFormatMap[parseInt(v, 10)];
            setPostProcessCurrFormat(this, this.dataLabels)
        },
        setPieLabelDisplay: function(v) {
            if (this.chartType !== "pie" && (this.chartType !== "matrix" || this.matrixProperties.chartType !== "pie"))
                return;
            v = parseInt(v, 10);
            switch (v) {
            case 0:
                this.dataLabels.formatCallback = function(dataObj) {
                    if (Math.abs(dataObj.value) < 1E-7) {
                        dataObj.noLabel = true;
                        return null
                    }
                    var d = dataObj.value;
                    d = dataObj.isNeg ? -1 * d : d;
                    return this.formatNumber(d, this.dataLabels.numberFormat, "dataLabels")
                }
                ;
                break;
            case 1:
                this.dataLabels.formatCallback = function(dataObj, s, g) {
                    if (Math.abs(dataObj.value) < 1E-7) {
                        dataObj.noLabel = true;
                        return null
                    }
                    var d = dataObj.value;
                    var total = getPieSum(this, g, dataObj);
                    return this.formatNumber(d / total || 0, "#%")
                }
                ;
                break;
            case 2:
                this.dataLabels.formatCallback = function(dataObj, s) {
                    if (Math.abs(dataObj.value) < 1E-7) {
                        dataObj.noLabel = true;
                        return null
                    }
                    return dataObj.isOtherSlice ? this.pieProperties.otherSlice.legendLabel : this.getSeries(s).label
                }
                ;
                break;
            case 3:
                this.dataLabels.formatCallback = function(dataObj, s, g) {
                    if (Math.abs(dataObj.value) < 1E-7) {
                        dataObj.noLabel = true;
                        return null
                    }
                    var d = dataObj.value;
                    var total = getPieSum(this, g, dataObj);
                    d = this.formatNumber(d / total || 0, "#%");
                    var lbl = dataObj.isOtherSlice ? this.pieProperties.otherSlice.legendLabel : this.getSeries(s).label;
                    return lbl + " (" + d + ")"
                }
                ;
                break;
            case 4:
                this.dataLabels.formatCallback = function(dataObj, s) {
                    if (Math.abs(dataObj.value) < 1E-7) {
                        dataObj.noLabel = true;
                        return null
                    }
                    var d = dataObj.value;
                    d = this.formatNumber(d, this.dataLabels.numberFormat, "dataLabels");
                    var lbl = dataObj.isOtherSlice ? this.pieProperties.otherSlice.legendLabel : this.getSeries(s).label;
                    return lbl + " (" + d + ")"
                }
                ;
                break;
            case 5:
                this.dataLabels.formatCallback = function(dataObj, s, g) {
                    if (Math.abs(dataObj.value) < 1E-7) {
                        dataObj.noLabel = true;
                        return null
                    }
                    var d = dataObj.value;
                    var total = getPieSum(this, g, dataObj);
                    var p = this.formatNumber(d / total || 0, "#%");
                    return "" + (s.isNeg ? -1 * d : d) + " (" + p + ")"
                }
                ;
                break;
            case 6:
                this.dataLabels.formatCallback = function(dataObj, s, g) {
                    if (Math.abs(dataObj.value) < 1E-7) {
                        dataObj.noLabel = true;
                        return null
                    }
                    var d = dataObj.value;
                    var total = getPieSum(this, g, dataObj);
                    var p = this.formatNumber(d / total || 0, "#%");
                    var lbl = dataObj.isOtherSlice ? this.pieProperties.otherSlice.legendLabel : this.getSeries(s).label;
                    return "" + (s.isNeg ? -1 * d : d) + " (" + p + ") - " + lbl
                }
                ;
                break
            }
            this.prePieLabelDisplayDefined = true;
            setPostProcessCurrFormat(this, this.dataLabels);
            setPostProcessPieFeelerDoubleFormat(this, "setPieLabelDisplay", v)
        },
        setPieRingSize: function(v) {
            this.pieProperties.holeSize = parseInt(v, 10)
        },
        setPieRingTotalDisplay: function(v) {
            this.pieProperties.totalLabel.visible = v
        },
        setPieRotate: function(v) {
            this.pieProperties.rotation = parseInt(v, 10)
        },
        setPieSliceDelete: function(t, v) {
            var seriesObj = getOrCreateSeries(this, t);
            if (!seriesObj)
                return;
            seriesObj.deleteSlice = v
        },
        setPieSliceDetach: function(t, v) {
            var seriesObj = getOrCreateSeries(this, t);
            if (!seriesObj)
                return;
            var pie_radius_in_pixels = calcFullRadius(this, this.width, this.height);
            var CORRECT_FACTOR = this.width / pie_radius_in_pixels * (1500 / 32E3);
            seriesObj.explodeSlice = parseFloat(v) * CORRECT_FACTOR
        },
        setPieSorting: function() {},
        setPiesPerRow: function(v) {
            this.chartsPerRow = parseInt(v, 10)
        },
        setPieTilt: function(v) {
            this.pieProperties.skew = parseFloat(v)
        },
        setPlacePosition: function(t, v) {
            t.position = {
                1: "bottom",
                4: "right"
            }[v]
        },
        setPlaceTruncateCount: function() {},
        setPlaceTruncatePosition: function() {},
        setRect: function(t, rect) {
            function getPosition(percent) {
                var pos = 50;
                if (percent !== 0) {
                    if (percent < 0)
                        pos = 50 - Math.abs(percent * 50);
                    else
                        pos = 50 + percent * 50;
                    pos = Math.round(pos);
                    if (pos < 10)
                        pos = 10;
                    if (pos > 90)
                        pos = 90
                }
                return pos
            }
            var chart = this;
            if (t === chart.legend) {
                t.position = "free";
                t.xy = {
                    x: chart.width * ((rect.x + 16E3) / 32E3),
                    y: chart.height * ((rect.y - 16E3) / -32E3)
                };
                return
            }
            if (chart.width != null) {
                var xPercentWidth = rect.x / 16E3;
                var xPos = getPosition(xPercentWidth);
                t.position.x = xPos + "%"
            }
            if (chart.height != null) {
                var yPercentHeight = rect.y / 16E3;
                var yPos = getPosition(yPercentHeight);
                t.position.y = 100 - yPos + "%"
            }
        },
        setReferenceLine: function(t, idx, v) {
            getReferenceLine(this, axisToLabel(this, t), idx).value = parseFloat(v)
        },
        setReferenceLineValue: function(t, v) {
            var f = parseFloat(v);
            t.value = isNaN(f) ? v : f
        },
        setReferenceLineValueO1: setRefLineXValueInternal,
        setReferenceLineValueO2: setRefLineXValueInternal,
        setReferenceLineValueX1: function(idx, v) {
            getReferenceLine(this, "x", idx).value = parseFloat(v)
        },
        setReferenceLineValueY1: function(idx, v) {
            getReferenceLine(this, "y", idx).value = parseFloat(v)
        },
        setReferenceLineValueY2: function(idx, v) {
            getReferenceLine(this, "y2", idx).value = parseFloat(v)
        },
        setReferenceTextPosition: function(t, v) {
            var line = this.referenceLines.filter(function(el) {
                return el.label === t
            })[0];
            if (line != null)
                if (line.axis === "y" || line.axis === "y2")
                    line.anchor = ["end", "start", "end", "start", "start"][parseInt(v, 10)];
                else
                    line.anchor = ["start", "end", "start", "end", "start"][parseInt(v, 10)]
        },
        setReportParsingErrors: function(v) {
            this.catchErrors = !v
        },
        setReverseGroups: function(v) {
            this.xaxis.invert = v
        },
        setScaleMax: function(o, v) {
            o.max = parseFloat(v)
        },
        setScaleMaxAuto: function(o, v) {
            o.max = v ? undefined : o.max
        },
        setScaleMin: function(o, v) {
            o.min = parseFloat(v)
        },
        setScaleMinAuto: function(o, v) {
            o.min = v ? undefined : o.min
        },
        setScaleMustIncludeZero: function(o, v) {
            o.mustIncludeZero = v
        },
        setSeriesDefaultBorderColor: function(v) {
            var allSeries = this.getDefaultSeries();
            if (allSeries == null) {
                allSeries = {
                    series: "all"
                };
                this.series.push(allSeries)
            }
            allSeries.border = allSeries.border || {};
            allSeries.border.color = v
        },
        setSeriesLabel: function(sID, lbl) {
            var series = this.getSeries(parseInt(sID, 10));
            if (series == null) {
                series = {
                    series: parseInt(sID, 10)
                };
                this.series.push(series)
            }
            series.label = lbl
        },
        setSeriesLabelArray: function() {
            var labels = Array.prototype.slice.call(arguments);
            this.setSeriesLabels(labels)
        },
        setSeriesLineWidthDefault: function(v) {
            var allSeries = this.getDefaultSeries();
            if (allSeries == null) {
                allSeries = {
                    series: "all"
                };
                this.series.push(allSeries)
            }
            allSeries.border = allSeries.border || {};
            allSeries.border.width = parseInt(v, 10) / 2
        },
        setSeriesLooping: function(v) {
            this.postSeriesLoopCount = parseInt(v, 10)
        },
        setSeriesType: function(t, v) {
            var seriesObj = getOrCreateSeries(this, t);
            if (!seriesObj)
                return;
            seriesObj.riserShape = ["bar", "bar", "line", "area"][parseInt(v, 10)]
        },
        setShadowDisplay: function(t, v) {
            t.shadow = v
        },
        setSkipBegin: function() {},
        setSkipCount: function(t, v) {
            if (typeof t === "boolean" && v == null) {
                v = t;
                t = this.xaxis.labels
            }
            labelToAxis(this, t).labelLayout.skip = parseInt(v, 10)
        },
        setSmoothLines: function(v) {
            this.blaProperties.lineConnection = v ? "curved" : "linear"
        },
        setStackedDataValueSum: function(v) {
            if (v)
                this.dataLabels.displayMode = "cumulative";
            else {
                var chartType = this.chartType === "matrix" ? this.matrixProperties.chartType : this.chartType;
                switch (chartType) {
                case "bubble":
                    this.dataLabels.displayMode = "z";
                    break;
                case "bar":
                case "line":
                case "area":
                default:
                    this.dataLabels.displayMode = "x";
                    break
                }
            }
        },
        setStackedDataValuePercentOfTotal: function(v) {
            if (v)
                this.dataLabels.displayMode = "%";
            else if (this.dataLabels.displayMode != null) {
                var chartType = this.chartType === "matrix" ? this.matrixProperties.chartType : this.chartType;
                switch (chartType) {
                case "bar":
                case "line":
                case "area":
                    this.dataLabels.displayMode = "cumulative";
                    break;
                case "bubble":
                    this.dataLabels.displayMode = "z";
                    break;
                default:
                    this.dataLabels.displayMode = "x";
                    break
                }
            }
        },
        setSubtitleDisplay: function(v) {
            this.subtitle.visible = v
        },
        setSubtitleString: function(v) {
            this.subtitle.text = v;
            this.subtitle.visible = v ? true : false
        },
        setTextRotation: function(t, v) {
            t.rotation = [0, 90, 270, 45][parseInt(v, 10)]
        },
        setTextFormatPattern: function(t, v) {
            var chart = this;
            var arg1 = chart.pfjParser.argNames[chart.pfjParser.argNames.length - 1];
            if (shouldCallTextFormat(chart, arg1))
                setTextFormatPatternInternal(chart, t, v)
        },
        setTextFormatPreset: function(t, v) {
            var chart = this;
            var arg1 = chart.pfjParser.argNames[chart.pfjParser.argNames.length - 1];
            if (shouldCallTextFormat(chart, arg1))
                setTextFormatPresetInternal(chart, t, v)
        },
        setTextJustHoriz: function(t, v) {
            t.align = v === "0" ? "left" : v === "1" ? "center" : "right"
        },
        setTextString: function(t, v) {
            var arg1 = this.pfjParser.argNames[this.pfjParser.argNames.length - 1];
            if (arg1 === "getAnnotation")
                t.label.text = v;
            else
                t.text = v
        },
        setTickStyle: function(t, v) {
            t.style = ["outer", "outer", "inner", "outer", "span"][parseInt(v, 10)]
        },
        setTitleDisplay: function(v) {
            this.title.visible = v
        },
        setTitleString: function(v) {
            this.title.text = v;
            this.title.visible = v ? true : false
        },
        setToolTipStyle: function(v) {
            if (typeof v === "string") {
                v = v.toLowerCase();
                if (v === "html5") {
                    this.series.map(function(el) {
                        el.tooltip = "auto"
                    });
                    this.htmlToolTip.enabled = true;
                    this.htmlToolTip.snap = true;
                    this.htmlToolTip.sticky = true
                } else if (v === "pfj")
                    this.pfjParser.methods.setToolTipDisplay.call(this, true)
            }
        },
        setToolTipDisplay: function(v) {
            var chart = this;
            chart.series.map(function(el) {
                if (v)
                    el.tooltip = function(d, s, g, dataObj) {
                        dataObj = dataObj || {};
                        var format = "auto";
                        var theSeries = getOrCreateSeries(chart, s);
                        if (theSeries != null)
                            if (theSeries.numberFormat != null)
                                format = theSeries.numberFormat;
                        var newFormat = format;
                        if (typeof newFormat !== "function")
                            if (format.search("%") >= 0)
                                newFormat = format.replace("%", "`%");
                        var val;
                        var fmt = tdg.partial(chart.formatNumber, [null, newFormat, "tooltip"], chart);
                        if (d && typeof d === "object" && d.hasOwnProperty("nodeValue"))
                            val = fmt(d.nodeValue);
                        else
                            val = fmt(d);
                        var seriesLbl = chart.getSeriesLabel(s);
                        switch (chart.chartType) {
                        case "bar":
                        case "line":
                        case "area":
                        case "streamgraph":
                            return seriesLbl + ", " + chart.getGroupLabel(g) + ": " + val;
                        case "pie":
                            var pieSum = getPieSum(chart, g);
                            var pct = d / pieSum * 100;
                            pct = pct.toFixed(2);
                            seriesLbl = dataObj.isOtherSlice ? chart.pieProperties.otherSlice.legendLabel || seriesLbl : seriesLbl;
                            var neg = dataObj.isNeg ? "-" : "";
                            return seriesLbl + ": " + val + " (" + neg + (isNaN(pct) ? 0 : pct) + "%)";
                        case "bubble":
                            return "(" + seriesLbl + " " + dataObj.y + ", " + chart.xaxis.title.text + " " + dataObj.x + ", " + dataObj.size + ")";
                        case "polar":
                            return "(" + seriesLbl + " " + dataObj.r + ", " + dataObj.phi + ")";
                        case "scatter":
                            return "(" + seriesLbl + " " + dataObj.y + ", " + chart.xaxis.title.text + " " + dataObj.x + ")";
                        case "stock":
                            return "(" + seriesLbl + " " + dataObj.high + ", " + dataObj.low + ", " + dataObj.open + ", " + dataObj.close + ")";
                        case "boxplot":
                            return "(" + seriesLbl + " " + dataObj.min + ", " + dataObj.lower + ", " + dataObj.median + ", " + dataObj.upper + ", " + dataObj.max + ")";
                        case "heatmap":
                            return "(" + seriesLbl + ", " + chart.getGroupLabel(g) + ", " + val + ")";
                        case "map":
                            if (this.mapProperties.engine && this.mapProperties.engine === "leaflet")
                                return g + ", " + seriesLbl + ": " + val;
                            if (this.mapProperties.markerType === "bubble")
                                return "lat: " + dataObj.y + ", lon: " + dataObj.x + ", value: " + fmt(dataObj.size);
                            return val;
                        case "tagcloud":
                            return "(" + chart.getGroupLabel(g) + " = " + fmt(dataObj.value) + ")";
                        case "parabox":
                            var maybeValObj = chart.data[s][g];
                            var maybeVal = typeof maybeValObj === "object" ? maybeValObj.value : null;
                            var valstr = maybeVal ? ", val = " + maybeVal : "";
                            return seriesLbl + valstr;
                        case "funnel":
                            return seriesLbl + " " + chart.getGroupLabel(g) + " " + val;
                        case "mekko":
                            return seriesLbl + ", " + chart.getGroupLabel(g) + ": " + val + " (" + fmt(dataObj.percent) + "%)";
                        default:
                            return val
                        }
                    }
                    ;
                else
                    el.tooltip = undefined
            })
        },
        setTransparentBorderColor: function(t, v) {
            function getBorder(chart, borderIn) {
                var borderOut = null;
                if (borderIn === chart.fill)
                    borderOut = chart.border;
                else if (borderIn.hasOwnProperty("series")) {
                    if (!borderIn.border)
                        borderIn.border = {};
                    borderOut = borderIn.border
                } else if (borderIn.hasOwnProperty("lineStyle"))
                    borderOut = borderIn.lineStyle;
                else if (borderIn.hasOwnProperty("majorGrid"))
                    borderOut = borderIn.majorGrid.lineStyle;
                else if (borderIn.hasOwnProperty("border"))
                    borderOut = borderIn.border;
                return borderOut
            }
            var theBorder = null;
            if (this.pfjParser.argNames[0] === "getParetoLineRiser")
                t.color = v ? "transparent" : t.color;
            else
                theBorder = getBorder(this, t);
            if (theBorder)
                setPostProcessTransparentBorderColor(this, theBorder, v)
        },
        setTransparentFillColor: function(t, v) {
            var theFill = null;
            if (t.hasOwnProperty("backgroundcolor"))
                theFill = t;
            else if (t.hasOwnProperty("fill"))
                theFill = t.fill;
            else if (t.hasOwnProperty("series"))
                theFill = t;
            if (theFill)
                setPostProcessTransparentFillColor(this, theFill, v)
        },
        setUseDefaultBubbleMarker: function(v) {
            var chartType = this.chartType === "matrix" ? this.matrixProperties.chartType : this.chartType;
            if (chartType === "bubble" && !v)
                this.series.map(function(el) {
                    el.marker = {
                        shape: "circle",
                        border: {
                            width: 0,
                            color: "transparent"
                        }
                    }
                })
        },
        setUseNegativeDataTextColor: function(v) {
            this.dataLabels.useNegativeColor = parseBoolean(v)
        },
        setNegativeDataTextColor: function(v) {
            this.dataLabels.negativeColor = v
        },
        setUseSeriesShapes: function() {},
        setURL: function() {
            function callback(callbackObj) {
                var target = callbackObj.userInfo.target;
                var url = callbackObj.userInfo.url;
                if (url.indexOf("MDitemClickGraph") >= 0 && typeof MDitemClickGraph === "function") {
                    var args = url.slice(url.indexOf("(") + 1, url.lastIndexOf(")"));
                    args = eval("[" + args + "]");
                    args.splice(0, 0, callbackObj.event);
                    MDitemClickGraph.apply(window, args)
                } else if (target)
                    window.open(url, target);
                else
                    document.location = url
            }
            var res = function(s, g, v) {
                this._pfjsetURLTargets = this._pfjsetURLTargets || {};
                if (typeof s === "object" && tdg.isANumber(s.series))
                    s = s.series;
                if (isNaN(parseInt(g, 10)) && v == null) {
                    v = g;
                    g = undefined
                }
                var t = this._pfjsetURLTargets["s" + s + "g" + g] || {
                    url: "",
                    target: ""
                };
                t.url = v;
                this._pfjsetURLTargets["s" + s + "g" + g] = t;
                this.registerEvent(callback, "setURL", "series", t, s, g);
                if (this.chartType === "line" || this.chartType === "area")
                    this.registerEvent(callback, "setURL", "marker", t, s, g)
            };
            res.setTarget = function(s, g, v) {
                var t = this._pfjsetURLTargets["s" + s + "g" + g] || {
                    url: "",
                    target: ""
                };
                t.target = v;
                this._pfjsetURLTargets["s" + s + "g" + g] = t
            }
            ;
            return res
        }(),
        setURLTarget: function(s, g, v) {
            if (typeof s === "object" && tdg.isANumber(s.series))
                s = s.series;
            if (isNaN(parseInt(g, 10)) && v == null) {
                v = g;
                g = undefined
            }
            this.pfjParser.methods.setURL.setTarget.call(this, s, g, v)
        },
        setUserToolTip: function(v) {
            var chart = this;
            v = v.replace(/ ?\[R\]/g, "<br>");
            v = v.replace("[ON]", "riser");
            v = v.replace("[OD]", "riser");
            v = v.replace("[OID]", "riser");
            v = v.replace("[OIN]", "riser");
            chart.series.map(function(el) {
                el.tooltip = function(d, s, g, dataObj) {
                    dataObj = dataObj || {};
                    var format = chart.getSeriesAndGroupProperty(s, g, "dataLabels.numberFormat");
                    function fmt(d) {
                        return chart.formatNumber(d, format, "tooltip")
                    }
                    function fmtNoPercent(d) {
                        var f = chart.chartType === "pie" && format.includes("%") ? "###,###" : format;
                        return chart.formatNumber(d, f, "tooltip")
                    }
                    var p, data, t = v;
                    var lookup = dataObj.y == null ? "value" : "y";
                    t = t.replace("[SL]", chart.getSeriesLabel(s));
                    t = t.replace("[GL]", chart.getGroupLabel(g));
                    t = t.replace("[XV]", fmt(dataObj.x));
                    t = t.replace("[YV]", fmtNoPercent(dataObj[lookup]));
                    t = t.replace("[ZV]", fmt(dataObj.size));
                    if (chart.isBLA() && chart.blaProperties.seriesLayout === "stacked" || chart.blaProperties.seriesLayout === "percent") {
                        var tData = tdg.transpose(chart.data);
                        var cumulative = tdg.sum(tData[g].slice(0, s + 1), lookup);
                        t = t.replace("[CUMSTKV]", fmt(cumulative));
                        t = t.replace("[CUMPCTV]", (cumulative / tdg.sum(tData[g], lookup) * 100).toFixed(1) + "%")
                    } else {
                        t = t.replace("[CUMSTKV]", "");
                        t = t.replace("[CUMPCTV]", "")
                    }
                    if (chart.chartType === "pie") {
                        data = chart.data;
                        if (chart.pfjParser.sceneType === "flash" && chart.swapData)
                            data = tdg.transpose(chart.data);
                        p = data[g] || [];
                        p = (p[s] || {}).value / tdg.sum(p, "value") * 100;
                        t = t.replace("[PIEPCTV]", p.toFixed(1) + "%")
                    } else
                        t = t.replace("[PIEPCTV]", "");
                    if (chart.chartType === "stock") {
                        t = t.replace("[HV]", fmt(dataObj.high));
                        t = t.replace("[LV]", fmt(dataObj.low));
                        t = t.replace("[OV]", fmt(dataObj.open));
                        t = t.replace("[CV]", fmt(dataObj.close));
                        t = t.replace("[VV]", "null")
                    } else {
                        t = t.replace("[HV]", "");
                        t = t.replace("[LV]", "");
                        t = t.replace("[OV]", "");
                        t = t.replace("[CV]", "");
                        t = t.replace("[VV]", "")
                    }
                    if (chart.chartType === "pareto") {
                        data = chart.data[0].sort(function(b, a) {
                            return a < b ? -1 : a > b ? 1 : 0
                        });
                        p = tdg.sum(data.slice(0, g + 1), "value") / tdg.sum(data, "value") * 100;
                        t = t.replace("[PV]", p.toFixed(1) + "%")
                    } else
                        t = t.replace("[PV]", "");
                    return t
                }
            })
        },
        setX1: function(t, v) {
            setAnnotationPoint(t, 0, "x", v)
        },
        setX2: function(t, v) {
            setAnnotationPoint(t, 1, "x", v)
        },
        setY1: function(t, v) {
            setAnnotationPoint(t, 0, "y", v)
        },
        setY2: function(t, v) {
            setAnnotationPoint(t, 1, "y", v)
        },
        setX1AxisSide: function(v) {
            this.xaxis.swapChartSide = v === "1"
        },
        setX1LogScale: function(v) {
            setLogScaleInternal(this.xaxis, v)
        },
        setX1MajorGridStyle: function(v) {
            setGridStyleInternal(this.xaxis.majorGrid, v)
        },
        setX1MinorGridStyle: function(v) {
            setGridStyleInternal(this.xaxis.minorGrid, v)
        },
        setX1TitleDisplay: function(v) {
            this.xaxis.title.visible = v ? true : false
        },
        setX1TitleString: function(v) {
            this.xaxis.title.text = v;
            this.xaxis.title.visible = v ? true : false
        },
        setX1MustIncludeZero: function(v) {
            this.xaxis.mustIncludeZero = parseBoolean(v)
        },
        setX1ExcludeMinLabel: function(v) {
            setExcludeMinLabelInternal(this.xaxis.labels, v)
        },
        setX1ExcludeMaxLabel: function(v) {
            setExcludeMaxLabelInternal(this.xaxis.labels, v)
        },
        setX1ScaleMin: function(v) {
            this.xaxis.min = parseFloat(v)
        },
        setX1ScaleMax: function(v) {
            this.xaxis.max = parseFloat(v)
        },
        setY1AxisSide: function(v) {
            this.yaxis.swapChartSide = v === "1"
        },
        setY1LogScale: function(v) {
            setLogScaleInternal(this.yaxis, v)
        },
        setY1MajorGridStyle: function(v) {
            setGridStyleInternal(this.yaxis.majorGrid, v)
        },
        setY1MinorGridStyle: function(v) {
            setGridStyleInternal(this.yaxis.minorGrid, v)
        },
        setY1TitleDisplay: function(v) {
            this.yaxis.title.visible = v
        },
        setY1TitleString: function(v) {
            this.yaxis.title.text = v;
            this.yaxis.title.visible = v ? true : false
        },
        setY1MustIncludeZero: function(v) {
            this.yaxis.mustIncludeZero = parseBoolean(v)
        },
        setY1ExcludeMinLabel: function(v) {
            setExcludeMinLabelInternal(this.yaxis.labels, v)
        },
        setY1ExcludeMaxLabel: function(v) {
            setExcludeMaxLabelInternal(this.yaxis.labels, v)
        },
        setY1ScaleMin: function(v) {
            this.yaxis.min = parseFloat(v)
        },
        setY1ScaleMax: function(v) {
            this.yaxis.max = parseFloat(v)
        },
        setY2AxisSide: function(v) {
            this.y2axis.swapChartSide = v === "1"
        },
        setY2LogScale: function(v) {
            setLogScaleInternal(this.y2axis, v)
        },
        setY2MajorGridStyle: function(v) {
            setGridStyleInternal(this.y2axis.majorGrid, v)
        },
        setY2MinorGridStyle: function(v) {
            setGridStyleInternal(this.y2axis.minorGrid, v)
        },
        setY2TitleDisplay: function(v) {
            this.y2axis.title.visible = v ? true : false
        },
        setY2TitleString: function(v) {
            this.y2axis.title.text = v;
            this.y2axis.title.visible = v ? true : false
        },
        setY2MustIncludeZero: function(v) {
            this.y2axis.mustIncludeZero = parseBoolean(v)
        },
        setY2ExcludeMinLabel: function(v) {
            setExcludeMinLabelInternal(this.y2axis.labels, v)
        },
        setY2ExcludeMaxLabel: function(v) {
            setExcludeMaxLabelInternal(this.y2axis.labels, v)
        },
        setY2ScaleMin: function(v) {
            this.y2axis.min = parseFloat(v)
        },
        setY2ScaleMax: function(v) {
            this.y2axis.max = parseFloat(v)
        },
        setZeroValueDataTextDisplay: function(v) {
            this.dataLabels.displayZero = v
        },
        setZeroValueDataTextStackedTotalOnTopDisplay: function(v) {
            this.blaProperties.stackTotalLabel.displayZero = v
        },
        getAllSeries: "series",
        getAnnotation: function(idx) {
            var annot = null;
            if (idx == null)
                annot = this.annotations;
            else
                annot = getAnnotationIndex(this, parseInt(idx, 10));
            return annot
        },
        getChartBackground: "fill",
        getCubeFloorGridX: "xaxis.majorGrid",
        getCubeFloorGridZ: "zaxis.majorGrid",
        getCubeLeftWallGridY: "yaxis.majorGrid",
        getCubeLeftWallGridZ: "zaxis.majorGrid",
        getCubeRightWallGridX: "xaxis.majorGrid",
        getCubeRightWallGridY: "yaxis.majorGrid",
        getDataText: function(v) {
            v = parseInt(v, 10);
            if (!isNaN(v)) {
                var s = this.pfjParser.methods.getSeries.call(this, v);
                s.dataLabels = s.dataLabels || {};
                return s.dataLabels
            }
            return this.dataLabels
        },
        getDataTextStackedTotalOnTop: "blaProperties.stackTotalLabel",
        getExceptionalRiser: function(s, g) {
            s = parseInt(s, 10);
            g = parseInt(g, 10);
            var res = this.getSeriesAndGroup(s, g);
            if (res == null) {
                res = {
                    series: s,
                    group: g
                };
                this.series.push(res)
            }
            return res
        },
        getFootnote: "footnote",
        getFrame: "chartFrame",
        getFrameSide: "chartFrame.leftedge",
        getFrameBottom: "chartFrame.bottomedge",
        getFunnelValueLabel: "dataLabels",
        getGaugeBand1: "yaxis.colorBands",
        getGaugeBand2: "yaxis.colorBands",
        getGaugeBand3: "yaxis.colorBands",
        getGaugeBand4: "yaxis.colorBands",
        getGaugeBand5: "yaxis.colorBands",
        getGaugeMajorTick: "yaxis.majorGrid",
        getGaugeMinorTick: "yaxis.minorGrid",
        getGaugeValue: "gaugeProperties.totalLabel",
        getGaugeTitle: "gaugeProperties.groupLabel",
        getHistogramRiser: function() {
            return this.getSeries(0)
        },
        getLegendArea: "legend",
        getLegendText: "legend.labels",
        getLegendTitle: "legend.title",
        getNestedO1Level: function(s, g) {
            return {
                level: s,
                index: g
            }
        },
        getNestedO1LabelLine: "xaxis.labels.nestingLineStyle",
        getO1Axis: "xaxis",
        getO1AxisLine: "xaxis.bodyLineStyle",
        getO1Label: "xaxis.labels",
        getO1MajorGrid: "xaxis.majorGrid",
        getO1MajorGridColorBand1: "xaxis",
        getO1MajorGridColorBand2: "xaxis",
        getO1MajorTick: "xaxis.majorGrid.ticks",
        getO1MinorGrid: "xaxis.minorGrid",
        getO1Title: "xaxis.title",
        getO2Axis: "zaxis",
        getO2AxisLine: "zaxis.bodyLineStyle",
        getO2Label: "zaxis.labels",
        getO2MajorGrid: "zaxis.majorGrid",
        getO2MajorTick: "zaxis.majorGrid.ticks",
        getO2MinorGrid: "zaxis.minorGrid",
        getO2Title: "zaxis.title",
        getParetoLineRiser: function() {
            return this.chartType === "pareto" ? this.getSeries(1) : undefined
        },
        getParetoLineMarker: function() {
            return this.chartType === "pareto" ? this.getSeries(1).marker : undefined
        },
        getPieFeelerLine: "dataLabels.feelerLine",
        getPieLabel: "pieProperties.label",
        getPieRingLabel: "pieProperties.totalLabel",
        getPieSliceLabel: "dataLabels",
        getPieSliceFeelerValue: function() {
            return this.pfjParser.getPieSliceFeelerValue || {
                numberFormat: "auto",
                name: "getPieSliceFeelerValue"
            }
        },
        getPieSliceFeelerPercent: function() {
            return this.pfjParser.getPieSliceFeelerPercent || {
                numberFormat: "auto",
                name: "getPieSliceFeelerPercent"
            }
        },
        getReferenceLine: "referenceLines",
        getReferenceLineO1: function(idx) {
            return getReferenceLine(this, "x", idx)
        },
        getReferenceLineO2: function(idx) {
            return getReferenceLine(this, "x", idx)
        },
        getReferenceLineX1: function(idx) {
            return getReferenceLine(this, "x", idx)
        },
        getReferenceLineY1: function(idx) {
            return getReferenceLine(this, "y", idx)
        },
        getReferenceLineY2: function(idx) {
            return getReferenceLine(this, "y2", idx)
        },
        getReferenceLineTextO1: function(idx) {
            return getReferenceLine(this, "x", idx).label
        },
        getReferenceLineTextO2: function(idx) {
            return getReferenceLine(this, "x", idx).label
        },
        getReferenceLineTextX1: function(idx) {
            return getReferenceLine(this, "x", idx).label
        },
        getReferenceLineTextY1: function(idx) {
            return getReferenceLine(this, "y", idx).label
        },
        getReferenceLineTextY2: function(idx) {
            return getReferenceLine(this, "y2", idx).label
        },
        getReferenceLineXY: function(idx) {
            return getAnnotation(this, idx)
        },
        getDefaultSeries: function() {
            var res = this.getDefaultSeries();
            if (!res) {
                res = {
                    series: "all"
                };
                this.series.push(res)
            }
            return res
        },
        getSeries: function(idx) {
            return getOrCreateSeries(this, idx)
        },
        getSubtitle: "subtitle",
        getTitle: "title",
        getWaterfallLine: "waterfallProperties.connectorLine",
        getX1Axis: "xaxis",
        getX1AxisLine: "xaxis.bodyLineStyle",
        getX1Label: "xaxis.labels",
        getX1MajorGrid: "xaxis.majorGrid",
        getX1MajorGridColorBand1: "xaxis",
        getX1MajorGridColorBand2: "xaxis",
        getX1MajorTick: "xaxis.majorGrid.ticks",
        getX1MinorGrid: "xaxis.minorGrid",
        getX1Title: "xaxis.title",
        getX1ZeroLine: "xaxis.baseLineStyle",
        getNonZeroBaselineX1: "yaxis.baseLineStyle",
        getO1AltFmtFrame: function(v) {
            this.xaxis.colorBands = this.xaxis.colorBands || [];
            if (v == null)
                return this.xaxis.colorBands;
            var band = this.xaxis.colorBands[parseInt(v, 10)];
            if (band)
                band.axis = "xaxis";
            return band
        },
        getO1AltFmtLabel: function(v) {
            if (this.xaxis.colorBands == null)
                this.xaxis.colorBands = [];
            v = parseInt(v, 10);
            if (!tdg.isANumber(v))
                return this.xaxis.colorBands;
            var band = this.xaxis.colorBands[v];
            if (!band)
                band = this.xaxis.colorBands[v] = {};
            band.axis = "xaxis";
            band.label = {
                text: ""
            };
            return band.label
        },
        getX1AltFmtFrame: function(v) {
            if (this.xaxis.colorBands == null)
                this.xaxis.colorBands = [];
            if (v == null)
                return this.xaxis.colorBands;
            var band = this.xaxis.colorBands[parseInt(v, 10)];
            if (band)
                band.axis = "xaxis";
            return band
        },
        getX1AltFmtLabel: function(v) {
            if (this.xaxis.colorBands == null)
                this.xaxis.colorBands = [];
            v = parseInt(v, 10);
            if (!tdg.isANumber(v))
                return this.xaxis.colorBands;
            var band = this.xaxis.colorBands[v];
            if (!band)
                band = this.xaxis.colorBands[v] = {};
            band.axis = "xaxis";
            band.label = {
                text: ""
            };
            return band.label
        },
        getY1AltFmtFrame: function(v) {
            if (this.yaxis.colorBands == null)
                this.yaxis.colorBands = [];
            if (v == null)
                return this.yaxis.colorBands;
            var band = this.yaxis.colorBands[parseInt(v, 10)];
            if (band)
                band.axis = "yaxis";
            return band
        },
        getY2AltFmtFrame: function(v) {
            if (this.y2axis.colorBands == null)
                this.y2axis.colorBands = [];
            if (v == null)
                return this.y2axis.colorBands;
            var band = this.y2axis.colorBands[parseInt(v, 10)];
            if (band)
                band.axis = "y2axis";
            return band
        },
        getY1AltFmtLabel: function(v) {
            if (this.yaxis.colorBands == null)
                this.yaxis.colorBands = [];
            v = parseInt(v, 10);
            if (!tdg.isANumber(v))
                return this.yaxis.colorBands;
            var band = this.yaxis.colorBands[v];
            if (band) {
                band.axis = "yaxis";
                band.label = band.label || {};
                band = band.label
            } else
                band = this.yaxis.colorBands[v] = {
                    label: {}
                };
            return band
        },
        getY2AltFmtLabel: function(v) {
            if (this.y2axis.colorBands == null)
                this.y2axis.colorBands = [];
            v = parseInt(v, 10);
            if (!tdg.isANumber(v))
                return this.y2axis.colorBands;
            var band = this.y2axis.colorBands[v];
            if (band) {
                band.axis = "y2axis";
                band.label = band.label || {};
                band = band.label
            } else
                band = this.y2axis.colorBands[v] = {
                    label: {}
                };
            return band
        },
        getY1Axis: "yaxis",
        getY1AxisLine: "yaxis.bodyLineStyle",
        getY1Label: "yaxis.labels",
        getY1MajorGrid: "yaxis.majorGrid",
        getY1MajorGridColorBand1: "yaxis",
        getY1MajorGridColorBand2: "yaxis",
        getY1MajorTick: "yaxis.majorGrid.ticks",
        getY1MinorTick: "yaxis.minorGrid.ticks",
        getY1MinorGrid: "yaxis.minorGrid",
        getY1Title: "yaxis.title",
        getY1ZeroLine: "yaxis.baseLineStyle",
        getNonZeroBaselineY1: "yaxis.baseLineStyle",
        getY2Axis: "y2axis",
        getY2AxisLine: "y2axis.bodyLineStyle",
        getY2Label: "y2axis.labels",
        getY2MajorGrid: "y2axis.majorGrid",
        getY2MajorGridColorBand1: "y2axis",
        getY2MajorGridColorBand2: "y2axis",
        getY2MajorTick: "y2axis.majorGrid.ticks",
        getY2MinorGrid: "y2axis.minorGrid",
        getY2Title: "y2axis.title",
        getY2ZeroLine: "y2axis.baseLineStyle",
        getNonZeroBaselineY2: "y2axis.baseLineStyle",
        getCurveFitLineRiser: function(idx) {
            var seriesObj = getOrCreateSeries(this, idx);
            if (!seriesObj)
                return;
            if (seriesObj.trendline == null)
                seriesObj.trendline = getTrendlineStruct();
            return seriesObj.trendline
        },
        "new Color": function(r, g, b, a) {
            if (g == null && b == null)
                if (typeof r === "string" && r.charAt(0) === "#")
                    return r;
            if (a == null)
                return "rgb(" + r + ", " + g + ", " + b + ")";
            a /= 255;
            return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")"
        },
        "new Rectangle": function(x, y, width, height) {
            return {
                x: parseFloat(x),
                y: parseFloat(y),
                width: parseFloat(width),
                height: parseFloat(height)
            }
        },
        setGridCount: function(v, c) {
            v.count = parseInt(c, 10)
        }
    }
}
)();
(function() {
    tdgchart.prototype.pfjParser.postProcessPFJ = postProcessPFJ;
    var tdg = tdgchart.util;
    function doPostFill(chart) {
        function doFillType(f) {
            var newCol;
            if (f && f.pfjColorType) {
                var pfjType = f.pfjColorType;
                if (pfjType.fillType === 2) {
                    if (pfjType.gradient != null)
                        if (pfjType.gradient.isInverted) {
                            var g = pfjType.gradient;
                            g.stops.map(function(el) {
                                el.offset = 1 - el.offset
                            })
                        }
                    newCol = pfjType.gradient
                } else
                    newCol = pfjType.clr
            }
            return newCol
        }
        function postProcessFill(theFill) {
            var newClr = doFillType(theFill);
            if (newClr && theFill && theFill.pfjColorType)
                if (theFill.pfjColorType.structAbove == null)
                    theFill.color = newClr;
                else {
                    var sa = theFill.pfjColorType.structAbove;
                    var loc = theFill.pfjColorType.location;
                    sa[loc] = newClr
                }
            if (theFill.pfjColorType)
                delete theFill.pfjColorType
        }
        function postProcessFillList(theList) {
            for (var n = 0; n < theList.length; n++) {
                var theItem = theList[n];
                postProcessFill(theItem)
            }
        }
        if (chart.postFillList != null) {
            postProcessFillList(chart.postFillList);
            delete chart.postFillList
        }
    }
    function doPostTransparentBorderColor(chart) {
        function postProcessTransparentBorder(theBorder) {
            if (theBorder.postTransparentBorder != null) {
                if (theBorder.postTransparentBorder)
                    theBorder.color = "transparent";
                else if (theBorder.color == null || theBorder.color === "transparent")
                    theBorder.color = "black";
                delete theBorder.postTransparentBorder
            }
        }
        function postProcessTransparentBorderList(theList) {
            for (var n = 0; n < theList.length; n++) {
                var theItem = theList[n];
                postProcessTransparentBorder(theItem)
            }
        }
        if (chart.postTransparentBorderColorList != null) {
            postProcessTransparentBorderList(chart.postTransparentBorderColorList);
            delete chart.postTransparentBorderColorList
        }
    }
    function doPostTransparentFillColor(chart) {
        function postProcessTransparentFill(theFill) {
            if (theFill.postTransparentFill != null) {
                if (theFill.postTransparentFill) {
                    if (theFill.hasOwnProperty("color"))
                        theFill.color = "transparent";
                    if (theFill.hasOwnProperty("fill"))
                        theFill.fill = "transparent";
                    if (theFill.hasOwnProperty("backgroundcolor"))
                        theFill.backgroundcolor = "transparent"
                } else if (theFill.color == null || theFill.color === "transparent")
                    theFill.color = "black";
                delete theFill.postTransparentFill
            }
        }
        function postProcessTransparentFillList(theList) {
            for (var n = 0; n < theList.length; n++) {
                var theItem = theList[n];
                postProcessTransparentFill(theItem)
            }
        }
        if (chart.postTransparentFillColorList != null) {
            postProcessTransparentFillList(chart.postTransparentFillColorList);
            delete chart.postTransparentFillColorList
        }
    }
    function doPostAltFmt(chart) {
        function initFmtFrameColor(colorBand, color) {
            if (colorBand != null)
                if (colorBand.color == null)
                    colorBand.color = color
        }
        function initFrameColors(bandArray) {
            initFmtFrameColor(bandArray[0], "pink");
            initFmtFrameColor(bandArray[1], "LawnGreen");
            initFmtFrameColor(bandArray[2], "cyan");
            initFmtFrameColor(bandArray[3], "yellow");
            initFmtFrameColor(bandArray[4], "magenta")
        }
        function initFmtSeparator(colorBand, start, stop) {
            if (colorBand != null)
                if (colorBand.start === 0 && colorBand.stop === 0) {
                    colorBand.start = start;
                    colorBand.stop = stop
                }
        }
        function initFormatSeparators(bandArray) {
            initFmtSeparator(bandArray[0], 0, 10);
            initFmtSeparator(bandArray[1], 10, 20);
            initFmtSeparator(bandArray[2], 20, 30);
            initFmtSeparator(bandArray[3], 30, 40);
            initFmtSeparator(bandArray[4], 40, 50)
        }
        function moveStopPastNonVisible(bandArray) {
            for (var i = bandArray.length - 1; i >= 0; i--)
                if (bandArray[i].visible != null)
                    if (!bandArray[i].visible && i !== 0) {
                        bandArray[i].start = 0;
                        bandArray[i].stop = 0;
                        bandArray[i - 1].stop = "100%"
                    }
        }
        function initO1FormatSeparators(bandArray) {
            var start = 0
              , spread = 1 / bandArray.length;
            for (var i = 0; i < bandArray.length; i++) {
                initFmtSeparator(bandArray[i], start, start + spread);
                start += spread
            }
        }
        function postProcessAltFrameDefaults(bandArray) {
            initFrameColors(bandArray);
            initFormatSeparators(bandArray);
            moveStopPastNonVisible(bandArray)
        }
        function postProcessO1AltFrameDefaults(bandArray) {
            initFrameColors(bandArray);
            initO1FormatSeparators(bandArray);
            moveStopPastNonVisible(bandArray)
        }
        function postProcessO1AltFmtSeparators(bandArray) {
            for (var i = 0; i < bandArray.length - 1; i++)
                if (bandArray[i].O1Stop != null) {
                    bandArray[i].stop = bandArray[i].O1Stop;
                    if (bandArray[i + 1])
                        bandArray[i + 1].start = bandArray[i].stop;
                    delete bandArray[i].O1Stop
                }
        }
        if (chart.postO1AltFmtFrameDefaults != null) {
            postProcessO1AltFrameDefaults(chart.postO1AltFmtFrameDefaults);
            delete chart.postO1AltFmtFrameDefaults
        }
        if (chart.postO1AltFmtFrameSeparators != null) {
            postProcessO1AltFmtSeparators(chart.postO1AltFmtFrameSeparators);
            delete chart.postX1MajorGridColorBand2Axis
        }
        if (chart.postX1AltFmtFrameDefaults != null) {
            postProcessAltFrameDefaults(chart.postX1AltFmtFrameDefaults);
            delete chart.postX1AltFmtFrameDefaults
        }
        if (chart.postY1AltFmtFrameDefaults != null) {
            postProcessAltFrameDefaults(chart.postY1AltFmtFrameDefaults);
            delete chart.postY1AltFmtFrameDefaults
        }
        if (chart.postY2AltFmtFrameDefaults != null) {
            postProcessAltFrameDefaults(chart.postY2AltFmtFrameDefaults);
            delete chart.postY2AltFmtFrameDefaults
        }
    }
    function doPostMajorGridColorBands(chart) {
        function postProcessColorBand1(theAxis, defColor) {
            if (theAxis.altFrameColor1Visible) {
                if (theAxis.altFrameColor1 == null)
                    theAxis.altFrameColor1 = defColor
            } else
                theAxis.altFrameColor1 = undefined
        }
        function postProcessColorBand2(theAxis, defColor) {
            if (theAxis.altFrameColorVisible) {
                if (theAxis.altFrameColor == null)
                    theAxis.altFrameColor = defColor
            } else
                theAxis.altFrameColor = undefined
        }
        if (chart.postO1MajorGridColorBand1Axis != null) {
            postProcessColorBand1(chart.postO1MajorGridColorBand1Axis, "rgb(0, 255, 0)");
            delete chart.postO1MajorGridColorBand1Axis
        }
        if (chart.postO1MajorGridColorBand2Axis != null) {
            postProcessColorBand2(chart.postO1MajorGridColorBand2Axis, "blue");
            delete chart.postO1MajorGridColorBand2Axis
        }
        if (chart.postY1MajorGridColorBand1Axis != null) {
            postProcessColorBand1(chart.postY1MajorGridColorBand1Axis, "red");
            delete chart.postY1MajorGridColorBand1Axis
        }
        if (chart.postY1MajorGridColorBand2Axis != null) {
            postProcessColorBand2(chart.postY1MajorGridColorBand2Axis, "rgb(0, 255, 0)");
            delete chart.postY1MajorGridColorBand2Axis
        }
        if (chart.postY2MajorGridColorBand1Axis != null) {
            postProcessColorBand1(chart.postY2MajorGridColorBand1Axis, "red");
            delete chart.postY2MajorGridColorBand1Axis
        }
        if (chart.postY2MajorGridColorBand2Axis != null) {
            postProcessColorBand2(chart.postY2MajorGridColorBand2Axis, "rgb(0, 255, 0)");
            delete chart.postY2MajorGridColorBand2Axis
        }
        if (chart.postX1MajorGridColorBand1Axis != null) {
            postProcessColorBand1(chart.postX1MajorGridColorBand1Axis, "red");
            delete chart.postX1MajorGridColorBand1Axis
        }
        if (chart.postX1MajorGridColorBand2Axis != null) {
            postProcessColorBand2(chart.postX1MajorGridColorBand2Axis, "rgb(0, 255, 0)");
            delete chart.postX1MajorGridColorBand2Axis
        }
    }
    function doPostNestedO1(chart) {
        function processNestedLabels() {
            chart.groupLabels = [];
            var nlevelIdx, nlevelGrpIdx;
            var nestedGroups = chart.postNestedO1.nestedGrp;
            var nestedLabels = chart.postNestedO1.nestedLabels;
            for (nlevelIdx = nestedLabels.length - 1; nlevelIdx >= 0; nlevelIdx--)
                if (nestedLabels[nlevelIdx].length > 0)
                    break;
            for (nlevelGrpIdx = nestedGroups.length - 1; nlevelGrpIdx >= 0; nlevelGrpIdx--)
                if (nestedGroups[nlevelGrpIdx].length > 0)
                    break;
            if (nlevelGrpIdx < nlevelIdx)
                for (var iLabel = 0; iLabel < nestedLabels[nlevelIdx].length; iLabel++)
                    nestedGroups[nlevelIdx].push(1);
            function getLabels(levelLblIdx, nbChildren) {
                var labels = [];
                var nFirstLabel = 0;
                var nNumLabels = nestedLabels[levelLblIdx].length;
                while (nestedLabels[levelLblIdx][nFirstLabel] == null && nFirstLabel < nNumLabels)
                    nFirstLabel++;
                for (var i = 0; i < nbChildren; i++) {
                    labels.push(nestedLabels[levelLblIdx][i + nFirstLabel]);
                    nestedLabels[levelLblIdx][i + nFirstLabel] = null
                }
                return labels
            }
            function getGroup(levelLblIdx) {
                var nFirstGroup = 0;
                var nNumGroups = nestedGroups[levelLblIdx].length;
                while (nestedGroups[levelLblIdx][nFirstGroup] == null && nFirstGroup < nNumGroups)
                    nFirstGroup++;
                var strGroup = nestedGroups[levelLblIdx][nFirstGroup];
                nestedGroups[levelLblIdx][nFirstGroup] = null;
                return parseInt(strGroup, 10)
            }
            function addChild(node, levelLblIdx) {
                var nbChildren = getGroup(levelLblIdx);
                var labels = getLabels(levelLblIdx, nbChildren);
                if (levelLblIdx > 0)
                    for (var child = 0; child < nbChildren; child++) {
                        var newNode = {};
                        newNode[labels[child]] = [];
                        addChild(newNode[labels[child]], levelLblIdx - 1);
                        node.push(newNode)
                    }
                else
                    for (var i = 0; i < nbChildren; i++)
                        node.push(labels[i])
            }
            var nbChildren = nestedGroups[nlevelIdx].length;
            for (var i = 0; i < nbChildren; i++)
                addChild(chart.groupLabels, nlevelIdx)
        }
        function shouldProcessNestedLabels() {
            var bProcess = false;
            if (chart.postNestedO1 != null) {
                bProcess = chart.postNestedO1.nestedGrp != null && chart.postNestedO1.nestedLabels != null;
                if (chart.chartType === "histogram")
                    bProcess = false
            }
            return bProcess
        }
        if (shouldProcessNestedLabels())
            processNestedLabels();
        delete chart.postNestedO1
    }
    function doPostSeriesLooping(chart) {
        if (chart.postSeriesLoopCount != null) {
            chart.series.forEach(function(el) {
                if (el.series === "all" || el.series >= chart.postSeriesLoopCount && el.group == null)
                    el.color = undefined
            });
            delete chart.postSeriesLoopCount
        }
    }
    function doPostCurrFormat(chart) {
        function postProcessCurrFormat(theFmt, strOriginalCurrencySymbol, strCurrencySymbol) {
            if (theFmt.numberFormat != null)
                theFmt.numberFormat = theFmt.numberFormat.replace(strOriginalCurrencySymbol, strCurrencySymbol)
        }
        function postProcessCurrFormatList(chart, theList) {
            if (chart.pfjParser.permanentState.postCurrencySymbolOverride != null && chart.pfjParser.permanentState.postOriginalCurrencySymbol != null)
                for (var n = 0; n < theList.length; n++) {
                    var theItem = theList[n];
                    postProcessCurrFormat(theItem, chart.pfjParser.permanentState.postOriginalCurrencySymbol, chart.pfjParser.permanentState.postCurrencySymbolOverride)
                }
        }
        if (chart.postCurrFormatList != null) {
            postProcessCurrFormatList(chart, chart.postCurrFormatList);
            delete chart.postCurrFormatList
        }
    }
    function doPostFormat(chart) {
        function postProcessFormat(theFmt) {
            if (theFmt.postFormatPreset != null)
                if (theFmt.postFormatPreset === -2) {
                    if (theFmt.postFormatPattern == null)
                        theFmt.postFormatPattern = "#.#";
                    theFmt.numberFormat = function(d) {
                        var numFmt = chart.formatNumber(d / 100, theFmt.postFormatPattern);
                        return numFmt
                    }
                }
        }
        function postProcessFormatList(chart, theList) {
            for (var n = 0; n < theList.length; n++) {
                var theItem = theList[n];
                postProcessFormat(theItem);
                theItem.postFormatPreset = null
            }
        }
        if (chart.postFormatList != null) {
            postProcessFormatList(chart, chart.postFormatList);
            delete chart.postFormatList
        }
    }
    function doPostPieFeelerDoubleFormat(chart) {
        function postProcessPieFeelerDoubleFormatObj(chart, theObj) {
            var labelDisplay = theObj.setPieLabelDisplay;
            var valFmt = theObj.setTextFormatPattern_getPieSliceFeelerValue || "auto";
            var pctFmt = theObj.setTextFormatPattern_getPieSliceFeelerPercent;
            pctFmt = pctFmt || (chart.dataLabels && typeof chart.dataLabels.numberFormat === "string" && chart.dataLabels.numberFormat.includes("%") ? chart.dataLabels.numberFormat : "#%");
            if (labelDisplay === 3)
                chart.dataLabels.formatCallback = function(dataObj, s, g) {
                    if (Math.abs(dataObj.value) < 1E-7) {
                        dataObj.noLabel = true;
                        return null
                    }
                    var d = dataObj.value;
                    var total = getPieSum(chart, g, dataObj);
                    d = chart.formatNumber(d / total || 0, pctFmt);
                    var lbl = dataObj.isOtherSlice ? chart.pieProperties.otherSlice.legendLabel : chart.getSeries(s).label;
                    return lbl + " (" + d + ")"
                }
                ;
            else if (labelDisplay === 5)
                chart.dataLabels.formatCallback = function(dataObj, s, g) {
                    if (Math.abs(dataObj.value) < 1E-7) {
                        dataObj.noLabel = true;
                        return null
                    }
                    var d = dataObj.value;
                    var total = getPieSum(chart, g, dataObj);
                    var p = chart.formatNumber(d / total || 0, pctFmt);
                    var dFormatted = chart.formatNumber(s.isNeg ? -1 * d : d, valFmt, "dataLabels");
                    return dFormatted + " (" + p + ")"
                }
                ;
            else if (labelDisplay === 6)
                chart.dataLabels.formatCallback = function(dataObj, s, g) {
                    if (Math.abs(dataObj.value) < 1E-7) {
                        dataObj.noLabel = true;
                        return null
                    }
                    var d = dataObj.value;
                    var total = getPieSum(chart, g, dataObj);
                    var p = chart.formatNumber(d / total || 0, pctFmt);
                    var dFormatted = chart.formatNumber(s.isNeg ? -1 * d : d, valFmt, "dataLabels");
                    var lbl = dataObj.isOtherSlice ? chart.pieProperties.otherSlice.legendLabel : chart.getSeries(s).label;
                    return dFormatted + " (" + p + ") - " + lbl
                }
        }
        if (chart.postPieFeelerDoubleFormatObj != null) {
            postProcessPieFeelerDoubleFormatObj(chart, chart.postPieFeelerDoubleFormatObj);
            delete chart.postPieFeelerDoubleFormatObj
        }
    }
    function getPieSum(chart, g, d) {
        function sumData(groupData) {
            if (!groupData || !groupData.length)
                return 1;
            var sum = 0;
            for (var i = 0; i < groupData.length; i++) {
                var gData = groupData[i];
                if (gData != null)
                    if (gData.value != null)
                        sum += Math.abs(gData.value)
            }
            return sum
        }
        var data = chart.data;
        if (chart.pfjParser.sceneType === "flash" && chart.swapData)
            data = tdg.transpose(chart.data);
        if (chart.chartType === "matrix")
            if (d && d._r != null && d._c != null)
                data = (data[d._r] || [])[d._c];
            else
                data = (data[0] || [])[0];
        return sumData(data[g])
    }
    function doPostTooltip(chart) {
        function postCopyTooltip(theItem) {
            if (theItem.postTooltip) {
                theItem.tooltip = theItem.postTooltip;
                delete theItem.postTooltip
            }
        }
        function postProcessTooltipList(theList) {
            for (var n = 0; n < theList.length; n++) {
                var theItem = theList[n];
                postCopyTooltip(theItem)
            }
        }
        if (chart.postTooltipList != null) {
            postProcessTooltipList(chart.postTooltipList);
            delete chart.postTooltipList
        }
    }
    function doPostNonZeroBaseline(chart) {
        function postNonZeroBaseline(theItem) {
            if (theItem.postDisplayNonZeroBaseline != null) {
                if (theItem.postDisplayNonZeroBaseline && theItem.postNonZeroBaselineValue != null) {
                    theItem.baseLineValue = theItem.postNonZeroBaselineValue;
                    if (theItem.baseLineStyle.width === 0)
                        theItem.baseLineStyle.width = 1
                } else
                    theItem.baseLineStyle.width = 0;
                delete theItem.postDisplayNonZeroBaseline;
                delete theItem.postNonZeroBaselineValue
            }
        }
        function postProcessNonZeroBaselineList(theList) {
            for (var n = 0; n < theList.length; n++) {
                var theItem = theList[n];
                postNonZeroBaseline(theItem)
            }
        }
        if (chart.postNonZeroBaselineList != null) {
            postProcessNonZeroBaselineList(chart.postNonZeroBaselineList);
            delete chart.postNonZeroBaselineList
        }
    }
    function deletePreFlags(chart) {
        if (chart.prePieLabelDisplayDefined != null)
            delete chart.prePieLabelDisplayDefined
    }
    function doPostAutoShade(chart) {
        if (chart.postAutoShade) {
            chart.chartFrame.leftedge.fill.color = "auto";
            chart.chartFrame.bottomedge.fill.color = "auto";
            delete chart.postAutoShade
        }
    }
    function doGenericPost(chart) {
        for (var i = 0; i < chart.pfjParser.postProcessList.length; i++)
            chart.pfjParser.postProcessList[i].call(chart)
    }
    function postProcessPFJ(chart) {
        deletePreFlags(chart);
        doPostFill(chart);
        doPostTransparentBorderColor(chart);
        doPostTransparentFillColor(chart);
        doPostMajorGridColorBands(chart);
        doPostAltFmt(chart);
        doPostNestedO1(chart);
        doPostSeriesLooping(chart);
        doPostCurrFormat(chart);
        doPostFormat(chart);
        doPostNonZeroBaseline(chart);
        doPostTooltip(chart);
        doPostPieFeelerDoubleFormat(chart);
        doPostAutoShade(chart);
        doGenericPost(chart);
        chart.pfjParser.postProcessList = [];
        chart.pfjParser.tempState = {}
    }
}
)();
tdgchart.prototype.parsePFJString = function() {
    function strip(s) {
        return s.replace(/^\s*/, "").replace(/\s*$/, "")
    }
    function removeComments(str) {
        str = str || "";
        var r1 = /\/\*[\s\S]*?\*\//g;
        var r2 = /new\s*color/ig;
        str = str.replace(r1, "");
        str = str.replace(r2, "new Color");
        return strip(str)
    }
    var chart = null;
    var debugMethods = [];
    function invokeMethod(method) {
        chart.pfjParser.argNames = method.argNames;
        var fx = chart.pfjParser.methods[method.name];
        if (!fx) {
            if (debugMethods.indexOf(method.name) === -1)
                debugMethods.push(method.name)
        } else if (method.args.indexOf(undefined) >= 0)
            ;
        else if (typeof fx === "function") {
            if (method.args)
                for (var i = 0; i < method.args.length; i++)
                    if (method.args[i] === "true")
                        method.args[i] = true;
                    else if (method.args[i] === "false")
                        method.args[i] = false;
            return fx.apply(chart, method.args)
        } else if (typeof fx === "string")
            return chart.stringToProperty(fx);
        return undefined
    }
    function tokenize(str) {
        var callStack = []
          , curMethod = null
          , stringMatch = /"[^"\\]*(?:\\.[^"\\]*)*"/
          , matchedParen = false;
        function popCallStack() {
            var res = invokeMethod(curMethod);
            callStack.pop();
            if (callStack.length > 0) {
                var name = (curMethod || {}).name;
                curMethod = callStack[callStack.length - 1];
                if (curMethod && curMethod.args && curMethod.argNames) {
                    curMethod.args.push(res);
                    curMethod.argNames.push(name)
                }
            }
        }
        function tokenCallback(match, isToken, token) {
            match = strip(match).replace(/\\"/g, '"');
            if (isToken)
                if (token === stringMatch && curMethod && curMethod.args)
                    curMethod.args.push(match.slice(1, match.length - 1));
                else {
                    if (token === ")") {
                        if (!matchedParen)
                            popCallStack();
                        matchedParen = false
                    }
                }
            else {
                matchedParen = false;
                if (token === "(") {
                    curMethod = {
                        name: match,
                        args: [],
                        argNames: []
                    };
                    callStack.push(curMethod)
                } else if (token === "," && curMethod && curMethod.args)
                    curMethod.args.push(match);
                else if (token === ")") {
                    matchedParen = true;
                    if (curMethod && curMethod.args)
                        curMethod.args.push(match);
                    popCallStack()
                }
            }
        }
        var tokenizer = new tdgchart.Tokenizer([stringMatch, "(", ",", ")", ";"],tokenCallback);
        tokenizer.parse(str)
    }
    return function(pfjString) {
        chart = this;
        if (this.catchErrors)
            try {
                if (chart.validateProperties)
                    chart.validateChartProperties();
                tokenize(removeComments(pfjString))
            } catch (e$10) {
                this.errorMessage = e$10
            }
        else {
            if (chart.validateProperties)
                chart.validateChartProperties();
            tokenize(removeComments(pfjString))
        }
        chart.pfjParser.postProcessPFJ(chart)
    }
}();
tdgchart.pfj_defaultProperties = {
    data: [],
    pieProperties: {
        skew: 13
    },
    legend: {
        position: "bottom"
    },
    xaxis: {
        altFrameColorVisible: false,
        altFrameColor1Visible: false,
        altFrameColor1: undefined
    },
    yaxis: {
        altFrameColorVisible: false,
        altFrameColor1Visible: false,
        altFrameColor1: undefined
    },
    y2axis: {
        altFrameColorVisible: false,
        altFrameColor1Visible: false,
        altFrameColor1: undefined
    },
    colorScale: {
        colors: ["red", "green"]
    },
    series: [{
        series: "all",
        marker: {
            shape: "square",
            border: {
                width: 0,
                color: "transparent"
            }
        }
    }, {
        series: 0,
        color: "rgb(153, 153, 255)"
    }, {
        series: 1,
        color: "rgb(153, 255, 153)"
    }, {
        series: 2,
        color: "rgb(255, 153, 255)"
    }, {
        series: 3,
        color: "rgb(255, 255, 153)"
    }, {
        series: 4,
        color: "rgb(153, 204, 255)"
    }, {
        series: 5,
        color: "rgb(67, 126, 28)"
    }, {
        series: 6,
        color: "rgb(239, 167, 0)"
    }, {
        series: 7,
        color: "rgb(102, 0, 112)"
    }, {
        series: 8,
        color: "rgb(0, 255, 255)"
    }, {
        series: 9,
        color: "rgb(0, 152, 82)"
    }, {
        series: 10,
        color: "rgb(206, 0, 121)"
    }, {
        series: 11,
        color: "rgb(255, 243, 172)"
    }, {
        series: 12,
        color: "rgb(0, 56, 105)"
    }, {
        series: 13,
        color: "rgb(106, 189, 187)"
    }, {
        series: 14,
        color: "rgb(145, 0, 38)"
    }, {
        series: 15,
        color: "rgb(162, 202, 0)"
    }, {
        series: 16,
        color: "rgb(253, 211, 154)"
    }, {
        series: 17,
        color: "rgb(255, 243, 172)"
    }]
};
tdgchart.prototype.applyPFJDefaults = function() {
    this.set(tdgchart.pfj_defaultProperties);
    this.parsePFJString("setToolTipDisplay(true)")
}
;
(function() {
    var originalSetSampleData = tdgchart.prototype.setSampleData;
    tdgchart.prototype.setSampleData = function() {
        var chart = this;
        if (chart.data === "sample") {
            originalSetSampleData.call(chart);
            return
        }
        switch (chart.chartType) {
        case "legend":
            chart.data = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
            break;
        case "map":
            if (chart.mapProperties.engine === "leaflet")
                chart.data = [[]];
            else {
                chart.mapProperties.map = "usall";
                chart.data = [[1, 2, 5, 4, 6, 7, 4, 3, 1, 3, 1, 2, 5, 4, 6, 7, 4, 3, 1, 3, 1, 2, 5, 4, 6, 7, 4, 3, 1, 3, 1, 2, 5, 4, 6, 7, 4, 3, 1, 3, 1, 2, 5, 4, 6, 7, 4, 3, 1, 3]]
            }
            break;
        case "treemap":
            chart.data = {
                West: {
                    doodads: 30,
                    widgets: 10,
                    thingies: 15
                },
                East: {
                    doodads: 10,
                    widgets: 5,
                    thingies: 12
                },
                North: {
                    doodads: 10,
                    widgets: 20,
                    thingies: 30
                },
                South: {
                    doodads: 20,
                    widgets: 20,
                    thingies: 20
                }
            };
            break;
        case "histogram":
            chart.data = [[1, 2, 1, 4, 1, 2, 3, 1, 4, 1, 2, 4, 1, 1, 1, 2, 3, 1, 2, 5, 5, 5]];
            break;
        case "waterfall":
            chart.data = [[3, 1, -2, 3]];
            break;
        case "pareto":
            chart.data = [[1, 2, 5, 7, 3]];
            break;
        case "sparkline":
            chart.data = [[1, 4, 2, 6, 1, 2, 3]];
            break;
        case "bullet":
            chart.data = [[5, 1, 4, 7]];
            break;
        case "boxplot":
            chart.data = [[[1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7]], [[1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7]]];
            break;
        case "stock":
            chart.data = [[[5, 2, 3, 4], [8, 2, 4, 5], [6, 2, 5, 3]], [[4, 1, 3, 2], [7, 4, 5, 6], [5, 1, 2, 4]]];
            break;
        case "bubble":
            chart.data = [[[1, 1, 1], [2, 2, 2], [3, 3, 3]], [[2, 1, 1], [2, 3, 2], [3, 1, 3]]];
            break;
        case "polar":
        case "scatter":
            chart.data = [[[0, 0], [5, 10], [12, 30], [8, 20]], [[33, 43], [40, 50], [30, 35], [35, 40]], [[16, 22], [22, 28], [18, 25], [24, 18]]];
            trim();
            break;
        case "gantt":
            chart.data = [[[1, 2, 0], [2, 3, 1], [3, 4, 2]], [[1, 3], [2, 4], [3, 5]]];
            break;
        case "pie":
            chart.data = [[5, 10, 15, 20, 25], [10, 15, 20, 25, 30], [15, 20, 25, 30, 35], [20, 25, 30, 35, 40], [25, 30, 35, 40, 45]];
            trim();
            break;
        case "funnel":
            chart.data = [[5, 10], [10, 15], [15, 20], [20, 25], [25, 30]];
            break;
        case "gauge":
            chart.data = [[35, 0]];
            break;
        case "parabox":
            chart.data = [[1, "A", 5, 1, 3, 2], [7, "C", 1, 3, 1, 4], [5, "B", 7, 5, 4, 6], [2, "A", 1, 3, 6, 7], [1, "A", 7, 7, 8, 8], [1, "B", 7, 3, 8, 9], [1, "B", 7, 3, 8, 2]];
            break;
        case "area":
            chart.data = [[25, 30, 35, 40, 45], [20, 25, 30, 35, 40], [15, 20, 25, 30, 35], [10, 15, 20, 25, 30], [5, 10, 15, 20, 25]];
            trim();
            break;
        case "bar3d":
        case "area3d":
        case "surface3d":
        case "streamgraph":
        case "mekko":
        case "radar":
        case "bar":
        case "line":
        default:
            chart.data = [[5, 10, 15, 20, 25], [10, 15, 20, 25, 30], [15, 20, 25, 30, 35], [20, 25, 30, 35, 40], [25, 30, 35, 40, 45]];
            trim();
            break
        }
        function trim() {
            if (chart.series.length < 5 && chart.series.length >= 2)
                chart.data.length = chart.series.length - 1
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.seriesMarkerShapeLookup = function() {
        var chart = this;
        var defaultLookup = chart.seriesPropertyLookup("marker.shape");
        return function(d) {
            if (d.shape != null)
                if (typeof d.shape === "string")
                    return d.shape;
                else if (typeof d.shape === "number")
                    return chart.markerShapeList[d.shape];
            return defaultLookup.call(this, d)
        }
    }
    ;
    function typeHandler(prop) {
        return function(mark, idx, d) {
            var target = null
              , anchorTarget = typeof mark.anchorTarget === "function" ? mark.anchorTarget() : null;
            if (mark.hasOwnProperty(prop))
                target = mark;
            else if (anchorTarget != null && anchorTarget.hasOwnProperty(prop))
                target = anchorTarget;
            try {
                if (prop === "parentIndex" && mark.parent && mark.parent.parent && mark.parent.parent.parent && mark.parent.parent.parent.hasOwnProperty("parentIndex"))
                    target = mark.parent.parent.parent
            } catch (e$11) {}
            if (target != null) {
                var tmp = target[prop]();
                if (Array.isArray(tmp))
                    return tmp[idx] == null ? idx : tmp[idx];
                else if (typeof tmp === "function") {
                    var res = tmp.call(mark, d);
                    return res == null ? idx : res
                }
            }
            return idx
        }
    }
    var seriesIndexHandler = typeHandler("seriesIndex");
    var parentIndexHandler = typeHandler("parentIndex");
    tdgchart.prototype.addExceptionalProperty = function addExceptionalProperty(property, value, s, g, r, c, a, p) {
        var chart = this;
        var ids = toIDs(s, g, r, c, a, p);
        tdg.set(property, value, ids);
        var seriesInfo = chart.cache.get("internalSeriesInfo", {
            exceptionalSeries: []
        });
        seriesInfo.exceptionalSeries.push(ids)
    }
    ;
    tdgchart.prototype.flattenSeriesArray = function flattenSeriesArray() {
        var chart = this;
        var seriesInfo = {
            defaultSeries: null,
            series: [],
            exceptionalSeries: []
        };
        for (var i = 0, len = chart.series.length; i < len; i++) {
            var series = chart.series[i];
            if (series.series === "all")
                seriesInfo.defaultSeries = series;
            else if (series.series != null && series.group == null && series.axis == null && series.col == null && series.row == null && series.page == null)
                seriesInfo.series[series.series] = series;
            else
                seriesInfo.exceptionalSeries.push(series)
        }
        chart.cache.set("internalSeriesInfo", seriesInfo)
    }
    ;
    function cycleSeries(chart, seriesID) {
        var seriesRepetitions;
        var seriesWithColor = chart.series.filter(function(el) {
            return typeof el.series === "number" && el.group == null && el.color != null
        });
        var maxSeries = seriesWithColor.length;
        var targetSeries = seriesWithColor[seriesID % maxSeries];
        function lightenColor(color) {
            var hsl = color.hsl();
            var dx = (chart.riserCycleEndLightness - hsl.l) / seriesRepetitions;
            var mx = Math.floor(seriesID / maxSeries);
            hsl.l += dx * mx;
            return hsl.rgb().toString()
        }
        if (targetSeries != null && targetSeries.color != null) {
            var seriesCount = chart.getColorMode() === "byGroup" ? chart.groupCount() : chart.seriesCount();
            if (chart.chartType === "pie" && chart.pieDrillDataStack)
                seriesCount = chart.pieDrillDataStack[0][0].length;
            seriesRepetitions = Math.max(1, Math.ceil(seriesCount / maxSeries) - 1);
            var color = tdg.color(targetSeries.color);
            if (tdg.color.isGradient(color)) {
                color.stops.forEach(function(el) {
                    el[1] = lightenColor(tdg.color(el[1]))
                });
                return color
            } else
                return lightenColor(color)
        }
        return "black"
    }
    tdgchart.prototype.getRiserColor = function(seriesId, groupId) {
        return this.getSerDepProperty("color", {
            series: seriesId,
            group: groupId
        })
    }
    ;
    tdgchart.prototype.setSeriesColors = function() {
        var i, len, aSeries, sAllColor;
        var chart = this;
        var sColors = [];
        aSeries = chart.getSeries("all");
        if (aSeries && aSeries.color)
            sAllColor = aSeries.color;
        for (i = 0,
        len = chart.series.length; i < len; ++i) {
            aSeries = chart.series[i];
            if (aSeries.series != null && aSeries.series !== "all" && aSeries.color === undefined && aSeries.label !== undefined)
                sColors[sColors.length] = {
                    "sidx": i,
                    "color": sAllColor === undefined ? chart.getRiserColor(aSeries.series, aSeries.group) : sAllColor
                }
        }
        for (i = 0,
        len = sColors.length; i < len; ++i)
            chart.series[sColors[i].sidx].color = sColors[i].color
    }
    ;
    tdgchart.prototype.seriesPropertyLookup = function(property, defaultValue, expandCallbacks) {
        var chart = this;
        return function lookup(d) {
            var res;
            if (chart.chartType === "pie")
                if (d != null && (d.hasOwnProperty("isOtherSlice") || d === chart.pieProperties.otherSlice.legendLabel)) {
                    var other = chart.pieProperties.otherSlice;
                    res = tdg.get(property, other) || chart.getSeriesAndGroupProperty(null, null, property);
                    if (typeof res === "function" && expandCallbacks)
                        res = res.call(chart, d, null, null);
                    return res
                }
            var ids = chart.getMarkSeriesAndGroupID(this, d);
            res = chart.getSerDepProperty(property, ids);
            if (typeof res === "function" && expandCallbacks)
                res = res.call(chart, d, ids.series, ids.group);
            return res == null && defaultValue != null ? defaultValue : res
        }
    }
    ;
    function toIDs(s, g, r, c, a, p) {
        var ids = s || {};
        if (s != null && typeof s !== "object")
            ids = {
                group: g,
                axis: a,
                row: r,
                col: c,
                series: s,
                page: p
            };
        if (ids.hasOwnProperty("_s") && ids.hasOwnProperty("_g"))
            ids = {
                group: ids._g,
                axis: ids._axis,
                row: ids._r,
                col: ids._c,
                series: ids._s
            };
        return ids
    }
    function matchRule(series, ids) {
        var matchedRules = [];
        var idList = ["group", "axis", "row", "col", "series"];
        for (var i = 0; i < idList.length; i++) {
            var s = idList[i];
            if (series[s] != null && series[s] !== ids[s])
                return null;
            else if (series[s] != null && series[s] === ids[s])
                matchedRules.push(s)
        }
        return matchedRules
    }
    function findBestRule(rules, ids, property) {
        rules = (rules || []).filter(function(el) {
            return tdg.get(property, el) != null
        });
        var i, match, matches = [];
        for (i = 0; i < rules.length; i++) {
            var test = matchRule(rules[i], ids);
            if (test != null)
                matches.push({
                    rules: test,
                    series: rules[i]
                })
        }
        if (matches.length > 1) {
            var maxMatchCount = 0, matchedRules;
            for (i = 0; i < matches.length; i++) {
                match = matches[i];
                if (match.rules.length > maxMatchCount) {
                    maxMatchCount = match.rules.length;
                    matchedRules = [match]
                } else if (match.rules.length === maxMatchCount)
                    matchedRules.push(match)
            }
            matches = matchedRules
        }
        if (matches.length > 1) {
            var matchByID = {
                group: [],
                axis: [],
                row: [],
                col: [],
                series: [],
                page: []
            };
            for (i = 0; i < matches.length; i++) {
                match = matches[i];
                for (var r = 0; r < match.rules.length; r++) {
                    var rule = match.rules[r];
                    if (matchByID.hasOwnProperty(rule))
                        matchByID[rule].push(match)
                }
            }
            var idList = ["group", "axis", "row", "col", "series", "page"];
            for (i = 0; i < idList.length; i++) {
                var id = idList[i];
                if (matchByID[id].length === 1) {
                    matches = matchByID[id];
                    break
                }
            }
        }
        if (matches.length > 1)
            matches = [matches[matches.length - 1]];
        if (matches.length === 1)
            return tdg.get(property, matches[0].series);
        return null
    }
    tdgchart.prototype.getExceptionalSerDepProperty = function(property, s, g, r, c, a, p) {
        var chart = this;
        var exceptionalInfo = chart.cache.get("internalSeriesInfo", {}).exceptionalSeries;
        if (!exceptionalInfo || !exceptionalInfo.length)
            return null;
        var ids = toIDs(s, g, r, c, a, p);
        var rule = findBestRule(exceptionalInfo, ids, property);
        return rule == null ? null : rule
    }
    ;
    tdgchart.prototype.getSerDepProperty = function(property, s, g, r, c, a, p) {
        var chart = this;
        var ids = toIDs(s, g, r, c, a, p);
        var prop, seriesInfo = chart.cache.get("internalSeriesInfo", {
            exceptionalSeries: [],
            series: []
        });
        var rule = findBestRule(seriesInfo.exceptionalSeries, ids, property);
        if (rule != null)
            return rule;
        var target = seriesInfo.series[ids.series];
        if (target) {
            prop = tdg.get(property, target);
            if (prop != null)
                return prop
        }
        if (seriesInfo.defaultSeries) {
            prop = tdg.get(property, seriesInfo.defaultSeries);
            if (prop != null)
                return prop
        }
        if (property === "color")
            return cycleSeries(chart, ids.series);
        else if (property === "marker.size")
            return 8;
        else if (property === "border.width")
            return 1;
        return null
    }
    ;
    tdgchart.prototype.getSeriesAndGroupProperty = function(s, g, property, axisName) {
        return this.getSerDepProperty(property, s, g, null, null, axisName)
    }
    ;
    tdgchart.prototype.getSeriesProperty = function(prop) {
        var res = []
          , chart = this;
        for (var i = 0; i < chart.series.length; i++)
            res.push(tdg.get(prop, chart.series[i]));
        return res
    }
    ;
    tdgchart.prototype.getSeriesPropertyList = function(prop, defaultValue) {
        var chart = this, i, res = [], count = 0;
        for (i = 0; i < chart.series.length; i++)
            if (chart.series[i].series != null && chart.series[i].series !== "all" && chart.series[i].group == null)
                count += 1;
        count = Math.max(chart.seriesCount(chart.data), count);
        for (i = 0; i < count; i++) {
            var p = chart.getSeriesAndGroupProperty(i, null, prop);
            res.push(p == null ? defaultValue : p)
        }
        return res
    }
    ;
    tdgchart.prototype.seriesColorLookup = function(panelSize) {
        var chart = this;
        var colorMode = chart.doSeriesColorMode(panelSize);
        var defaultLookup = colorMode || chart.seriesPropertyLookup("color", null, true);
        if (chart.colorScale && chart.cache.hasKey("colorAxis"))
            return colorByDataLookup(chart, defaultLookup);
        return defaultLookup
    }
    ;
    function colorByDataLookup(chart, defaultLookup) {
        var cs = chart.cache.get("colorAxis", {});
        return function(d, data) {
            if (d != null && d[cs.odata_key] != null)
                return cs.scale(d[cs.odata_key]);
            else if (!cs.nullval_draws_nothing)
                return defaultLookup.call(this, d, data);
            return null
        }
    }
    tdgchart.prototype.seriesToolTipLookup = function() {
        var chart = this;
        var lookup = this.seriesPropertyLookup("tooltip");
        return function(d, data) {
            var mark = this;
            var res = lookup.call(mark, d);
            var ids = chart.getMarkSeriesAndGroupID(mark, d);
            return chart.resolveToolTipSeriesContent(res, d, data, ids)
        }
    }
    ;
    tdgchart.prototype.getSeries = function(index) {
        for (var i = this.series.length - 1; i >= 0; i--) {
            var s = this.series[i];
            if (s != null && s.series === index && (s.group == null || s.group < 0) && s.axis == null && s.row == null && s.col == null && s.page == null)
                return s
        }
        return null
    }
    ;
    tdgchart.prototype.getDefaultSeries = function() {
        return this.getSeries("all")
    }
    ;
    tdgchart.prototype.getSeriesAndGroup = function(series, group) {
        for (var i = this.series.length - 1; i >= 0; i--)
            if (this.series[i].series === series && this.series[i].group === group)
                return this.series[i];
        return null
    }
    ;
    tdgchart.prototype.markerRotationLookup = function() {
        var lookup = this.seriesPropertyLookup("marker.rotation");
        return function(d) {
            return tdg.radians(lookup.call(this, d))
        }
    }
    ;
    tdgchart.prototype.markerSizeLookup = function() {
        var lookup = this.seriesPropertyLookup("marker.size");
        return function(d) {
            return lookup.call(this, d) / 2
        }
    }
    ;
    tdgchart.prototype.markerFillStyle = function() {
        var chart = this;
        var riserLookup = chart.seriesPropertyLookup("riserShape");
        var fillEffectLookup = chart.seriesPropertyLookup("marker.fillEffect");
        var markerFillLookup = chart.seriesPropertyLookup("marker.color");
        var colorLookup = chart.seriesColorLookup();
        var colorMode = this.doSeriesColorMode();
        if (colorMode)
            return colorMode;
        return function _markerFillStyle(d) {
            var color, fillEffect = fillEffectLookup.call(this, d);
            if (tdg.isPercentString(fillEffect) && !fillEffect.includes("gradient")) {
                color = colorLookup.call(this, d) || "white";
                var lerp = tdg.parsePercent(fillEffect, -1);
                return tdg.color(color).alpha(lerp)
            }
            if (fillEffect === "seriesAuto") {
                var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
                var riserShape = riserLookup.call(this, d) || chartType;
                switch (riserShape) {
                case "line":
                    fillEffect = "seriesWhite";
                    break;
                case "scatter":
                case "radar":
                    fillEffect = "seriesHollow";
                    break;
                case "map":
                case "bubble":
                case "polar":
                    fillEffect = "seriesLighten";
                    break;
                case "pictogram":
                    fillEffect = null;
                    break;
                default:
                    fillEffect = "seriesFill";
                    break
                }
            }
            switch (fillEffect) {
            case "seriesHollow":
                return "rgba(255, 255, 255, 0.0001)";
            case "seriesFill":
                return colorLookup.call(this, d);
            case "seriesWhite":
                return "white";
            case "seriesLighten":
                color = colorLookup.call(this, d) || "white";
                return tdg.color(color).alpha(.6);
            case "seriesLightenOpaque":
                color = colorLookup.call(this, d) || "white";
                return tdg.color(color).lighter(.3)
            }
            return markerFillLookup.call(this, d) || colorLookup.call(this, d)
        }
    }
    ;
    tdgchart.prototype.markerStrokeStyle = function() {
        var chart = this;
        var markerBorderLookup = chart.seriesPropertyLookup("marker.border.color");
        var colorLookup = chart.seriesColorLookup();
        return function markerStrokeLookup(d) {
            if (tdg.isEmpty(d))
                d = {
                    _s: null,
                    _g: null
                };
            var fillEffect = chart.getSeriesAndGroupFillEffect(d._s, d._g);
            switch (fillEffect) {
            case "seriesHollow":
            case "seriesWhite":
            case "seriesLighten":
            case "seriesLightenOpaque":
                return colorLookup.call(this, d);
            case "seriesFill":
                return "transparent"
            }
            return markerBorderLookup.call(this, d)
        }
    }
    ;
    tdgchart.prototype.getSeriesAndGroupFillEffect = function(s, g) {
        var chart = this;
        var fillEffect = chart.getSeriesAndGroupProperty(s, g, "marker.fillEffect");
        if (fillEffect === "seriesAuto")
            if (chart.chartType === "bubble" || chart.chartType === "matrix" && chart.matrixProperties.chartType === "bubble")
                fillEffect = "seriesFill";
            else
                fillEffect = "seriesHollow";
        return fillEffect
    }
    ;
    tdgchart.prototype.getSeriesAndGroupMarkerStrokeStyle = function(s, g) {
        var chart = this;
        var fillEffect = chart.getSeriesAndGroupFillEffect(s, g);
        if (fillEffect === "seriesFill")
            return "transparent";
        else if (fillEffect === "seriesHollow" || fillEffect === "seriesWhite" || fillEffect === "seriesLighten" || fillEffect === "seriesLightenOpaque")
            return chart.getSeriesAndGroupProperty(s, g, "color");
        return chart.getSeriesAndGroupProperty(s, g, "marker.border.color")
    }
    ;
    tdgchart.prototype.dataLabelVisibleLookup = function() {
        var chart = this;
        var lookup = chart.seriesPropertyLookup("dataLabels.visible");
        return function(d) {
            var anchor = this.anchorTarget();
            if (anchor && !anchor.visible())
                return false;
            else if (d && d.noLabel)
                return false;
            return lookup.call(this, d)
        }
    }
    ;
    function setProperty(target, prop, value) {
        prop = prop.split(".");
        for (var i = 0; i < prop.length - 1; i++) {
            if (!target.hasOwnProperty(prop[i]))
                target[prop[i]] = {};
            target = target[prop[i]]
        }
        target[prop[prop.length - 1]] = value
    }
    tdgchart.prototype.setSeriesProperty = function(prop, propValue, cache) {
        var chart = this;
        if (Array.isArray(propValue))
            for (var i = 0, len = propValue.length; i < len; i++) {
                var s = chart.getSeries(i);
                if (s == null) {
                    s = {
                        series: i
                    };
                    chart.series.push(s)
                }
                if (cache) {
                    var sIdx = chart.series.indexOf(s);
                    chart.cache.setProperty("series[" + sIdx + "]." + prop, propValue[i])
                } else
                    setProperty(s, prop, propValue[i])
            }
        else
            chart.series.map(function(el, i) {
                if (cache)
                    chart.cache.setProperty("series[" + i + "]." + prop, propValue);
                else
                    setProperty(el, prop, propValue)
            })
    }
    ;
    tdgchart.prototype.setSeriesLabels = function(labels, cache) {
        return this.setSeriesProperty("label", labels, cache)
    }
    ;
    tdgchart.prototype.getMarkSeriesAndGroupID = function(mark, d) {
        var chart = this;
        if (mark === window)
            mark = null;
        d = d || (mark ? mark.data() : {}) || {};
        var seriesID = d._s;
        var groupID = d._g;
        if (seriesID == null && mark && mark.parent)
            seriesID = seriesIndexHandler(mark, mark.parent.index, d);
        seriesID = seriesID || 0;
        if (groupID == null && mark)
            groupID = parentIndexHandler(mark, mark.index, d);
        if (chart.chartType === "pie" && !tdg.isEmpty(chart.pieDrillSeriesMap)) {
            seriesID = chart.pieDrillSeriesMap[chart.pieDrillSeriesMap.length - 1][seriesID];
            if (seriesID == null && d != null && d.hasOwnProperty("isOtherSlice"))
                seriesID = chart.pieDrillDataStack[chart.pieDrillDataStack.length - 1].length
        }
        if (chart.cache.hasKey("treemapSeriesMap"))
            seriesID = chart.cache.get("treemapSeriesMap")[seriesID];
        var ids = {
            series: seriesID,
            group: groupID
        };
        if (chart.chartType === "matrix") {
            ids.row = d._r == null ? traverseParent(mark, "row") : d._r;
            ids.col = d._c == null ? traverseParent(mark, "col") : d._c
        }
        if (d._axis != null)
            ids.axis = d._axis;
        return ids
    }
    ;
    function traverseParent(node, key) {
        while (node && node.parent && node !== window) {
            if (node.parent[key] != null)
                return node.parent[key];
            node = node.parent
        }
        return null
    }
    tdgchart.prototype.classNameLookup = function(misc, obj, axisName) {
        obj = obj || "series";
        var chart = this;
        return function(d) {
            var o = obj;
            var ids = chart.getMarkSeriesAndGroupID(this, d);
            var mRow, mCol;
            if (chart.chartType === "matrix") {
                mRow = traverseParent(this, "row");
                mCol = traverseParent(this, "col")
            }
            if (chart._isChartSlider)
                o = "slider-" + o;
            return chart.buildClassName(o, ids.series, ids.group, misc, mRow, mCol, axisName)
        }
    }
    ;
    tdgchart.prototype.getMatrixRowCol = function(node) {
        var rowCol = {};
        if (this.chartType !== "matrix")
            return rowCol;
        while (node && node !== window) {
            if (node.row != null || node.col != null) {
                rowCol = {
                    row: node.row,
                    col: node.col
                };
                if (node.datarow != null || node.datacol != null) {
                    rowCol.datarow = node.datarow;
                    rowCol.datacol = node.datacol
                }
                break
            }
            node = node.parent
        }
        return rowCol
    }
    ;
    tdgchart.prototype.getRiserClassName = function(node, d, obj, misc, axisName) {
        var chart = this;
        var rowCol = chart.getMatrixRowCol(node);
        if (chart._isChartSlider)
            obj = "slider-" + (obj || "");
        return chart.buildClassName(obj, d._s, d._g, misc, rowCol.row, rowCol.col, axisName, rowCol.datarow, rowCol.datacol)
    }
    ;
    tdgchart.buildClassName = tdgchart.prototype.buildClassName = function(obj, s, g, m, r, c, a, dr, dc) {
        if (obj && typeof obj === "object" && s == null && g == null && m == null && r == null && c == null && a == null) {
            s = obj.series;
            g = obj.group;
            m = obj.misc;
            r = obj.row;
            c = obj.col;
            e = obj.datarow;
            d = obj.datacol;
            a = obj.axis;
            obj = obj.object || null
        }
        var res = obj + "!";
        if (s != null && s >= 0)
            res += "s" + s + "!";
        if (g != null && g >= 0)
            res += "g" + g + "!";
        if (a != null)
            res += "a" + a + "!";
        if (m != null)
            res += "m" + m + "!";
        if (r != null && r >= 0)
            res += "r" + r + "!";
        if (c != null && c >= 0)
            res += "c" + c + "!";
        if (dr != null && dr >= 0)
            res += "d" + dr + "!";
        if (dc != null && dc >= 0)
            res += "e" + dc + "!";
        return res
    }
    ;
    tdgchart.prototype.classNameToIds = function(className) {
        var chart = this;
        if (className && typeof className === "object" && className.getAttribute)
            className = className.getAttribute("class");
        className = className || "";
        var items = className.split("!");
        var res = {
            object: items[0],
            series: null,
            group: null,
            misc: null,
            row: null,
            col: null,
            axis: null
        };
        function getNumber(val) {
            var res = parseInt(val, 10);
            return isNaN(res) ? val : res
        }
        for (var i = 1; i < items.length; i++) {
            var s = items[i].slice(1);
            s = chart.chartType === "treemap" ? s : getNumber(s);
            switch (items[i].charAt(0)) {
            case "s":
                res.series = s;
                break;
            case "g":
                res.group = s;
                break;
            case "m":
                res.misc = s;
                break;
            case "r":
                res.row = s;
                break;
            case "c":
                res.col = s;
                break;
            case "a":
                res.axis = s;
                break
            }
        }
        if (chart.cache.get("matrixFacetCols") && res.row != null && res.col != null) {
            res.datarow = 0;
            res.datacol = res.col + res.row * chart.cache.get("matrixFacetCols")
        }
        return res
    }
    ;
    tdgchart.prototype.transposeIDs = function(data, groupOffset) {
        groupOffset = groupOffset || 0;
        data.forEach(function(el) {
            el.forEach(function(a) {
                var tmp = a._s;
                a._s = a._g + groupOffset;
                a._g = tmp
            })
        })
    }
    ;
    tdgchart.prototype.getShowNullSeries = function(data) {
        var chart = this;
        if (chart.showNullSeries !== false)
            return undefined;
        var chartCompressible = ["bar", "line", "area", "waterfall", "heatmap", "streamgraph", "pictogram"].includes(chart.chartType);
        if (chart.chartType === "matrix")
            ;if (!chartCompressible)
            return undefined;
        var field = chart.getDefaultDataField() || "value";
        var hideSeries = [];
        for (var i = 0; i < data.length; i++) {
            var s = chart.getSeries(i);
            if (s && s.hasOwnProperty("visible") && s.visible === false)
                continue;
            var exclude = true;
            for (var j = 0; j < data[i].length; j++) {
                var value = data[i][j] && data[i][j].hasOwnProperty(field) ? data[i][j][field] : data[i][j];
                if (value != null) {
                    exclude = false;
                    break
                }
            }
            if (exclude)
                hideSeries[i] = true
        }
        return hideSeries
    }
    ;
    tdgchart.prototype.trimInvisibleSeries = function(data, hideSeries) {
        var chart = this;
        var newData = []
          , seriesMap = [];
        data = data || chart.data;
        var i, j, len, r, c;
        var sc = chart.seriesCount();
        var haveInvisibleSeries = false;
        for (i = 0; i < sc; i++) {
            var s = chart.getSeries(i);
            if (hideSeries && hideSeries[i])
                haveInvisibleSeries = true;
            else if (s && s.hasOwnProperty("visible") && !s.visible)
                haveInvisibleSeries = true;
            else
                seriesMap.push(i)
        }
        if (!haveInvisibleSeries)
            return {
                data: data,
                seriesMap: seriesMap
            };
        if (chart.chartType === "matrix") {
            var matrixType = chart.matrixProperties.chartType;
            if (matrixType === "pie" || matrixType === "gauge" || matrixType === "funnel")
                for (r = 0; r < data.length; r++) {
                    newData[r] = [];
                    for (c = 0; c < data[r].length; c++) {
                        newData[r][c] = [];
                        for (i = 0,
                        len = data[r][c].length; i < len; i++) {
                            newData[r][c][i] = [];
                            for (j = 0; j < data[r][c][i].length; j++)
                                if (seriesMap.indexOf(j) >= 0)
                                    newData[r][c][i].push(data[r][c][i][j])
                        }
                    }
                }
            else
                for (r = 0; r < data.length; r++) {
                    newData[r] = [];
                    for (c = 0; c < data[r].length; c++) {
                        newData[r][c] = [];
                        for (i = 0,
                        len = data[r][c].length; i < len; i++)
                            if (seriesMap.indexOf(i) >= 0)
                                newData[r][c].push(data[r][c][i])
                    }
                }
        } else if (chart.chartType === "pie" || chart.chartType === "gauge" || chart.chartType === "funnel")
            for (i = 0,
            len = data.length; i < len; i++) {
                newData[i] = [];
                for (j = 0; j < data[i].length; j++)
                    if (seriesMap.indexOf(j) >= 0)
                        newData[i].push(data[i][j])
            }
        else
            for (i = 0,
            len = data.length; i < len; i++)
                if (seriesMap.indexOf(i) >= 0)
                    newData.push(data[i]);
        return {
            data: newData,
            seriesMap: seriesMap
        }
    }
}
)();
(function() {
    tdgchart.prototype.formatNumber = formatNumber;
    tdgchart.setDecimalSeparator = tdgchart.prototype.setDecimalSeparator = setDecimalSeparator;
    tdgchart.setThousandSeparator = tdgchart.prototype.setThousandSeparator = setThousandSeparator;
    tdgchart.getDecimalCharToReplaceWithQuote = tdgchart.prototype.getDecimalCharToReplaceWithQuote = getDecimalCharToReplaceWithQuote;
    tdgchart.getThousandCharToReplaceWithQuote = tdgchart.prototype.getThousandCharToReplaceWithQuote = getThousandCharToReplaceWithQuote;
    tdgchart.numberFormatter = {};
    var cdnDecimalSep;
    var cdnThousandSep;
    var cdnReplaceDecimalQuote = false;
    var cdnReplaceThousandQuote = false;
    var cdnDecimalCharToReplaceWithQuote = "~";
    var cdnThousandCharToReplaceWithQuote = "@";
    function shouldTrimZeroes() {
        return cdnThousandSep !== "."
    }
    function trimLeadingThousSep(fmt) {
        if (cdnThousandSep != null && fmt[0] === cdnThousandSep)
            fmt = fmt.substring(1, fmt.length);
        return fmt
    }
    function setDecimalSeparator(decimalSep) {
        cdnDecimalSep = decimalSep;
        if (decimalSep === cdnDecimalCharToReplaceWithQuote)
            cdnReplaceDecimalQuote = true
    }
    function setThousandSeparator(thousandSep) {
        cdnThousandSep = thousandSep;
        if (thousandSep === cdnThousandCharToReplaceWithQuote)
            cdnReplaceThousandQuote = true
    }
    function getDecimalCharToReplaceWithQuote() {
        return cdnDecimalCharToReplaceWithQuote
    }
    function getThousandCharToReplaceWithQuote() {
        return cdnThousandCharToReplaceWithQuote
    }

    /**
     * 数値を指定されたフォーマットに従ってフォーマットします。
     *
     * @param {number|string|null} n - フォーマットする数値。nullの場合はnullRepresentationを返します。
     * @param {string|function|object|null} format - フォーマット指定。文字列、関数、またはオブジェクトが使用できます。
     * @param {object} config - フォーマットに必要な追加設定。
     * @param {boolean} applyLangTable - 言語テーブルを適用するかどうか。
     * @returns {string} フォーマットされた数値の文字列。
     */
    function formatNumber(n, format, config, applyLangTable) {
        var chart = this;
        if (n == null)
            return chart ? chart.nullRepresentation || "" : "";
        else if (typeof n === "string" && isNaN(parseFloat(n)))
            return n;
        if (format == null)
            return n + "";
        if (typeof format === "function")
            return format(n);
        var grouping = typeof format.mode === "string" && format.grouping;
        var formatString = typeof format === "string" ? format : typeof format.mode === "string" ? format.mode : undefined;
        var isMetadata = formatString && formatString.toLowerCase() === "metadata";
        if (isMetadata)
            format = resolveMetadataFormat(chart, format, config.bucketID, config.ids, grouping);
        else if (formatString && grouping === "auto")
            format = resolveGrouping(formatString, grouping);
        if (chart.pfjParser && chart.pfjParser.permanentState && chart.pfjParser.permanentState.postOriginalCurrencySymbol != null && chart.pfjParser.permanentState.postCurrencySymbolOverride != null && typeof format === "string" && format.includes(chart.pfjParser.permanentState.postOriginalCurrencySymbol)) {
            var newSymbol = chart.pfjParser.permanentState.postCurrencySymbolOverride;
            var originalSymbol = chart.pfjParser.permanentState.postOriginalCurrencySymbol;
            if (originalSymbol.includes("$"))
                originalSymbol = originalSymbol.replace(/\$/g, "\\$");
            format = format.replace(new RegExp(originalSymbol,"g"), newSymbol)
        }
        if (typeof format === "string" && format.toLowerCase().indexOf("auto") >= 0)
            return autoFormatNumber(chart, n, format, config);
        if (typeof format === "object")
            format = objToStr(format);
        var res = tdgchart.numberFormatter.formatFromString(n, format);
        if (applyLangTable)
            return numericFormatLocaleSubstitution(chart, res);
        return res
    }
    function autoFormatNumber(chart, n, format, config) {
        if (!config)
            return n + "";
        var localFormat = format;
        if (config)
            if (typeof config === "object" && (config.object === "axis" || config.object == null))
                localFormat = autoFormatAxis(chart, n, config);
            else {
                if (config.hasOwnProperty("object"))
                    config = config.object;
                if (chart.autoNumberFormats && chart.autoNumberFormats[config])
                    localFormat = chart.autoNumberFormats[config];
                else
                    localFormat = "[<=-100000000000000]-#,,,,T;[<=-10000000000000]-#,,,,.#T;[<=-1000000000000]-#,,,,.##T;[<=-100000000000]-#,,,B;[<=-10000000000]-#,,,.#B;[<=-1000000000]-#,,,.##B;[<=-100000000]-#,,M;[<=-10000000]-#,,.#M;[<=-1000000]-#,,.##M;[<=-100000]-#,K;[<=-100]-#,#;[<=-10]-#.#;[<=-1]-#.##;[<0]-#.###;[=0]#;[<1]#.###;[<10]#.##;[<100]#.#;[<100000]#,#;[<1000000]#,K;[<10000000]#,,.##M;[<100000000]#,,.#M;[<1000000000]#,,M;[<10000000000]#,,,.##B;[<100000000000]#,,,.#B;[<1000000000000]#,,,B;[<10000000000000]#,,,,.##T;[<100000000000000]#,,,,.#T;[<1000000000000000]#,,,,T;#,,,,T"
            }
        var res = chart.formatNumber(n, localFormat);
        if (shouldTrimZeroes())
            if (res.indexOf(".") >= 0) {
                res = res.replace(/0*$/, "");
                if (res.charAt(res.length - 1) === ".")
                    res = res.substr(0, res.length - 1)
            }
        res = trimLeadingThousSep(res);
        if (cdnReplaceDecimalQuote) {
            var charDecimalQuoteReplace = tdgchart.getDecimalCharToReplaceWithQuote();
            res = res.replace(charDecimalQuoteReplace, "'")
        }
        if (cdnReplaceThousandQuote) {
            var charThousandQuoteReplace = tdgchart.getThousandCharToReplaceWithQuote();
            var regEx = new RegExp(charThousandQuoteReplace,"g");
            res = res.replace(regEx, "'")
        }
        var includesAuto = format.toLowerCase().indexOf("{{auto}}");
        var includesAutoNT = includesAuto == -1 ? format.toLowerCase().indexOf("{{autont}}") : -1;
        if (includesAuto != -1 || includesAutoNT != -1) {
            if (format.includes(";")) {
                var formatList = format.split(";");
                if (n > 0)
                    format = formatList[0];
                else if (n < 0) {
                    format = formatList[1];
                    if (res.startsWith("-"))
                        res = res.slice(1)
                } else if (Math.abs(n) < 1E-4)
                    format = formatList.length > 2 ? formatList[2] : formatList[0]
            }
            var idx = includesAuto != -1 ? includesAuto : includesAutoNT;
            var prepend = format.substr(0, idx);
            var postpend = format.substr(idx + (includesAuto != -1 ? 8 : 10), format.length - 1);
            res = prepend + res + postpend;
            if (includesAutoNT != -1)
                return res
        }
        return numericFormatLocaleSubstitution(chart, res)
    }
    function numericFormatLocaleSubstitution(chart, n) {
        if (chart.locale)
            return applyLocale(n, tdgchart.getLocaleLookup(chart.locale));
        else
            return applyLocale(n, tdgchart.getTranslationLocaleLookup())
    }
    function applyLocale(n, locale) {
        var res = n;
        res = res.replace(/(\b|[^a-zA-Z]+)([KMBT])(\b|[^a-zA-Z])/g, function(match, m1, m2, m3) {
            var ending_backticks = m1.match(/`*$/)[0].length;
            if (ending_backticks % 2 != 0)
                return m1 + (m2 || "") + m3;
            return m1 + (locale[m2] || "") + m3
        });
        res = res.replace(/`(.)/g, "$1");
        return res
    }
    function autoFormatAxis(chart, n, config) {
        config = config || {};
        if (config.isPercent)
            return "#`%";
        var format = {
            mode: "numeric",
            thousandSep: "",
            decimalSep: ".",
            decimalPlaces: 3,
            grouping: "",
            prefix: "",
            suffix: "",
            zero: "0"
        };
        if (cdnDecimalSep != null)
            format.decimalSep = cdnDecimalSep;
        if (cdnThousandSep != null)
            format.thousandSep = cdnThousandSep;
        var range = Math.abs(config.max - config.min);
        var compress = 1;
        var lower = !config.invert ? config.min : config.max;
        if (range >= 1E15)
            format.mode = "scientific";
        else if (range > 1E12 && (!config.islog || lower >= 1E11)) {
            format.grouping = "T";
            compress = 1E12
        } else if (range > 1E9 && (!config.islog || lower >= 1E8)) {
            format.grouping = "B";
            compress = 1E9
        } else if (range > 1E6 && (!config.islog || lower >= 1E5)) {
            format.grouping = "M";
            compress = 1E6
        } else if (range > 1E4 && (!config.islog || lower >= 100)) {
            format.grouping = "K";
            compress = 1E3
        }
        if (config.islog)
            if (n < compress / 100)
                format.decimalPlaces = 3;
            else if (n < compress / 10)
                format.decimalPlaces = 2;
            else if (n < compress)
                format.decimalPlaces = 1;
            else if (Math.abs(Math.round(n / compress) - n / compress) < .1)
                format.decimalPlaces = 0;
            else
                format.decimalPlaces = 1;
        else {
            if (Math.abs(Math.round(n / compress) - n / compress) < .1)
                format.decimalPlaces = 0;
            else
                format.decimalPlaces = 1;
            var x = Math.abs(Math.round(n / compress) - n / compress);
            var x100 = Math.round(x * 100) / 100;
            if (x100 < .1)
                format.decimalPlaces = 0;
            else
                format.decimalPlaces = 1
        }
        if (range > 0 && range < 1)
            format.decimalPlaces = Math.min(10, Math.floor(-Math.log10(range)) + 3);
        return objToStr(format)
    }
    var groupingCounts = {
        K: 1,
        M: 2,
        B: 3,
        T: 4
    };
    function objToStr(format) {
        var s = "";
        var sepIdx = 0;
        if (format.thousandSep) {
            s += "{t" + (format.thousandSep.charAt(0) === ";" ? "," : format.thousandSep.charAt(0)) + "}";
            sepIdx = s.length
        }
        if (format.decimalSep) {
            s += "{d" + (format.decimalSep.charAt(0) === ";" ? "." : format.decimalSep.charAt(0)) + "}";
            sepIdx = s.length
        }
        if (format.prefix)
            s += format.prefix;
        if (typeof format.mode === "undefined" || ["numeric", "currency", "scientific", "percent"].indexOf(format.mode) < 0)
            format.mode = "numeric";
        if (format.mode === "currency")
            s += "$";
        if (format.thousandSep !== "")
            s += "#,#";
        else
            s += "#";
        if (format.grouping)
            s += tdgchart.numberFormatter.repeatString(",", groupingCounts[format.grouping]);
        if (format.decimalPlaces && format.mode !== "scientific")
            s += "." + tdgchart.numberFormatter.repeatString("#", Math.max(0, Math.min(20, format.decimalPlaces)));
        else if (format.mode === "currency" && typeof format.decimalPlaces === "undefined")
            s += ".##";
        if (format.mode === "scientific") {
            var decimals = typeof format.decimalPlaces === "undefined" ? 2 : Math.max(0, Math.min(20, format.decimalPlaces));
            s += "0." + tdgchart.numberFormatter.repeatString("0", decimals) + "E+00"
        }
        if (format.grouping)
            s += format.grouping;
        if (format.mode === "percent") {
            if (s === "")
                s += "#";
            s += "%"
        }
        if (format.suffix)
            s += format.suffix;
        s = "[<0]" + s.substr(0, sepIdx) + "-" + s.substr(sepIdx) + ";" + s;
        if (format.zero) {
            s = s.split(";");
            s = s[0] + ";[=0]" + format.zero + ";" + s[1]
        }
        return s
    }
    var formatFunctions = {
        count: 0
    };
    var conditionRE = /\[(>=|<=|=|>|<)([0-9.-]+)\]/;
    tdgchart.numberFormatter.formatFromString = function(n, format, context) {
        if (isNaN(n) || n == null)
            return "NaN";
        else if (n === +Infinity)
            return "Infinity";
        else if (n === -Infinity)
            return "-Infinity";
        else if (formatFunctions[format] == null)
            createNewFormat(format);
        var fmt = tdgchart.numberFormatter[formatFunctions[format]].apply(n, [context]);
        if (cdnReplaceDecimalQuote) {
            var charDecimalQuoteReplace = tdgchart.getDecimalCharToReplaceWithQuote();
            fmt = fmt.replace(charDecimalQuoteReplace, "'")
        }
        if (cdnReplaceThousandQuote) {
            var charThousandQuoteReplace = tdgchart.getThousandCharToReplaceWithQuote();
            var regEx = new RegExp(charThousandQuoteReplace,"g");
            fmt = fmt.replace(regEx, "'")
        }
        return fmt
    }
    ;
    function createNewFormat(format) {
        var result;
        var funcName = "format" + formatFunctions.count++;
        formatFunctions[format] = funcName;
        var code = "tdgchart.numberFormatter." + funcName + " = function(context){\n";
        var formats = format.split(";");
        var equalConditionsCode = "";
        var otherConditionsCode = "";
        var rulesWithoutConditionsCount = 0;
        var defaultRuleFormat = "###.##";
        if (formats.length < 2 && format.match(conditionRE) == null)
            code += createTerminalFormat(format);
        else {
            for (var i = 0; formats[i]; i++) {
                format = formats[i];
                if ((result = format.match(conditionRE)) != null) {
                    var newFormat = format.replace(result[0], "");
                    if (result[1] === "=")
                        equalConditionsCode += createConditionCode(result[1], result[2], newFormat);
                    else
                        otherConditionsCode += createConditionCode(result[1], result[2], newFormat)
                } else {
                    switch (rulesWithoutConditionsCount) {
                    case 0:
                        defaultRuleFormat = format;
                        otherConditionsCode += createConditionCode(">=", 0, format);
                        break;
                    case 1:
                        otherConditionsCode += createConditionCode("<", 0, format);
                        break;
                    case 2:
                        equalConditionsCode += createConditionCode("=", 0, format);
                        break;
                    default:
                        equalConditionsCode = "throw 'Too many semicolons in format string';" + equalConditionsCode;
                        break
                    }
                    rulesWithoutConditionsCount++
                }
            }
            if (rulesWithoutConditionsCount === 1)
                otherConditionsCode += createConditionCode("<", 0, defaultRuleFormat);
            else if (rulesWithoutConditionsCount === 0)
                otherConditionsCode += createConditionCode("all", 0, defaultRuleFormat);
            code += equalConditionsCode + otherConditionsCode
        }
        code += "}";
        eval(code)
    }
    function createConditionCode(condition, conditionNumber, format) {
        var conditionStr = "";
        if (condition === "all")
            return "\nreturn tdgchart.numberFormatter.formatFromString(this, '" + tdgchart.numberFormatter.escapeString(format) + "', 1);";
        else {
            switch (condition) {
            case "=":
                conditionStr = "==";
                break;
            case ">":
                conditionStr = "> ";
                break;
            case "<":
                conditionStr = "< ";
                break;
            case ">=":
                conditionStr = ">=";
                break;
            case "<=":
                conditionStr = "<=";
                break;
            default:
                throw "Error! Unrecognized condition format!";
            }
            return "\n" + "if (this " + conditionStr + " " + parseFloat(conditionNumber, 10) + ") {" + "return tdgchart.numberFormatter.formatFromString(this, '" + tdgchart.numberFormatter.escapeString(format) + "', 1);" + "}"
        }
    }
    function createTerminalFormat(format) {
        if (format.length > 0 && format.search(/[0#?]/) === -1)
            return "return '" + tdgchart.numberFormatter.escapeString(format) + "';\n";
        var code = "var val = (context == null) ? new Number(this) : Math.abs(this);\n";
        var thousands = false;
        var rodp = "";
        var ldigits = 0;
        var rdigits = 0;
        var scidigits = 0;
        var scishowsign = false;
        var sciletter = "";
        var decimalChar = ".";
        var thousandChar = ",";
        if (cdnDecimalSep != null)
            decimalChar = cdnDecimalSep;
        if (cdnThousandSep != null)
            thousandChar = cdnThousandSep;
        var m = format.match(/\{t.\}/i);
        if (m) {
            thousandChar = m[0].charAt(2);
            format = format.replace(/\{t.\}/i, "")
        }
        m = format.match(/\{d.\}/i);
        if (m) {
            decimalChar = m[0].charAt(2);
            format = format.replace(/\{d.\}/i, "")
        }
        var lodp = format;
        m = format.match(/\..*(e)([+-]?)(0+)/i);
        if (m) {
            sciletter = m[1];
            scishowsign = m[2] === "+";
            scidigits = m[3].length;
            format = format.replace(/(e)([+-]?)(0+)/i, "")
        }
        m = format.match(/^([^.]*)\.(.*)$/);
        if (m) {
            lodp = m[1].replace(/\./g, "");
            rodp = m[2].replace(/\./g, "")
        }
        if (format.indexOf("%") >= 0)
            if (format.indexOf("`") !== format.indexOf("%") - 1)
                code += "val *= 100;\n";
            else {
                lodp = lodp.replace("`", "");
                rodp = rodp.replace("`", "")
            }
        m = lodp.match(/(,+)(?:$|[^0#?,])/);
        if (m)
            code += "val /= " + Math.pow(1E3, m[1].length) + ";\n";
        if (lodp.search(/[0#?],[0#?]/) >= 0)
            thousands = true;
        if (m || thousands)
            lodp = lodp.replace(/,/g, "");
        m = lodp.match(/0[0#?]*/);
        if (m)
            ldigits = m[0].length;
        m = rodp.match(/[0#?]*/);
        if (m)
            rdigits = m[0].length;
        if (scidigits > 0) {
            code += "var sci = tdgchart.numberFormatter.toScientific(val,";
            code += ldigits + ", " + rdigits + ", " + scidigits + ", " + scishowsign + ");\n";
            code += "var arr = [sci.l, sci.r];\n"
        } else {
            if (format.indexOf(".") < 0) {
                code += "var sign = (this < 0 && context == null) ? -1 : 1;\n";
                code += "val = Math.round(val*sign)*sign;\n"
            }
            rdigits = Math.max(0, Math.min(20, rdigits));
            code += "var arr = tdgchart.numberFormatter.round(val, " + rdigits + ").toFixed(" + rdigits + ").split('.');\n";
            code += "arr[0] = (val < 0 ? '-' : '') + tdgchart.numberFormatter.leftPadString((val < 0 ? arr[0].substring(1) : arr[0]), ";
            code += ldigits + ", '0');\n"
        }
        if (thousands)
            code += "arr[0] = tdgchart.numberFormatter.addSeparators(arr[0], '" + thousandChar + "');\n";
        code += "arr[0] = tdgchart.numberFormatter.reverseString(tdgchart.numberFormatter.injectIntoFormat(tdgchart.numberFormatter.reverseString(arr[0]), '";
        code += tdgchart.numberFormatter.escapeString(tdgchart.numberFormatter.reverseString(lodp)) + "', true));\n";
        if (rdigits > 0)
            code += "arr[1] = tdgchart.numberFormatter.injectIntoFormat(arr[1], '" + tdgchart.numberFormatter.escapeString(rodp) + "', false);\n";
        if (scidigits > 0)
            code += "arr[1] = arr[1].replace(/(\\d{" + rdigits + "})/, '$1" + sciletter + "' + sci.s);\n";
        return code + "return arr.join('" + decimalChar + "');\n"
    }
    tdgchart.numberFormatter.toScientific = function(val, ldigits, rdigits, scidigits, showsign) {
        var result = {
            l: "",
            r: "",
            s: ""
        };
        var ex = "";
        var digits = Math.max(0, Math.min(20, ldigits + rdigits + 1));
        var before = tdgchart.numberFormatter.trimString(Math.abs(val).toFixed(digits), "0");
        var after = Math.round(parseFloat(before.replace(".", "").replace(new RegExp("(\\d{" + (ldigits + rdigits) + "})(.*)"), "$1.$2") || 0)).toFixed(0);
        if (after.length >= ldigits)
            after = after.substring(0, ldigits) + "." + after.substring(ldigits);
        else
            after += ".";
        result.s = before.indexOf(".") - before.search(/[1-9]/) - after.indexOf(".");
        if (result.s < 0)
            result.s++;
        result.l = (val < 0 ? "-" : "") + tdgchart.numberFormatter.leftPadString(after.substring(0, after.indexOf(".")), ldigits, "0");
        result.r = after.substring(after.indexOf(".") + 1);
        if (result.s < 0)
            ex = "-";
        else if (showsign)
            ex = "+";
        result.s = ex + tdgchart.numberFormatter.leftPadString(Math.abs(result.s).toFixed(0), scidigits, "0");
        return result
    }
    ;
    tdgchart.numberFormatter.injectIntoFormat = function(val, format, stuffExtras) {
        var i = 0;
        var j = 0;
        var result = "";
        var revneg = val.charAt(val.length - 1) === "-";
        if (revneg)
            val = val.substring(0, val.length - 1);
        while (i < format.length && j < val.length && format.substring(i).search(/[0#?]/) >= 0) {
            if (format.charAt(i).match(/[0#?]/)) {
                if (val.charAt(j) !== "-")
                    result += val.charAt(j);
                else
                    result += "0";
                j++
            } else
                result += format.charAt(i);
            ++i
        }
        if (revneg && j === val.length)
            result += "-";
        if (j < val.length) {
            if (stuffExtras)
                result += val.substring(j);
            if (revneg)
                result += "-"
        }
        if (i < format.length)
            result += format.substring(i);
        return result.replace(/#/g, "").replace(/\?/g, " ")
    }
    ;
    tdgchart.numberFormatter.addSeparators = function(val, sep) {
        val = tdgchart.numberFormatter.reverseString(val).replace(/(\d{3})/g, "$1" + sep);
        val = tdgchart.numberFormatter.reverseString(val).replace(new RegExp("^(-)?\\" + sep), "$1");
        return val
    }
    ;
    tdgchart.numberFormatter.round = function(val, decimals) {
        if (decimals > 0) {
            var decimalPrecision = Math.min(decimals + 10, 20);
            var m = val.toFixed(decimalPrecision).match(new RegExp("(-?\\d*).(\\d{" + decimals + "})(\\d)\\d*$"));
            if (m && m.length) {
                var carryover = m[1].charAt(0) === "-" ? -1 : 1;
                var s = tdgchart.numberFormatter.leftPadString(Math.round(m[2] + "." + m[3]), decimals, "0");
                return s.length > decimals ? parseFloat(m[1] || 0) + carryover : parseFloat((m[1] || 0) + "." + s)
            }
        }
        return val
    }
    ;
    tdgchart.numberFormatter.reverseString = function(s) {
        var res = "";
        for (var i = s.length; i > 0; --i)
            res += s.charAt(i - 1);
        return res
    }
    ;
    tdgchart.numberFormatter.trimString = function(s, ch) {
        if (!ch)
            ch = " ";
        return s.replace(new RegExp("^" + ch + "+|" + ch + "+$","g"), "")
    }
    ;
    tdgchart.numberFormatter.repeatString = function(s, num) {
        return (new Array(isNaN(num) ? 1 : ++num)).join(s)
    }
    ;
    tdgchart.numberFormatter.leftPadString = function(val, size, ch) {
        var result = val + "";
        if (ch == null)
            ch = " ";
        while (result.length < size)
            result = ch + result;
        return result
    }
    ;
    tdgchart.numberFormatter.escapeString = function(s) {
        return s.replace(/(')/g, "\\$1").replace(/[\r\n]/g, "")
    }
    ;
    tdgchart.prototype.findBucketFormat = function findBucketFormat(bucketID, ids, defaultFormat) {
        var chart = this;
        if (chart.dataBuckets && typeof chart.dataBuckets.getBucket === "function") {
            var bucket = chart.dataBuckets.getBucket(bucketID);
            if (bucket) {
                var fields = bucket.fields || [];
                var idxLookup = chart.isPieLike() ? "group" : "series";
                if (fields.length > 1 && (ids == null || ids[idxLookup] == null)) {
                    var fmt = fields[0].numberFormat;
                    for (var i = 1; i < fields.length; i++)
                        if (fields[i].numberFormat !== fmt)
                            return "auto"
                }
                var id = ids && ids[idxLookup] != null ? ids[idxLookup] : 0;
                id = id % fields.length;
                return (fields[id] || {}).numberFormat || defaultFormat
            }
        }
        return null
    }
    ;
    function resolveGrouping(format, grouping) {
        format = format.replace(/\.[0#]+/g, "");
        format = format.replace(/,###/g, ",");
        format = format.replace(/,000/g, ",");
        if (grouping.toLowerCase() === "auto")
            if (format === "0" || format === "#")
                format = "{{auto}}";
            else
                format = format.replace(/([0#],+(`?)[KMBT]?)(\b|[^a-zA-Z]|$)/g, function(match, n1, n2, n3) {
                    return (n2 == "`" ? "{{autont}}" : "{{auto}}") + n3
                });
        else {
            var commaCount = groupingCounts[grouping];
            var groupString = tdgchart.numberFormatter.repeatString(",", commaCount) + grouping;
            format = format.replace(/,+/g, groupString)
        }
        return format
    }
    function resolveMetadataFormat(chart, format, bucketID, ids, grouping) {
        if (bucketID == null)
            return "#";
        var bucketFormat = chart.findBucketFormat(bucketID, ids, "#");
        if (bucketFormat == null && bucketID === "y")
            bucketFormat = chart.findBucketFormat("value", ids, "#");
        if (bucketFormat == null && bucketID === "x")
            bucketFormat = chart.findBucketFormat("value", ids, "#");
        if (bucketFormat == null && bucketID === "colorScale")
            bucketFormat = chart.findBucketFormat("color", ids, "#");
        bucketFormat = bucketFormat || "#";
        if (grouping)
            bucketFormat = resolveGrouping(bucketFormat, grouping);
        return bucketFormat
    }
}
)();
(function() {
    tdgchart.prototype.drawRadarChart = drawRadarChart;
    tdgchart.prototype.drawPolarChart = drawPolarChart;
    var tdg = tdgchart.util;
    function hasSizeScaleData(data) {
        return data.some(function(r) {
            return r.some(function(d) {
                return typeof d === "object" && d.size != null
            })
        })
    }
    function getLineWidthScale(chart, data, odata_key, y) {
        var minMax = chart.getScaleMinMax({
            globalAxisHeadroom: 1
        }, "", data || this._internalData, null, odata_key || "size");
        var maxRange = Math.round(Math.max(10, y.range()[1])) / 10;
        if (minMax.min == minMax.max)
            return function() {
                return maxRange
            }
            ;
        return pv.Scale.linear(minMax.min, minMax.max).range(1, maxRange)
    }
    function thickRadarPath(chart, cx, cy, data, y, series) {
        function line(p, r) {
            if (tdg.eq(p.x, r.x))
                return {
                    x: p.x
                };
            else {
                var a = (p.y - r.y) / (p.x - r.x);
                return {
                    a: a,
                    b: p.y - a * p.x
                }
            }
        }
        function vector(p, r) {
            return {
                x: r.x - p.x,
                y: r.y - p.y
            }
        }
        function orthogonal(v) {
            if (tdg.eq(v.x, 0)) {
                var dir = v.y < 0 ? 1 : -1;
                return {
                    x: 1 * dir,
                    y: 0
                }
            } else if (tdg.eq(v.y, 0)) {
                var dir = v.x > 0 ? 1 : -1;
                return {
                    x: 0,
                    y: 1 * dir
                }
            } else {
                var dir = v.y < 0 ? 1 : -1;
                var z = -v.y / v.x;
                var ov = {};
                ov.x = Math.abs(z) / Math.sqrt(1 + z * z) * dir;
                ov.y = ov.x / z;
                return ov
            }
        }
        function removeInnerOverlapedSegments(pts) {
            var filter = [];
            if (pts.length <= 8)
                return pts;
            for (var i = 0; i < pts.length - 1; i += 2) {
                var first = [pts[i], pts[i + 1]];
                var fourth = [pts[(i + 6) % pts.length], pts[(i + 7) % pts.length]];
                if (tdg.geom.segmentsIntersects(first, fourth)) {
                    filter[(i + 2) % pts.length] = filter[(i + 3) % pts.length] = filter[(i + 4) % pts.length] = filter[(i + 5) % pts.length] = true;
                    i += 4
                }
            }
            if (filter.length)
                pts = pts.filter(function(pt, i) {
                    return !filter[i]
                });
            return pts
        }
        function intersection(lineFirst, lineSecond) {
            var p = {};
            if (lineFirst.x != undefined) {
                p.x = lineFirst.x;
                p.y = lineSecond.a * p.x + lineSecond.b
            } else if (lineSecond.x != undefined) {
                p.x = lineSecond.x;
                p.y = lineFirst.a * p.x + lineFirst.b
            } else {
                p.x = -(lineFirst.b - lineSecond.b) / (lineFirst.a - lineSecond.a);
                p.y = lineFirst.a * p.x + lineFirst.b
            }
            return p
        }
        function intersectionPts(pts) {
            var connectedPts = [];
            for (var i = 0, lineSecond = line(pts[0], pts[1]); i < pts.length - 1; i += 2) {
                var lineFirst = lineSecond;
                lineSecond = line(pts[(i + 2) % pts.length], pts[(i + 3) % pts.length]);
                var p = intersection(lineFirst, lineSecond);
                connectedPts.push({
                    x: R10(p.x),
                    y: R10(p.y)
                })
            }
            return connectedPts
        }
        var lineWidthScale = getLineWidthScale(chart, data, "size", y);
        var basePath = [];
        var startAngle = Math.PI / 2;
        var angle = 2 * Math.PI / chart.groupCount();
        for (var g = 0; g < series.length; g++) {
            var ca = Math.cos(startAngle - g * angle);
            var sa = Math.sin(startAngle - g * angle);
            var radius = y(series[g].value);
            var pt = {
                x: ca * radius,
                y: -sa * radius
            };
            basePath.push(pt)
        }
        var innerSegments = [];
        var outerSegments = [];
        for (var first = 0; first < series.length; first++) {
            var second = (first + 1) % series.length;
            var orthDir = orthogonal(vector(basePath[first], basePath[second]));
            var radiusF = lineWidthScale(series[first].size) / 2;
            var radiusS = lineWidthScale(series[second].size) / 2;
            var orthVectF = {
                x: orthDir.x * radiusF,
                y: orthDir.y * radiusF
            };
            var orthVectS = {
                x: orthDir.x * radiusS,
                y: orthDir.y * radiusS
            };
            innerSegments.push({
                x: basePath[first].x + orthVectF.x,
                y: basePath[first].y + orthVectF.y
            });
            innerSegments.push({
                x: basePath[second].x + orthVectS.x,
                y: basePath[second].y + orthVectS.y
            });
            outerSegments.push({
                x: basePath[first].x - orthVectF.x,
                y: basePath[first].y - orthVectF.y,
                r: radiusF
            });
            outerSegments.push({
                x: basePath[second].x - orthVectS.x,
                y: basePath[second].y - orthVectS.y,
                r: radiusS
            })
        }
        function closedPath(p, pts) {
            pts.forEach(function(pt, i) {
                if (i == 0)
                    p.moveTo(pt.x, pt.y);
                else
                    p.lineTo(pt.x, pt.y)
            });
            p.closePath()
        }
        var p = new tdgchart.tdgscene.path;
        if (0)
            closedPath(p, intersectionPts(outerSegments));
        else {
            for (var i = 0; i < outerSegments.length; i += 2) {
                if (i == 0)
                    p.moveTo(outerSegments[i + 1].x, outerSegments[i + 1].y);
                else
                    p.lineTo(outerSegments[i + 1].x, outerSegments[i + 1].y);
                p.arcTo(outerSegments[i + 1].r, outerSegments[i + 1].r, 0, 0, 1, outerSegments[(i + 2) % outerSegments.length].x, outerSegments[(i + 2) % outerSegments.length].y)
            }
            p.closePath()
        }
        closedPath(p, intersectionPts(removeInnerOverlapedSegments(innerSegments)).reverse());
        return p
    }
    function R10(v) {
        return Math.round(v * 10) / 10
    }
    function addRadar(chart, rootGroup, data, y) {
        var w = rootGroup.w
          , h = rootGroup.h;
        var baseGroup = rootGroup.group("eventPanel");
        baseGroup.rect(0, 0, w, h, {
            color: "transparent",
            "pointer-events": "all"
        });
        var groupPanel = baseGroup.group("groupPanel");
        var risersGroup = groupPanel.group("risers");
        var startAngle = Math.PI / 2;
        var angle = 2 * Math.PI / chart.groupCount();
        var colorLookup = chart.seriesColorLookup();
        var borderWidthLookup = chart.seriesPropertyLookup("border.width");
        var borderColorLookup = !chart.polarProperties.drawAsArea ? null : chart.seriesPropertyLookup("border.color");
        var riserList = [];
        for (var s = 0; s < data.length; s++) {
            var series = data[s];
            if (!series || !series.length)
                continue;
            riserList[s] = [];
            var elementWithId = series.find(function(e) {
                return e._s != undefined
            });
            var ids = {
                _s: (elementWithId || {})._s,
                _g: null
            };
            var color = colorLookup(ids);
            var path, style = {
                className: chart.getRiserClassName(risersGroup, ids, "riser", "line"),
                title: chart.getSeriesAndGroupProperty(ids._s, ids._g, "tooltip"),
                lineCap: "round"
            };
            if (!hasSizeScaleData(data)) {
                path = new tdgchart.tdgscene.path;
                var next = "moveTo";
                var firstPoint = null
                  , anyGaps = false;
                for (var g = 0; g < series.length; g++)
                    if (series[g].value != undefined) {
                        var ca = Math.cos(startAngle - g * angle);
                        var sa = Math.sin(startAngle - g * angle);
                        var radius = y(series[g].value);
                        pt = {
                            x: R10(ca * radius),
                            y: R10(-sa * radius)
                        };
                        path[next](pt.x, pt.y);
                        if (g == 0)
                            firstPoint = pt;
                        next = "lineTo"
                    } else {
                        next = "moveTo";
                        anyGaps = true
                    }
                if (next == "lineTo" && firstPoint)
                    if (anyGaps)
                        path[next](firstPoint.x, firstPoint.y);
                    else
                        path.closePath();
                style.lineStyle = {
                    width: borderWidthLookup(ids)
                };
                if (!chart.polarProperties.drawAsArea)
                    style.lineStyle.color = color;
                else {
                    style.color = color;
                    style.lineStyle.color = borderColorLookup(ids)
                }
            } else {
                path = thickRadarPath(chart, w / 2, h / 2, data, y, series);
                style.color = color
            }
            risersGroup.path(w / 2, h / 2, path, style);
            for (var g = 0; g < series.length; g++) {
                var ca = Math.cos(startAngle - g * angle);
                var sa = Math.sin(startAngle - g * angle);
                var radius = y(series[g].value);
                var dot = {
                    props: {
                        w: 0,
                        h: 0,
                        size: 0,
                        x: R10(ca * radius),
                        y: R10(-sa * radius)
                    }
                };
                dot.d = series[g];
                dot.data = series;
                riserList[s].push(dot)
            }
        }
        chart.addMarkersScene(rootGroup.group("markers", w / 2, h / 2), riserList, data, "line");
        chart.doDataLabelsScene(rootGroup.group("labels", w / 2, h / 2), riserList, "top")
    }
    function circularChartRadius(chart, w, h) {
        var radius = Math.min(w / 2, h / 2) - chart.getPadding("frame", "maxVert");
        var axisProperties = chart.axisList.x1;
        var lblHeight;
        if (axisProperties.title.visible) {
            lblHeight = tdg.measureFont(axisProperties.title.font).height;
            radius -= lblHeight + chart.getPadding("label", "top")
        }
        if (axisProperties.labels.visible) {
            lblHeight = tdg.measureFont(axisProperties.labels.font).height;
            radius -= lblHeight + chart.getPadding("label", "top")
        }
        return radius
    }
    function drawRadarChart(panel, externalTitlePanel, chartLayout, passedData) {
        var chart = this;
        var originalChartData = chart.data;
        chart.data = chart.adjustData(chart._internalData);
        var data = passedData ? chart.adjustData(passedData) : chart.data;
        var xaxis = {
            side: "",
            properties: chart.axisList.x1
        };
        var yaxis = {
            side: "",
            properties: chart.axisList.y1
        };
        var y = chart.getNumericScale(panel.computedSize, yaxis);
        var groupCount = chart.groupCount();
        var labels = chart.getGroupLabels();
        chart.addChartFrame(panel);
        var scene = chart.cache.get("tdgscene");
        var rootGroup = scene.group(panel, undefined, 0, 0, panel.computedSize.width, panel.computedSize.height);
        var radius = circularChartRadius(chart, rootGroup.w, rootGroup.h);
        y.range(0, radius);
        chart.drawCircularAxisColorRanges(rootGroup, radius, null, xaxis, true, groupCount, labels);
        chart.drawCircularAxisColorRanges(rootGroup, radius, y, yaxis, false, groupCount);
        if (!xaxis.properties.majorGrid.aboveRisers)
            chart.drawRadialAxis(rootGroup, radius, groupCount, labels, xaxis.properties, "x1");
        if (!yaxis.properties.majorGrid.aboveRisers)
            chart.drawNumericAxisCircular(rootGroup, externalTitlePanel, radius, y, yaxis, groupCount);
        addRadar(chart, rootGroup, data, y);
        if (xaxis.properties.majorGrid.aboveRisers)
            chart.drawRadialAxis(rootGroup, radius, groupCount, labels, xaxis.properties, "x1");
        if (yaxis.properties.majorGrid.aboveRisers)
            chart.drawNumericAxisCircular(rootGroup, externalTitlePanel, radius, y, yaxis, groupCount);
        chart.data = originalChartData
    }
    function addPolar(chart, rootGroup, data, x, y) {
        var groupPanel = rootGroup.group("groupPanel")
          , w = rootGroup.w
          , h = rootGroup.h;
        var shapeLookup = chart.seriesPropertyLookup("marker.shape");
        var angleLookup = chart.markerRotationLookup();
        var fillLookup = chart.markerFillStyle();
        var borderLookup = chart.seriesPropertyLookup("marker.border");
        var titleLookup = chart.seriesToolTipLookup();
        var sizeLookup = chart.isDataDrivenMarkerSize() ? chart.dataDrivenMarkerSize() : chart.markerSizeLookup();
        var markerGroup = groupPanel.group("markers", w / 2, h / 2);
        var riserList = [];
        for (var s = 0; s <= data.length; s++) {
            if (!data[s])
                continue;
            riserList[s] = [];
            var seriesGroup = markerGroup.group();
            for (var g = 0; g < data[s].length; g++) {
                var d = data[s][g];
                if (d.phi == null || d.r == null)
                    continue;
                var border = borderLookup.call({}, d) || {};
                var dx = R10(y(d.r) * Math.sin(x(d.phi)));
                var dy = R10(-y(d.r) * Math.cos(x(d.phi)));
                var radius = R10(sizeLookup.call({}, d));
                var shape = shapeLookup.call({}, d);
                var rotation = tdg.degrees(angleLookup.call({}, d)) || undefined;
                var antialias = !tdg.isEmpty(rotation) || pv.SvgScene.shapeRequiresAntiAlias(shape);
                var markerStyle = {
                    className: chart.getRiserClassName(seriesGroup, d, "riser", "marker"),
                    color: fillLookup.call({}, d),
                    rotation: tdg.degrees(angleLookup.call({}, d)),
                    title: chart.getSeriesAndGroupProperty(d._s, d._g, "tooltip"),
                    border: border.color,
                    lineWidth: border.width,
                    dash: border.dash,
                    antialias: antialias === true ? null : antialias
                };
                var dot = seriesGroup.dot(dx, dy, radius * 2, shape, markerStyle);
                dot.d = d;
                dot.data = data[s];
                riserList[s].push(dot)
            }
        }
        chart.doDataLabelsScene(rootGroup.group("labels", w / 2, h / 2), riserList, "top")
    }
    function drawPolarChart(panel, externalTitlePanel, chartLayout, passedData) {
        var chart = this;
        var data = passedData || chart._internalData;
        var xaxis = {
            side: "",
            properties: chart.axisList.x1
        };
        var yaxis = {
            side: "",
            properties: chart.axisList.y1
        };
        var x = chart.getNumericScale(panel.computedSize, xaxis);
        var y = chart.getNumericScale(panel.computedSize, yaxis);
        var ticks = x.ticks();
        chart.addChartFrame(panel);
        x.range(0, 2 * Math.PI * ((ticks.length - 1) / ticks.length));
        chart.cache.setProperty("polarProperties.straightGridLines", false);
        var scene = chart.cache.get("tdgscene");
        var rootGroup = scene.group(panel, undefined, 0, 0, panel.computedSize.width, panel.computedSize.height);
        var radius = circularChartRadius(chart, rootGroup.w, rootGroup.h);
        y.range(0, radius);
        chart.drawCircularAxisColorRanges(rootGroup, radius, x, xaxis, true);
        chart.drawCircularAxisColorRanges(rootGroup, radius, y, yaxis, false);
        if (!xaxis.properties.majorGrid.aboveRisers)
            chart.drawRadialAxis(rootGroup, radius, ticks.length, ticks, xaxis.properties, "x1");
        if (!yaxis.properties.majorGrid.aboveRisers)
            chart.drawNumericAxisCircular(rootGroup, externalTitlePanel, radius, y, yaxis, ticks.length);
        addPolar(chart, rootGroup, data, x, y);
        if (xaxis.properties.majorGrid.aboveRisers)
            chart.drawRadialAxis(rootGroup, radius, ticks.length, ticks, xaxis.properties, "x1");
        if (yaxis.properties.majorGrid.aboveRisers)
            chart.drawNumericAxisCircular(rootGroup, externalTitlePanel, radius, y, yaxis, ticks.length)
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    function drawGroupLabel(chart, panel) {
        var labels = chart.getGroupLabels();
        var pad = chart.getPadding("label", "bottom") + 1;
        panel.anchor(chart.gaugeProperties.groupLabel.position).className(chart.getPieLabelClassName("groupLabel")).add(pv.Label).textMargin(pad).text(function() {
            return labels[this.parent.parent.index]
        }).font(chart.gaugeProperties.groupLabel.font).textStyle(chart.gaugeProperties.groupLabel.color)
    }
    function getTotalLabelFn(chart) {
        var gaugeProps = chart.gaugeProperties;
        var content = gaugeProps.totalLabel.content
          , totalLabelText = gaugeProps.totalLabel.content;
        if (totalLabelText === "auto")
            totalLabelText = function(d) {
                var group = this && this.parent && this.parent.parent ? this.parent.parent.index : 0;
                var config = {
                    object: "totalLabel",
                    bucketID: "value",
                    ids: {
                        series: 0,
                        group: group
                    }
                };
                return chart.formatNumber(tdg.sum(d, "value"), gaugeProps.totalLabel.numberFormat, config)
            }
            ;
        else if (tdgchart.templateEngine.isTemplateString(totalLabelText))
            totalLabelText = function(d, data) {
                d = (data || [])[0];
                var ids = chart.getMarkSeriesAndGroupID(this, d);
                return chart.parseTemplate(content, d, data, ids)
            }
            ;
        return totalLabelText
    }
    function drawOneGaugeChart(chart, panel, w, h, passedMinMax) {
        var gaugeProps = chart.gaugeProperties;
        var isSemiCircle = chart.gaugeProperties.layout == "semiCircle";
        var axisProps = chart.axisList.y1;
        var startAngle = gaugeProps.startAngle == null ? 135 : gaugeProps.startAngle;
        var endAngle = gaugeProps.endAngle == null ? 45 : gaugeProps.endAngle;
        var minMax = passedMinMax || chart.getScaleMinMax(axisProps, "y1");
        var offset = gaugeProps.outerBorder.shape === "tight" ? .15 : 0;
        var pos = {
            x: w / 2,
            y: h / 2
        };
        var needleBaseSize = gaugeProps.needleBase.size;
        if (isSemiCircle) {
            startAngle = 180;
            endAngle = 0
        }
        while (endAngle > startAngle)
            endAngle -= 360;
        startAngle = tdg.radians(startAngle) + offset;
        endAngle = tdg.radians(360 + endAngle) - offset;
        var scaleType = axisProps.bIsLog ? "log" : "linear";
        var gaugeScale = pv.Scale[scaleType](minMax.min, minMax.max);
        gaugeScale.stepSize = minMax.step;
        if (axisProps.invert)
            gaugeScale.range(endAngle, startAngle);
        else
            gaugeScale.range(startAngle, endAngle);
        if (axisProps.min != null || axisProps.max != null) {
            var domain = gaugeScale.domain();
            var min = axisProps.min;
            var max = axisProps.max;
            if (min === max)
                max += 1;
            gaugeScale.domain(min == null ? domain[0] : min, max == null ? domain[1] : max)
        }
        var r, needleBaseRadius;
        var axisLablesHeight = tdg.measureFont(axisProps.labels.font).height;
        var adjustedH = h;
        var groupLabelHeight = gaugeProps.groupLabel.visible ? tdg.measureFont(gaugeProps.groupLabel.font).height : 0;
        adjustedH -= groupLabelHeight;
        if (!isSemiCircle) {
            adjustedH -= chart.getPadding("label", "height");
            r = Math.min(w - chart.getPadding("label", "width"), adjustedH) / 2;
            needleBaseRadius = tdg.bound(baseRadius(needleBaseSize, r), 0, r * .5)
        } else {
            pos.y = 0;
            var axisLablesSpace = !axisProps.labels.visible ? 0 : chart.getPadding("label", "bottom") + axisLablesHeight;
            adjustedH -= axisLablesSpace;
            if (gaugeProps.groupLabel.visible)
                pos.y += groupLabelHeight + chart.getPadding("label", "top");
            if (gaugeProps.totalLabel.visible) {
                var totalLabelHeight = tdg.measureFont(gaugeProps.totalLabel.font).height;
                adjustedH -= totalLabelHeight + chart.getPadding("label", "top");
                pos.y += totalLabelHeight + chart.getPadding("label", "top")
            }
            var tmp_r = Math.max(20, Math.min(w / 2 - axisLablesSpace, adjustedH));
            needleBaseSize = tmp_r / 25;
            var tmp_needleBaseRadius = baseRadius(needleBaseSize, tmp_r);
            adjustedH -= tmp_needleBaseRadius;
            r = Math.max(20, Math.min(w / 2 - axisLablesSpace, adjustedH));
            needleBaseSize = r / 25;
            needleBaseRadius = tdg.bound(baseRadius(needleBaseSize, r), 0, r * .5);
            pos.y += needleBaseRadius;
            if (r < adjustedH)
                pos.y += (adjustedH - r) / 2
        }
        var border = gaugeProps.outerBorder;
        var borderInnerR = isSemiCircle ? r : tdg.bound(widthToRadius(border.width, r), r * .2, r);
        var rangeOuterR = isSemiCircle ? r : borderInnerR - 10;
        var rangeInnerR = tdg.bound(widthToRadius(isSemiCircle ? "20%" : gaugeProps.axisWidth, rangeOuterR), r * .2, rangeOuterR);
        var tickInnerR = tdg.bound(widthToRadius(gaugeProps.axisTickLength, rangeOuterR), r * .2, rangeOuterR);
        if (chart.needHTMLToolTip())
            panel.add(pv.Panel).className("eventPanel").events("all");
        if (gaugeProps.fill.color !== "transparent") {
            var gaugeFill;
            if (gaugeProps.outerBorder.shape === "tight")
                gaugeFill = panel.add(pv.Dot).shape("gaugeFill").def("startAngle", startAngle - offset).def("endAngle", endAngle + offset).def("innerRadius", borderInnerR + 1).def("outerRadius", r).def("baseSize", tdg.bound(baseRadius(needleBaseSize, r), 0, r * .5));
            else
                gaugeFill = panel.add(pv.Wedge).angle(2 * Math.PI).outerRadius(r * .99);
            gaugeFill.left(pos.x).bottom(pos.y).fillStyle(gaugeProps.fill.color).lineStyle("transparent")
        }
        if (r - borderInnerR > 0)
            if (gaugeProps.outerBorder.shape === "tight")
                panel.add(pv.Dot).shape("gaugeBorder").def("startAngle", startAngle - offset).def("endAngle", endAngle + offset).def("innerRadius", borderInnerR).def("outerRadius", r).def("baseSize", tdg.bound(baseRadius(needleBaseSize, r), 0, r * .5)).left(pos.x).bottom(pos.y).fillStyle(border.fill.color).lineStyle(border.border);
            else
                panel.add(pv.Wedge).left(pos.x).bottom(pos.y).angle(2 * Math.PI).innerRadius(borderInnerR).outerRadius(r).fillStyle(border.fill.color).lineStyle(border.border);
        if (isSemiCircle)
            panel.add(pv.Wedge).left(pos.x).bottom(pos.y).startAngle(startAngle).endAngle(endAngle).innerRadius(needleBaseRadius * 2.5).outerRadius(rangeInnerR).fillStyle(gaugeProps.secondaryRingFillColor).lineStyle("invisible");
        var ranges = panel.add(pv.Wedge).fillStyle(null).left(pos.x).bottom(pos.y).startAngle(startAngle).endAngle(endAngle).innerRadius(rangeInnerR).outerRadius(rangeOuterR);
        var axisStart = gaugeScale.domain()[0]
          , axisStop = gaugeScale.domain()[1];
        function offsetToAngle(val) {
            if (tdg.isPercentString(val))
                return (endAngle - startAngle) * tdg.parsePercent(val) + startAngle;
            if (val < axisStart || val > axisStop)
                return undefined;
            return gaugeScale(val)
        }
        if (axisProps.colorBands && axisProps.colorBands.length > 0) {
            var minValue = gaugeScale.domain()[0];
            var maxValue = gaugeScale.domain()[1];
            for (var i = 0; i < axisProps.colorBands.length; i++) {
                var band = axisProps.colorBands[i];
                if (band.start < minValue)
                    band.start = minValue;
                else if (band.start > maxValue)
                    band.start = maxValue;
                if (band.stop < minValue)
                    band.stop = minValue;
                else if (band.stop > maxValue)
                    band.stop = maxValue
            }
            ranges.add(pv.Wedge).className("gaugeRange").data(axisProps.colorBands).startAngle(function(d) {
                return offsetToAngle(d.start)
            }).endAngle(function(d) {
                return offsetToAngle(d.stop)
            }).fillStyle(function(d) {
                return d.color
            })
        }
        var tickData;
        var isIntervalModeEnabled = axisProps.intervalMode === "interval" && axisProps.intervalValue > 0;
        if (isIntervalModeEnabled) {
            var value = axisProps.intervalValue;
            var tempDomain = gaugeScale.domain();
            tickData = tdg.range(tempDomain[0], tempDomain[1] + value * 1, value);
            gaugeScale.domain(tickData[0], tickData[tickData.length - 1])
        } else
            tickData = gaugeScale.ticks(true);
        if (axisProps.min != null)
            tickData[0] = axisProps.min;
        if (axisProps.max != null && !isIntervalModeEnabled)
            tickData[tickData.length - 1] = axisProps.max;
        if (isSemiCircle && axisProps.colorBands && axisProps.colorBands.length) {
            tickData = axisProps.colorBands.map(function(band) {
                return band.start
            });
            tickData = tickData.filter(function(d, i, arr) {
                return !i || d != arr[i - 1]
            })
        }
        var ticks = ranges.add(pv.Wedge).data(tickData).className("rangeTicks").fillStyle(null).startAngle(function(d) {
            return gaugeScale(d)
        }).endAngle(null).angle(0).innerRadius(isSemiCircle ? rangeOuterR + chart.getPadding("label", "bottom") : tickInnerR).strokeStyle(axisProps.majorGrid.visible ? axisProps.majorGrid.lineStyle.color : "transparent").lineWidth(axisProps.majorGrid.lineStyle.width).dashStyle(axisProps.majorGrid.lineStyle.dash);
        if (axisProps.minorGrid.visible && axisProps.minorGrid.count !== 0) {
            var minorInnerR = tdg.bound(widthToRadius(gaugeProps.axisMinorTickLength, rangeOuterR), r * .2, rangeOuterR);
            var minGrd = axisProps.minorGrid;
            var majGrdGap = (endAngle - startAngle) / (tickData.length - 1);
            if (axisProps.invert)
                majGrdGap *= -1;
            var minGrdCount = (minGrd.count || 4) + 1
              , minGrdGap = majGrdGap / minGrdCount;
            var internalNums = function(start, stop) {
                return tdg.range(gaugeScale(start) + minGrdGap, gaugeScale(stop), minGrdGap)
            };
            var minTickData = [];
            tickData.reduce(function(prev, cur) {
                minTickData = minTickData.concat(internalNums(prev, cur));
                return cur
            });
            ranges.add(pv.Wedge).data(minTickData).className("minorGridTicks").startAngle(function(d) {
                return d
            }).endAngle(null).angle(0).innerRadius(minorInnerR).strokeStyle(axisProps.minorGrid.visible ? axisProps.minorGrid.lineStyle.color : "transparent").lineWidth(axisProps.minorGrid.lineStyle.width).dashStyle(axisProps.minorGrid.lineStyle.dash)
        }
        if (axisProps.labels.visible) {
            var config = {
                islog: axisProps.bIsLog,
                min: minMax.min,
                max: minMax.max,
                bucketID: "value"
            };
            ticks.anchor("inner").add(pv.Label).textAlign("center").textBaseline(isSemiCircle ? "bottom" : "top").textAngle(function() {
                return this.anchorTarget().midAngle() + Math.PI / 2
            }).text(function(d) {
                var group = this && this.parent && this.parent.parent ? this.parent.parent.index : 0;
                config.ids = {
                    series: 0,
                    group: group
                };
                return chart.formatNumber(d, axisProps.numberFormat, config)
            }).font(axisProps.labels.font).textStyle(axisProps.labels.color)
        }
        function needleVisible(d) {
            if (d == null || d.value == null)
                return false;
            return gaugeProps.secondaryNeedlesAsMarkers ? this.index === 0 : true
        }
        var colorLookup = chart.seriesColorLookup();
        var markerFillLookup = chart.seriesPropertyLookup("marker.color");
        var needleRadius = rangeInnerR + 2;
        needleRadius += (rangeOuterR - rangeInnerR) * (isSemiCircle ? .75 : .5);
        panel.add(pv.Dot).data(function(d) {
            return d
        }).className(chart.classNameLookup("needle", "riser")).left(pos.x).top(h - pos.y).visible(needleVisible).angle(function(d) {
            return Math.max(startAngle, Math.min(endAngle, gaugeScale(d.value))) - Math.PI / 2
        }).shape(isSemiCircle ? "needle2" : "needle").def("needleBaseRadius", isSemiCircle ? needleBaseRadius : undefined).radius(needleRadius).fillStyle(function(d) {
            return markerFillLookup.call(this, d) || colorLookup.call(this, d)
        }).lineStyle(chart.seriesPropertyLookup("border")).title(chart.seriesToolTipLookup());
        if (gaugeProps.secondaryNeedlesAsMarkers)
            panel.add(pv.Dot).data(function(d) {
                return d
            }).angle(function(d) {
                return Math.max(startAngle, Math.min(endAngle, gaugeScale(d.value))) - Math.PI / 2
            }).left(function() {
                return pos.x - rangeInnerR * Math.sin(this.angle())
            }).top(function() {
                return pos.y + rangeInnerR * Math.cos(this.angle())
            }).visible(function() {
                return this.index > 0
            }).shape(chart.seriesPropertyLookup("marker.shape")).radius(chart.markerSizeLookup()).fillStyle(function(d) {
                return markerFillLookup.call(this, d) || colorLookup.call(this, d)
            }).lineStyle(chart.seriesPropertyLookup("marker.border"));
        function baseRadius(val, r) {
            return tdg.applyNumOrPercent(val, r)
        }
        if (!isSemiCircle)
            panel.add(pv.Wedge).left(pos.x).bottom(pos.y).angle(2 * Math.PI).outerRadius(needleBaseRadius).fillStyle(gaugeProps.needleBase.color).lineStyle(gaugeProps.needleBase.border);
        else
            panel.add(pv.Wedge).left(pos.x).bottom(pos.y).angle(2 * Math.PI).outerRadius(needleBaseRadius / 2).fillStyle("white").lineStyle("invisible");
        if (gaugeProps.groupLabel.visible)
            drawGroupLabel(chart, panel);
        if (gaugeProps.totalLabel.visible) {
            var totalLabelText = getTotalLabelFn(chart);
            panel.add(pv.Label).className(chart.getPieLabelClassName("totalLabel")).left(pos.x).top(h - pos.y + needleBaseRadius + 5).text(totalLabelText).font(gaugeProps.totalLabel.font).textStyle(gaugeProps.totalLabel.color).textBaseline("top").textAlign("center")
        }
    }
    function widthToRadius(val, r) {
        return r - tdg.applyNumOrPercent(val, r)
    }
    function drawSimpleGauge(chart, panel, w, h, passedData, minMax) {
        var gaugeProps = chart.gaugeProperties;
        var axisProps = chart.axisList.y1;
        var data = passedData || chart.data;
        var d = data && data[0] != null && data[0][0] != null ? data[0][0] : undefined;
        var value = data && data[0] != null && data[0][0] != null ? data[0][0].value : undefined;
        var adjustedH = h - chart.getPadding("label", "height");
        var r = Math.min(w - chart.getPadding("label", "width"), adjustedH) / 2;
        var border = gaugeProps.outerBorder;
        var borderInnerR = tdg.bound(widthToRadius(border.width, r), r * .2, r);
        var rangeOuterR = borderInnerR - 5;
        var rangeInnerR = tdg.bound(widthToRadius(gaugeProps.axisWidth, rangeOuterR), r * .2, rangeOuterR);
        if (chart.needHTMLToolTip())
            panel.add(pv.Panel).className("eventPanel").events("all");
        if (gaugeProps.fill.color !== "transparent")
            panel.add(pv.Wedge).left(w / 2).bottom(h / 2).angle(2 * Math.PI).outerRadius(rangeInnerR * 1.005).fillStyle(gaugeProps.fill.color);
        if (r - borderInnerR > 0)
            panel.add(pv.Wedge).left(w / 2).bottom(h / 2).angle(2 * Math.PI).innerRadius(borderInnerR).outerRadius(r).fillStyle(border.fill.color).lineStyle(border.border);
        var startAngle = tdg.radians(gaugeProps.startAngle == null ? 270 : gaugeProps.startAngle);
        var endAngle = tdg.radians(gaugeProps.endAngle == null ? 0 : gaugeProps.endAngle);
        var clockwise = 1;
        if (startAngle < 0 || 1 / startAngle === -Infinity) {
            startAngle *= -1;
            clockwise = -1
        }
        if (Math.abs(endAngle - startAngle) < 1E-4)
            endAngle += 2 * Math.PI;
        while (endAngle < startAngle)
            endAngle += 2 * Math.PI;
        if (gaugeProps.secondaryRingFillColor)
            panel.add(pv.Wedge).fillStyle(gaugeProps.secondaryRingFillColor).className("gauge_secondary_ring").left(w / 2).bottom(h / 2).startAngle(startAngle).endAngle(endAngle).innerRadius(rangeInnerR).outerRadius(rangeOuterR);
        if (isNaN(value) || value == null)
            return;
        var range = panel.add(pv.Wedge).data(function(d) {
            return d
        }).fillStyle(chart.getSeriesAndGroupProperty(0, null, "color")).className(chart.classNameLookup("range", "riser")).left(w / 2).bottom(h / 2).startAngle(startAngle).innerRadius(rangeInnerR).outerRadius(rangeOuterR).title(chart.seriesToolTipLookup());
        var endScaleAngle = gaugeProps.secondaryRingFillColor ? endAngle : startAngle + 2 * Math.PI;
        var valueMinMax = minMax || {
            min: value,
            max: value
        };
        if (minMax == null)
            minMax = chart.getScaleMinMax(axisProps, "y1");
        if (axisProps.min == null)
            minMax.min = Math.min(0, valueMinMax.min);
        if (axisProps.max == null) {
            var min = valueMinMax.min;
            var max = valueMinMax.max;
            if (min >= 0 && max >= 0)
                if (min <= 1.1 && max <= 1.1)
                    minMax.max = 1;
                else if (min <= 100 && max <= 100)
                    minMax.max = 100
        } else
            minMax.max = axisProps.max;
        var gaugeScale = pv.Scale.linear(minMax.min, minMax.max).range(startAngle, endScaleAngle);
        range.endAngle(gaugeScale(value * clockwise));
        if (1 || gaugeProps.totalLabel.visible) {
            var text = gaugeProps.totalLabel.content;
            if (text === "auto") {
                var config = {
                    object: "totalLabel",
                    bucketID: "value",
                    ids: {
                        series: 0,
                        group: 0
                    }
                };
                text = chart.formatNumber(value, gaugeProps.totalLabel.numberFormat, config)
            } else if (tdgchart.templateEngine.isTemplateString(text)) {
                var ids = chart.getMarkSeriesAndGroupID(chart, d);
                text = chart.parseTemplate(text, d, data, ids)
            }
            var label = gaugeProps.totalLabel;
            var font = label.font;
            if (label.fontSize) {
                var fontParts = tdg.fontToFontParts(font);
                fontParts.fontSize = label.fontSize;
                font = fontParts.toString()
            } else
                font = tdg.scaleFontToBox(text, label.font, rangeInnerR);
            panel.add(pv.Label).className("Total Label").left(w / 2).top(h / 2).text(text).font(font).textStyle(gaugeProps.totalLabel.color).textBaseline("middle").textAlign("center")
        }
    }
    function drawTextArrowGauge(chart, panel, w, h, data, isSimpleText) {
        data = data || chart.data;
        chart.addChartFrame(panel);
        var props = chart.gaugeProperties;
        var scene = chart.cache.get("tdgscene");
        var group = scene.group(panel, isSimpleText ? "simpleTextGauge" : "textArrowGauge");
        var lbl = props.totalLabel;
        var d = data[0][0] || {};
        var value = d.value;
        var config = {
            object: "dataLabels",
            bucketID: "value",
            ids: {
                series: 0,
                group: 0
            }
        };
        var text = lbl.content;
        if (text === "auto")
            text = chart.formatNumber(value, lbl.numberFormat, config);
        else if (tdgchart.templateEngine.isTemplateString(text)) {
            var ids = chart.getMarkSeriesAndGroupID(chart, d);
            text = chart.parseTemplate(text, d, data, ids)
        }
        var valueLabelSize = chart.measureLabel(text, lbl.font);
        var seriesColor, labelColor = lbl.color;
        var shape = "triangle"
          , rotation = value >= 0 ? 180 : 0;
        var mode = chart.getColorMode();
        if (mode === "byPosNeg")
            labelColor = seriesColor = value >= 0 ? chart.colorMode.posColor || "green" : chart.colorMode.negColor || "red";
        else if (mode === "byNegPos")
            labelColor = seriesColor = value < 0 ? chart.colorMode.posColor || "green" : chart.colorMode.negColor || "red";
        else
            seriesColor = chart.getSeriesAndGroupProperty(0, null, "color");
        var stroke = chart.markerStrokeStyle().call({
            index: 0,
            parent: {
                index: 0
            }
        }, d);
        var strokeWidth = chart.getSeriesAndGroupProperty(0, null, "marker.border.width");
        var radius = isSimpleText ? 0 : chart.getSeriesAndGroupProperty(0, null, "marker.size") / 2;
        var x = Math.max(radius + 10, w / 2 - valueLabelSize.width / 2);
        var className = chart.buildClassName(isSimpleText ? "simpleText" : "textArrow", 0, 0);
        var tooltip = chart.seriesToolTipLookup().call({
            index: 0,
            parent: {
                index: 0
            },
            data: function() {},
            className: function() {
                return className
            }
        }, data[0][0], data);
        var x = w / 2;
        var y = h / 2;
        var gaugeProps = chart.gaugeProperties;
        var haveGroupLabel = gaugeProps.groupLabel.visible;
        var groupLabelSize = {
            width: 0,
            height: 0
        };
        var vertDistance = 0;
        if (haveGroupLabel) {
            var labels = chart.getGroupLabels();
            var groupLabel = labels[0];
            groupLabelSize = chart.measureLabel(groupLabel, chart.gaugeProperties.groupLabel.font);
            vertDistance = chart.getPadding("label", "width")
        }
        var xg, yg;
        var xl, yl;
        var xm;
        if (gaugeProps.groupLabel.position === "left") {
            yg = yl = y;
            xg = x - (groupLabelSize.width + valueLabelSize.width + vertDistance) / 2;
            xl = xg + groupLabelSize.width + vertDistance;
            if (!isSimpleText) {
                xm = xl;
                xl += radius + 8;
                xg -= radius
            }
        } else if (gaugeProps.groupLabel.position === "right") {
            yg = yl = y;
            xl = x - (groupLabelSize.width + valueLabelSize.width + vertDistance) / 2;
            xg = xl + valueLabelSize.width + vertDistance;
            if (!isSimpleText) {
                xm = xl;
                xl += radius + 8;
                xg += radius + 8
            }
        } else if (gaugeProps.groupLabel.position === "top") {
            yg = y - valueLabelSize.height / 2;
            xg = x - groupLabelSize.width / 2;
            yl = yg + (valueLabelSize.height + groupLabelSize.height) / 2;
            xl = x - valueLabelSize.width / 2;
            if (!isSimpleText) {
                xg += 4;
                xm = xl;
                xl = xm + radius + 8
            }
        } else {
            yl = y - groupLabelSize.height / 2;
            xl = x - valueLabelSize.width / 2;
            yg = yl + (valueLabelSize.height + groupLabelSize.height) / 2;
            xg = x - groupLabelSize.width / 2;
            if (!isSimpleText) {
                xg += 4;
                xm = xl;
                xl = xm + radius + 8
            }
        }
        if (!isSimpleText)
            group.dot(xm, yl, 2 * radius, shape, {
                className: className,
                color: seriesColor,
                border: stroke,
                lineWidth: strokeWidth,
                tdgtitle: tooltip,
                rotation: rotation
            });
        if (haveGroupLabel)
            group.label(xg, yg, groupLabel, {
                shift: .35,
                font: chart.gaugeProperties.groupLabel.font,
                "class": className,
                color: chart.gaugeProperties.groupLabel.color
            });
        group.label(xl, yl, text, {
            shift: .35,
            title: isSimpleText ? tooltip : undefined,
            font: lbl.font,
            "class": chart.buildClassName("totalLabel", null, 0, "totalLabel"),
            color: labelColor
        });
        return undefined
    }
    tdgchart.prototype.drawGaugeChart = function(panel, chartLayout, passedData, minMax) {
        var chart = this;
        var data = passedData ? passedData : chart._internalData.slice(chart.dataSubset.startGroup || 0, chart.dataSubset.stopGroup || chart._internalData.length);
        if (Array.isArray(data) && !data.length)
            data = [[]];
        var layout = chart.gridLayout(panel, data);
        if (chart.gaugeProperties.layout === "simple")
            drawSimpleGauge(chart, layout.panel, layout.w, layout.h, data, minMax);
        else if (chart.gaugeProperties.layout === "textArrow")
            drawTextArrowGauge(chart, layout.panel, layout.w, layout.h, data, false);
        else if (chart.gaugeProperties.layout === "simpleText")
            drawTextArrowGauge(chart, layout.panel, layout.w, layout.h, data, true);
        else
            drawOneGaugeChart(chart, layout.panel, layout.w, layout.h, minMax);
        chart.drawChartAnnotations(layout.panel, data.length)
    }
}
)();
(function() {
    tdgchart.prototype.drawFunnelChart = drawFunnelChart;
    var tdg = tdgchart.util;
    function drawGroupLabel(chart, panel) {
        var labels = chart.getGroupLabels();
        var pad = chart.getPadding("label", "aveHorz") / 2;
        panel.anchor("bottom").add(pv.Label).textMargin(pad).text(function() {
            return labels[this.parent.parent.index]
        }).font(chart.funnelProperties.groupLabel.font).textStyle(chart.funnelProperties.groupLabel.color)
    }
    function drawOneFunnel(chart, panel, w, h) {
        function propToVal(prop, fraction, defaultVal) {
            if (prop == null)
                return defaultVal;
            else if (tdg.isPercentString(prop))
                return tdg.parsePercent(prop) * fraction;
            else
                return Math.max(0, Math.min(prop, fraction))
        }
        function findLargestLabel() {
            return tdg.maxR(chart.data, "value")
        }
        var props = chart.funnelProperties;
        var seriesCount = chart.seriesCount();
        var pad = chart.getPadding("label", "aveHorz");
        var outsideLabelGap = w * .05;
        var largestLabelWidth = chart.measureLabel("" + findLargestLabel(), "7.5pt Sans-Serif").width;
        var funnelLabelWidth = outsideLabelGap + largestLabelWidth + pad * 2;
        var padWidth = Math.min(w, h) - pad - pad;
        var leftForLabels = (w - padWidth) / 2;
        var gapWidth = propToVal(props.riserGap, padWidth / (seriesCount + 1), 0);
        var subtractFromPadWidth = 0;
        if (leftForLabels < funnelLabelWidth && chart.areDataLabelsOutside())
            subtractFromPadWidth = funnelLabelWidth - leftForLabels;
        padWidth -= subtractFromPadWidth * 2;
        var topWidth = propToVal(props.topWidth, padWidth, padWidth);
        var baseWidth = propToVal(props.baseWidth, padWidth, .2 * padWidth);
        var edgeInset = (w - topWidth) / 2;
        var groupLabelHeight = props.groupLabel.visible ? tdg.measureFont(props.groupLabel.font).height : 0;
        var adjustedH = h - chart.getPadding("label", "height") - groupLabelHeight + gapWidth;
        var r = (topWidth - baseWidth) / 2 / adjustedH;
        function top() {
            var s = this.sibling();
            return Math.floor(this.index === 0 ? 0 : Math.min(s.top + s.height + gapWidth, adjustedH - gapWidth))
        }
        function edge() {
            var s = this.sibling();
            return this.index === 0 ? edgeInset : s.inset + s.left
        }
        function height(d, data) {
            if (d && tdg.eq(d.value, 0))
                return 0;
            var sum = tdg.sum(data.map(function(el) {
                return Math.abs(el.value || 0)
            }));
            var y = pv.Scale.linear(0, sum).range(0, adjustedH);
            return Math.floor(Math.max(y(Math.abs(d.value)) - gapWidth, 1) || 0)
        }
        function inset() {
            return this.height() * r
        }
        var funnel = panel.add(pv.Trapezoid).data(function(d) {
            return d
        }).className(chart.classNameLookup("riser", "riser")).top(top).height(height).left(edge).right(edge).inset(inset).fillStyle(chart.seriesColorLookup()).lineStyle(chart.seriesPropertyLookup("border")).title(chart.seriesToolTipLookup());
        chart.addBevel(funnel);
        if (props.groupLabel.visible)
            drawGroupLabel(chart, panel);
        if (topWidth < baseWidth) {
            var bottomOffSet = (baseWidth - topWidth) / 2;
            outsideLabelGap += bottomOffSet
        }
        function feelerWidth() {
            var parent = this.anchorTarget().anchorTarget();
            var inset = parent.inset();
            var height = parent.height() || 1;
            var halfHeight = height / 2;
            var offset = inset / height * halfHeight;
            var LineRightOffset = w / 2 - (topWidth / 2 + outsideLabelGap);
            return offset + parent.right() - LineRightOffset - pad
        }
        var margin = topWidth / 2 + outsideLabelGap;
        if (chart.areDataLabelsOutside()) {
            var lblProps = {
                textAlign: "left",
                textBaseline: "middle",
                textMargin: margin
            };
            var labels = chart.doDataLabels(funnel, "center", lblProps);
            if (labels)
                labels.anchor("left").add(pv.Rule).visible(chart.dataLabelVisibleLookup()).display(function() {
                    return this.anchorTarget().text() == null ? "none" : null
                }).width(feelerWidth).right(w / 2 - topWidth / 2 - outsideLabelGap + pad).lineStyle(chart.seriesPropertyLookup("dataLabels.feelerLine"))
        } else
            chart.doDataLabels(funnel, "center")
    }
    function drawFunnelChart(panel) {
        var chart = this;
        var data = chart._internalData.slice(chart.dataSubset.startGroup || 0, chart.dataSubset.stopGroup || chart.data.length);
        var layout = chart.gridLayout(panel, data);
        drawOneFunnel(chart, layout.panel, layout.w, layout.h);
        chart.drawChartAnnotations(layout.panel, data.length)
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    function interpolateLineConnection(line) {
        line = line || "linear";
        return {
            linear: "linear",
            stepbefore: "step-before",
            stepbetween: "step-between",
            stepafter: "step-after",
            curved: "cardinal",
            baselinedescender: "baselineDescender"
        }[line.toLowerCase()] || "linear"
    }
    function drawSparkline(chart, panel, data) {
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        var pad = Math.min(chart.getPadding("frame", "aveHorz"), Math.min(panel.computedSize.width, panel.computedSize.height) / 2);
        var bw = pad + chart.border.width;
        var w = panel.computedSize.width - bw * 2;
        var h = panel.computedSize.height - bw * 2;
        var groupSize = (isHorizontal ? h : w) / (chart.groupCount() - 1);
        var groupPanel = panel.add(pv.Panel).width(w).height(h).left(bw).top(bw);
        groupPanel.computedSize = {
            width: w,
            height: h
        };
        var yaxis = {
            side: chart.yaxis.swapChartSide ? isHorizontal ? "top" : "right" : isHorizontal ? "bottom" : "left",
            name: "y1",
            properties: chart.yaxis
        };
        chart.cache.setProperty("yaxis.title.visible", false);
        chart.cache.setProperty("yaxis.labels.visible", false);
        var y = chart.getNumericScale(groupPanel.computedSize, yaxis);
        var interpolate = interpolateLineConnection(chart.blaProperties.lineConnection);
        data = data || (chart.isPageSliderEnabled() ? chart.data[chart.dataPageSlider.currentPage || 0] : chart.data);
        var line = groupPanel.add(pv.Line).className(chart.buildClassName("sparkline", 0, 0)).data(data[0]).interpolate(interpolate).antialias(interpolate.indexOf("step") < 0).strokeStyle(chart.seriesColorLookup()).lineWidth(chart.seriesPropertyLookup("border.width")).dashStyle(chart.seriesPropertyLookup("border.dash")).title(chart.seriesToolTipLookup());
        if (isHorizontal)
            line.top(function() {
                return this.index * groupSize
            }).left(function(d) {
                return y(d.value)
            });
        else
            line.left(function() {
                return this.index * groupSize
            }).bottom(function(d) {
                return y(d.value)
            })
    }
    function drawBullet(chart, panel, data) {
        var inMatrix = chart.chartType === "matrix";
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        var pad = chart.getPadding("frame", "aveHorz");
        var bw = pad + chart.border.width;
        var w = panel.computedSize.width - bw * 2;
        var h = panel.computedSize.height - bw * 2;
        var titleSize = chart.measureLabel(chart.title);
        var subtitleSize = chart.measureLabel(chart.subtitle);
        var titleWidth = Math.max(chart.title.visible ? titleSize.width : 0, chart.subtitle.visible ? subtitleSize.width : 0);
        var titleHeight = (chart.title.visible ? pad + titleSize.height : 0) + (chart.subtitle.visible ? pad + subtitleSize.height : 0);
        var invertAxis = chart.yaxis.invert;
        var markerList = [];
        var i, scaledValue;
        function markerPosition(pos, isHorizontal, markerSize) {
            if (isHorizontal) {
                if (pos === "top")
                    return markerSize / 2;
                else if (pos === "bottom")
                    return frameHeight - markerSize / 2;
                return frameHeight / 2
            } else {
                if (pos === "left" || pos === "top")
                    return markerSize / 2;
                else if (pos === "right" || pos === "bottom")
                    return frameWidth - markerSize / 2;
                return frameWidth / 2
            }
        }
        data = data || chart.data;
        data = chart.isPageSliderEnabled() ? data[chart.dataPageSlider.currentPage || 0] : data;
        data = data[0];
        if (tdg.isEmpty(data))
            return;
        var yaxis = {
            side: isHorizontal ? "bottom" : "left",
            name: "y1",
            properties: chart.yaxis
        };
        var barDatum, markerData = [];
        if (data[0] && data[0].value != null && chart.get("bulletProperties.drawFirstValueAsBar"))
            barDatum = data[0];
        if (chart.dataArrayMap && chart.dataArrayMap.includes("markers") && !tdg.isEmpty(data[0].markers && data.length === 1))
            markerData = data[0].markers.map(function(el, idx) {
                return {
                    _s: 0,
                    _g: idx + (barDatum ? 1 : 0),
                    value: el
                }
            });
        else if (!barDatum || data.length > 1)
            markerData = data.slice(barDatum ? 1 : 0);
        var frameX, frameY, frameWidth, frameHeight;
        if (inMatrix) {
            frameWidth = panel.computedSize.axisWidth || panel.computedSize.width;
            frameHeight = panel.computedSize.height;
            frameX = frameY = titleWidth = titleHeight = bw = 0
        } else {
            chart.cache.setProperty("yaxis.title.visible", false);
            chart.cache.setProperty("yaxis.majorGrid.visible", false);
            var axisSizeInfo = chart.axisWidth(yaxis);
            var axisSize = axisSizeInfo.size;
            frameX = isHorizontal ? titleWidth + pad : axisSize;
            frameY = 0;
            frameWidth = isHorizontal ? w - titleWidth - pad - axisSizeInfo.halfLabel : w - axisSize;
            frameHeight = isHorizontal ? h - axisSize : h - titleHeight
        }
        var scene = chart.cache.get("tdgscene");
        var group = scene.group(panel, "bullet", bw, bw);
        var bulletGroup = group.group("bullet-frame", frameX, frameY);
        var frameStyle = {
            className: "chartFrame",
            antialias: false,
            color: "lightgrey"
        };
        if (inMatrix)
            bulletGroup.rect(0, 0, panel.computedSize.width, panel.computedSize.height, frameStyle);
        else
            bulletGroup.rect(0, 0, frameWidth, frameHeight, frameStyle);
        var axisGroup = bulletGroup.group("yaxis", isHorizontal ? 0 : -frameWidth, isHorizontal ? frameHeight : 0);
        axisGroup.computedSize = {
            width: frameWidth,
            height: frameHeight
        };
        var scale = chart.getNumericScale(axisGroup.computedSize, yaxis);
        scale.side = isHorizontal ? "bottom" : "left";
        var bands = chart.get("yaxis.colorBands", []);
        for (i = 0; i < bands.length; i++) {
            var band = bands[i];
            var scaledStart = scale(band.start);
            var scaledStop = scale(band.stop);
            var bandX = isHorizontal ? scaledStart : 0;
            var bandY = isHorizontal ? 0 : frameHeight - scaledStop;
            var bandWidth = isHorizontal ? scaledStop : frameWidth;
            var bandHeight = isHorizontal ? frameHeight : scaledStop - scaledStart;
            var bandStyle = {
                className: chart.buildClassName("yaxis-colorBand", null, null, i),
                color: band.color,
                antialias: false
            };
            bulletGroup.rect(bandX, bandY, bandWidth, bandHeight, bandStyle)
        }
        var riserGroup = bulletGroup.group("risers");
        if (barDatum) {
            var labelAnchor = isHorizontal ? invertAxis ? "left" : "right" : invertAxis ? "bottom" : "top";
            chart.addExceptionalProperty("dataLabels.position", labelAnchor, 0, 0);
            var barStyle = {
                className: chart.getRiserClassName(riserGroup, barDatum, "riser", "bar"),
                color: chart.getSeriesAndGroupProperty(0, 0, "color"),
                lineStyle: chart.getSeriesAndGroupProperty(0, 0, "border") || {
                    width: 0,
                    color: "black",
                    dash: ""
                },
                title: chart.getSerDepProperty("tooltip", barDatum),
                antialias: false
            };
            scaledValue = scale(barDatum.value);
            var barWidth = isHorizontal ? invertAxis ? frameWidth - scaledValue : scaledValue : frameWidth / 2.6;
            var barHeight = isHorizontal ? frameHeight / 2.6 : invertAxis ? frameHeight - scaledValue : scaledValue;
            var barX = isHorizontal ? invertAxis ? scaledValue : 0 : frameWidth / 3.25;
            var barY = isHorizontal ? frameHeight / 3.25 : invertAxis ? 0 : frameHeight - barHeight;
            var bar = riserGroup.rect(barX, barY, barWidth, barHeight, barStyle);
            bar.d = barDatum;
            bar.data = data;
            markerList.push(bar)
        }
        for (i = 0; i < markerData.length; i++) {
            var d = markerData[i];
            if (!d || d.value == null)
                continue;
            var markerStyle = {
                className: chart.getRiserClassName(riserGroup, d, "riser", "marker"),
                color: chart.getSeriesAndGroupProperty(0, d._g, "color"),
                lineStyle: chart.getSeriesAndGroupProperty(0, d._g, "marker.border")
            };
            var shape = chart.getSeriesAndGroupProperty(0, d._g, "marker.shape");
            var size = chart.getSeriesAndGroupProperty(0, d._g, "marker.size");
            var markerPos = markerPosition(chart.getSeriesAndGroupProperty(0, d._g, "marker.position"), isHorizontal, size);
            scaledValue = scale(d.value);
            var markerX = isHorizontal ? scaledValue : markerPos;
            var markerY = isHorizontal ? markerPos : frameHeight - scaledValue;
            var marker = riserGroup.dot(markerX, markerY, size, shape, markerStyle);
            marker.d = d;
            marker.data = data;
            markerList.push(marker)
        }
        chart.doDataLabelsScene(riserGroup, [markerList]);
        if (inMatrix)
            return;
        var panels = {
            axis: [],
            yAxis: {
                fg: axisGroup,
                bg: axisGroup,
                axis: axisGroup,
                title: axisGroup
            },
            chartSize: axisGroup.computedSize
        };
        chart.drawNumericAxis(panels, scale, yaxis);
        var titleX = isHorizontal ? frameX - pad : frameX + frameWidth / 2;
        if (chart.title.visible) {
            var titleStyle = {
                className: "title",
                font: chart.title.font,
                color: chart.title.color,
                align: isHorizontal ? "right" : "middle",
                valign: isHorizontal ? chart.subtitle.visible ? "bottom" : "middle" : "top"
            };
            var titleY = isHorizontal ? frameHeight / 2 - 4 : frameHeight + pad;
            group.label(titleX, titleY, chart.title.text, titleStyle)
        }
        if (chart.subtitle.visible) {
            var subtitleStyle = {
                className: "subtitle",
                font: chart.subtitle.font,
                color: chart.subtitle.color,
                align: isHorizontal ? "right" : "middle",
                valign: isHorizontal ? chart.title.visible ? "top" : "middle" : "top"
            };
            var subtitleY = isHorizontal ? frameHeight / 2 : frameHeight + pad + titleSize.height + pad;
            group.label(titleX, subtitleY, chart.subtitle.text, subtitleStyle)
        }
    }
    function drawMarkerChart(chart, panel, data, sizeMinMax) {
        var w = panel.computedSize.width;
        var h = panel.computedSize.height;
        data = data || (chart.isPageSliderEnabled() ? chart.data[chart.dataPageSlider.currentPage || 0] : chart.data);
        if (!data || !data[0] || !data[0].length)
            return;
        data = data[0];
        if (data[0] == null || data[0].size == null && data[0].color == null)
            return;
        var marker, markerShape;
        if (data.length === 1 && chart.chartType === "matrix") {
            var shape = chart.getSerDepProperty("marker.shape", data[0]);
            if (typeof shape === "string" && shape.toLowerCase() === "fill")
                markerShape = "fill"
        }
        if (markerShape === "fill")
            marker = panel.add(pv.Bar).data(data).left(0).top(0).width(w).height(h).antialias(false);
        else {
            sizeMinMax = sizeMinMax || chart.getScaleMinMax(chart.zaxis, "z1");
            marker = panel.add(pv.Dot).data(data).left(w / 2).top(h / 2).shape(chart.seriesPropertyLookup("marker.shape")).angle(chart.markerRotationLookup()).radius(markerSize(chart, panel, data[0].size || 0, sizeMinMax)).includeRadius(chart.mouseOverIndicator.enabled || chart.needHTMLToolTip())
        }
        marker.className(chart.classNameLookup("marker", "riser")).fillStyle(chart.seriesColorLookup()).strokeStyle(chart.markerStrokeStyle()).lineWidth(chart.seriesPropertyLookup("marker.border.width")).dashStyle(chart.seriesPropertyLookup("marker.border.dash")).shadow(chart.riserShadow ? "parent" : null).title(chart.seriesToolTipLookup());
        chart.addBevel(marker);
        chart.doDataLabels(marker, null, {
            textMargin: 5
        })
    }
    function markerSize(chart, panel, d, sizeMinMax) {
        var maxBubbleR = Math.min(panel.computedSize.width, panel.computedSize.height) - 6;
        return chart.dataDrivenMarkerSize("size", {
            min: 2,
            max: maxBubbleR
        }, sizeMinMax, d)
    }
    tdgchart.prototype.drawSimpleLabelChart = function(panel) {
        var chart = this;
        chart.addChartFrame(panel);
        var label = tdg.clone(chart.simpleLabelProperties);
        if (tdgchart.templateEngine.isTemplateString(label.text)) {
            var ids = {
                series: 0,
                group: 0
            };
            var data = chart.getDataFromIds(ids);
            label.text = chart.parseTemplate(label.text, data.d, data.data, ids) || label.text
        }
        chart.drawLabel(panel, label, "simpleLabel")
    }
    ;
    tdgchart.prototype.drawMicroChart = function(panel, chartType, data, sizeMinMax) {
        var chart = this;
        chartType = chartType || chart.chartType;
        if (chartType === "sparkline")
            drawSparkline(chart, panel, data);
        else if (chartType === "bullet")
            drawBullet(chart, panel, data);
        else if (chartType === "marker")
            drawMarkerChart(chart, panel, data, sizeMinMax)
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    function isOtherRiser(chart, index, d) {
        var isOther = (d || {}).subtotal;
        if (typeof isOther === "number" && isOther === 3)
            return true;
        var others = chart.waterfallProperties.otherRisers;
        var labels = chart.getGroupLabels();
        return others.indexOf(index) > -1 || others.indexOf(labels[index]) > -1
    }
    function isTotalRiser(index, d, data) {
        var isTotal = (d || {}).subtotal;
        if (typeof isTotal === "number" && isTotal === 2)
            return true;
        else if (Array.isArray(data) && index === data.length - 1)
            return true;
        return false
    }
    tdgchart.prototype.isSubtotalRiser = function(index, d) {
        var chart = this;
        var isSubtotal = (d || {}).subtotal;
        if (typeof isSubtotal === "number" && (isSubtotal === 1 || isSubtotal === 2))
            return true;
        else if (typeof isSubtotal === "boolean" && isSubtotal === true)
            return true;
        else if (chart.waterfallProperties.appendTotalRiser && index === chart._internalData[0].length)
            return true;
        var subtotals = chart.waterfallProperties.subtotalRisers;
        var labels = chart.getGroupLabels();
        return subtotals.indexOf(index) > -1 || subtotals.indexOf(labels[index]) > -1
    }
    ;
    function addWaterfall(rootPanel, data, x, y) {
        var chart = this;
        if (data.length === 0)
            return null;
        if (Array.isArray(data[0]))
            data = [data[0]];
        var panel = rootPanel.add(pv.Panel).className("groupPanel");
        panel.computedSize = rootPanel.computedSize;
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        var wfallProps = chart.waterfallProperties;
        var w = panel.computedSize.width;
        var h = panel.computedSize.height;
        if (wfallProps.appendTotalRiser) {
            var total = 0;
            for (var i = 0; i < data[0].length; i++) {
                var d = data[0][i];
                var val = d.value ? d.value : d.total || 0;
                total = chart.isSubtotalRiser(i, d) ? val : total + val
            }
            data[0].push({
                total: total,
                value: total,
                y: total,
                _s: 0,
                _g: data[0].length
            })
        }
        function invert(d) {
            return chart.yaxis.invert ? d.y >= 0 : d.y < 0
        }
        var baselineValue = chart.getAxisBaselineValue(y);
        var baseline = chart.getAxisBaseline(y, chart.yaxis.invert);
        var naiveBaseLine = y(baselineValue);
        function barHeight(d) {
            var baselineUsed = this.index === 0 || chart.isSubtotalRiser(this.index, d) ? baseline : naiveBaseLine;
            var bh = invert(d) ? baselineUsed - y(d.y) : y(d.y) - baselineUsed;
            this.adjustHeight = 0;
            if (bh < 1) {
                bh = 2;
                this.adjustHeight = 2
            }
            return bh
        }
        var barWidth = x.range().band / chart.seriesCount();
        var barInset = function() {
            return x(this.index) + this.parent.index * barWidth
        };
        function bottom(d) {
            if (invert(d))
                return null;
            if (this.index === 0 || chart.isSubtotalRiser(this.index, d))
                return baseline;
            var s = this.sibling();
            var adjustHeight = this.adjustHeight || 0;
            return !invert(s.data) ? s.bottom + (s.height || 0) - adjustHeight : h - s.top - (s.height || 0) + adjustHeight
        }
        function top(d) {
            if (!invert(d) && d.y != null)
                return null;
            if (this.index === 0 || chart.isSubtotalRiser(this.index, d))
                return h - baseline;
            var s = this.sibling();
            var adjustHeight = this.adjustHeight || 0;
            return !invert(s.data) ? h - s.bottom - (s.height || 0) + adjustHeight : s.top + (s.height || 0) - adjustHeight
        }
        function left(d) {
            if (invert(d))
                return null;
            if (this.index === 0 || chart.isSubtotalRiser(this.index, d))
                return baseline;
            var s = this.sibling();
            return !invert(s.data) ? s.left + (s.width || 0) : w - s.right - (s.width || 0)
        }
        function right(d) {
            if (!invert(d))
                return null;
            if (this.index === 0 || chart.isSubtotalRiser(this.index, d))
                return w - baseline;
            var s = this.sibling();
            return !invert(s.data) ? w - s.left - (s.width || 0) : s.right + (s.width || 0)
        }
        panel.data(data);
        var depth = chart.depth25d();
        var bar = panel.add(depth ? pv.Bar25d : pv.Bar).className(chart.classNameLookup("bar", "riser")).data(function(d) {
            return d
        });
        if (depth)
            bar.depth(depth).dmargin(chart.getRiserDepthGap());
        if (isHorizontal)
            bar.top(barInset).height(barWidth).left(left).right(right).width(barHeight);
        else
            bar.left(barInset).width(barWidth).bottom(bottom).top(top).height(barHeight);
        var lookup = chart.seriesColorLookup();
        function fill(d, data) {
            var series = chart.getSeriesAndGroup(this.parent.index, this.index);
            if (series != null && series.color != null)
                return series.color;
            else if (chart.waterfallProperties.firstLastFormat && chart.waterfallProperties.firstLastFormat.color && (this.index === 0 || this.index === data.length - 1))
                return chart.waterfallProperties.firstLastFormat.color;
            else if (isOtherRiser(chart, this.index, d) && wfallProps.otherRiserColor != null)
                return wfallProps.otherRiserColor;
            else if (isTotalRiser(this.index, d, data) && wfallProps.totalRiserColor != null)
                return wfallProps.totalRiserColor;
            else if (chart.isSubtotalRiser(this.index, d) && wfallProps.zeroRiserColor != null)
                return wfallProps.zeroRiserColor;
            else if (d.y >= 0 && wfallProps.positiveRiserColor != null)
                return wfallProps.positiveRiserColor;
            else if (d.y < 0 && wfallProps.negativeRiserColor != null)
                return wfallProps.negativeRiserColor;
            return lookup.call(this, d)
        }
        var borderLookup = chart.seriesPropertyLookup("border");
        function border(d) {
            if (chart.waterfallProperties.firstLastFormat && chart.waterfallProperties.firstLastFormat.border && (this.index === 0 || this.index === data[0].length - 1))
                return chart.waterfallProperties.firstLastFormat.border;
            return borderLookup.call(this, d)
        }
        bar.fillStyle(fill).lineStyle(border).antialias(false).title(chart.seriesToolTipLookup());
        function lineLeft(d, data) {
            var idx = data[data.length - 1];
            return this.index === 0 ? x(idx) + barWidth : x(idx + 1)
        }
        var connector = chart.waterfallProperties.connectorLine;
        if (connector.color !== "transparent" && chart.blaProperties.barGroupGapWidth > 0) {
            var sum = 0;
            var lineData = data[0].slice(0, data[0].length - 1);
            lineData = lineData.map(function(el, index) {
                var isSubtotal = chart.isSubtotalRiser(index, el);
                if (isSubtotal && chart.isSubtotalRiser(index + 1, lineData[index + 1]))
                    return null;
                sum = isSubtotal ? el.y || 0 : sum + (el.y || 0);
                var yPos = y(sum);
                return [yPos, yPos, index]
            });
            lineData = lineData.filter(function(el) {
                return el != null
            });
            var linePanel = panel.add(pv.Panel).data(lineData);
            var lines = linePanel.add(pv.Line).className(function() {
                return chart.buildClassName("waterfallProperties-connectorLine", this.parent.index, this.index)
            }).data(function(d) {
                return d.slice(0, 2)
            }).antialias(false).lineStyle(connector);
            if (isHorizontal)
                lines.left(function(d) {
                    return d
                }).top(lineLeft);
            else
                lines.left(lineLeft).bottom(function(d) {
                    return d
                })
        }
        function invertLabel(mark) {
            var d = mark.data();
            return chart.yaxis.invert ? d.y >= 0 : d.y < 0
        }
        if (chart.waterfallProperties.subtotalFormat && chart.waterfallProperties.subtotalFormat.numberFormat)
            data[0].map(function(d, idx) {
                d = d || {};
                if (chart.isSubtotalRiser(idx, d))
                    d._numberFormat = chart.waterfallProperties.subtotalFormat.numberFormat
            });
        var overrides;
        if (chart.waterfallProperties.subtotalFormat && (chart.waterfallProperties.subtotalFormat.dataLabelPosition || chart.waterfallProperties.subtotalFormat.color)) {
            var subtotalOverride = {
                position: chart.waterfallProperties.subtotalFormat.dataLabelPosition,
                color: chart.waterfallProperties.subtotalFormat.color
            };
            overrides = data[0].map(function(d, idx) {
                return chart.isSubtotalRiser(idx, d) ? subtotalOverride : null
            })
        }
        var labelPos = chart.dataTextAnchorOverride(invertLabel, false, overrides);
        chart.doDataLabels(bar, labelPos.anchor, labelPos.properties, overrides);
        return {
            panel: panel,
            risers: bar
        }
    }
    tdgchart.prototype.drawWaterfall = function(panel, chartLayout) {
        var chart = this;
        var chartPanels = chart.createBLAScrollXYPanels(panel, chartLayout.chartSize, chartLayout);
        var data = chart.adjustData(chart._internalData);
        applyWaterfallSubtotalsRules(chart, chartPanels, chartLayout, data);
        chart.drawXOrdinalYChart(chartPanels, chartLayout, data, addWaterfall)
    }
    ;
    function applyWaterfallSubtotalsRules(chart, chartPanels, chartLayout, data) {
        var subtotals = data[0].map(function(d, idx) {
            return chart.isSubtotalRiser(idx, d)
        });
        if (chart.waterfallProperties.subtotalFormat && chart.waterfallProperties.subtotalFormat.bold) {
            var boldFont = "bold " + chart.xaxis.labels.font;
            chart.cache.set("xAxisLabelsFont", function(d, index) {
                return subtotals[index == null ? this.index : index] ? boldFont : chart.xaxis.labels.font
            })
        }
        drawWaterfallGroupDividers(chart, chartPanels, chartLayout, data)
    }
    function drawWaterfallGroupDividers(chart, chartPanels, chartLayout, data) {
        var line = (chart.waterfallProperties.subtotalFormat || {}).dividerLine;
        if (line && line.width) {
            var subtotals = data[0].map(function(d, idx) {
                if (d.hasOwnProperty("underline") && !d.underline)
                    return false;
                return chart.isSubtotalRiser(idx, d)
            });
            var x = chartLayout.axisLayout.xScalesList[0];
            var xaxis = chartLayout.axisLayout.xAxisList[0];
            drawOrdDividers(chart, chartPanels.xAxis.axis, x, xaxis, subtotals, line);
            drawOrdDividers(chart, chartPanels.xAxis.bg, x, xaxis, subtotals, line)
        }
    }
    function drawOrdDividers(chart, panel, scale, axis, groups, lineProps) {
        if (panel == null || scale == null)
            return;
        if (!lineProps || !lineProps.width)
            return;
        var scene = chart.cache.get("tdgscene");
        var isHorizontal = axis.side === "left" || axis.side === "right";
        var barWidth = scale.range().band / chart.seriesCount();
        var panelWidth = panel.computedSize.width
          , panelHeight = panel.computedSize.height;
        if (!tdgchart.tdgscene.isTDGSceneGroup(panel))
            panel = scene.group(panel);
        lineProps.color = lineProps.color || "black";
        var lineStyle = {
            lineStyle: lineProps,
            antialias: false
        };
        for (var i = 0; i < groups.length; i++)
            if (groups[i]) {
                var top = (scale(i) + scale(i - 1) + barWidth) / 2;
                var x1 = 0
                  , y1 = 0
                  , x2 = panelWidth
                  , y2 = panelHeight;
                if (isHorizontal)
                    y1 = y2 = top;
                else
                    x1 = x2 = top;
                var axisName = chart.axisNameToClassName(axis.name);
                if (axisName.includes("xaxisOrdinal"))
                    axisName = "xaxis";
                lineStyle.className = chart.buildClassName(axisName + "-groupDivider", null, null, i);
                panel.line(x1, y1, x2, y2, lineStyle)
            }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.calculateBoxplotStats = function() {
        var chart = this;
        if (!Array.isArray(chart.dataArrayMap) || !chart.dataArrayMap.includes("markList"))
            return;
        var data = chart._internalData || chart.data;
        for (var s = 0; s < data.length; s++) {
            var seriesData = data[s] || [];
            for (var g = 0; g < seriesData.length; g++) {
                var d = seriesData[g];
                if (d.hasOwnProperty("markList"))
                    calculateOneBoxplot(d)
            }
        }
    }
    ;
    function calculateOneBoxplot(d) {
        if (!d || !d.markList || !Array.isArray(d.markList))
            return;
        var markList = tdg.clone(d.markList);
        markList = markList.sort(function(a, b) {
            return a - b
        });
        d.median = tdg.median(markList, null, true);
        var count = markList.length;
        var lowerSplit = count % 2 ? (count - 1) / 2 : count / 2;
        var upperSplit = count % 2 ? (count - 1) / 2 + 1 : count / 2;
        d.lower = tdg.median(markList.slice(0, lowerSplit), null, true);
        d.upper = tdg.median(markList.slice(upperSplit), null, true);
        var iqr = (d.upper - d.lower) * 1.5;
        d.min = Math.max(d.lower - iqr, markList[0]);
        d.max = Math.min(d.upper + iqr, markList[markList.length - 1]);
        d.outliers = markList.filter(function(el) {
            return el < d.lower - iqr || el > d.upper + iqr
        })
    }
    function addRiser(list, s, g, d, key) {
        d = tdg.clone(d);
        d.x = d.y = d.value = d[key];
        list[s] = list[s] || [];
        var res = list[s][g] = {
            d: d,
            props: {
                w: 0,
                h: 0
            }
        };
        return res
    }
    function addBoxplot(panel, data, x, y) {
        if (!data || !data.length)
            return;
        var chart = this;
        var scene = chart.cache.get("tdgscene");
        var group = scene.group(panel, "groupPanel");
        var allRiserGroup = group.group("risers", null, null, null, null, null, {
            antialias: false
        });
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        var w = panel.computedSize.width;
        var h = panel.computedSize.height;
        var s, g;
        var drawHatAsBox = chart.get("boxPlotProperties.drawHatAsBox");
        var colorLookup = chart.seriesColorLookup({
            width: w,
            height: h,
            isScene: true
        });
        var hatStyle = chart.get("boxPlotProperties.connectorLine", {});
        var medianLineStyle = chart.get("boxPlotProperties.medianLine", {});
        var barWidth = x.range().band / chart.seriesCount();
        var hatWidth = chart.get("boxPlotProperties.hatWidth");
        hatWidth = hatWidth == null ? "100%" : hatWidth;
        hatWidth = tdg.applyNumOrPercent(hatWidth, barWidth);
        var hatStart = (barWidth - hatWidth) / 2;
        var xCenter = barWidth / 2;
        var riserLists;
        if (chart.areDataLabelsVisible())
            riserLists = {
                topWhiskerRisers: [],
                topBoxRisers: [],
                medianRisers: [],
                bottomBoxRisers: [],
                bottomWhiskerRisers: []
            };
        var notch = {
            haveNotch: false,
            width: barWidth,
            inset: 0
        };
        var notchWidth = chart.get("boxPlotProperties.notch.width");
        if (tdg.isPercentString(notchWidth)) {
            notch.haveNotch = true;
            notch.width = tdg.applyNumOrPercent(notchWidth, barWidth);
            notch.inset = (barWidth - notch.width) / 2
        }
        for (s = 0; s < data.length; s++) {
            var seriesData = data[s] || [];
            var seriesX = isHorizontal ? 0 : barWidth * s
              , seriesY = isHorizontal ? barWidth * s : 0;
            var seriesGroup = allRiserGroup.group(null, seriesX, seriesY);
            var outlierProps = chart.getSerDepProperty("marker", s) || {};
            for (g = 0; g < seriesData.length; g++) {
                var d = seriesData[g];
                if (!d)
                    continue;
                var groupX = isHorizontal ? 0 : x(g)
                  , groupY = isHorizontal ? x(g) : 0;
                var riserGroup = seriesGroup.group(null, groupX, groupY);
                var boxStyle = {
                    color: colorLookup(d),
                    lineStyle: chart.getSerDepProperty("border", d),
                    className: chart.buildClassName("box", s, g)
                };
                var mx, my;
                var yMin = y(d.min)
                  , yMax = y(d.max);
                var boxMin = y(d.lower)
                  , boxMax = y(d.upper);
                var yStart, barHeight = Math.abs(boxMax - boxMin);
                var yMedian = y(d.median);
                if (drawHatAsBox) {
                    var boxHeight = Math.abs(yMin - yMax);
                    var hatBoxStyle = tdg.clone(boxStyle);
                    hatBoxStyle.className = chart.buildClassName("hatBox", s, g);
                    if (isHorizontal) {
                        yStart = chart.axisList.y1.invert ? yMax : yMin;
                        riserGroup.rect(yStart, hatStart, boxHeight, hatWidth, hatBoxStyle)
                    } else {
                        yStart = chart.axisList.y1.invert ? yMin : yMax;
                        riserGroup.rect(hatStart, h - yStart, hatWidth, boxHeight, hatBoxStyle)
                    }
                    if (riserLists) {
                        var topWhiskerBoxRiser = addRiser(riserLists.topWhiskerRisers, s, g, d, "max");
                        var bottomWhiskerBoxRiser = addRiser(riserLists.bottomWhiskerRisers, s, g, d, "min");
                        if (isHorizontal) {
                            topWhiskerBoxRiser.props.h = bottomWhiskerBoxRiser.props.h = barWidth;
                            topWhiskerBoxRiser.props.y = bottomWhiskerBoxRiser.props.y = seriesY + groupY;
                            topWhiskerBoxRiser.props.x = seriesX + groupX + yMax;
                            bottomWhiskerBoxRiser.props.x = seriesX + groupX + yMin
                        } else {
                            topWhiskerBoxRiser.props.w = bottomWhiskerBoxRiser.props.w = barWidth;
                            topWhiskerBoxRiser.props.x = bottomWhiskerBoxRiser.props.x = seriesX + groupX;
                            topWhiskerBoxRiser.props.y = seriesY + groupY + h - yMax;
                            bottomWhiskerBoxRiser.props.y = seriesY + groupY + h - yMin
                        }
                    }
                }
                if (tdg.isANumber(boxMin) && tdg.isANumber(boxMax)) {
                    var notchMultiplier = chart.get("boxPlotProperties.notch.multiplier") || 1.58;
                    var pointCount = Array.isArray(d.markList) ? d.markList.length : d.point_count;
                    if (tdg.isANumber(yMedian) && notch.haveNotch && tdg.isANumber(pointCount)) {
                        var notchValue = notchMultiplier * (d.upper - d.lower) / Math.sqrt(pointCount);
                        var yMinNotch = y(d.median - notchValue);
                        var yMaxNotch = y(d.median + notchValue);
                        var notchPath = "";
                        var notchInsetOnMin = yMinNotch > boxMin || yMinNotch == yMedian ? undefined : notch.inset * (yMinNotch - boxMin) / (yMinNotch - yMedian);
                        var notchInsetOnMax = yMaxNotch < boxMax || yMaxNotch == yMedian ? undefined : notch.inset * (yMaxNotch - boxMax) / (yMaxNotch - yMedian);
                        if (isHorizontal)
                            notchPath = (notchInsetOnMin == undefined ? "M" + boxMin + ",0" + "v" + barWidth + "H" + yMinNotch : "M" + boxMin + "," + notchInsetOnMin + "v" + (barWidth - 2 * notchInsetOnMin)) + "L" + yMedian + "," + (notch.inset + notch.width) + (notchInsetOnMax == undefined ? "L" + yMaxNotch + "," + barWidth + "H" + boxMax : "L" + boxMax + "," + (barWidth - notchInsetOnMax)) + (notchInsetOnMax == undefined ? "V0" + "H" + yMaxNotch : "V" + notchInsetOnMax) + "L" + yMedian + "," + notch.inset + (notchInsetOnMin == undefined ? "L" + yMinNotch + ",0" : "") + "Z";
                        else
                            notchPath = (notchInsetOnMax == undefined ? "M0," + (h - boxMax) + "h" + barWidth + "V" + (h - yMaxNotch) : "M" + notchInsetOnMax + "," + (h - boxMax) + "h" + (barWidth - 2 * notchInsetOnMax)) + "L" + (notch.inset + notch.width) + "," + (h - yMedian) + (notchInsetOnMin == undefined ? "L" + barWidth + "," + (h - yMinNotch) + "L" + barWidth + "," + (h - boxMin) : "L" + (barWidth - notchInsetOnMin) + "," + (h - boxMin)) + (notchInsetOnMin == undefined ? "H0" + "V" + (h - yMinNotch) : "H" + notchInsetOnMin) + "L" + notch.inset + "," + (h - yMedian) + (notchInsetOnMax == undefined ? "L0," + (h - yMaxNotch) : "L" + notchInsetOnMax + "," + (h - boxMax)) + "Z";
                        boxStyle.antialias = true;
                        riserGroup.path(0, 0, notchPath, boxStyle)
                    } else if (isHorizontal) {
                        yStart = chart.axisList.y1.invert ? boxMax : boxMin;
                        riserGroup.rect(yStart, 0, barHeight, barWidth, boxStyle)
                    } else {
                        yStart = chart.axisList.y1.invert ? boxMin : boxMax;
                        riserGroup.rect(0, h - yStart, barWidth, barHeight, boxStyle)
                    }
                    if (riserLists) {
                        var bottomRiser = addRiser(riserLists.bottomBoxRisers, s, g, d, "lower");
                        var topRiser = addRiser(riserLists.topBoxRisers, s, g, d, "upper");
                        if (isHorizontal) {
                            topRiser.props.h = bottomRiser.props.h = barWidth;
                            topRiser.props.y = bottomRiser.props.y = seriesY + groupY;
                            bottomRiser.props.x = seriesX + groupX + boxMin;
                            topRiser.props.x = seriesX + groupX + boxMax
                        } else {
                            topRiser.props.w = bottomRiser.props.w = barWidth;
                            topRiser.props.x = bottomRiser.props.x = seriesX + groupX;
                            bottomRiser.props.y = seriesY + groupY + h - boxMin;
                            topRiser.props.y = seriesY + groupY + h - boxMax
                        }
                    }
                }
                if (!drawHatAsBox && tdg.color.isLineVisible(hatStyle)) {
                    var connectorPath = "";
                    if (isHorizontal) {
                        if (tdg.isANumber(yMin)) {
                            connectorPath += "M" + yMin + "," + hatStart + "v" + hatWidth;
                            if (tdg.isANumber(boxMin))
                                connectorPath += "M" + yMin + "," + xCenter + "H" + boxMin
                        }
                        if (tdg.isANumber(yMax)) {
                            connectorPath += "M" + yMax + "," + hatStart + "v" + hatWidth;
                            if (tdg.isANumber(boxMax))
                                connectorPath += "M" + yMax + "," + xCenter + "H" + boxMax
                        }
                    } else {
                        if (tdg.isANumber(yMax)) {
                            connectorPath += "M" + hatStart + "," + (h - yMax) + "h" + hatWidth;
                            if (tdg.isANumber(boxMax))
                                connectorPath += "M" + xCenter + "," + (h - yMax) + "V" + (h - boxMax)
                        }
                        if (tdg.isANumber(yMin)) {
                            connectorPath += "M" + hatStart + "," + (h - yMin) + "h" + hatWidth;
                            if (tdg.isANumber(boxMin))
                                connectorPath += "M" + xCenter + "," + (h - boxMin) + "V" + (h - yMin)
                        }
                    }
                    var connectorStyle = {
                        className: chart.buildClassName("hatLine", s, g),
                        lineStyle: hatStyle
                    };
                    riserGroup.path(0, 0, connectorPath, connectorStyle);
                    if (riserLists) {
                        var bottomWhiskerRiser = addRiser(riserLists.bottomWhiskerRisers, s, g, d, "min");
                        var topWhiskerRiser = addRiser(riserLists.topWhiskerRisers, s, g, d, "max");
                        if (isHorizontal) {
                            topWhiskerRiser.props.h = bottomWhiskerRiser.props.h = barWidth;
                            topWhiskerRiser.props.y = bottomWhiskerRiser.props.y = seriesY + groupY;
                            topWhiskerRiser.props.x = seriesX + groupX + yMax;
                            bottomWhiskerRiser.props.x = seriesX + groupX + yMin
                        } else {
                            topWhiskerRiser.props.w = bottomWhiskerRiser.props.w = barWidth;
                            topWhiskerRiser.props.x = bottomWhiskerRiser.props.x = seriesX + groupX;
                            topWhiskerRiser.props.y = seriesY + groupY + h - yMax;
                            bottomWhiskerRiser.props.y = seriesY + groupY + h - yMin
                        }
                    }
                }
                if (tdg.isANumber(yMedian) && tdg.color.isLineVisible(medianLineStyle)) {
                    var medianStyle = {
                        className: chart.buildClassName("medianLine", s, g),
                        lineStyle: medianLineStyle
                    };
                    if (isHorizontal)
                        riserGroup.line(yMedian, notch.inset, yMedian, notch.inset + notch.width, medianStyle);
                    else
                        riserGroup.line(notch.inset, h - yMedian, notch.inset + notch.width, h - yMedian, medianStyle);
                    if (riserLists) {
                        var medianRiser = addRiser(riserLists.medianRisers, s, g, d, "median");
                        if (isHorizontal) {
                            medianRiser.props.h = barWidth;
                            medianRiser.props.x = seriesX + groupX + yMedian;
                            medianRiser.props.y = seriesY + groupY
                        } else {
                            medianRiser.props.w = barWidth;
                            medianRiser.props.x = seriesX + groupX;
                            medianRiser.props.y = seriesY + groupY + h - yMedian
                        }
                    }
                }
                var meanMarkerStyle = chart.get("boxPlotProperties.meanMarker");
                if ((Array.isArray(d.markList) || tdg.isANumber(d.mean)) && meanMarkerStyle && meanMarkerStyle.visible) {
                    meanMarkerStyle.lineStyle = meanMarkerStyle.border;
                    var mean = Array.isArray(d.markList) ? tdg.mean(d.markList) : d.mean;
                    var yMean = y(mean);
                    if (tdg.isANumber(yMean)) {
                        meanMarkerStyle.antialias = true;
                        var shape = meanMarkerStyle.shape || "circle";
                        var size = meanMarkerStyle.size || 10;
                        mx = isHorizontal ? yMean : xCenter;
                        my = isHorizontal ? xCenter : h - yMean;
                        riserGroup.dot(mx, my, size, shape, meanMarkerStyle)
                    }
                }
                var eventCatcherStyle = {
                    className: chart.getRiserClassName(seriesGroup, d, "riser", "box"),
                    color: "transparent",
                    title: chart.getSerDepProperty("tooltip", d)
                };
                if (isHorizontal) {
                    var left = [yMin, boxMin, yMedian, boxMax, yMax].filter(tdg.isANumber)[0];
                    var right = [yMax, boxMax, yMedian, boxMin, yMin].filter(tdg.isANumber)[0];
                    if (tdg.isANumber(left) && tdg.isANumber(right) && left < right)
                        riserGroup.rect(left, 0, right - left, barWidth, eventCatcherStyle)
                } else {
                    var top = [yMax, boxMax, yMedian, boxMin, yMin].filter(tdg.isANumber)[0];
                    var bottom = [yMin, boxMin, yMedian, boxMax, yMax].filter(tdg.isANumber)[0];
                    if (tdg.isANumber(top) && tdg.isANumber(bottom) && top > bottom)
                        riserGroup.rect(0, h - top, barWidth, top - bottom, eventCatcherStyle)
                }
                if (d.hasOwnProperty("outliers") && outlierProps.visible !== false) {
                    var outlierStyle = {
                        antialias: true,
                        color: outlierProps.color || boxStyle.color,
                        lineStyle: outlierProps.border
                    };
                    var outlierGroup = riserGroup.group("outliers", null, null, null, null, null, outlierStyle);
                    var outliers = Array.isArray(d.outliers) ? d.outliers : [d.outliers];
                    var rotation = outlierProps.shape && outlierProps.shape !== "circle" ? chart.getSeriesAndGroupProperty(s, g, "marker.rotation") : null;
                    var oneOutlierStyle = {
                        rotation: rotation,
                        title: chart.getSerDepProperty("marker.tooltip", d)
                    };
                    for (var i = 0; i < outliers.length; i++) {
                        mx = isHorizontal ? y(outliers[i]) : xCenter;
                        my = isHorizontal ? xCenter : h - y(outliers[i]);
                        oneOutlierStyle.className = chart.buildClassName("outlier", s, g, i);
                        outlierGroup.dot(mx, my, outlierProps.size || 10, outlierProps.shape || "circle", oneOutlierStyle)
                    }
                }
            }
        }
        if (chart.areDataLabelsVisible())
            Object.entries(riserLists).forEach(function(entry) {
                var key = entry[0];
                var position = isHorizontal ? "right" : "top";
                if (isHorizontal) {
                    if (key === "bottomWhiskerRisers" || key === "topBoxRisers")
                        position = "left"
                } else if (key === "bottomWhiskerRisers" || key === "topBoxRisers")
                    position = "bottom";
                chart.doDataLabelsScene(group.group("datalabels"), entry[1], position)
            })
    }
    tdgchart.prototype.drawBoxPlot = function(panel, chartLayout) {
        var chart = this;
        var chartPanels = chart.createBLAScrollXYPanels(panel, chartLayout.chartSize, chartLayout);
        chart.drawXOrdinalYChart(chartPanels, chartLayout, chart.adjustData(chart._internalData), addBoxplot)
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    function drawOneErrorBar(group, hatLength, isHorizontal, px, py, length, className) {
        var p = new tdgchart.tdgscene.path;
        var halfHat = hatLength / 2;
        p.moveTo(px, py);
        if (isHorizontal) {
            p.lineTo(length, 0, true);
            p.moveTo(px, py - halfHat);
            p.lineTo(0, hatLength, true);
            p.moveTo(px + length, py - halfHat);
            p.lineTo(0, hatLength, true)
        } else {
            p.lineTo(0, -length, true);
            p.moveTo(px - halfHat, py);
            p.lineTo(hatLength, 0, true);
            p.moveTo(px - halfHat, py - length);
            p.lineTo(hatLength, 0, true)
        }
        group.path(0, 0, p, {
            className: className
        })
    }
    function doOrdinalErrorBars(chart, group, x, y) {
        var axisHeight = group.parent.computedSize.height;
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        var chartType = chart.chartType;
        var layout = chart.blaProperties.comboCharts.barSeriesLayout || chart.blaProperties.seriesLayout;
        var isStacked = layout === "stacked" || layout === "percent";
        var data = chart.errorBars.yData;
        if (chart.swapData || chart.swapDataAndLabels)
            data = tdg.transpose(data);
        for (var i = 0, len = Math.min(data.length, chart.data.length); i < len; i++) {
            data[i] = data[i] || [];
            data[i] = data[i].slice(0, chart.data[i].length)
        }
        data = data.slice(0, chart.data.length);
        var riserWidth = x.range().band / (isStacked && chartType === "bar" ? 1 : chart.seriesCount());
        var hatWidth = chart.errorBars.hatWidth;
        hatWidth = hatWidth == null ? "50%" : hatWidth;
        hatWidth = tdg.applyNumOrPercent(hatWidth, riserWidth);
        var groupStyle = {
            lineStyle: chart.errorBars.line,
            antialias: false
        };
        var markerStyle, m = chart.get("errorBars.marker");
        if (m != null)
            markerStyle = {
                visible: m.visible,
                color: m.color || "grey",
                size: m.size / 2 || hatWidth,
                shape: m.shape || "diamond",
                rotation: m.rotation || 0,
                lineStyle: m.border || {
                    color: "black",
                    width: 1
                }
            };
        var errorBarGroup = group.group("errorBars", null, null, null, null, null, groupStyle);
        var errorMarkerGroup = group.group("errorMarkers");
        var drawBar = tdg.partial(drawOneErrorBar, [errorBarGroup, hatWidth, isHorizontal, null, null, null, null]);
        for (var s = 0; s < data.length; s++)
            for (var g = 0; g < data[s].length; g++) {
                var d = data[s][g];
                if (!d || !Array.isArray(d))
                    continue;
                var riserInset = chart.chartType === "bar" ? riserWidth / 2 + (isStacked ? 0 : s * riserWidth) : riserWidth;
                var dx = x(g) + riserInset;
                var dy = y(d[0]);
                var length = y(d[d.length - 1]) - dy;
                var className = chart.buildClassName("errorBar", s, g);
                if (isHorizontal)
                    drawBar(dy, dx, length, className);
                else
                    drawBar(dx, axisHeight - dy, length, className);
                if (d.length > 2) {
                    var style = markerStyle;
                    if (style == null) {
                        var lookup = tdg.partial(chart.getSeriesAndGroupProperty, [s, g, null], chart);
                        style = {
                            color: lookup("marker.color") || lookup("color"),
                            size: lookup("marker.size") || 8,
                            shape: lookup("marker.shape") || "circle",
                            rotation: lookup("marker.rotation") || 0,
                            lineStyle: lookup("marker.border")
                        }
                    }
                    style.className = chart.buildClassName("errorBarMarker", s, g);
                    if (isHorizontal)
                        errorMarkerGroup.dot(axisHeight - y(d[1]), dx, style.size, style.shape, style);
                    else
                        errorMarkerGroup.dot(dx, axisHeight - y(d[1]), style.size, style.shape, style)
                }
            }
    }
    function doNumericErrorBars(chart, group, data, x, y) {
        var xData = chart.get("errorBars.xData", [[]]);
        var yData = chart.get("errorBars.yData", [[]]);
        if (chart.swapData || chart.swapDataAndLabels) {
            xData = tdg.transpose(xData);
            yData = tdg.transpose(yData)
        }
        var xd, yd, dx, dy, length;
        var hatWidth = 20;
        var groupStyle = {
            lineStyle: chart.errorBars.line,
            antialias: false
        };
        var markerStyle, m = chart.get("errorBars.marker");
        if (m != null)
            markerStyle = {
                visible: m.visible,
                color: m.color || "grey",
                size: m.size / 2 || hatWidth / 1.5,
                shape: m.shape || "diamond",
                rotation: m.rotation || 0,
                lineStyle: m.border || {
                    color: "black",
                    width: 1
                }
            };
        var errorBarGroup = group.group("errorBars", null, null, null, null, null, groupStyle);
        var errorMarkerGroup = group.group("errorMarkers");
        for (var s = 0; s < data.length; s++)
            for (var g = 0; data[s] && g < data[s].length; g++) {
                var d = data[s][g];
                if (!tdg.isEmpty(d)) {
                    var className = chart.buildClassName("errorBar", s, g);
                    if (Array.isArray(xData[s]) && !tdg.isEmpty(xData[s][g])) {
                        xd = xData[s][g];
                        dx = x(xd[0]);
                        dy = group.h - y(d.y);
                        length = x(xd[xd.length - 1]) - dx;
                        drawOneErrorBar(errorBarGroup, hatWidth, true, dx, dy, length, className);
                        if (xd.length > 2)
                            drawErrorBarMarker(chart, errorMarkerGroup, markerStyle, s, g, dx + length / 2, dy)
                    }
                    if (Array.isArray(yData[s]) && !tdg.isEmpty(yData[s][g])) {
                        yd = yData[s][g];
                        dx = x(d.x);
                        dy = group.h - y(yd[0]);
                        length = y(yd[yd.length - 1]) + dy - group.h;
                        drawOneErrorBar(errorBarGroup, hatWidth, false, dx, dy, length, className);
                        if (yd.length > 2)
                            drawErrorBarMarker(chart, errorMarkerGroup, markerStyle, s, g, dx, dy - length / 2)
                    }
                }
            }
    }
    function drawErrorBarMarker(chart, group, markerStyle, s, g, x, y) {
        var style = markerStyle || {
            color: chart.getSeriesAndGroupProperty(s, g, "marker.color") || chart.getSeriesAndGroupProperty(s, g, "color"),
            size: chart.getSeriesAndGroupProperty(s, g, "marker.size") || 8,
            shape: chart.getSeriesAndGroupProperty(s, g, "marker.shape") || "circle",
            rotation: chart.getSeriesAndGroupProperty(s, g, "marker.rotation") || 0,
            lineStyle: chart.getSeriesAndGroupProperty(s, g, "marker.border")
        };
        style.className = chart.buildClassName("errorBarMarker", s, g);
        group.dot(x, y, style.size, style.shape, style)
    }
    tdgchart.prototype.doErrorBars = function(panel, x, y, data) {
        var chart = this;
        if (x.range().hasOwnProperty("band")) {
            if (chart.errorBars.yData != null)
                doOrdinalErrorBars(chart, panel, x, y)
        } else if (!tdg.isEmpty(chart.errorBars.xData) || !tdg.isEmpty(chart.errorBars.yData))
            doNumericErrorBars(chart, panel, data, x, y)
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    function getHistogramMetricData(chart, data) {
        var metricData = [];
        for (var b = 0; b < data.length; b++) {
            var bucket = data[b];
            metricData.push([]);
            for (var i = 0; i < chart.colorMode.data.length; i++) {
                var seriesData = chart.colorMode.data[i];
                metricData[b][i] = {
                    value: 0,
                    _s: i,
                    _g: b
                };
                for (var j = 0; j < seriesData.length; j++)
                    if (seriesData[j] > bucket.binStart && seriesData[j] <= bucket.binStart + bucket.binSize)
                        metricData[b][i].value += 1
            }
        }
        for (var k = 0; k < metricData.length; k++) {
            var dx = data[k].value - tdg.sum(metricData[k], "value");
            metricData[k].push({
                value: dx > 0 ? dx : undefined,
                _s: metricData[k].length,
                _g: k
            })
        }
        metricData = tdg.transpose(metricData);
        return metricData
    }
    tdgchart.prototype.addHistogram = function(rootPanel, data, x, y) {
        var chart = this;
        if (chart.getColorMode() === "byMetric") {
            data = getHistogramMetricData(chart, data);
            chart.cache.setProperty("blaProperties.seriesLayout", "stacked")
        } else
            data = [data];
        var scene = chart.cache.get("tdgscene");
        var w = rootPanel.computedSize.width;
        var h = rootPanel.computedSize.height;
        var groupPanel = scene.group(rootPanel, "groupPanel");
        chart.addBar(groupPanel, w, h, data, x, y, null)
    }
    ;
    function oneBinData(chart, val) {
        val = Math.max(val, 1);
        var data = [{
            binStart: 0,
            binSize: 2,
            value: val,
            _s: 0,
            _g: 0
        }];
        data.min = 0;
        data.max = val * 2;
        chart.cache.set("histogramBins", data);
        return data
    }
    tdgchart.prototype.histogramData = function(data) {
        var chart = this;
        if (chart.cache.hasKey("histogramBins"))
            return chart.cache.get("histogramBins");
        data = data || (chart.isPageSliderEnabled() ? chart.data[chart.dataPageSlider.currentPage || 0][0] : chart.data[0]);
        if (data.length === 1)
            return oneBinData(chart, data[0].value);
        var startBinValue = chart.get("histogramProperties.startBinValue");
        var bucketMode = Array.isArray(chart.dataArrayMap) && chart.dataArrayMap.includes("bucketCount");
        var minThreshold = bucketMode ? null : chart.get("histogramProperties.minThreshold");
        var maxThreshold = bucketMode ? null : chart.get("histogramProperties.maxThreshold");
        if (bucketMode)
            data.forEach(function(el) {
                el.value = el.bucketCount
            });
        var minMax = tdg.minMaxR(data, "value");
        var min = Math.floor(minMax.min);
        var max = Math.ceil(minMax.max);
        if (startBinValue != null)
            min = startBinValue;
        else if (bucketMode)
            min = 0;
        min = minThreshold == null ? min : minThreshold;
        max = maxThreshold == null ? max : maxThreshold;
        if (tdg.eq(min, max))
            return oneBinData(chart, min);
        var binSize = chart.get("histogramProperties.binSize");
        var binCount = chart.get("histogramProperties.binCount");
        binCount = typeof binCount === "number" && binCount >= 0 ? binCount : null;
        if (bucketMode && binCount == null)
            binCount = data.length;
        if (Array.isArray(binSize) && binSize.length === 1)
            binSize = binSize[0];
        if (!bucketMode && binSize >= max - min)
            return oneBinData(chart, binSize);
        var binList;
        if (Array.isArray(binSize) && binSize.length > 0)
            binList = binSize;
        else if (typeof binSize === "number")
            if (binCount == null) {
                binList = tdg.range(min, max, binSize);
                binList.push(max)
            } else {
                binCount -= (minThreshold == null ? 0 : 1) + (maxThreshold == null ? 0 : 1);
                binList = tdg.repeat(min, binCount + 1).map(function(el, idx) {
                    return el + idx * binSize
                })
            }
        else {
            var localBinCount = binCount;
            if (localBinCount == null)
                localBinCount = Math.ceil(Math.max(5, Math.sqrt(data.length)));
            localBinCount -= (minThreshold == null ? 0 : 1) + (maxThreshold == null ? 0 : 1);
            var step = (max - min) / localBinCount;
            binList = tdg.range(min, max, step);
            binList.push(max)
        }
        if (minThreshold != null)
            binList.unshift(Number.MIN_VALUE);
        if (maxThreshold != null)
            binList.push(Number.MAX_VALUE);
        var i, binData = [];
        for (i = 0; i < binList.length - 1; i++)
            binData[i] = {
                _s: 0,
                _g: i,
                binStart: binList[i],
                binSize: binList[i + 1] - binList[i],
                value: 0
            };
        for (i = 0; i < data.length; i++)
            if (data[i] != null && data[i].value != null)
                if (bucketMode) {
                    if (binData[i])
                        binData[i].value = data[i].value
                } else {
                    var j = pv.search.index(binList, data[i].value) - 1;
                    binData[Math.max(0, Math.min(binData.length - 1, j))].value++
                }
        binData.min = min;
        binData.max = max;
        if (binCount == null && binSize == null) {
            while (binData[0].value === 0)
                binData.shift();
            binData.min = binData[0].binStart;
            while (binData[binData.length - 1].value === 0)
                binData.pop();
            binData.max = binData[binData.length - 1].binStart + binData[binData.length - 1].binSize
        }
        chart.cache.set("histogramBins", binData);
        return binData
    }
    ;
    tdgchart.prototype.buildHistogramGroupLabels = function() {
        var chart = this;
        var data = chart.histogramData(chart.cachedMaxValArray);
        var format = chart.get("axisList.x1.numberFormat", "auto");
        var bucketMode = Array.isArray(chart.dataArrayMap) && chart.dataArrayMap.includes("bucketCount");
        var minThreshold = bucketMode ? null : chart.get("histogramProperties.minThreshold");
        var maxThreshold = bucketMode ? null : chart.get("histogramProperties.maxThreshold");
        var minMax = {
            min: minThreshold == null ? data.min : minThreshold,
            max: maxThreshold == null ? data.max : maxThreshold
        };
        data = data.map(function(el) {
            return chart.formatNumber(el.binStart, format, minMax)
        });
        if (minThreshold != null)
            data[0] = "< " + chart.formatNumber(minThreshold, format, minMax);
        if (maxThreshold == null)
            data.push(chart.formatNumber(minMax.max, format, minMax));
        else
            data.push("> " + chart.formatNumber(maxThreshold, format, minMax));
        return data
    }
    ;
    tdgchart.prototype.layoutHistogram = function(overallChartSize) {
        var chart = this;
        var chartLayout = chart.layoutDefaultChart(overallChartSize);
        if (chart.data.length === 0 || chart.data[0].length === 0)
            return chartLayout;
        chart.axisList.x1.centerGroupLabels = false;
        var data = chart.histogramData();
        chartLayout.histogramInfo = {
            data: data
        };
        var minMax;
        if (data.length === 1)
            minMax = {
                min: 0,
                max: data[0].value * 2
            };
        else
            minMax = chart.getScaleMinMax(chart.yaxis, "y1", [data]);
        function doLayout(size) {
            chartLayout.axisLayout = chart.getXOrdYAxisLayout(size, minMax);
            chartLayout.chartSize = chart.updateSizeAxisLayout(size, chartLayout.axisLayout.spacing);
            return chartLayout.chartSize
        }
        doLayout(chartLayout.chartSize);
        chart.applyBLAScrolling(chartLayout, doLayout);
        return chartLayout
    }
    ;
    tdgchart.prototype.drawHistogram = function(panel, chartLayout) {
        var chart = this;
        var chartPanels = chart.createBLAScrollXYPanels(panel, chartLayout.chartSize, chartLayout);
        chart.drawXOrdinalYChart(chartPanels, chartLayout, chartLayout.histogramInfo.data, chart.addHistogram)
    }
}
)();
(function() {
    function addStockChart(rootPanel, data, x, y) {
        var chart = this;
        if (data.length === 0)
            return null;
        var panel = rootPanel.add(pv.Panel).className("groupPanel").data(data);
        panel.computedSize = rootPanel.computedSize;
        var o = chart.blaProperties.orientation === "horizontal"
          , barWidth = x.range().band / chart.seriesCount();
        function dl(dataValue, idx) {
            if (chart.yaxis.invert) {
                var invert_map = {
                    high: "low",
                    low: "high",
                    open: "close",
                    close: "open"
                };
                return y(dataValue[invert_map[idx]])
            } else
                return y(dataValue[idx])
        }
        function bottomBar(d) {
            return dl(d, "low")
        }
        function topBar(d) {
            return Math.abs(dl(d, "high") - dl(d, "low"))
        }
        function borderLookup(chart) {
            var lookup = chart.seriesPropertyLookup("border");
            return function(d) {
                var val = lookup.call(this, d) || {};
                val.width = val.width == null ? 1 : val.width;
                val.color = val.color || "black";
                val.dash = val.dash || "";
                return val
            }
        }
        function riserColor(d) {
            var upRiser = chart.stockProperties.upRiserColor;
            var downRiser = chart.stockProperties.downRiserColor;
            var series = chart.getSeriesAndGroup(this.parent.index, this.index);
            var lookup = chart.seriesColorLookup();
            if (series != null && series.color != null)
                return series.color;
            if (d.open <= d.close && upRiser != null)
                return upRiser;
            if (d.open > d.close && downRiser != null)
                return downRiser;
            return lookup.call(this, d)
        }
        var rule = panel.add(pv.Rule).className(function() {
            return chart.buildClassName("boxplotConnectorLine", this.parent.index, this.index)
        }).data(function(d) {
            return d
        }).antialias(false);
        if (chart.stockProperties.hiLowLine == null)
            rule.lineStyle(borderLookup(chart));
        else {
            var line = chart.stockProperties.hiLowLine;
            rule.lineWidth(line.width).strokeStyle(line.color == null ? riserColor : line.color).dashStyle(line.dash)
        }
        if (o)
            rule.top(function() {
                return x(this.index) + barWidth / 2 + this.parent.index * barWidth
            }).left(bottomBar).width(topBar);
        else
            rule.left(function() {
                return x(this.index) + barWidth / 2 + this.parent.index * barWidth
            }).bottom(bottomBar).height(topBar);
        function barInset() {
            return x(this.index) + this.parent.index * barWidth
        }
        var bar = panel.add(pv.Bar).className(chart.classNameLookup("bar", "riser")).data(function(d) {
            return d
        });
        if (o)
            bar.top(barInset).height(barWidth).left(function(d) {
                return dl(d, "open")
            }).width(function(d) {
                return Math.abs(dl(d, "close") - dl(d, "open"))
            });
        else
            bar.left(barInset).width(barWidth).bottom(function(d) {
                return Math.min(dl(d, "open"), dl(d, "close"))
            }).height(function(d) {
                return Math.max(1, Math.abs(dl(d, "close") - dl(d, "open")))
            });
        bar.fillStyle(riserColor).lineStyle(borderLookup(chart)).antialias(false).title(chart.seriesToolTipLookup());
        return bar
    }
    tdgchart.prototype.layoutStockChart = function(overallChartSize) {
        var chart = this;
        var sp = this.stockProperties;
        var ta = this.xaxis.timeAxis;
        var enabled = ta.enabled;
        var start = ta.startTime;
        var stop = ta.stopTime;
        var interval = ta.interval;
        var format = ta.labelFormat;
        if (sp.startTime != null && sp.stopTime != null) {
            ta.enabled = true;
            ta.startTime = sp.startTime;
            ta.stopTime = sp.stopTime;
            ta.interval = sp.interval;
            ta.labelFormat = sp.labelFormat
        }
        var chartLayout = chart.layoutDefaultChart(overallChartSize);
        chartLayout.axisLayout = chart.getXOrdYAxisLayout(chartLayout.chartSize);
        chartLayout.chartSize = chart.updateSizeAxisLayout(chartLayout.chartSize, chartLayout.axisLayout.spacing);
        ta.enabled = enabled;
        ta.startTime = start;
        ta.stopTime = stop;
        ta.interval = interval;
        ta.labelFormat = format;
        return chartLayout
    }
    ;
    tdgchart.prototype.drawStockChart = function(panel, chartLayout) {
        var sp = this.stockProperties;
        var ta = this.xaxis.timeAxis;
        var enabled = ta.enabled;
        var start = ta.startTime;
        var stop = ta.stopTime;
        var interval = ta.interval;
        var format = ta.labelFormat;
        if (sp.startTime != null && sp.stopTime != null) {
            ta.enabled = true;
            ta.startTime = sp.startTime;
            ta.stopTime = sp.stopTime;
            ta.interval = sp.interval;
            ta.labelFormat = sp.labelFormat
        }
        var chartPanels = this.createXYPanels(panel, chartLayout.chartSize, chartLayout.axisLayout);
        this.drawXOrdinalYChart(chartPanels, chartLayout, this.adjustData(this._internalData), addStockChart);
        ta.enabled = enabled;
        ta.startTime = start;
        ta.stopTime = stop;
        ta.interval = interval;
        ta.labelFormat = format
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    function addGanttChart(rootPanel, data, x, y) {
        var chart = this;
        var panel = rootPanel.add(pv.Panel).className("groupPanel").data(data);
        panel.computedSize = rootPanel.computedSize;
        var o = chart.blaProperties.orientation === "horizontal";
        var barWidth = chart.ganttProperties.staggerRisers ? x.range().band / chart.seriesCount() : x.range().band;
        function bottom(d) {
            return d.fromValue == null ? y(d.toValue) : y(d.fromValue)
        }
        function height(d) {
            return y(d.toValue) - y(d.fromValue)
        }
        function left(d) {
            var offset = d && d.shape && d.shape !== "bar" ? barWidth / 2 : 0;
            if (chart.ganttProperties.staggerRisers)
                return x(this.index) + this.parent.index * barWidth + offset;
            else
                return x(this.index) + offset
        }
        function seriesHasColor(series) {
            return series != null && series.color != null
        }
        function fill(d) {
            var res;
            var idx = d._g;
            if (d.series != null) {
                res = chart.getSeriesAndGroup(d.series, idx);
                if (seriesHasColor(res))
                    return res.color;
                res = chart.getSeries(d.series);
                if (seriesHasColor(res))
                    return res.color
            }
            res = chart.getSeriesAndGroup(this.parent.index, idx);
            if (seriesHasColor(res))
                return res.color;
            res = chart.getSeries(idx);
            if (seriesHasColor(res))
                return res.color;
            return "black"
        }
        var depth = chart.depth25d();
        var bar = panel.add(depth ? pv.Bar25d : pv.Bar).data(function(d) {
            return d
        }).visible(function(d) {
            return d.shape == null || d.shape === "bar"
        }).className(chart.classNameLookup("bar", "riser")).fillStyle(fill).lineStyle(chart.seriesPropertyLookup("border")).antialias(false).title(chart.seriesToolTipLookup());
        if (depth)
            bar.depth(depth).dmargin(chart.getRiserDepthGap());
        var symbols = false;
        for (var i = 0; i < data.length && !symbols; i++)
            for (var j = 0; j < data[i].length; j++)
                if (data[i][j].shape && data[i][j].shape !== "bar") {
                    symbols = true;
                    break
                }
        if (symbols)
            symbols = panel.add(pv.Dot).data(function(d) {
                return d
            }).visible(function(d) {
                return d.shape != null && d.shape !== "bar"
            }).className(chart.classNameLookup("bar", "riser")).fillStyle(fill).lineWidth(chart.seriesPropertyLookup("border.width")).strokeStyle(chart.seriesPropertyLookup("border.color")).dashStyle(chart.seriesPropertyLookup("border.dash")).title(chart.seriesToolTipLookup()).shape(function(d) {
                return d.shape
            }).radius(barWidth / 2);
        if (o) {
            bar.top(left).left(bottom).width(height).height(barWidth);
            if (symbols)
                symbols.left(bottom).top(left)
        } else {
            bar.left(left).bottom(bottom).height(height).width(barWidth);
            if (symbols)
                symbols.left(left).bottom(bottom)
        }
        chart.doDataLabels(bar, "center")
    }
    function ganttData(chart, data) {
        var i, j;
        var startTime = Date.parse(chart.ganttProperties.startTime);
        if (startTime != null) {
            chart.ganttProperties.haveTimeData = true;
            startTime = startTime.getTime();
            for (i = 0; i < data.length; i++)
                for (j = 0; j < data[i].length; j++) {
                    var val0 = data[i][j].from
                      , val1 = data[i][j].to;
                    if (typeof val0 === "string" && Date.parse(val0) != null)
                        data[i][j].fromValue = Date.parse(val0).getTime() - startTime;
                    else
                        data[i][j].fromValue = val0;
                    if (typeof val1 === "string" && Date.parse(val1) != null)
                        data[i][j].toValue = Date.parse(val1).getTime() - startTime;
                    else
                        data[i][j].toValue = val1
                }
        } else
            for (i = 0; i < data.length; i++)
                for (j = 0; j < data[i].length; j++) {
                    data[i][j].fromValue = data[i][j].from;
                    data[i][j].toValue = data[i][j].to
                }
        if (chart.ganttProperties.durationValues)
            for (i = 0; i < data.length; i++)
                for (j = 0; j < data[i].length; j++)
                    data[i][j].toValue += data[i][j].fromValue;
        if (!chart.ganttProperties.staggerRisers)
            for (i = 0; i < data.length; i++)
                for (j = 0; j < data[i].length - 1; j++)
                    if (data[i][j].toValue >= data[i][j + 1].fromValue)
                        data[i][j + 1].fromValue = data[i][j].toValue;
        data.forEach(function(el, g) {
            el.forEach(function(a) {
                if (a.hasOwnProperty("series"))
                    a._g = g;
                else {
                    var tmp = a._g;
                    a._g = a._s;
                    a._s = tmp
                }
            })
        });
        data = tdg.transpose(data);
        return data
    }
    tdgchart.prototype.layoutGanttChart = function(overallChartSize) {
        var chart = this;
        function deepCopy(el) {
            if (Array.isArray(el))
                return el.map(function(x) {
                    return deepCopy(x)
                });
            else
                return el
        }
        var originalData = deepCopy(chart._internalData);
        var data = ganttData(chart, chart._internalData);
        chart.data = chart._internalData = chart.adjustData(data);
        var chartLayout = chart.layoutDefaultChart(overallChartSize);
        chartLayout.ganttInfo = {
            data: data
        };
        chartLayout.axisLayout = chart.getXOrdYAxisLayout(chartLayout.chartSize);
        chartLayout.chartSize = chart.updateSizeAxisLayout(chartLayout.chartSize, chartLayout.axisLayout.spacing);
        chart.data = chart._internalData = originalData;
        return chartLayout
    }
    ;
    tdgchart.prototype.drawGanttChart = function(panel, chartLayout) {
        var chart = this;
        var originalData = chart._internalData;
        chart.data = chart._internalData = chartLayout.ganttInfo.data;
        var chartPanels = chart.createXYPanels(panel, chartLayout.chartSize, chartLayout.axisLayout);
        chart.drawXOrdinalYChart(chartPanels, chartLayout, chart.data, addGanttChart);
        chart.data = chart._internalData = originalData
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.getTreemapLabelSeparator = function() {
        return "-_-"
    }
    ;
    tdgchart.getTreemapNodePath = function(node) {
        var nodeNameList = [];
        while (node && node.parentNode) {
            nodeNameList.unshift(node.nodeName);
            node = node.parentNode
        }
        return nodeNameList
    }
    ;
    tdgchart.prototype.treemapHasSeriesLegend = function() {
        var chart = this;
        return chart.dataArrayMap && chart.dataArrayMap.includes("series")
    }
    ;
    function findNode(tree, targetNode) {
        for (var node in tree)
            if (tree.hasOwnProperty(node)) {
                if (typeof targetNode === "object" && tree[node] === targetNode)
                    return tree[node];
                else if (typeof targetNode === "string" && node === targetNode)
                    return tree[node];
                if (typeof tree[node] === "object") {
                    var res = findNode(tree[node], targetNode);
                    if (res)
                        return res
                }
            }
        return null
    }
    function sumTree(tree) {
        var sum = 0;
        for (var node in tree)
            if (tree.hasOwnProperty(node)) {
                var n = tree[node];
                if (typeof n === "object")
                    sum += sumTree(n);
                else if (typeof n === "number")
                    sum += n;
                else if (Array.isArray(n))
                    sum += n[0]
            }
        return sum
    }
    function flattenData(tree, depth, currentLevel) {
        currentLevel = currentLevel || 1;
        for (var node in tree)
            if (tree.hasOwnProperty(node) && typeof tree[node] === "object")
                if (currentLevel < depth)
                    flattenData(tree[node], depth, currentLevel + 1);
                else if (currentLevel === depth)
                    tree[node] = sumTree(tree[node]);
        return tree
    }
    function getClassName(node, obj, misc) {
        var s = node.nodeName
          , p = node.parentNode;
        while (p && p.parentNode) {
            s = p.nodeName + tdgchart.getTreemapLabelSeparator() + s;
            p = p.parentNode
        }
        return obj + "!s" + s + "!g0!m" + misc
    }
    function sumNodes(root) {
        if (root && typeof root.size === "number")
            return root.size || 0;
        return tdg.sum(root.childNodes.map(sumNodes))
    }
    function headerTooltip(className, tooltip) {
        return function(v, s, g, d, data) {
            var chart = this;
            var ids = chart.classNameToIds(className);
            d.isHeader = true;
            var res = chart.resolveToolTipSeriesContent(tooltip, d, data, ids);
            d.isHeader = false;
            return res
        }
    }
    function drawHeader(chart, group, node, drawOptions, x, y, w) {
        var g = node && node.parentNode && node.parentNode.childNodes ? node.parentNode.childNodes.indexOf(node) : null;
        var className = chart.buildClassName("group-header", null, g, node.nodeName);
        var tooltip = drawOptions.header.tooltip;
        var style = {
            color: drawOptions.header.fill,
            lineStyle: drawOptions.header.border,
            className: className,
            title: tooltip ? headerTooltip(className, tooltip) : null,
            antialias: false
        };
        group.rect(x, y, w, drawOptions.header.height, style);
        if (drawOptions.header.label.visible) {
            var labelStyle = tdg.clone(drawOptions.header.label);
            labelStyle.align = labelStyle.valign = "center";
            var text = chart.truncateLabel(node.nodeName, drawOptions.header.font, w - 6);
            group.label(x + w / 2, y + drawOptions.header.height / 2 - 2, text, labelStyle)
        }
    }
    function drawNode(chart, group, node, nodeList, drawOptions, x, y, w, h) {
        var outerBorderWidth = 0;
        if (node.parentNode && node.parentNode.parentNode == null)
            if (drawOptions.cellBorder.outerCellWidth)
                outerBorderWidth = drawOptions.cellBorder.outerCellWidth;
        if (outerBorderWidth) {
            if (x < 1) {
                x += outerBorderWidth;
                w -= outerBorderWidth
            } else {
                x += outerBorderWidth / 2;
                w -= outerBorderWidth / 2
            }
            if (y < 1) {
                y += outerBorderWidth;
                h -= outerBorderWidth
            } else {
                y += outerBorderWidth / 2;
                h -= outerBorderWidth / 2
            }
            if (tdg.eq(x + w, drawOptions.panelWidth, 1))
                w -= outerBorderWidth;
            else
                w -= outerBorderWidth / 2;
            if (tdg.eq(y + h, drawOptions.panelHeight, 1))
                h -= outerBorderWidth;
            else
                h -= outerBorderWidth / 2
        }
        var risers = [];
        var borderWidth = drawOptions.cellBorder.width || 0;
        if (node.childNodes.length)
            risers = squarify(chart, group, node, drawOptions, x, y, w, h);
        else {
            var newX = x
              , newY = y
              , newW = w
              , newH = h;
            if (borderWidth) {
                newX += borderWidth / 2;
                newY += borderWidth / 2;
                newW = Math.max(1, newW - borderWidth);
                newH = Math.max(1, newH - borderWidth)
            }
            var style = {
                antialias: false,
                className: getClassName(node, "riser", "node"),
                color: drawOptions.colorFn(node),
                lineStyle: drawOptions.cellBorder,
                title: chart.getSeriesAndGroupProperty(node._s, node._g, "tooltip")
            };
            var riser = group.rect(newX, newY, newW, newH, style);
            riser.d = node;
            riser.data = nodeList;
            riser.font = node.font;
            node.truncatedNodeName = chart.truncateLabel(node.nodeName, node.font, w - 6);
            var lblSize = chart.measureLabel(node.truncatedNodeName, node.font);
            if (lblSize.width > w || lblSize.height > h)
                node.truncatedNodeName = "";
            risers = [riser]
        }
        if (node.parentNode && node.parentNode.parentNode == null) {
            if (drawOptions.header.height && (tdg.color.isVisible(drawOptions.header.fill) || drawOptions.header.border.width))
                if (drawOptions.header.height < h) {
                    drawHeader(chart, group, node, drawOptions, x, y, w);
                    risers.forEach(function(el) {
                        if (el && el.props && el.props.y < y + drawOptions.header.height) {
                            el.props.h -= drawOptions.header.height - el.props.y + y - borderWidth / 2;
                            el.props.y = y + drawOptions.header.height - borderWidth / 2
                        }
                    })
                }
            if (outerBorderWidth) {
                var outerBorderStyle = {
                    fill: null,
                    lineStyle: tdg.clone(drawOptions.cellBorder),
                    antialias: false,
                    "pointer-events": "none"
                };
                outerBorderStyle.lineStyle.width = drawOptions.cellBorder.outerCellWidth;
                group.rect(x - outerBorderWidth / 2, y - outerBorderWidth / 2, w + outerBorderWidth, h + outerBorderWidth, outerBorderStyle)
            }
        }
        return risers
    }
    function placeColumn(chart, group, nodeList, drawOptions, x, y, w, h) {
        if (nodeList.length === 1)
            return drawNode(chart, group, nodeList[0], nodeList, drawOptions, x, y, w, h);
        var risers = [];
        var colSum = tdg.sum(nodeList, "size");
        var colArea = w * h;
        var isVertical = w <= h;
        for (var i = 0; i < nodeList.length; i++) {
            var node = nodeList[i];
            var nodeArea = node.size / colSum * colArea;
            if (isVertical)
                h = nodeArea / w;
            else
                w = nodeArea / h;
            risers = risers.concat(drawNode(chart, group, node, nodeList, drawOptions, x, y, w, h));
            if (isVertical)
                y += h;
            else
                x += w
        }
        return risers
    }
    function ratio(row, w, h, treeSum) {
        var max = -Infinity
          , min = Infinity
          , sum = 0;
        for (var i = 0; i < row.length; i++) {
            var a = row[i].size / treeSum * w * h;
            if (a < min)
                min = a;
            if (a > max)
                max = a;
            sum += a
        }
        var s2 = sum * sum;
        var length = Math.min(w, h);
        length = length * length;
        return {
            ratio: Math.max(length * max / s2, s2 / (length * min)),
            area: sum
        }
    }
    function squarify(chart, group, treeData, drawOptions, x, y, w, h) {
        var panelArea = w * h;
        var treeSum = sumNodes(treeData);
        var risers = [];
        var nodeList = treeData.childNodes.slice().sort(function(a, b) {
            return b.size - a.size
        });
        for (var i = 0; i < nodeList.length; ) {
            var node = nodeList[i];
            if (!node.size) {
                i++;
                continue
            }
            if (i === nodeList.length - 1) {
                risers = risers.concat(drawNode(chart, group, node, nodeList, drawOptions, x, y, w, h));
                break
            }
            var j = i + 1;
            var colList = [node];
            var worst = ratio(colList, w, h, treeSum);
            while (j <= nodeList.length) {
                if (tdg.isEmpty(nodeList[j])) {
                    j++;
                    continue
                }
                colList.push(nodeList[j]);
                var worst2 = ratio(colList, w, h, treeSum);
                if (worst.ratio < worst2.ratio) {
                    colList.pop();
                    if (w < h) {
                        var dh = worst.area / w;
                        risers = risers.concat(placeColumn(chart, group, colList, drawOptions, x, y, w, dh));
                        y += dh;
                        h -= dh
                    } else {
                        var dw = worst.area / h;
                        risers = risers.concat(placeColumn(chart, group, colList, drawOptions, x, y, dw, h));
                        x += dw;
                        w -= dw
                    }
                    break
                } else {
                    j++;
                    worst = worst2
                }
            }
            var colSum = tdg.sum(colList, "size");
            panelArea -= colSum / treeSum * panelArea;
            treeSum -= colSum;
            i += colList.length
        }
        return risers
    }
    function getCellColorFn(chart) {
        var colorScale;
        var isColorScale = chart.cache.get("axisModes", {}).y1 === "color" || chart.dataArrayMap && chart.dataArrayMap.includes("color");
        if (isColorScale) {
            var cs = chart.cache.get("colorAxis", {}).scale;
            colorScale = function(node) {
                return cs(node.nodeColor || 0)
            }
        } else if (chart.dataArrayMap && chart.dataArrayMap.includes("series")) {
            var seriesIdx = chart.dataArrayMap.indexOf("series");
            colorScale = function(d) {
                var sID = d.nodeValue[seriesIdx] || 0;
                return chart.getSeriesAndGroupProperty(sID, null, "color")
            }
        } else if (chart.colorMode && chart.colorMode.mode === "byGroup")
            colorScale = function() {
                return chart.getDefaultSeries().color || "red"
            }
            ;
        else if (!chart.riserCycleEndLightness || chart.riserCycleEndLightness < 0) {
            var colorList = [];
            chart.series.forEach(function(el) {
                if (el.group == null && typeof el.series === "number" && el.color != null)
                    colorList[el.series] = el.color
            });
            colorList = colorList.filter(function(el) {
                return el != null
            }).concat(tdg.color.palettes.category20);
            colorScale = pv.Scale.ordinal().range(colorList).by(function(d) {
                return d.parentNode.nodeName
            })
        } else {
            var maxSeries = 0;
            var seriesNodeNameMap = {};
            colorScale = function(node) {
                var s = seriesNodeNameMap[node.parentNode.nodeName];
                if (s == null)
                    s = seriesNodeNameMap[node.parentNode.nodeName] = maxSeries++;
                return chart.getSeriesAndGroupProperty(s, null, "color")
            }
        }
        return colorScale
    }
    tdgchart.prototype.drawTreemap = function(panel) {
        var chart = this;
        var data = chart._internalData;
        if (chart.autoDrillDown && chart.autoDrillDown.enabled) {
            data = tdg.cloneObject(data);
            if (chart.autoDrillDown.root)
                data = findNode(chart.data, chart.autoDrillDown.root);
            data = flattenData(data, 2)
        }
        var treeData = tdg.tree(chart._internalData);
        if (Array.isArray(chart.dataArrayMap) && !chart.dataArrayMap.includes("size")) {
            var haveData = false;
            treeData.search(function(node) {
                if (tdg.isEmpty(node.nodeValue))
                    return false;
                haveData = true;
                return true
            });
            if (haveData)
                treeData.pruneEmptyChildren();
            else
                treeData.visitBefore(function(node) {
                    if (tdg.isEmpty(node.childNodes))
                        node.nodeValue = 1
                })
        } else
            treeData.pruneEmptyChildren();
        if (tdg.isEmpty(treeData.childNodes) && tdg.isEmpty(treeData.nodeValue))
            treeData.appendChild(new tdg.tree.TreeNode(1,"undefined"));
        var dataLabelsVisible = chart.areDataLabelsVisible();
        var dataLabelFont = chart.getSeriesAndGroupProperty(0, null, "dataLabels.font") || "bold 12pt Georgia";
        var fontScaleFactor, fontParts, minLabelFontSize;
        if (dataLabelsVisible && chart.treemapProperties.scaleCellFonts) {
            var fontMinMax = chart.getDataSetMinMax(chart.xaxis, "", data, null, "size");
            var maxLabelFontSize = tdg.bound(chart.height * .08, 2, 40);
            minLabelFontSize = tdg.bound(chart.height * .02, 2, 40);
            fontScaleFactor = (maxLabelFontSize - minLabelFontSize) / Math.abs(fontMinMax.max - fontMinMax.min);
            fontParts = tdg.fontToFontParts(dataLabelFont)
        }
        var sizeIdx = 0
          , colorIdx = 1;
        if (Array.isArray(chart.dataArrayMap) && !tdg.isEmpty(chart.dataArrayMap)) {
            sizeIdx = chart.dataArrayMap.indexOf("size");
            sizeIdx = sizeIdx >= 0 ? sizeIdx : null;
            colorIdx = chart.dataArrayMap.indexOf("color");
            colorIdx = colorIdx >= 0 ? colorIdx : null
        }
        var cb = chart.get("chartFrame.border", {
            width: 0
        });
        var cbw = Math.round(tdg.color.isVisible(cb.color) ? cb.width / 2 : 0);
        var leftPad = this.getPadding("frame", "left");
        panel.computedSize.x += cbw + leftPad;
        panel.computedSize.width -= leftPad + cbw + cbw + leftPad;
        panel.left(panel.computedSize.x).width(panel.computedSize.width);
        panel.computedSize.y += cbw;
        panel.computedSize.height -= cbw + cbw;
        panel.top(panel.computedSize.y).height(panel.computedSize.height);
        var headerHeight = chart.get("treemapProperties.header.height");
        if (headerHeight == null)
            headerHeight = 1.33 * tdg.measureFont(chart.get("treemapProperties.header.label.font") || "10pt Arial").height;
        headerHeight = tdg.applyNumOrPercent(headerHeight, panel.computedSize.height);
        treeData.visitBefore(function(node) {
            if (!tdg.isEmpty(node.nodeValue)) {
                if (!Array.isArray(node.nodeValue))
                    node.nodeValue = [node.nodeValue, node.nodeValue];
                node.size = sizeIdx == null ? 1 : Math.abs(node.nodeValue[sizeIdx] || 0);
                node.nodeColor = colorIdx == null ? 1 : node.nodeValue[colorIdx];
                node._s = node._g = 0;
                if (dataLabelsVisible && chart.treemapProperties.scaleCellFonts) {
                    fontParts.fontSize = minLabelFontSize + fontScaleFactor * node.size + "pt";
                    node.font = fontParts.toString()
                } else
                    node.font = dataLabelFont
            }
        });
        treeData.visitAfter(function(node) {
            if (node.size == null && node.childNodes.length)
                node.size = sumNodes(node)
        });
        chart._internalData = treeData;
        var scene = chart.cache.get("tdgscene");
        var rootGroup = panel;
        if (!tdgchart.tdgscene.isTDGSceneGroup(rootGroup))
            rootGroup = scene.group(panel);
        var panelWidth = panel.computedSize.width - cbw - cbw;
        var panelHeight = panel.computedSize.height - cbw - cbw;
        var header = tdg.clone(chart.get("treemapProperties.header", {}));
        header.height = headerHeight;
        var drawOptions = {
            colorFn: getCellColorFn(chart),
            cellBorder: chart.get("treemapProperties.cellBorder"),
            header: header,
            panelWidth: panelWidth,
            panelHeight: panelHeight
        };
        chart.addChartFrame(panel);
        var riserGroup = rootGroup.group("riser-group", cbw, cbw);
        var riserList = squarify(chart, riserGroup, treeData, drawOptions, 0, 0, panelWidth, panelHeight);
        if (dataLabelsVisible) {
            var labelPosition = chart.getSeriesAndGroupProperty(0, 0, "dataLabels.position") || "center";
            if (labelPosition === "top" || labelPosition === "bottom")
                labelPosition = "center";
            chart.doDataLabelsScene(rootGroup, [riserList], labelPosition)
        }
    }
}
)();
(function() {
    var zoomDelay = 750;
    tdgchart.prototype.drawCirclePack = drawCirclePack;
    var tdg = tdgchart.util;
    function className(chart, node, obj, misc) {
        var s = node.name.replace("\n", "\\n")
          , p = node.parent;
        while (p && p.parent) {
            s = p.name + tdgchart.getTreemapLabelSeparator() + s;
            p = p.parent
        }
        return obj + "!s" + s + "!g0!m" + misc + "!"
    }
    function drawOneLevel(chart, diameter, offset, riserGroup, data) {
        if (!data.children)
            return;
        var i;
        for (i = 0; i < data.children.length; i++) {
            var n = data.children[i];
            n.subChildren = n.children;
            n.children = undefined
        }
        var nodes = tdgchart.d3.layout.pack().size([diameter, diameter]).value(function(d) {
            return d.value
        })(data);
        for (i = 1; i < nodes.length; i++) {
            var node = nodes[i];
            var x = node.x + offset.x;
            var y = node.y + offset.y;
            var style = node.style || node.parent.style || node.parent.parent.style || {
                color: undefined,
                border: {}
            };
            style.border = style.border || {};
            riserGroup.circle(x, y, node.r, {
                className: className(chart, node, "riser", "circle"),
                color: style.color || "black",
                border: style.border.color || "black",
                lineWidth: style.border.width || 1,
                tdgtitle: getToolTip(chart, node)
            });
            if (node.subChildren) {
                node.children = node.subChildren;
                drawOneLevel(chart, node.r * 2, {
                    x: x - node.r,
                    y: y - node.r
                }, riserGroup, node)
            }
            var haveNameLbl = style && style.nameLabel && style.nameLabel.visible;
            var haveValueLbl = style && style.valueLabel && style.valueLabel.visible;
            var drawLbl = tdg.partial(drawCircleLabel, [chart, riserGroup, node, {
                x: x,
                y: y,
                r: node.r
            }, null, null, null, null, null, null]);
            if (haveNameLbl)
                if (node.subChildren)
                    drawLbl(node.name, "top", style.nameLabel, 1.5);
                else if (haveValueLbl)
                    drawLbl(node.name, "center", style.nameLabel, undefined);
                else
                    drawLbl(node.name, "center", style.nameLabel, .35);
            if (!node.subChildren && haveValueLbl) {
                var text = chart.formatNumber(node.value, style.valueLabel.numberFormat);
                if (haveNameLbl)
                    drawLbl(text, "center", style.valueLabel, "1.1em");
                else
                    drawLbl(text, "center", style.valueLabel, "0.5em")
            }
        }
    }
    function anchorOffset(r, position) {
        switch (position) {
        case "top":
            return {
                x: 0,
                y: -r
            };
        case "bottom":
            return {
                x: 0,
                y: r
            };
        case "left":
            return {
                x: -r,
                y: 0
            };
        case "right":
            return {
                x: r,
                y: 0
            }
        }
        return {
            x: 0,
            y: 0
        }
    }
    function drawCircleLabel(chart, riserGroup, node, target, text, anchor, style, dy) {
        var lblSize = chart.measureLabel(text, style.font);
        if (lblSize.height >= node.r * 2)
            return;
        if (lblSize.width > node.r * 2)
            text = chart.truncateLabel(text, style.font, node.r * 2);
        var offset = anchorOffset(target.r, anchor);
        riserGroup.label(0 + target.x + offset.x, -3 + target.y + offset.y, text, {
            "pointer-events": "none",
            className: className(chart, node, "dataLabels", "dataLabels"),
            color: style.color,
            align: "middle",
            shift: dy,
            font: style.font
        })
    }
    function getToolTip(chart, node) {
        return chart.seriesToolTipLookup().call({
            index: 0,
            parent: {
                index: 0
            },
            data: function() {}
        }, node)
    }
    function drawCirclePack(panel, chartLayout) {
        var chart = this;
        chart.addChartFrame(panel);
        var pos = panel.computedSize;
        var style = chart.data.style || {
            color: undefined,
            border: {}
        };
        var inset = style.border.width + 5;
        var diameter = Math.min(pos.width, pos.height) - inset - inset;
        var r = diameter / 2;
        var offset = {
            x: Math.max(inset, (pos.width - diameter) / 2),
            y: Math.max(inset, (pos.height - diameter) / 2)
        };
        var scene = chart.cache.get("tdgscene");
        var riserGroup = scene.group("chartPanel", "groupPanel", pos.x + offset.x, pos.y + offset.y);
        riserGroup.circle(r, r, r, {
            className: "root-node",
            color: style.color || "black",
            border: style.border.color || "black",
            lineWidth: style.border.width || 1
        });
        drawOneLevel(chart, diameter, {
            x: 0,
            y: 0
        }, riserGroup, chart.data);
        if (chart.interaction.click === "zoom")
            chart._postProcessCallbacks.push(addZoom(diameter))
    }
    function addZoom(diameter) {
        var x = pv.Scale.linear().range(0, diameter);
        var y = pv.Scale.linear().range(0, diameter);
        return function() {
            var focus, chart = this;
            var root = tdgchart.d3.select("#" + chart.documentRoot);
            var groupPanel = root.select(".groupPanel");
            function zoom(d) {
                var k = diameter / d.r / 2;
                x.domain([d.x - d.r, d.x + d.r]);
                y.domain([d.y - d.r, d.y + d.r]);
                tdgchart.d3.event.stopPropagation();
                groupPanel.selectAll("circle").transition().duration(zoomDelay).attr("cx", function() {
                    return x(this.origin.x)
                }).attr("cy", function() {
                    return y(this.origin.y)
                }).attr("r", function() {
                    return k * this.origin.r
                });
                groupPanel.selectAll("text").transition().duration(zoomDelay).attr("x", function() {
                    return x(this.origin.x)
                }).attr("y", function() {
                    return y(this.origin.y)
                })
            }
            function unzoom() {
                groupPanel.selectAll("circle").transition().duration(zoomDelay).attr("cx", function() {
                    return this.origin.x
                }).attr("cy", function() {
                    return this.origin.y
                }).attr("r", function() {
                    return this.origin.r
                });
                groupPanel.selectAll("text").transition().duration(zoomDelay).attr("x", function() {
                    return this.origin.x
                }).attr("y", function() {
                    return this.origin.y
                })
            }
            root.selectAll("svg").on("click.tdg_zoom", function() {
                focus = undefined;
                unzoom()
            });
            root.selectAll('[class="root-node"], [class^=riser], [class^=dataLabels]').each(function() {
                if (this.tagName === "circle")
                    this.origin = {
                        x: parseFloat(this.getAttribute("cx")),
                        y: parseFloat(this.getAttribute("cy")),
                        r: parseFloat(this.getAttribute("r"))
                    };
                else if (this.tagName === "text")
                    this.origin = {
                        x: parseFloat(this.getAttribute("x")),
                        y: parseFloat(this.getAttribute("y"))
                    }
            }).on("click.tdg_zoom", function() {
                chart.hideHoverNode();
                chart.hideToolTip();
                if (focus === this) {
                    focus = undefined;
                    unzoom()
                } else {
                    focus = this;
                    zoom(this.origin)
                }
            })
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.getHeatmapAxisLayout = function(chartSize, matrixMasterChartSize) {
        var chart = this;
        chart.axisList.x1.majorGrid.aboveRisers = true;
        chart.zaxis.majorGrid.aboveRisers = true;
        var axisLayout = {
            xAxisList: [{
                side: chart.axisList.x1.swapChartSide ? "top" : "bottom",
                name: "x1",
                properties: chart.axisList.x1
            }, {
                side: chart.zaxis.swapChartSide ? "right" : "left",
                name: "z1",
                properties: chart.zaxis
            }]
        };
        if (matrixMasterChartSize)
            axisLayout.spacing = chart.layoutAxis(chartSize, axisLayout.xAxisList, matrixMasterChartSize);
        else {
            axisLayout.spacing = chart.layoutAxis(chartSize, axisLayout.xAxisList);
            var pad = chart.chartType === "matrix" ? 0 : chart.getPadding("frame", "width");
            if (axisLayout.spacing.inset.right < pad) {
                axisLayout.spacing.w -= pad - axisLayout.spacing.inset.right;
                axisLayout.spacing.inset.right = pad
            }
            axisLayout.spacing.inset.right = Math.max(axisLayout.spacing.inset.right, chart.getPadding("frame", "width"))
        }
        var size = {
            width: axisLayout.spacing.w,
            height: axisLayout.spacing.h
        };
        var x = chart.getOrdinalScale(size, 1, "horizontal", chart.axisList.x1.invert);
        var z = chart.getOrdinalScale(size, 1, "vertical", chart.zaxis.invert, true);
        axisLayout.xScalesList = [x, z];
        return axisLayout
    }
    ;
    tdgchart.prototype.layoutHeatmap = function(overallChartSize) {
        var chart = this;
        var chartLayout = chart.layoutDefaultChart(overallChartSize);
        function doLayout(size) {
            chartLayout.axisLayout = chart.getHeatmapAxisLayout(size);
            chartLayout.chartSize = chart.updateSizeAxisLayout(size, chartLayout.axisLayout.spacing);
            return chartLayout.chartSize
        }
        doLayout(chartLayout.chartSize);
        chart.applyBLAScrolling(chartLayout, doLayout);
        return chartLayout
    }
    ;
    tdgchart.prototype.drawHeatmap = function(chartPanels, chartLayout, data) {
        var chart = this;
        var chartSize = chartLayout.chartSize;
        data = data || chart._internalData;
        chart.addChartFrame(chartPanels.riser.panel);
        var border = 0;
        if (chart.chartFrame && chart.chartFrame.border && chart.chartFrame.border.width > 0)
            border = chart.chartFrame.border.width / 2;
        var x = chartLayout.axisLayout.xScalesList[0];
        var cols = chart.visibleGroupCount();
        var rows = chart.seriesCount();
        var w = (chartSize.width - border - border) / cols;
        var h = (chartSize.height - border - border) / rows;
        var offset = chart.getOrdinalScale(chartSize, 1, "horizontal", chart.axisList.x1.invert);
        var ar = x.range();
        var last = ar[ar.length - 1];
        if (ar.length > 1 && ar[1] - ar[0] === w) {
            offset.range(tdg.range(0, last, w));
            offset.range().push(last)
        } else
            offset.range(tdg.range(0, last, w));
        var bar = chartPanels.riser.panel.add(pv.Panel).data(data).top(function() {
            return this.index * h + border
        }).height(h).add(pv.Bar).data(function(d) {
            return d
        }).className(chart.classNameLookup("bar", "riser")).left(function() {
            return offset(this.index) + border
        }).width(w).fillStyle(chart.seriesColorLookup(chartLayout.chartSize)).strokeStyle(null).lineWidth(1).antialias(false).title(chart.seriesToolTipLookup());
        function hideToWideLabels(dataSeries, maxWidth) {
            var dataTextFn = chart.dataTextMarkLookup();
            data.forEach(function(dataSeries) {
                if (dataSeries)
                    dataSeries.forEach(function(d) {
                        var clipToContainer = chart.getSeriesAndGroupProperty(d._s, d._g, "dataLabels.clipToContainer");
                        if (clipToContainer) {
                            var labelText = dataTextFn(d, data);
                            if (labelText) {
                                var labelFont = chart.getSeriesAndGroupProperty(d._s, d._g, "dataLabels.font");
                                var labelWidth = chart.measureLabel(labelText, labelFont).width;
                                if (labelWidth > maxWidth)
                                    d.noLabel = true
                            }
                        }
                    })
            })
        }
        hideToWideLabels(data, w);
        chart.doDataLabels(bar, null, {
            textMargin: 5
        });
        if (chart.colorMode.mode === "byMetric")
            bar.add(pv.Bar).fillStyle(chart.dataSelection.unselectedColor || "grey").height(function(d) {
                var val = chart.colorMode.data[this.parent.index][this.index];
                var pct = tdg.isPercentString(val) ? tdg.parsePercent(val) : val / d.color;
                return d ? this.parent.height() * (1 - pct) : 0
            });
        chart.drawOrdinalAxis(chartPanels, chartLayout.axisLayout.xScalesList[0], chartLayout.axisLayout.xAxisList[0], chartLayout.axisLayout.spacing, false);
        chart.drawOrdinalAxis(chartPanels, chartLayout.axisLayout.xScalesList[1], chartLayout.axisLayout.xAxisList[1], chartLayout.axisLayout.spacing, false)
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.drawParabox = function(panel) {
        var chart = this;
        chart.dataSelection.enabled = true;
        var dims = chart.groupLabels;
        var ordinal = chart.data[0].map(function(v) {
            return typeof v.value === "string"
        });
        var categoryAxisWidth = 60;
        var groupLabels = chart.groupLabels.slice();
        var allowedLblWidth = (panel.computedSize.width - (groupLabels.length + 1) * 5) / groupLabels.length;
        groupLabels = groupLabels.map(function(lbl) {
            return chart.truncateLabel(lbl, chart.xaxis.labels.font, allowedLblWidth)
        });
        var leftLabelSize = chart.measureLabel(groupLabels[0], chart.xaxis.labels.font).width;
        var rightLabelSize = chart.measureLabel(groupLabels[groupLabels.length - 1], chart.xaxis.labels.font).width;
        var leftEdge = Math.max(leftLabelSize / 2 + 8, categoryAxisWidth / 2);
        var rightEdge = Math.max(rightLabelSize / 2 + 8, categoryAxisWidth / 2);
        var w = panel.computedSize.width - leftEdge - rightEdge;
        var h = panel.computedSize.height - 50;
        chart.dataSelection._disableSelection = true;
        function setActiveCategory(a) {
            var idx;
            if (typeof a === "number" && a >= 0 && a < chart.groupLabels.length)
                idx = a;
            else
                idx = chart.groupLabels.indexOf(a);
            if (colorMode === "byGroup" && !ordinal[idx])
                idx = ordinal.indexOf(true);
            if (idx === -1)
                idx = 0;
            return chart.groupLabels[idx]
        }
        var mattching_data_pattern = function(row) {
            var i = 0;
            while (i < ordinal.length) {
                if (row[i].value == null)
                    return false;
                if (typeof row[i].value === "string" !== ordinal[i])
                    return false;
                i++
            }
            return true
        };
        var radiusOverride = ordinal[0] && chart.paraboxProperties.bubbleRadius;
        var dataRows = 0;
        var dataRevMapping = [];
        var dataMapping = chart.data.map(function(row, i) {
            if (mattching_data_pattern(row)) {
                dataRevMapping.push(i);
                return dataRows++
            }
            return -1
        });
        var data = chart.data.filter(function(row, i) {
            return dataMapping[i] !== -1
        });
        var ordinfo = ordinal.map(function() {
            return {
                seq: [],
                value: {},
                sum: 0
            }
        });
        data.forEach(function(row) {
            ordinal.forEach(function(isOrdinal, i) {
                if (isOrdinal) {
                    var key = row[i].value;
                    var idx = ordinfo[i].seq.indexOf(key);
                    if (idx >= 0) {
                        if (radiusOverride == null)
                            ordinfo[i].value[key].count++
                    } else {
                        ordinfo[i].value[key] = {
                            count: 1,
                            sums: 0,
                            idx: ordinfo[i].seq.length
                        };
                        ordinfo[i].seq.push(key)
                    }
                }
            })
        });
        ordinfo.forEach(function(os, i) {
            if (!ordinal[i])
                return true;
            var ordsum = 0;
            var rsum = 0;
            var smallest = 0;
            var biggest = 0;
            os.seq.forEach(function(key) {
                ordsum += ordinfo[i].value[key].count;
                os.value[key].sums = ordsum;
                os.value[key].radius = Math.sqrt(os.value[key].count) / 2;
                if (smallest === 0 || smallest > os.value[key].radius)
                    smallest = os.value[key].radius;
                if (biggest < os.value[key].radius)
                    biggest = os.value[key].radius;
                os.value[key].rstart = rsum;
                rsum += 2 * os.value[key].radius
            });
            var dmin = chart.defaultSeries.marker.size;
            var dmax = 60;
            os.sum = rsum;
            var ratio = 1;
            if (biggest * 2 / rsum * h > dmax)
                ratio = dmax / (biggest * 2 / rsum * h);
            if (smallest * 2 / rsum * h * ratio < dmin)
                ratio *= dmin / (smallest * 2 / rsum * h * ratio);
            var margin = 0;
            if (ratio < 1)
                margin = 1 - ratio;
            if (ratio >= 1 && h)
                margin = (os.seq.length - 1) * 1 / h;
            if (margin) {
                var spacing = (os.sum / (1 - margin) - os.sum) / os.seq.length;
                os.seq.forEach(function(key, n) {
                    os.value[key].rstart += n * spacing + spacing / 2;
                    os.sum += spacing
                })
            }
        });
        if (radiusOverride === "auto")
            radiusOverride = Math.min(categoryAxisWidth, h / ordinfo[0].seq.length) / 2 - .5;
        var fudge = .5;
        var x = pv.Scale.ordinal(dims).splitFlush(0, w);
        var y = tdg.dict(dims, function(t, idx) {
            if (ordinal[idx]) {
                ordinfo[idx].scales = pv.Scale.linear(0, ordinfo[idx].sum).range(0, h);
                return ordinfo[idx].scales.by(function(v) {
                    return ordinfo[idx].sum - (ordinfo[idx].value[v].rstart + ordinfo[idx].value[v].radius)
                })
            } else
                return pv.Scale.linear(data, function(d) {
                    return Math.floor(d[idx] ? d[idx].value : NaN) - fudge
                }, function(d) {
                    return Math.ceil(d[idx] ? d[idx].value : NaN) + fudge
                }).range(0, h)
        });
        var revPos = function(d) {
            var t = chart.groupLabels[this.parent.index];
            var range = y[t].range();
            var max = range[1];
            return max - y[t](d)
        };
        var colorModeColors = ["steelblue", "brown"];
        var colorMode = chart.getColorMode();
        var seriesColors = chart.series.filter(function(s) {
            return typeof s.series === "number" && s.color != null
        }).sort(function(a, b) {
            return a.series - b.series
        }).map(function(s) {
            return s.color
        });
        if (!seriesColors.length)
            colorMode = "byHeight";
        if (typeof chart.colorMode === "object" && chart.colorMode.hasOwnProperty("colorList") && typeof chart.colorMode.colorList !== "undefined" && chart.colorMode.colorList.length >= 2)
            colorModeColors = chart.colorMode.colorList;
        else if (typeof chart.colorModeColors !== "undefined" && chart.colorModeColors.length >= 2)
            colorModeColors = chart.colorModeColors;
        var domain, c = tdg.dict(dims, function(t, idx) {
            if (ordinal[idx]) {
                domain = tdg.rangeCount(0, ordinfo[idx].seq.length, colorModeColors.length);
                return pv.Scale.linear.apply(null, domain).range(colorModeColors).by(function(v) {
                    return ordinfo[idx].seq.length - ordinfo[idx].value[v].idx
                })
            } else {
                var idxData = data.map(function(el) {
                    return el[idx] ? el[idx].value : NaN
                });
                domain = tdg.rangeCount(tdg.min(idxData, function(d) {
                    return Math.floor(d) - fudge
                }), tdg.max(idxData, function(d) {
                    return Math.ceil(d) + fudge
                }), colorModeColors.length);
                return pv.Scale.linear.apply(null, domain).range(colorModeColors)
            }
        });
        var filter = tdg.dict(dims, function(t, idx) {
            if (ordinal[idx])
                return {
                    all: true,
                    list: {}
                };
            else
                return {
                    min: y[t].domain()[0],
                    max: y[t].domain()[1]
                }
        });
        var active = setActiveCategory(chart.paraboxProperties.activeGroup);
        var selectedLines = computeSelectedLines();
        function computeSelectedLines() {
            var selected = data.map(function(d) {
                return dims.every(function(t) {
                    var idx = chart.groupLabels.indexOf(t);
                    if (ordinal[idx])
                        return bubbleInFilter(idx, d[idx].value);
                    else
                        return d[idx] ? d[idx].value >= filter[t].min && d[idx].value <= filter[t].max : false
                })
            });
            return selected
        }
        function filtersChanged() {
            selectedLines = computeSelectedLines()
        }
        var prevSelected = [];
        function updateSelectedCallback() {
            if (!chart.previewSelection.enabled)
                return;
            var callback = chart.previewSelection.eventCallback;
            if (!callback || typeof callback !== "function")
                return;
            if (selectedLines != prevSelected && !selectedLines.every(function(isSelected, i) {
                return isSelected == prevSelected[i]
            })) {
                var selectedData = [];
                selectedLines.every(function(isSelected, i) {
                    if (isSelected) {
                        selectedData.push({
                            series: dataRevMapping[i],
                            group: 0
                        });
                        return true
                    }
                });
                prevSelected = selectedLines;
                chart.previewSelection.eventCallback.call(chart, selectedData)
            }
        }
        function selectLinesAPI(sel) {
            selectedLines = data.map(function() {
                return false
            });
            sel.every(function(s) {
                var idx = dataMapping[s.series];
                if (idx != null && idx !== -1) {
                    selectedLines[idx] = true;
                    return true
                }
            });
            change.render()
        }
        tdgchart.prototype.selectLines = selectLinesAPI;
        var dataPanel = panel.add(pv.Panel).width(w).height(h).left(leftEdge).top(30);
        var idx = chart.groupLabels.indexOf(active);
        var lineWidthLookup = 1;
        if (chart.paraboxProperties.border && chart.paraboxProperties.border.width != undefined)
            lineWidthLookup = chart.paraboxProperties.border.width;
        dataPanel.add(pv.Panel).data(data).visible(true).add(pv.Line).data(dims).left(function(t) {
            return x(t)
        }).bottom(function(t, d) {
            return y[t](d[this.index] ? d[this.index].value : NaN)
        }).lineWidth(lineWidthLookup).strokeStyle(chart.dataSelection.unselectedColor);
        var rule = dataPanel.add(pv.Rule).strokeStyle("black").data(dims).left(x);
        var lblHeight = chart.measureLabel("W", chart.xaxis.labels.font || "bold 10px sans-serif").height;
        rule.anchor("top").add(pv.Label).top(-lblHeight || -12).font(chart.xaxis.labels.font || "bold 10px sans-serif").textStyle(chart.xaxis.labels.color).text(function() {
            return groupLabels[this.index]
        });
        function bubbleInFilter(idx, dataval) {
            var f = filter[chart.groupLabels[idx]];
            return f.all || f.list[dataval] === true
        }
        var change = dataPanel.add(pv.Panel);
        var bubbles = change.add(pv.Panel).data(dims).visible(function() {
            return ordinal[this.index]
        }).left(function(d) {
            return x(d)
        }).add(pv.Dot).shape("circle").lineStyle("none").data(function() {
            return ordinfo[this.parent.index].seq
        }).className(function() {
            return "riser!s" + this.parent.index + "!g" + this.index
        }).fillStyle(chart.dataSelection.unselectedColor).top(revPos).radius(radiusOverride != null ? radiusOverride : function(d) {
            return ordinfo[this.parent.index].scales(ordinfo[this.parent.index].value[d].radius)
        }
        );
        function bubbleActiveRadius(val) {
            var idx = this.parent.index;
            var count = 0;
            data.forEach(function(d, i) {
                if (d[idx].value == val && selectedLines[i]) {
                    count++;
                    return true
                }
            });
            var all = ordinfo[this.parent.index].value[val].count;
            var radius = ordinfo[this.parent.index].value[val].radius;
            return ordinfo[this.parent.index].scales(radius * Math.sqrt(count / all))
        }
        function bubbleColorByHeight(d) {
            if (chart.groupLabels[this.parent.index] == active)
                return c[chart.groupLabels[this.parent.index]](d);
            else
                return chart.dataSelection.selectedColor
        }
        function bubbleColorByGroup() {
            if (chart.groupLabels[this.parent.index] == active)
                return seriesColors[this.index % seriesColors.length];
            else
                return chart.dataSelection.selectedColor
        }
        var bubblesHighlight = change.add(pv.Panel).data(dims).visible(function() {
            return ordinal[this.index]
        }).left(function(d) {
            return x(d)
        }).add(pv.Dot).shape("circle").lineStyle("none").data(function() {
            return ordinfo[this.parent.index].seq
        }).visible(function(d) {
            return bubbleInFilter(this.parent.index, d)
        }).fillStyle(colorMode === "byHeight" ? bubbleColorByHeight : colorMode === "byGroup" ? bubbleColorByGroup : colorMode === "bySeries" ? chart.dataSelection.selectedColor : bubbleColorByHeight).top(revPos).radius(radiusOverride != null ? radiusOverride : bubbleActiveRadius);
        dataPanel.add(pv.Panel).data(dims).visible(function() {
            return ordinal[this.index]
        }).left(function(d) {
            return x(d) - 30
        }).add(pv.Panel).data(function() {
            return ordinfo[this.parent.index].seq
        }).top(revPos).add(pv.Label).events("none").textBaseline("middle").text(function(d) {
            return d
        });
        change.add(pv.Panel).data(data).visible(function() {
            return selectedLines[this.index]
        }).add(pv.Line).className(chart.classNameLookup("line", "riser")).title(chart.seriesToolTipLookup()).data(dims).left(function(t) {
            return x(t)
        }).bottom(function(t, d) {
            return y[t](d[this.index] ? d[this.index].value : NaN)
        }).lineWidth(lineWidthLookup).strokeStyle(function(t, d) {
            var color;
            if (colorMode === "bySeries")
                color = seriesColors[this.parent.index % seriesColors.length];
            else if (colorMode === "byGroup" && ordinal[idx])
                color = seriesColors[ordinfo[idx].seq.indexOf(d[idx].value) % seriesColors.length];
            else
                color = c[active](d[idx].value);
            return color
        });
        function select(d) {
            if (chart.dataSelection.selectionMode.indexOf("dragRect") === -1)
                return true;
            var t = d.dim;
            filter[t].min = Math.max(y[t].domain()[0], y[t].invert(h - d.y - d.dy));
            filter[t].max = Math.min(y[t].domain()[1], y[t].invert(h - d.y));
            filtersChanged();
            change.render();
            chart.addHTMLToolTips();
            return false
        }
        function selectAll(d) {
            if (d.dy < 3) {
                var t = d.dim;
                filter[t].min = Math.max(y[t].domain()[0], y[t].invert(0));
                filter[t].max = Math.min(y[t].domain()[1], y[t].invert(h));
                d.y = 0;
                d.dy = h;
                filtersChanged();
                change.render()
            }
            updateSelectedCallback();
            return false
        }
        function selectEnd() {
            updateSelectedCallback();
            return false
        }
        function selectOrdinalClick(d, g) {
            var wantCtrlClick = chart.dataSelection.selectionMode.indexOf("ctrlClick") !== -1;
            var t = g.dim;
            if (wantCtrlClick && (pv.event.ctrlKey || pv.event.shiftKey))
                if (filter[t].all) {
                    var idx = chart.groupLabels.indexOf(t);
                    filter[t].all = false;
                    ordinfo[idx].seq.every(function(v) {
                        filter[t].list[v] = v != d;
                        return true
                    })
                } else
                    filter[t].list[d] = !filter[t].list[d];
            else {
                if (chart.dataSelection.selectionMode.indexOf("click") === -1)
                    return true;
                filter[t].all = false;
                filter[t].list = {};
                filter[t].list[d] = true
            }
            filtersChanged();
            change.render();
            updateSelectedCallback();
            return true
        }
        function selectOrdinal(d) {
            var wantCtrlClick = chart.dataSelection.selectionMode.indexOf("ctrlClick") !== -1;
            var t = d.dim;
            if (wantCtrlClick && (pv.event.ctrlKey || pv.event.shiftKey))
                ;
            else {
                if (chart.dataSelection.selectionMode.indexOf("dragRect") === -1)
                    return true;
                d.selecting = true;
                if (d.dy >= 3) {
                    var idx = chart.groupLabels.indexOf(t);
                    filter[t].all = false;
                    filter[t].list = {};
                    ordinfo[idx].seq.every(function(v) {
                        var filter_min = Math.max(y[t].domain()[0], y[t].invert(h - d.y - d.dy));
                        var filter_max = Math.min(y[t].domain()[1], y[t].invert(h - d.y));
                        var dmin = y[t].domain()[1] - ordinfo[idx].value[v].rstart - 2 * ordinfo[idx].value[v].radius;
                        var dmax = dmin + ordinfo[idx].value[v].radius * 2;
                        if (filter_min <= dmax && filter_max >= dmin)
                            filter[t].list[v] = true;
                        return true
                    })
                }
            }
            filtersChanged();
            change.render();
            chart.addHTMLToolTips();
            return false
        }
        function selectOrdinalEnd(d) {
            var wantCtrlClick = chart.dataSelection.selectionMode.indexOf("ctrlClick") !== -1;
            var t = d.dim;
            d.selecting = false;
            change.render();
            updateSelectedCallback();
            return false
        }
        function selectOrdinalAll(d) {
            if (chart.dataSelection.selectionMode.indexOf("click") === -1)
                return true;
            var t = d.dim;
            filter[t].all = true;
            filtersChanged();
            change.render();
            updateSelectedCallback();
            return false
        }
        var categoryAxis = change.add(pv.Panel).data(dims.map(function(dim) {
            return {
                y: 0,
                dy: h,
                dim: dim
            }
        })).visible(function() {
            return !ordinal[this.index]
        }).left(function(t) {
            return x(t.dim) - 30
        }).width(categoryAxisWidth).fillStyle("rgba(0,0,0,.001)");
        if (chart.dataSelection.enabled && chart.dataSelection.selectionMode.indexOf("dragRect") !== -1) {
            categoryAxis.cursor("crosshair").event("mousedown", pv.Behavior.select()).event("select", select).event("selectend", selectAll);
            var handle = categoryAxis.add(pv.Bar).left(25).top(function(d) {
                return d.y
            }).width(10).height(function(d) {
                return d.dy
            }).fillStyle(function(t) {
                return t.dim == active ? c[t.dim]((filter[t.dim].max + filter[t.dim].min) / 2) : "hsla(0,0,50%,.5)"
            }).strokeStyle("white").cursor("move").event("mousedown", pv.Behavior.drag()).event("dragstart", select).event("drag", select).event("dragend", selectEnd);
            handle.anchor("bottom").add(pv.Label).textBaseline("top").text(function(d) {
                return filter[d.dim].min.toFixed(0)
            }).font(chart.xaxis.labels.font || "bold 10px sans-serif").textStyle(chart.xaxis.labels.color);
            handle.anchor("top").add(pv.Label).textBaseline("bottom").text(function(d) {
                return filter[d.dim].max.toFixed(0)
            }).font(chart.xaxis.labels.font || "bold 10px sans-serif").textStyle(chart.xaxis.labels.color)
        } else {
            categoryAxis.anchor("bottom").add(pv.Label).textBaseline("top").text(function(d) {
                return filter[d.dim].min.toFixed(0)
            }).font(chart.xaxis.labels.font || "bold 10px sans-serif").textStyle(chart.xaxis.labels.color);
            categoryAxis.anchor("top").add(pv.Label).textBaseline("bottom").text(function(d) {
                return filter[d.dim].max.toFixed(0)
            }).font(chart.xaxis.labels.font || "bold 10px sans-serif").textStyle(chart.xaxis.labels.color)
        }
        if (chart.dataSelection.enabled)
            change.add(pv.Panel).data(dims.map(function(dim) {
                return {
                    selecting: false,
                    y: 0,
                    dy: h,
                    dim: dim
                }
            })).visible(function() {
                return ordinal[this.index]
            }).left(function(t) {
                return x(t.dim) - categoryAxisWidth / 2
            }).width(categoryAxisWidth).fillStyle("rgba(0,0,0,.001)").cursor(chart.dataSelection.selectionMode.indexOf("dragRect") === -1 ? "auto" : "crosshair").event("mousedown", pv.Behavior.select()).event("select", selectOrdinal).event("selectend", selectOrdinalEnd).event("click", selectOrdinalAll).add(pv.Bar).visible(function(d) {
                return d.selecting
            }).left(function(d) {
                return d.x
            }).top(function(d) {
                return d.y
            }).width(function(d) {
                return d.dx
            }).height(function(d) {
                return d.dy
            }).fillStyle(chart.dataSelection.selectionRect.fill).lineStyle(chart.dataSelection.selectionRect.border).parent.add(pv.Wedge).data(function() {
                return ordinfo[this.parent.index].seq
            }).angle(360).fillStyle("rgba(0,0,0,.001)").left(categoryAxisWidth / 2).top(revPos).innerRadius(0).outerRadius(function(d) {
                return ordinfo[this.parent.index].scales(ordinfo[this.parent.index].value[d].radius)
            }).cursor(chart.dataSelection.selectionMode.indexOf("dragRect") === -1 ? "auto" : "crosshair").event("click", selectOrdinalClick);
        chart.addBevel(bubbles);
        chart.addBevel(bubblesHighlight)
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    (function() {
        var cw = 1 << 11 >> 5, ch = 1 << 11, c, canvas, ratio = 1;
        function cloudCreator() {
            initialize();
            var size = [256, 256], text = cloudText, font = cloudFont, fontSize = cloudFontSize, fontStyle = cloudFontNormal, fontWeight = cloudFontNormal, rotate = cloudRotate, padding = cloudPadding, spiral = archimedeanSpiral, words = [], timeInterval = Infinity, timer = null, cloud = {}, randomNumber;
            var lastFunction;
            cloud.closingFunction = function(func) {
                lastFunction = func;
                return cloud
            }
            ;
            cloud.start = function() {
                var board = zeroArray((size[0] >> 5) * size[1])
                  , bounds = null
                  , n = words.length
                  , i = -1
                  , tags = []
                  , data = words.map(function(d, i) {
                    d.text = text.call(this, d, i);
                    d.font = font.call(this, d, i);
                    d.style = fontStyle.call(this, d, i);
                    d.weight = fontWeight.call(this, d, i);
                    d.rotate = rotate.call(this, d, i);
                    d.size = ~~fontSize.call(this, d, i);
                    d.padding = padding.call(this, d, i);
                    return d
                }).sort(function(a, b) {
                    return b.size - a.size
                });
                if (timer)
                    clearInterval(timer);
                timer = setInterval(step, 0);
                step();
                return cloud;
                function step() {
                    var d, start = +new Date;
                    randomNumber = random(data.length);
                    while (+new Date - start < timeInterval && ++i < n && timer) {
                        d = data[i];
                        d.x = size[0] * (randomNumber() + .5) >> 1;
                        d.y = size[1] * (randomNumber() + .5) >> 1;
                        cloudSprite(d, data, i);
                        var _place = d.hasText && place(board, d, bounds, data.length);
                        if (_place) {
                            tags.push(d);
                            if (bounds)
                                cloudBounds(bounds, d);
                            else
                                bounds = [{
                                    x: d.x + d.x0,
                                    y: d.y + d.y0
                                }, {
                                    x: d.x + d.x1,
                                    y: d.y + d.y1
                                }];
                            d.x -= size[0] >> 1;
                            d.y -= size[1] >> 1
                        } else
                            ;
                    }
                    if (i >= n) {
                        cloud.stop();
                        lastFunction(tags)
                    }
                }
            }
            ;
            cloud.stop = function() {
                if (timer) {
                    clearInterval(timer);
                    timer = null
                }
                return cloud
            }
            ;
            cloud.timeInterval = function(x) {
                if (!arguments.length)
                    return timeInterval;
                timeInterval = x == null ? Infinity : x;
                return cloud
            }
            ;
            function random(seed) {
                var memo = seed;
                return function() {
                    Math.abs(memo);
                    memo *= 3.713713713;
                    if (!isFinite(memo))
                        memo = ++seed;
                    var x = Math.sin(++memo) * 1E4;
                    return x - Math.floor(x)
                }
            }
            function place(board, tag, bounds) {
                var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), s = spiral(size), dt = randomNumber() < .5 ? 1 : -1, t = -dt, dxdy, dx, dy;
                while (dxdy = s(t += dt)) {
                    dx = ~~dxdy[0];
                    dy = ~~dxdy[1];
                    if (Math.min(dx, dy) > maxDelta)
                        break;
                    tag.x = startX + dx;
                    tag.y = startY + dy;
                    if (tag.x + tag.x0 < 0 || tag.x + tag.x1 > size[0])
                        continue;
                    if (tag.y + tag.y0 < 0)
                        continue;
                    if (tag.y + tag.y1 - (tag.height >> 1) > size[1])
                        continue;
                    if (!bounds || !cloudCollide(tag, board, size[0]))
                        if (!bounds || collideRects(tag, bounds)) {
                            var sprite = tag.sprite, w = tag.width >> 5, sw = size[0] >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0, x = (tag.y + tag.y0) * sw + (lx >> 5), last;
                            for (var j = 0; j < h; j++) {
                                last = 0;
                                for (var i = 0; i <= w; i++)
                                    board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
                                x += sw
                            }
                            delete tag.sprite;
                            return true
                        }
                }
                return false
            }
            cloud.words = function(x) {
                if (!arguments.length)
                    return words;
                words = x;
                return cloud
            }
            ;
            cloud.size = function(x) {
                if (!arguments.length)
                    return size;
                size = [+x[0], +x[1]];
                return cloud
            }
            ;
            cloud.font = function(x) {
                if (!arguments.length)
                    return font;
                font = tdgchart.d3.functor(x);
                return cloud
            }
            ;
            cloud.fontStyle = function(x) {
                if (!arguments.length)
                    return fontStyle;
                fontStyle = tdgchart.d3.functor(x);
                return cloud
            }
            ;
            cloud.fontWeight = function(x) {
                if (!arguments.length)
                    return fontWeight;
                fontWeight = tdgchart.d3.functor(x);
                return cloud
            }
            ;
            cloud.rotate = function(x) {
                if (!arguments.length)
                    return rotate;
                rotate = tdgchart.d3.functor(x);
                return cloud
            }
            ;
            cloud.text = function(x) {
                if (!arguments.length)
                    return text;
                text = tdgchart.d3.functor(x);
                return cloud
            }
            ;
            cloud.fontSize = function(x) {
                if (!arguments.length)
                    return fontSize;
                fontSize = tdgchart.d3.functor(x);
                return cloud
            }
            ;
            cloud.padding = function(x) {
                if (!arguments.length)
                    return padding;
                padding = tdgchart.d3.functor(x);
                return cloud
            }
            ;
            return cloud
        }
        function cloudText(d) {
            return d.nodeName
        }
        function cloudFont() {
            return "serif"
        }
        function cloudFontNormal() {
            return "normal"
        }
        function cloudFontSize(d) {
            return Math.sqrt(d.value)
        }
        function cloudRotate() {
            return (~~(Math.random() * 6) - 3) * 30
        }
        function cloudPadding() {
            return 1
        }
        function cloudSprite(d, data, di) {
            if (d.sprite)
                return;
            c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
            var cloudRadians = Math.PI / 180;
            var x = 0
              , y = 0
              , maxh = 0;
            var n = data.length;
            var w, h, i, ts;
            --di;
            while (++di < n) {
                d = data[di];
                c.save();
                c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
                ts = c.measureText(d.text + "m");
                w = ts.width * ratio;
                h = Math.ceil(d.size) << 1;
                if (d.rotate) {
                    var sr = Math.sin(d.rotate * cloudRadians)
                      , cr = Math.cos(d.rotate * cloudRadians)
                      , wcr = w * cr
                      , wsr = w * sr
                      , hcr = h * cr
                      , hsr = h * sr;
                    w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
                    h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr))
                } else
                    w = w + 31 >> 5 << 5;
                if (h > maxh)
                    maxh = h;
                if (x + w >= cw << 5) {
                    x = 0;
                    y += maxh;
                    maxh = 0
                }
                if (y + h >= ch)
                    break;
                c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
                if (d.rotate)
                    c.rotate(d.rotate * cloudRadians);
                c.fillText(d.text, 0, 0);
                if (d.padding) {
                    c.lineWidth = 2 * d.padding;
                    c.strokeText(d.text, 0, 0)
                }
                c.restore();
                d.width = w;
                d.height = h;
                d.xoff = x;
                d.yoff = y;
                d.x1 = w >> 1;
                d.y1 = h >> 1;
                d.x0 = -d.x1;
                d.y0 = -d.y1;
                d.hasText = true;
                x += w
            }
            var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data
              , sprite = [];
            while (--di >= 0) {
                d = data[di];
                if (!d.hasText)
                    continue;
                w = d.width;
                var w32 = w >> 5;
                h = d.y1 - d.y0;
                for (i = 0; i < h * w32; i++)
                    sprite[i] = 0;
                x = d.xoff;
                if (x == null)
                    return;
                y = d.yoff;
                var seen = 0
                  , seenRow = -1;
                for (var j = 0; j < h; j++) {
                    for (i = 0; i < w; i++) {
                        var k = w32 * j + (i >> 5)
                          , m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;
                        sprite[k] |= m;
                        seen |= m
                    }
                    if (seen)
                        seenRow = j;
                    else {
                        d.y0++;
                        h--;
                        j--;
                        y++
                    }
                }
                d.y1 = d.y0 + seenRow;
                d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32)
            }
        }
        function cloudCollide(tag, board, sw) {
            sw >>= 5;
            var sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0, x = (tag.y + tag.y0) * sw + (lx >> 5), last;
            for (var j = 0; j < h; j++) {
                last = 0;
                for (var i = 0; i <= w; i++)
                    if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i])
                        return true;
                x += sw
            }
            return false
        }
        function cloudBounds(bounds, d) {
            var b0 = bounds[0]
              , b1 = bounds[1];
            if (d.x + d.x0 < b0.x)
                b0.x = d.x + d.x0;
            if (d.y + d.y0 < b0.y)
                b0.y = d.y + d.y0;
            if (d.x + d.x1 > b1.x)
                b1.x = d.x + d.x1;
            if (d.y + d.y1 > b1.y)
                b1.y = d.y + d.y1
        }
        function collideRects(a, b) {
            return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y
        }
        function archimedeanSpiral(size) {
            var e = size[0] / size[1];
            return function(t) {
                return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)]
            }
        }
        function zeroArray(n) {
            var a = []
              , i = -1;
            while (++i < n)
                a[i] = 0;
            return a
        }
        var isInitialized = false;
        function initialize() {
            if (isInitialized)
                return;
            isInitialized = true;
            canvas = typeof document !== "undefined" && document.createElement("canvas");
            if (canvas && canvas.getContext) {
                canvas.width = 1;
                canvas.height = 1;
                ratio = Math.sqrt(canvas.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
                canvas.width = (cw << 5) / ratio;
                canvas.height = ch / ratio;
                c = canvas.getContext("2d");
                c.fillStyle = c.strokeStyle = "red";
                c.textAlign = "center"
            }
        }
        tdgchart.d3.layout = tdgchart.d3.layout || {};
        tdgchart.d3.layout.cloud = cloudCreator
    }
    )();
    var truncationRatio = .35;
    tdgchart.prototype.drawTagCloud = function(panel) {
        var chart = this;
        var useNewEngine = !!tdgchart.d3.layout.cloud && chart.tagcloudProperties.engine === "new";
        var data = chart.isPageSliderEnabled() ? chart.data[chart.dataPageSlider.currentPage || 0] : chart.data;
        var len = data[0].length;
        var i, j;
        var font = chart.tagcloudProperties.font || "bold 12pt Georgia";
        var maxWidth = panel.computedSize.width * truncationRatio;
        var dataArray = [];
        for (i = 0; i < len; i++)
            if (data[0][i].value != null) {
                var d = tdg.cloneObject(data[0][i]);
                d.group = i;
                d.label = Array.isArray(chart.groupLabels) && chart.groupLabels.length ? chart.groupLabels[i] : "Group " + i;
                d.label = this.truncateLabel(d.label, font, maxWidth);
                dataArray.push(d)
            }
        len = dataArray.length;
        if (len < 1)
            return;
        dataArray.sort(function(a, b) {
            return b.value - a.value
        });
        var maxNumberOfTags = chart.tagcloudProperties.maxNumberOfTags > 0 ? chart.tagcloudProperties.maxNumberOfTags : 1E4;
        if (maxNumberOfTags < len) {
            dataArray = dataArray.slice(0, maxNumberOfTags);
            len = maxNumberOfTags
        }
        var automaticResizing = !chart.xaxis.min && !chart.xaxis.max;
        var minFontSize = chart.xaxis.min || 6;
        var maxFontSize = chart.xaxis.max || 36;
        var bLog = chart.xaxis.bIsLog === true;
        var max = bLog ? Math.log(dataArray[0].value) : dataArray[0].value;
        var min = bLog ? Math.log(dataArray[len - 1].value) : dataArray[len - 1].value;
        var padding = chart.getPadding("label", "maxHorz");
        var skews = [{
            v: 0,
            h: 0
        }];
        var colorScale;
        if (Array.isArray(chart.dataArrayMap) && chart.dataArrayMap.includes("color"))
            colorScale = chart.cache.get("colorAxis", {}).scale;
        else {
            var series0Color = chart.getSeriesAndGroupProperty(0, null, "color");
            colorScale = function() {
                return series0Color
            }
        }
        chart.addChartFrame(panel);
        panel.data(skews);
        if (chart.needHTMLToolTip())
            panel.add(pv.Panel).className("eventPanel").events("all");
        var fontParts = tdg.fontToFontParts(font);
        fontParts.fontFamily = fontParts.fontFamily || "Georgia";
        var makeFontScaleFn;
        if (min === max)
            makeFontScaleFn = function(minFontSize, maxFontSize) {
                return function() {
                    return maxFontSize
                }
            }
            ;
        else
            makeFontScaleFn = function(minFontSize, maxFontSize) {
                return pv.Scale.linear(min, max).range(minFontSize, maxFontSize)
            }
            ;
        var fontScaleFunction = makeFontScaleFn(minFontSize, maxFontSize);
        if (useNewEngine && automaticResizing) {
            maxFontSize = panel.computedSize.height * .3 > 16 ? panel.computedSize.height * .3 : 16;
            maxFontSize = Math.floor(maxFontSize);
            minFontSize = Math.max(Math.floor(maxFontSize / 6), 8);
            fontScaleFunction = makeFontScaleFn(minFontSize, maxFontSize);
            var panelArea = panel.computedSize.width * panel.computedSize.height;
            var labelDim;
            var goodRatio = Math.max(.66, Math.log10(dataArray.length / 4) - 1.1);
            var goodLabelsArea = panelArea * goodRatio;
            for (i = 0; i < 7; i++) {
                var actualLabelsArea = 0;
                for (j = 0; j < dataArray.length; j++) {
                    fontParts.fontSize = Math.floor(fontScaleFunction(dataArray[j].value)) + "px";
                    labelDim = chart.measureLabel(dataArray[j].label + "i", fontParts.toString());
                    actualLabelsArea += labelDim.width * labelDim.height
                }
                maxFontSize *= Math.sqrt(goodLabelsArea / actualLabelsArea);
                minFontSize = Math.max(Math.floor(maxFontSize / 6), 8);
                maxFontSize = Math.floor(maxFontSize) <= minFontSize ? minFontSize + 5 : Math.floor(maxFontSize);
                fontScaleFunction = makeFontScaleFn(minFontSize, maxFontSize);
                if (Math.abs(goodLabelsArea / actualLabelsArea - 1) < .05)
                    break
            }
            var maxLabelLength = 0;
            for (i = 0; i < dataArray.length; i++) {
                fontParts.fontSize = Math.floor(fontScaleFunction(dataArray[i].value)) + "px";
                labelDim = tdg.measureLabelWidth(dataArray[i].label + "i", fontParts.toString());
                maxLabelLength = Math.max(maxLabelLength, labelDim)
            }
            if (maxLabelLength > panel.computedSize.width * .8) {
                maxFontSize = Math.floor(maxFontSize * .8 * panel.computedSize.width / maxLabelLength);
                maxFontSize = Math.max(maxFontSize, minFontSize + 5);
                fontScaleFunction = makeFontScaleFn(minFontSize, maxFontSize)
            }
        }
        var nodes = dataArray.map(function(t) {
            var d = tdg.cloneObject(t);
            d.nodeName = t.label;
            d.nodeGroup = t.group;
            d.nodeValue = fontScaleFunction(t.value);
            return d
        });
        var labelGroup;
        if (useNewEngine) {
            var pos = panel.computedSize;
            var scene = chart.cache.get("tdgscene");
            labelGroup = scene.group("chartPanel", "groupPanel", pos.x + pos.width / 2, pos.y + pos.height / 2);
            var maxTries = 4
              , fontResizeRatio = 1
              , resulttags = [];
            for (var iter = 0; iter < maxTries; iter++) {
                tdgchart.d3.layout.cloud().size([pos.width, pos.height]).words(nodes).rotate(0).font(fontParts.fontFamily).fontWeight(fontParts.fontWeight).fontStyle(fontParts.fontStyle).fontSize(function(d) {
                    return d.nodeValue
                }).closingFunction(function(tags) {
                    resulttags = tags
                }).start();
                if (resulttags.length < nodes.length) {
                    fontResizeRatio -= .1;
                    fontScaleFunction = makeFontScaleFn(minFontSize * fontResizeRatio, maxFontSize * fontResizeRatio);
                    nodes = dataArray.map(function(t) {
                        var d = tdg.cloneObject(t);
                        d.nodeName = t.label;
                        d.nodeGroup = t.group;
                        d.nodeValue = fontScaleFunction(t.value);
                        return d
                    })
                } else
                    break
            }
            if (resulttags.length < nodes.length)
                ;addTags(resulttags)
        }
        function addTags(tags) {
            for (var i = 0; i < tags.length; i++) {
                var tag = tags[i];
                labelGroup.label(tag.x, tag.y, tag.text, {
                    className: chart.buildClassName("riser", 0, tag.nodeGroup, "tag"),
                    shift: 0,
                    font: font,
                    color: colorScale(tag.color),
                    size: tag.size,
                    align: "middle",
                    title: chart.getSeriesAndGroupProperty(0, tag.nodeGroup, "tooltip"),
                    cursor: "default"
                })
            }
        }
        if (!useNewEngine) {
            var tagCloud = panel.add(pv.Layout.Cloud.Text).nodes(nodes).padding(padding).maxTagCount(len).font(function(d) {
                fontParts.fontSize = d.nodeValue + "px";
                return fontParts.toString()
            }).horizontalSkew(skews.h).verticalSkew(skews.v);
            tagCloud.label.add(pv.Label).events(null).cursor("default").title(chart.seriesToolTipLookup()).className(function(d) {
                return "riser!s0!g" + d.nodeGroup + "!mtag"
            }).textStyle(function(d) {
                return colorScale(bLog ? Math.log(d.color) : d.color) || "black"
            })
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    function getStreamGraphInfo(data, overallChartSize, xAxisScale, paddingLeft) {
        var n = data.length;
        var m = data[0].length;
        var s;
        for (s = 0; s < n; s++) {
            var ms = data[s].length;
            if (ms > m)
                m = ms
        }
        var maxGroupTotal = 0;
        for (var g = 0; g < m; g++) {
            var gTotal = 0;
            for (s = 0; s < n; s++) {
                if (data[s][g] == null)
                    data[s][g] = {
                        value: 0
                    };
                else if (data[s][g].value == null)
                    data[s][g].value = 0;
                gTotal += data[s][g].value
            }
            if (gTotal > maxGroupTotal)
                maxGroupTotal = gTotal
        }
        var w = overallChartSize.width;
        var h = overallChartSize.height;
        var xoffset = xAxisScale(0) + xAxisScale.range().band / 2 + paddingLeft;
        var xscale = pv.Scale.linear(0, m - 1).range(xoffset, w - xoffset);
        var yscale = pv.Scale.linear(0, 2 * maxGroupTotal).range(0, h);
        return {
            data: data,
            xscale: xscale,
            yscale: yscale
        }
    }
    tdgchart.prototype.layoutStreamGraph = function(overallChartSize) {
        var chart = this;
        var data = chart._internalData || chart.data;
        var xaxis = {
            side: chart.axisList.x1.swapChartSide ? "top" : "bottom",
            name: "x1",
            properties: chart.axisList.x1
        };
        var chartLayout = chart.layoutDefaultChart(overallChartSize);
        chartLayout.axisLayout = {};
        var x = chart.getOrdinalScale(overallChartSize, 1, null, chart.axisList.x1.invert);
        chartLayout.axisLayout.xAxisList = [xaxis];
        chartLayout.axisLayout.xScalesList = [x];
        chartLayout.streamGraphInfo = getStreamGraphInfo(data, overallChartSize, x, chart.getPadding("frame", "left"));
        chartLayout.axisLayout.spacing = chart.layoutAxis(chartLayout.chartSize, chartLayout.axisLayout.xAxisList);
        chartLayout.chartSize = chart.updateSizeAxisLayout(chartLayout.chartSize, chartLayout.axisLayout.spacing);
        return chartLayout
    }
    ;
    tdgchart.prototype.drawStreamGraph = function(panel, chartLayout) {
        var chart = this;
        var seriesLabels = chart.getSeriesLabels();
        var chartPanels = chart.createXYPanels(panel, chartLayout.chartSize, chartLayout.axisLayout);
        if (chart.mouseOverIndicator.enabled || chart.needHTMLToolTip())
            chartPanels.riser.panel.className("eventPanel").events("all");
        var x = chartLayout.axisLayout.xScalesList[0];
        chart.drawOrdinalAxis(chartPanels, x, chartLayout.axisLayout.xAxisList[0], chartLayout.axisLayout.spacing, false);
        var interpolate = {
            linear: "linear",
            stepBefore: "step-before",
            stepAfter: "step-after",
            curved: "cardinal",
            curvedB: "basis"
        }[chart.blaProperties.lineConnection] || "basis";
        var risers = chartPanels.riser.panel.add(pv.Layout.Stack).layers(chartLayout.streamGraphInfo.data).offset("wiggle").x(chartLayout.streamGraphInfo.xscale.by(pv.index)).y(function(d) {
            return chartLayout.streamGraphInfo.yscale(d.value)
        }).layer.add(pv.Area).fillStyle(chart.seriesColorLookup()).className(chart.classNameLookup("area", "riser")).interpolate(interpolate).title(chart.seriesToolTipLookup());
        chart.addMarkers(risers, chartLayout.streamGraphInfo.data);
        var labels = chart.doDataLabels(risers, "center");
        if (labels)
            labels.def("max", function(d) {
                return tdg.max(d, "value", "index")
            }).visible(function() {
                return this.index === this.max()
            }).text(function() {
                return seriesLabels[this.parent.index]
            })
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.layoutDataGrid = function(overallChartSize) {
        var chart = this;
        var i, j, r, c, v, lblWidth, font;
        var layout = chart.layoutDefaultChart(overallChartSize);
        var rowCount = 0
          , colCount = 0;
        var nullDataCase = tdg.isEmpty(chart.data) || chart.data.length === 1 && chart.data[0].length === 0;
        if (!nullDataCase) {
            rowCount = chart.seriesCount();
            colCount = chart.groupCount()
        }
        var lb = "dataGridProperties.cell.labels.";
        var cellStyle = {
            labels: {
                font: chart.get(lb + "font", "10pt Arial"),
                color: chart.get(lb + "color", "black"),
                numberFormat: chart.get(lb + "numberFormat", "auto"),
                align: chart.get(lb + "align", "center"),
                valign: chart.get(lb + "valign", "center")
            }
        };
        var tt = chart.get("dataGridProperties.cell.tooltip");
        if (tt != undefined)
            cellStyle.tooltip = tt;
        lb = "dataGridProperties.columnTotals.cellLabel.";
        var totalCellStyle = {
            labels: {
                font: chart.get(lb + "font", "10pt Arial"),
                color: chart.get(lb + "color", "black"),
                numberFormat: chart.get(lb + "numberFormat", "auto"),
                align: chart.get(lb + "align", "center"),
                valign: chart.get(lb + "valign", "center")
            }
        };
        var fmtList = chart.get("dataGridProperties.cell.formatList", []);
        var exceptionalList = normalizeExceptionalList(fmtList, rowCount, colCount, cellStyle, totalCellStyle);
        var cellPad = chart.get("dataGridProperties.cell.layout.cellPadding", {
            left: 5,
            top: 5,
            right: 5,
            bottom: 5
        });
        var freezeRow = chart.get("dataGridProperties.scroll.freezeRowHeader");
        var freezeCol = chart.get("dataGridProperties.scroll.freezeColHeader");
        var cellBorderWidth = chart.get("dataGridProperties.cell.border.width", 1);
        var halfCellBorderWidth = cellBorderWidth / 2;
        var maxWidth = overallChartSize.width - cellBorderWidth - chart.getPadding("frame", "left") - chart.getPadding("frame", "right");
        var maxHeight = overallChartSize.height - cellBorderWidth;
        var cellPadWidth = cellPad.left + cellPad.right;
        var cellPadHeight = cellPad.top + cellPad.bottom;
        var sortPad = chart.get("dataGridProperties.colHeader.sorting.enabled") ? 10 + cellPad.right : 0;
        var colWidthList = [];
        var cellFont = chart.get("dataGridProperties.cell.labels.font", "10pt Arial");
        var singleCharWidth = tdg.measureLabelWidth("#", cellFont) + 1;
        var cellLayout = chart.get("dataGridProperties.cell.layout", {});
        if (typeof cellLayout.width === "number" && cellLayout.width)
            cellLayout.width = {
                rule: "exactSize",
                value: cellLayout.width
            };
        else if (!cellLayout.width || !cellLayout.width.rule || ["maxSize", "minSize", "exactSize"].indexOf(cellLayout.width.rule) < 0)
            cellLayout.width = {
                rule: null
            };
        if (typeof cellLayout.height === "number" && cellLayout.height)
            cellLayout.height = {
                rule: "exactSize",
                value: cellLayout.height
            };
        else if (!cellLayout.height || !cellLayout.height.rule || ["maxSize", "minSize", "exactSize"].indexOf(cellLayout.height.rule) < 0)
            cellLayout.height = {
                rule: null
            };
        var exactWidth = cellLayout.width.rule === "exactSize" ? cellLayout.width.value : null;
        var exactHeight = cellLayout.height.rule === "exactSize" ? cellLayout.height.value : null;
        var defaultFormat = chart.get("dataGridProperties.cell.labels.numberFormat", "auto");
        var nullRepr = chart.get("nullRepresentation", "");
        for (r = 0; r < chart._internalData.length; r++)
            for (c = 0; c < chart._internalData[r].length; c++) {
                var format = tdg.flattenProperty("labels.numberFormat", getExceptionalFormat(exceptionalList, r, c));
                format = format || defaultFormat;
                v = chart._internalData[r][c].value;
                var ids = {
                    series: c,
                    group: r
                };
                var config = format === "auto" ? null : {
                    bucketID: "value",
                    ids: ids
                };
                v = v == null ? nullRepr : chart.formatNumber(v, format, config);
                chart._internalData[r][c]._formattedValue = v;
                if (!exactWidth) {
                    var lblSize = singleCharWidth * v.length + cellPadWidth;
                    colWidthList[c] = Math.max(colWidthList[c] || 0, lblSize)
                }
            }
        if (exactWidth)
            colWidthList = tdg.repeat(cellLayout.width.value, colCount);
        var rowLabelFont = chart.get("dataGridProperties.rowHeader.labels.font", "8pt Sans-Serif");
        var rowLabels = tdg.cloneObject(chart.get("dataGridProperties.rowHeader.labels.content"));
        var rowHeight = 0
          , rowHeaderWidthList = [];
        if (!tdg.isEmpty(rowLabels)) {
            if (exactHeight)
                rowHeight = exactHeight;
            else
                rowHeight = tdg.measureFont(rowLabelFont).height + cellPadHeight;
            rowHeaderWidthList = chart.nestedRowWidths(rowLabels, rowLabelFont, cellPad.left, cellPad.right);
            if (tdg.isNestedLabels(rowLabels))
                rowLabels = nestedLabelObjectToArray(rowLabels, rowCount, rowHeaderWidthList.length, false);
            else
                rowLabels = [rowLabels.slice(0, rowCount || rowLabels.length)]
        } else
            rowLabels = [[]];
        if (nullDataCase)
            rowCount = rowLabels[0].length;
        var rowHeaderWidth = tdg.sum(rowHeaderWidthList);
        var rowTitleFont, rowTitleHeight = 0;
        var rowTitleLabels = tdg.clone(chart.get("dataGridProperties.rowHeader.title.text"));
        var sortIconSize = chart.get("dataGridProperties.colHeader.sorting.icon.size", 10);
        if (!tdg.isEmpty(rowTitleLabels)) {
            rowTitleFont = chart.get("dataGridProperties.rowHeader.title.font", "8pt Sans-Serif");
            rowTitleHeight = Math.max(tdg.measureFont(rowTitleFont).height + cellPadHeight, sortIconSize + sortIconSize + cellPad.top);
            if (typeof rowTitleLabels === "string")
                rowTitleLabels = [rowTitleLabels]
        } else if (sortPad && (rowLabels.length > 1 || rowLabels[0].length > 0)) {
            rowTitleLabels = tdg.repeat(" ", rowLabels.length);
            rowTitleHeight = sortIconSize + sortIconSize + cellPad.top
        } else
            rowTitleLabels = null;
        var colFont = chart.get("dataGridProperties.colHeader.labels.font", "8pt Sans-Serif");
        var colLastRowFont = chart.get("dataGridProperties.colHeader.lastLabels.font", colFont);
        var colLabels = chart.get("dataGridProperties.colHeader.labels.content");
        var colLabelHeight = 0
          , colHeaderRowCount = 0;
        var mergeColLabels = chart.get("dataGridProperties.colHeader.labels.mergeMatching", true);
        var colTitleHeight, colTitleFont;
        var colTitleLabels = chart.get("dataGridProperties.colHeader.title.text");
        colTitleLabels = typeof colTitleLabels === "string" ? [colTitleLabels] : colTitleLabels;
        if (!tdg.isEmpty(colLabels)) {
            colLabelHeight = tdg.measureFont(colFont).height;
            if (!tdg.isEmpty(colTitleLabels)) {
                colTitleFont = chart.get("dataGridProperties.colHeader.title.font", "8pt Sans-Serif");
                colTitleHeight = tdg.measureFont(colTitleFont).height;
                colLabelHeight = Math.max(colTitleHeight, colLabelHeight)
            }
            colLabelHeight = colLabelHeight + cellPadHeight;
            colLabelHeight = rowTitleHeight = Math.max(colLabelHeight, rowTitleHeight);
            colHeaderRowCount = 1;
            if (tdg.isNestedLabels(colLabels)) {
                colHeaderRowCount = chart.nestedHeaderDepth(colLabels);
                colLabels = nestedLabelObjectToArray(colLabels, colCount, colHeaderRowCount, false)
            } else
                colLabels = [colLabels.slice(0, colCount || colLabels.length)]
        } else
            colLabels = [[]];
        if (nullDataCase)
            colCount = colLabels[0].length;
        var colHeaderHeight = Math.max(colHeaderRowCount * colLabelHeight, rowTitleHeight);
        if (exactWidth) {
            if (nullDataCase)
                colWidthList = tdg.repeat(cellLayout.width.value, colCount)
        } else
            for (r = colLabels.length - 1; r >= 0; r--) {
                var mergeCount = 0
                  , availableMergeSpace = 0;
                font = r === colLabels.length - 1 ? colLastRowFont : colFont;
                for (c = 0; c < colCount; c++) {
                    lblWidth = 0;
                    colWidthList[c] = Math.max(colWidthList[c] || 0, 0);
                    if (!colLabels[r][c])
                        continue;
                    lblWidth = tdg.measureLabelWidth(colLabels[r][c], font) + cellPadWidth;
                    if (r === colLabels.length - 1)
                        lblWidth += sortPad;
                    else if (mergeColLabels)
                        while (colLabels[r][c] === colLabels[r][c + 1]) {
                            c += 1;
                            mergeCount += 1;
                            availableMergeSpace += colWidthList[c]
                        }
                    if (mergeCount && colWidthList[c] < lblWidth - availableMergeSpace) {
                        var splitSize = lblWidth / (mergeCount + 1);
                        colWidthList[c] = lblWidth - availableMergeSpace;
                        for (i = 0; i < mergeCount + 1; i++)
                            colWidthList[c - i] = splitSize
                    } else
                        colWidthList[c] = Math.max(colWidthList[c], lblWidth - availableMergeSpace);
                    availableMergeSpace = mergeCount = 0
                }
            }
        if (rowTitleLabels) {
            if (rowTitleLabels.length === 1) {
                lblWidth = tdg.measureLabelWidth(rowTitleLabels[0], rowTitleFont) + cellPadWidth + sortPad;
                if (!rowHeaderWidth)
                    rowHeaderWidthList = [lblWidth];
                else if (rowHeaderWidth < lblWidth)
                    rowHeaderWidthList = shrinkSizeList(rowHeaderWidthList, lblWidth, rowHeaderWidth)
            } else {
                if (!rowHeaderWidth)
                    rowHeaderWidthList = [0];
                for (i = 0; i < rowHeaderWidthList.length; i++) {
                    lblWidth = tdg.measureLabelWidth(rowTitleLabels[i], rowTitleFont) + cellPadWidth + sortPad;
                    rowHeaderWidthList[i] = Math.max(rowHeaderWidthList[i], lblWidth)
                }
            }
            rowHeaderWidth = tdg.sum(rowHeaderWidthList)
        }
        if (!tdg.isEmpty(colTitleLabels)) {
            var maxLbl = tdg.max(colTitleLabels, function(el) {
                return tdg.measureLabelWidth(el, colTitleFont)
            }) + cellPadWidth;
            if (!rowHeaderWidth)
                rowHeaderWidthList = [maxLbl];
            else if (maxLbl >= rowHeaderWidth)
                rowHeaderWidthList = shrinkSizeList(rowHeaderWidthList, maxLbl, rowHeaderWidth);
            rowHeaderWidth = tdg.sum(rowHeaderWidthList)
        }
        if (exactHeight)
            rowHeight = exactHeight;
        else {
            rowHeight = Math.max(rowHeight, tdg.measureFont(cellFont).height + cellPadHeight);
            if (!tdg.isEmpty(fmtList))
                for (i = 0; i < fmtList.length; i++)
                    if (fmtList[i] && fmtList[i].labels && fmtList[i].labels.font)
                        rowHeight = Math.max(rowHeight, tdg.measureFont(fmtList[i].labels.font).height + cellPadHeight)
        }
        var singleTotalCharWidth, totalLabels, totalRowTitle, totalRowHeight = 0;
        var totalRow = chart.get("dataGridProperties.columnTotals", {});
        if (totalRow.visible && !nullDataCase) {
            totalRowHeight = Math.max(tdg.measureFont(totalRow.headerLabel.font).height, tdg.measureFont(totalRow.cellLabel.font).height);
            totalRowHeight = totalRowHeight + cellPadHeight;
            totalRowHeight = Math.max(totalRowHeight, rowHeight);
            totalLabels = getTotalLabelList(chart, chart._internalData, exceptionalList);
            totalRowTitle = chart.get("dataGridProperties.columnTotals.headerLabel.text");
            if (totalRowTitle == null)
                totalRowTitle = tdgchart.translations.TOTAL;
            singleTotalCharWidth = tdg.measureLabelWidth("#", totalRow.cellLabel.font);
            for (c = 0; c < colWidthList.length; c++) {
                var exceptionalFont = tdg.flattenProperty("labels.font", getExceptionalFormat(exceptionalList, "total", c));
                if (exceptionalFont)
                    lblWidth = tdg.measureLabelWidth("#", exceptionalFont) * totalLabels[c].length + cellPadWidth;
                else
                    lblWidth = singleTotalCharWidth * totalLabels[c].length + cellPadWidth;
                colWidthList[c] = Math.max(colWidthList[c], lblWidth)
            }
            if (!tdg.isEmpty(totalRowTitle)) {
                var totalRowTitleFont = chart.get("dataGridProperties.columnTotals.headerLabel.font", "bold 10pt Sans-Serif");
                var titleSize = tdg.measureLabelWidth(totalRowTitle, totalRowTitleFont) + cellPadWidth;
                if (titleSize > rowHeaderWidth) {
                    rowHeaderWidthList = shrinkSizeList(rowHeaderWidthList, titleSize, rowHeaderWidth);
                    rowHeaderWidth = Math.max(rowHeaderWidth, titleSize)
                }
            }
        }
        if (!exactWidth)
            for (i = 0; i < fmtList.length; i++) {
                var f = fmtList[i];
                if (f && f.row != null && f.col != null && f.labels && f.labels.font) {
                    v = chart._internalData[f.row][f.col]._formattedValue;
                    lblWidth = tdg.measureLabelWidth(v, f.labels.font) + cellPadWidth;
                    colWidthList[f.row] = Math.max(colWidthList[f.row], lblWidth)
                }
            }
        if (cellLayout.width.rule === "maxSize")
            colWidthList = colWidthList.map(function(el) {
                return Math.min(el, cellLayout.width.value || el)
            });
        else if (cellLayout.width.rule === "minSize")
            colWidthList = colWidthList.map(function(el) {
                return Math.max(el, cellLayout.width.value || el)
            });
        if (cellLayout.height.rule === "maxSize")
            rowHeight = Math.min(rowHeight, cellLayout.height.value || rowHeight);
        else if (cellLayout.height.rule === "minSize")
            rowHeight = Math.max(rowHeight, cellLayout.height.value || rowHeight);
        var tableWidth = tdg.sum(colWidthList);
        var tableHeight = rowHeight * rowCount;
        var scroll = {
            horizontal: false,
            vertical: false
        };
        function shrinkSizeList(list, currentSize, availableSize) {
            var shrink = currentSize / availableSize;
            return list.map(function(el) {
                return Math.floor(el * shrink)
            })
        }
        var scrollEnabled = chart.get("dataGridProperties.scroll.enabled");
        var scrollBarWidth = chart.get("dataGridProperties.scroll.size", 15);
        var vScrollBarWidth = 0, hScrollBarWidth;
        if (tableHeight + colHeaderHeight + totalRowHeight > maxHeight)
            if (scrollEnabled) {
                scroll.vertical = true;
                vScrollBarWidth = scrollBarWidth
            }
        if (tableWidth + rowHeaderWidth + vScrollBarWidth > maxWidth) {
            var maxRowHeaderPercent = scrollEnabled ? .5 : .3;
            if (rowHeaderWidth > maxWidth * maxRowHeaderPercent && freezeRow) {
                var rowLabelWrap = chart.get("dataGridProperties.rowHeader.labels.wrap") || 0;
                if (rowLabelWrap > 1) {
                    var tmpRowHeight = tdg.measureFont(cellFont).height * 2 + cellPadHeight;
                    if (tmpRowHeight * rowCount + colHeaderHeight + totalRowHeight < maxHeight) {
                        rowHeight = tmpRowHeight;
                        tableHeight = rowHeight * rowCount
                    } else if (scrollEnabled) {
                        rowHeight = tmpRowHeight;
                        tableHeight = rowHeight * rowCount;
                        scroll.vertical = true;
                        vScrollBarWidth = scrollBarWidth
                    } else
                        rowLabelWrap = 1
                }
                var availableWidth = Math.max((maxWidth - vScrollBarWidth) * maxRowHeaderPercent, maxWidth - tableWidth - vScrollBarWidth);
                rowHeaderWidthList = shrinkSizeList(rowHeaderWidthList, availableWidth, rowHeaderWidth);
                var wrappedRowHeaderWidthList = [];
                for (i = 0; i < rowLabels.length; i++)
                    for (j = 0; j < rowLabels[i].length; j++)
                        if (rowLabelWrap > 1) {
                            rowLabels[i][j] = chart.applyWrapAndTruncate(rowLabels[i][j], rowLabelFont, rowLabelWrap, "rowHeader", rowHeaderWidthList[i] - cellPadWidth);
                            var tmpWidth = chart.measureLabel(rowLabels[i][j], rowLabelFont).width + cellPadWidth;
                            wrappedRowHeaderWidthList[i] = Math.max(tmpWidth, wrappedRowHeaderWidthList[i] || 0)
                        } else
                            rowLabels[i][j] = chart.truncateLabel(rowLabels[i][j], rowLabelFont, rowHeaderWidthList[i] - cellPadWidth);
                if (rowLabelWrap > 1)
                    rowHeaderWidthList = wrappedRowHeaderWidthList;
                rowHeaderWidth = tdg.sum(rowHeaderWidthList);
                if (rowTitleLabels)
                    if (rowTitleLabels.length === 1)
                        rowTitleLabels[0] = chart.truncateLabel(rowTitleLabels[0], rowTitleFont, rowHeaderWidth - cellPadWidth);
                    else
                        for (i = 0; i < rowTitleLabels.length; i++)
                            rowTitleLabels[i] = chart.truncateLabel(rowTitleLabels[i], rowTitleFont, rowHeaderWidthList[i] - cellPadWidth - sortPad)
            }
            if (tableWidth + rowHeaderWidth + vScrollBarWidth > maxWidth)
                if (scrollEnabled && tableWidth + rowHeaderWidth + vScrollBarWidth - maxWidth > 15)
                    scroll.horizontal = true;
                else if (!exactWidth && cellLayout.width.rule !== "minSize") {
                    colWidthList = shrinkSizeList(colWidthList, maxWidth - rowHeaderWidth, tableWidth);
                    tableWidth = tdg.sum(colWidthList)
                }
        }
        if (scrollEnabled) {
            if (scroll.horizontal && !scroll.vertical && tableHeight + colHeaderHeight + totalRowHeight + scrollBarWidth > maxHeight)
                scroll.vertical = true;
            if (scroll.vertical && !scroll.horizontal && tableWidth + rowHeaderWidth + scrollBarWidth > maxWidth)
                scroll.horizontal = true
        }
        vScrollBarWidth = scroll.vertical ? scrollBarWidth : 0;
        hScrollBarWidth = scroll.horizontal ? scrollBarWidth : 0;
        if (cellLayout.width.rule == null && tableWidth + rowHeaderWidth < maxWidth) {
            var dx = maxWidth - tableWidth - rowHeaderWidth - vScrollBarWidth;
            var incr = dx / colCount;
            colWidthList = colWidthList.map(function(el) {
                return el + incr
            });
            tableWidth += dx
        }
        if (cellLayout.height.rule == null && tableHeight + colHeaderHeight + totalRowHeight < maxHeight) {
            var dy = maxHeight - tableHeight - colHeaderHeight - totalRowHeight - hScrollBarWidth;
            rowHeight += dy / rowCount;
            tableHeight += dy
        }
        if (scrollEnabled)
            scroll.panel = {
                x: freezeRow ? rowHeaderWidth : 0,
                y: freezeCol ? colHeaderHeight : 0,
                width: scroll.horizontal ? maxWidth - (freezeRow ? rowHeaderWidth : 0) - vScrollBarWidth : freezeRow ? tableWidth : tableWidth + rowHeaderWidth,
                height: scroll.vertical ? maxHeight - (freezeCol ? colHeaderHeight : 0) - hScrollBarWidth : freezeCol ? tableHeight + totalRowHeight : tableHeight + colHeaderHeight + totalRowHeight,
                virtualWidth: tableWidth + (freezeRow ? 0 : rowHeaderWidth),
                virtualHeight: tableHeight + (freezeCol ? 0 : colHeaderHeight) + totalRowHeight,
                freezeRow: freezeRow,
                freezeCol: freezeCol
            };
        layout.dataGridLayout = {
            x: halfCellBorderWidth + chart.getPadding("frame", "left"),
            y: halfCellBorderWidth,
            width: tableWidth + rowHeaderWidth,
            height: tableHeight + colHeaderHeight + totalRowHeight,
            maxWidth: maxWidth,
            maxHeight: maxHeight,
            nullDataCase: nullDataCase,
            exceptionalList: exceptionalList,
            colHeader: {
                x: rowHeaderWidth,
                y: 0,
                width: tableWidth,
                height: colHeaderHeight,
                labels: colLabels,
                widthList: colWidthList,
                originalWidthList: tdg.cloneObject(colWidthList),
                rowHeight: colLabelHeight,
                rowCount: colHeaderRowCount,
                title: {
                    height: colTitleHeight,
                    labels: colTitleLabels
                }
            },
            rowHeader: {
                x: 0,
                y: colHeaderHeight,
                width: rowHeaderWidth,
                height: tableHeight,
                labels: rowLabels,
                widthList: rowHeaderWidthList,
                rowHeight: rowHeight,
                colCount: rowHeaderWidthList.length,
                title: {
                    height: rowTitleHeight,
                    labels: rowTitleLabels
                }
            },
            innerTable: {
                x: rowHeaderWidth,
                y: colHeaderHeight,
                width: tableWidth,
                height: tableHeight
            },
            totalRow: {
                x: 0,
                y: colHeaderHeight + tableHeight,
                width: tableWidth,
                height: totalRowHeight,
                labels: totalLabels
            },
            cells: {
                style: cellStyle,
                singleCharWidth: singleCharWidth,
                singleTotalCharWidth: singleTotalCharWidth,
                minColWidth: singleCharWidth + cellPadWidth,
                height: rowHeight,
                widthList: colWidthList,
                rows: tdg.rangeCount(0, tableHeight, rowCount + 1),
                cols: [0].concat(tdg.accumulate(colWidthList))
            },
            scroll: scroll
        };
        return layout
    }
    ;
    tdgchart.prototype.drawDataGridChart = function(rootChartPanel, chartLayout) {
        var chart = this;
        var cellPad = chart.get("dataGridProperties.cell.layout.cellPadding", {
            left: 5,
            top: 5,
            right: 5,
            bottom: 5
        });
        var scene = chart.cache.get("tdgscene");
        var layout = chartLayout.dataGridLayout;
        var rows = layout.cells.rows;
        var cols = layout.cells.cols;
        var i, r, c, color, divider;
        var needResize = chart.get("dataGridProperties.colHeader.resize.enabled", false);
        var sortedColumn;
        var needSort = chart.get("dataGridProperties.colHeader.sorting.enabled", false);
        var sortIconSelColor = chart.get("dataGridProperties.colHeader.sorting.icon.selectedColor", "rgb(51, 51, 51)");
        var sortIconUnSelColor = chart.get("dataGridProperties.colHeader.sorting.icon.unSelectedColor", "rgba(51, 51, 51, 0.5)");
        var sortIconStrokeWidth = chart.get("dataGridProperties.colHeader.sorting.icon.borderWidth", 1);
        var sortIconSize = chart.get("dataGridProperties.colHeader.sorting.icon.size", 10);
        scene.initBackend();
        var sortArrowPath = scene.addShapePath(0, 0, "arrowslim", sortIconSize / 2).p.join(" ");
        var doubleSortArrowPath = scene.addShapePath(0, 0, "arrowslimdouble", sortIconSize / 2).p.join(" ");
        var rootGroup = scene.group(rootChartPanel, "tablePanel", layout.x, layout.y);
        var cb = "dataGridProperties.cell.innerGridLines.";
        var cellBorderStyle = {
            horizontal: {
                width: chart.get(cb + "horizontal.width") || chart.get(cb + "width"),
                color: chart.get(cb + "horizontal.color") || chart.get(cb + "color"),
                dash: chart.get(cb + "horizontal.dash") || chart.get(cb + "dash")
            },
            vertical: {
                width: chart.get(cb + "vertical.width") || chart.get(cb + "width"),
                color: chart.get(cb + "vertical.color") || chart.get(cb + "color"),
                dash: chart.get(cb + "vertical.dash") || chart.get(cb + "dash")
            }
        };
        var cellStyle = layout.cells.style;
        var scrollGroupInfo, scrollBox, hScrollBar;
        if (layout.scroll && (layout.scroll.horizontal || layout.scroll.vertical)) {
            scrollBox = layout.scroll.panel;
            scrollGroupInfo = {
                name: "tableScroll",
                x: 0,
                y: 0,
                w: scrollBox.width,
                h: scrollBox.height,
                clip_w: scrollBox.width + layout.rowHeader.width,
                clip_h: scrollBox.height + layout.colHeader.height,
                virt_w: scrollBox.virtualWidth,
                virt_h: scrollBox.virtualHeight,
                scroll_h: true,
                scroll_h_panels: [],
                scroll_v: true,
                scroll_v_panels: [],
                scroll_h_v: [],
                clip: true,
                className: "scrollTable"
            };
            var baseRootGroup = rootGroup;
            rootGroup = chart.addScrollGroup(rootGroup, scrollGroupInfo);
            var scrollBarGroup = baseRootGroup.group("scrollBars", scrollBox.x, scrollBox.y);
            var scrollName = "dataGridProperties.scroll.";
            var scrollBarWidth = chart.get(scrollName + "size", 15);
            var colors = {
                space: chart.get(scrollName + "color", "rgb(240, 240, 240)"),
                bar: chart.get(scrollName + "handle.color", "grey"),
                hoverBar: chart.get(scrollName + "handle.hoverColor", "rgb(88, 88, 88)"),
                barborder: chart.get(scrollName + "handle.border.color"),
                barborderwidth: chart.get(scrollName + "handle.border.width")
            };
            if (layout.scroll.horizontal)
                hScrollBar = chart.addScrollBar(scrollBarGroup, "tableScroll-h", {
                    x: 0,
                    y: scrollBox.height
                }, scrollBox.width, scrollBarWidth, scrollGroupInfo, colors);
            if (layout.scroll.vertical)
                chart.addScrollBar(scrollBarGroup, "tableScroll-v", {
                    x: scrollBox.width,
                    y: 0
                }, scrollBox.height, scrollBarWidth, scrollGroupInfo, colors)
        }
        var innerTableGroup = rootGroup.group("innerTable", layout.innerTable.x, layout.innerTable.y);
        if (scrollGroupInfo) {
            innerTableGroup = addLocalScrollGroup(innerTableGroup, "innerTableScroll", scrollBox, scrollBox);
            scrollGroupInfo.scroll_h_panels.push(innerTableGroup);
            scrollGroupInfo.scroll_v_panels.push(innerTableGroup)
        }
        if (!layout.nullDataCase) {
            var backgroundGroup = innerTableGroup.group().group("background");
            drawBackground();
            var props = {
                color: "transparent",
                font: cellStyle.labels.font
            };
            var innerLabelGroup = innerTableGroup.group("labels").group("reorder_placeholder_PageGroup", null, null, null, null, null, props);
            drawInnerLabels();
            var hLineGroup = innerTableGroup.group("horizontal-lines");
            drawHGrid();
            var vLineGroup = innerTableGroup.group().group("vertical-lines");
            drawVGrid()
        }
        function drawBackground() {
            var bg = chart.get("chartFrame.fill.color");
            if (bg && tdg.color.isVisible(bg))
                backgroundGroup.rect(0, 0, layout.innerTable.width, layout.innerTable.height, {
                    color: bg
                });
            var altFill = chart.get("dataGridProperties.altRowFill");
            if (!tdg.isEmpty(altFill)) {
                if (!Array.isArray(altFill))
                    altFill = [null, altFill];
                for (r = 0; r < rows.length - 1; r++) {
                    color = altFill[r % altFill.length];
                    if (color)
                        backgroundGroup.rect(0, r * layout.cells.height, layout.innerTable.width, layout.cells.height, {
                            color: color
                        })
                }
            }
        }
        function drawHGrid() {
            if (isLineVisible(cellBorderStyle.horizontal)) {
                var hLine = lineToSceneLine(cellBorderStyle.horizontal);
                var p = new tdgchart.tdgscene.path;
                var lineLength = layout.innerTable.width;
                for (r = 1; r < rows.length; r++) {
                    p.moveTo(0, rows[r]);
                    p.lineTo(lineLength, rows[r])
                }
                hLineGroup.path(0, 0, p, hLine)
            }
        }
        function drawVGrid() {
            if (isLineVisible(cellBorderStyle.vertical)) {
                var vLine = lineToSceneLine(cellBorderStyle.vertical);
                var p = new tdgchart.tdgscene.path;
                var lineLength = layout.innerTable.height;
                for (c = 0; c <= layout.colHeader.widthList.length; c++) {
                    p.moveTo(cols[c], 0);
                    p.lineTo(cols[c], lineLength)
                }
                vLineGroup.path(0, 0, p, vLine)
            }
        }
        if (layout.colHeader.rowCount) {
            var header = "dataGridProperties.colHeader.";
            var grid = header + "innerGridLines.";
            var colHeaderStyle = {
                horizontal: {
                    lineWidth: chart.get(grid + "horizontal.width") || chart.get(grid + "width"),
                    border: chart.get(grid + "horizontal.color") || chart.get(grid + "color"),
                    dash: chart.get(grid + "horizontal.dash") || chart.get(grid + "dash")
                },
                vertical: {
                    lineWidth: chart.get(grid + "vertical.width") || chart.get(grid + "width"),
                    border: chart.get(grid + "vertical.color") || chart.get(grid + "color"),
                    dash: chart.get(grid + "vertical.dash") || chart.get(grid + "dash")
                },
                lineWidth: chart.get(header + "border.width"),
                border: chart.get(header + "border.color"),
                color: chart.get(header + "fill"),
                lineCap: "square",
                antialias: false
            };
            var colTitle = chart.get(header + "title");
            if (colTitle && !tdg.isEmpty(colTitle.text)) {
                var colTitleGroup = rootGroup.group("colTitle", 0, 0);
                var titleList = layout.colHeader.title.labels.slice(0, layout.colHeader.rowCount - 1);
                var colTitleStyle = {
                    font: chart.get(header + "title.font", "8pt Sans-Serif"),
                    color: chart.get(header + "title.color", "black"),
                    align: chart.get(header + "title.align", "right"),
                    valign: chart.get(header + "title.valign", "center")
                };
                for (i = 0; i < titleList.length; i++)
                    drawLabelInBox(cellPad, colTitleGroup, titleList[i], 0, i * layout.colHeader.rowHeight, layout.rowHeader.width, layout.colHeader.height, colTitleStyle);
                if (isLineVisible(chart.get(header + "border"))) {
                    colTitleGroup.line(0, 0, layout.rowHeader.width, 0, colHeaderStyle);
                    colTitleGroup.line(0, 0, 0, layout.colHeader.height, colHeaderStyle)
                }
                if (isLineVisible(chart.get(header + "title.dividerLine"))) {
                    var line = lineToSceneLine(chart.get(header + "title.dividerLine"));
                    colTitleGroup.line(layout.rowHeader.width, 0, layout.rowHeader.width, layout.colHeader.height, line)
                }
            }
            var colScrollGroup = rootGroup.group("colHeaderScroll", layout.colHeader.x, layout.colHeader.y);
            var colGroup = colScrollGroup;
            if (scrollGroupInfo) {
                var rect = {
                    width: scrollBox.width,
                    height: layout.colHeader.height
                };
                colScrollGroup = addLocalScrollGroup(colScrollGroup, "colHeaderScroll", scrollBox, rect);
                scrollGroupInfo.scroll_h_panels.push(colScrollGroup);
                if (!scrollBox.freezeCol)
                    scrollGroupInfo.scroll_v_panels.push(colScrollGroup);
                colGroup = colScrollGroup.group("colHeader")
            }
            drawColHeader()
        }
        function drawColHeader() {
            var header = layout.colHeader;
            colGroup.rect(0, 0, header.width, header.height, colHeaderStyle);
            for (c = 1; c < header.rowCount; c++)
                colGroup.line(0, c * header.rowHeight, header.width, c * header.rowHeight, colHeaderStyle.horizontal);
            divider = chart.get("dataGridProperties.colHeader.dividerLine", {});
            if (divider.width > 0 && tdg.color.isVisible(divider.color)) {
                divider = {
                    border: divider.color,
                    lineWidth: divider.width,
                    antialias: false
                };
                colGroup.line(0, header.height, header.width, header.height, divider)
            }
            drawNestedColLabels()
        }
        function drawSortIcon(group, x, y, boxWidth, boxHeight, align, colIdx) {
            var detNodeWidth = cellPad.left + sortIconSize + cellPad.right;
            x -= align === "right" ? boxWidth : detNodeWidth;
            var sortIconDetNodeStyle = {
                color: "transparent",
                cursor: "pointer",
                interaction: {
                    events: {
                        mousedown: function(owner, props, e) {
                            return sortRowHandler(sortArrow, props, e)
                        }
                    }
                }
            };
            group.rect(x, y, detNodeWidth, boxHeight, sortIconDetNodeStyle);
            var sortIconArrowStyle = {
                color: "transparent",
                className: "sortIcon",
                "pointer-events": "none",
                lineStyle: {
                    width: sortIconStrokeWidth,
                    color: sortIconUnSelColor
                }
            };
            x += sortIconSize / 2 + (align === "right" ? cellPad.left : cellPad.right);
            y += (boxHeight - cellPad.top - cellPad.bottom) / 2 + cellPad.top;
            var sortArrow = group.dot(x, y, sortIconSize, doubleSortArrowPath, sortIconArrowStyle).setAttr("direction", "none").setAttr("colIdx", colIdx)
        }
        function drawNestedColLabels() {
            var headerLabel = chart.get("dataGridProperties.colHeader", {});
            var labelStyle = {
                font: tdg.get("labels.font", headerLabel, "8pt Sans-Serif"),
                color: tdg.get("labels.color", headerLabel, "black"),
                align: tdg.get("labels.align", headerLabel, "left"),
                valign: tdg.get("labels.valign", headerLabel, "top")
            };
            var lastRowLabelStyle = {
                font: tdg.get("lastLabels.font", headerLabel, labelStyle.font),
                color: tdg.get("lastLabels.color", headerLabel, labelStyle.color),
                align: tdg.get("lastLabels.align", headerLabel, labelStyle.align),
                valign: tdg.get("lastLabels.valign", headerLabel, labelStyle.valign)
            };
            var resizeHandleProps = {
                className: "colResizeHandle",
                border: "transparent",
                cursor: "col-resize",
                lineWidth: (colHeaderStyle.vertical.lineWidth || 1) + 4,
                interaction: {
                    events: {
                        mousedown: onMouseDown
                    }
                }
            };
            var y = 0;
            var sortGroup = needSort ? colGroup.group("sortIcons") : null;
            var merge = chart.get("dataGridProperties.colHeader.labels.mergeMatching", true);
            var pad = cellPad.left + cellPad.right;
            var labels = layout.colHeader.labels;
            for (var r = 0; r < labels.length; r++) {
                var x = 0;
                var width = layout.colHeader.widthList[0];
                var height = layout.colHeader.rowHeight;
                for (var c = 0; c < labels[r].length; c++) {
                    var label = labels[r][c];
                    var style = r === labels.length - 1 ? lastRowLabelStyle : labelStyle;
                    if (merge && label === labels[r][c + 1] && r < labels.length - 1)
                        width += layout.colHeader.widthList[c + 1];
                    else {
                        var actualPad = needSort && r === labels.length - 1 ? pad + sortIconSize + cellPad.right : pad;
                        label = chart.truncateLabel(label, style.font, width - actualPad);
                        drawLabelInBox(cellPad, colGroup, label, x, y, width, height, style);
                        if (c < labels[r].length - 1)
                            colGroup.line(x + width, y, x + width, y + height, colHeaderStyle.vertical);
                        if (needResize) {
                            var line = colGroup.line(x + width, y, x + width, y + height, resizeHandleProps);
                            line.colIdx = c
                        }
                        x += width;
                        width = layout.colHeader.widthList[c + 1]
                    }
                    if (needSort && r === labels.length - 1)
                        drawSortIcon(sortGroup, x, y, layout.colHeader.widthList[c], height, style.align, c)
                }
                y += height
            }
        }
        if (layout.rowHeader.colCount) {
            var rh = "dataGridProperties.rowHeader.";
            var rg = rh + "innerGridLines.";
            var rowHeaderStyle = {
                horizontal: {
                    lineWidth: chart.get(rg + "horizontal.width") || chart.get(rg + "width"),
                    border: chart.get(rg + "horizontal.color") || chart.get(rg + "color"),
                    dash: chart.get(rg + "horizontal.dash") || chart.get(rg + "dash")
                },
                vertical: {
                    lineWidth: chart.get(rg + "vertical.width") || chart.get(rg + "width"),
                    border: chart.get(rg + "vertical.color") || chart.get(rg + "color"),
                    dash: chart.get(rg + "vertical.dash") || chart.get(rg + "dash")
                },
                lineWidth: chart.get(rh + "border.width"),
                border: chart.get(rh + "border.color"),
                dash: chart.get(rh + "border.dash"),
                color: chart.get(rh + "fill"),
                antialias: false
            };
            var clipSize, rowTitleGroup;
            if (layout.rowHeader.title.labels) {
                var tl = "dataGridProperties.rowHeader.title.";
                var labels = layout.rowHeader.title.labels.slice(0, layout.rowHeader.colCount);
                var title = layout.rowHeader.title;
                var labelStyle = {
                    font: chart.get(tl + "font", "8pt Sans-Serif"),
                    color: chart.get(tl + "color", "black"),
                    align: chart.get(tl + "align", "left"),
                    valign: chart.get(tl + "valign", "top")
                };
                rowTitleGroup = rootGroup.group("rowTitle", layout.rowHeader.x, layout.rowHeader.y - title.height);
                if (scrollGroupInfo) {
                    clipSize = {
                        width: layout.rowHeader.width,
                        height: scrollBox.height
                    };
                    rowTitleGroup = addLocalScrollGroup(rowTitleGroup, "rowTitleScroll", scrollBox, clipSize);
                    if (!scrollBox.freezeRow)
                        scrollGroupInfo.scroll_h_panels.push(rowTitleGroup);
                    if (!scrollBox.freezeCol)
                        scrollGroupInfo.scroll_v_panels.push(rowTitleGroup)
                }
                rowTitleGroup.rect(0, 0, layout.rowHeader.width, title.height, rowHeaderStyle);
                if (labels.length === 1) {
                    drawLabelInBox(cellPad, rowTitleGroup, labels[0], 0, 0, layout.rowHeader.width, title.height, labelStyle);
                    if (needSort)
                        drawSortIcon(rowTitleGroup, layout.rowHeader.width, 0, layout.rowHeader.width, title.height, labelStyle.align, "0_r")
                } else {
                    var x = 0;
                    for (i = 0; i < labels.length; i++) {
                        var boxWidth = layout.rowHeader.widthList[i];
                        drawLabelInBox(cellPad, rowTitleGroup, labels[i], x, 0, boxWidth, title.height, labelStyle);
                        x += boxWidth;
                        if (i < labels.length - 1)
                            rowTitleGroup.line(x, 0, x, title.height, rowHeaderStyle.vertical);
                        if (needSort)
                            drawSortIcon(rowTitleGroup, x, 0, boxWidth, title.height, labelStyle.align, i + "_r")
                    }
                }
                if (isLineVisible(chart.get(tl + "dividerLine"))) {
                    var dl = lineToSceneLine(chart.get(tl + "dividerLine"));
                    rowTitleGroup.line(0, title.height, layout.rowHeader.width, title.height, dl)
                }
            }
            var rowGroup = rootGroup.group("rowHeader", layout.rowHeader.x, layout.rowHeader.y);
            if (scrollGroupInfo) {
                clipSize = {
                    width: layout.rowHeader.width,
                    height: scrollBox.height
                };
                rowGroup = addLocalScrollGroup(rowGroup, "rowHeaderScroll", scrollBox, clipSize);
                scrollGroupInfo.scroll_v_panels.push(rowGroup);
                if (!scrollBox.freezeRow)
                    scrollGroupInfo.scroll_h_panels.push(rowGroup)
            }
            rowGroup.rect(0, 0, layout.rowHeader.width, layout.rowHeader.height, rowHeaderStyle);
            var xList = tdg.accumulate(layout.rowHeader.widthList);
            if (chart.dataSelection.enabled) {
                var rowXList = [0].concat(xList);
                var cellSelGroup = rowGroup.group("rowSelectionFills", null, null, null, null, null, {
                    color: "transparent"
                });
                for (r = 0; r < layout.cells.rows.length - 1; r++)
                    for (c = 0; c < rowXList.length - 1; c++) {
                        var selStyle = {
                            className: chart.buildClassName("rowHeader", null, null, "cellFill", r, c)
                        };
                        cellSelGroup.rect(rowXList[c], r * layout.rowHeader.rowHeight, layout.rowHeader.widthList[c], layout.rowHeader.rowHeight, selStyle)
                    }
            }
            for (i = 0; i < xList.length - 1; i++)
                rowGroup.line(xList[i], 0, xList[i], layout.rowHeader.height, rowHeaderStyle.vertical);
            divider = chart.get("dataGridProperties.rowHeader.dividerLine", {});
            if (isLineVisible(divider))
                rowGroup.line(layout.rowHeader.width, 0, layout.rowHeader.width, layout.rowHeader.height, lineToSceneLine(divider));
            var labelProps = {
                font: chart.get("dataGridProperties.rowHeader.labels.font", "8pt Sans-Serif"),
                color: chart.get("dataGridProperties.rowHeader.labels.color", "black")
            };
            layout.rowHeader.labelGroup = rowGroup.group("rowLabels", null, null, null, null, null, labelProps);
            layout.rowHeader.lineGroup = rowGroup.group("rowLines", null, null, null, null, null, rowHeaderStyle.horizontal);
            drawNestedRowLabels(layout.rowHeader.labels, layout.rowHeader)
        }
        function drawNestedRowLabels(labels, layout) {
            var labelStyle = {
                align: chart.get("dataGridProperties.rowHeader.labels.align", "left"),
                valign: chart.get("dataGridProperties.rowHeader.labels.valign", "top")
            };
            var x = 0;
            var merge = chart.get("dataGridProperties.rowHeader.labels.mergeMatching", true);
            for (var r = 0; r < labels.length; r++) {
                var y = 0;
                var width = layout.widthList[r];
                var height = layout.rowHeight;
                for (var c = 0; c < labels[r].length; c++) {
                    var label = labels[r][c];
                    if (label == null || merge && label === labels[r][c + 1])
                        height += layout.rowHeight;
                    else {
                        drawLabelInBox(cellPad, layout.labelGroup, labels[r][c], x, y, width, height, labelStyle);
                        if (c < labels[r].length - 1)
                            layout.lineGroup.line(x, y + height, x + width, y + height, {});
                        y += height;
                        height = layout.rowHeight
                    }
                }
                x += width
            }
        }
        function drawInnerLabels() {
            var cellFill = {};
            var cellWidthList = layout.colHeader.widthList;
            var cellHeight = layout.cells.height;
            var needCellFill = chart.dataSelection.enabled || chart.mouseOverIndicator.enabled;
            var defaultStyle = tdg.cloneObject(cellStyle);
            defaultStyle.labels.font = null;
            for (var r = 0; r < chart._internalData.length; r++) {
                var rowGroup = innerLabelGroup.group("row" + r, 0, r * cellHeight);
                var x = 0;
                for (var c = 0; c < chart._internalData[0].length; c++) {
                    var d = (chart._internalData[r] || [])[c];
                    var style = getExceptionalFormat(layout.exceptionalList, r, c) || defaultStyle;
                    if (needCellFill || style.tooltip || style.color) {
                        var ids = {
                            object: "riser",
                            series: 0,
                            group: 0,
                            misc: "cellFill",
                            row: r,
                            col: c
                        };
                        cellFill.className = chart.buildClassName(ids);
                        cellFill.title = style.tooltip || null;
                        cellFill.color = style.color ? style.color : null;
                        rowGroup.rect(x, 0, cellWidthList[c], cellHeight, cellFill)
                    }
                    var cellLabel = d._formattedValue;
                    drawLabelInBox(cellPad, rowGroup, cellLabel, x, 0, cellWidthList[c], cellHeight, style.labels, layout.cells.singleCharWidth);
                    x += cellWidthList[c]
                }
            }
        }
        var totalGroup, totalHeaderGroup, totalBorder;
        if (layout.totalRow.height && !tdg.isEmpty(layout.totalRow.labels)) {
            var lbl = chart.get("dataGridProperties.columnTotals.headerLabel.text");
            if (lbl == null)
                lbl = tdgchart.translations.TOTAL;
            var rowProps = tdg.cloneObject(chart.get("dataGridProperties.columnTotals.headerLabel"));
            rowProps = tdg.mergeObjects(rowProps, tdg.cloneObject(cellStyle.labels));
            totalHeaderGroup = rootGroup.group("totalHeader", layout.totalRow.x, layout.totalRow.y);
            if (scrollGroupInfo) {
                totalHeaderGroup.x = totalHeaderGroup.y = 0;
                totalHeaderGroup.clip = {
                    x: 0,
                    y: scrollBox.y,
                    width: layout.rowHeader.width,
                    height: scrollBox.height
                };
                totalHeaderGroup = totalHeaderGroup.group("totalHeaderRowScroll", layout.totalRow.x, layout.totalRow.y);
                scrollGroupInfo.scroll_v_panels.push(totalHeaderGroup);
                if (!scrollBox.freezeRow)
                    scrollGroupInfo.scroll_h_panels.push(totalHeaderGroup)
            }
            drawLabelInBox(cellPad, totalHeaderGroup, lbl, 0, 0, layout.rowHeader.width, layout.totalRow.height, rowProps);
            totalBorder = chart.get("dataGridProperties.columnTotals.border");
            if (isLineVisible(totalBorder))
                totalHeaderGroup.rect(0, 0, layout.rowHeader.width, layout.totalRow.height, lineToSceneLine(totalBorder));
            var dividerLine = chart.get("dataGridProperties.columnTotals.dividerLine");
            if (isLineVisible(dividerLine))
                totalHeaderGroup.line(0, 0, layout.rowHeader.width, 0, lineToSceneLine(dividerLine));
            var totalScrollGroup = rootGroup.group("totalRow", layout.totalRow.x + layout.rowHeader.width, layout.totalRow.y);
            totalGroup = totalScrollGroup;
            if (scrollGroupInfo) {
                totalScrollGroup.x = totalScrollGroup.y = 0;
                totalScrollGroup.clip = scrollBox;
                totalScrollGroup = totalScrollGroup.group("totalRowScroll", layout.totalRow.x + layout.rowHeader.width, layout.totalRow.y);
                scrollGroupInfo.scroll_h_panels.push(totalScrollGroup);
                scrollGroupInfo.scroll_v_panels.push(totalScrollGroup);
                totalGroup = totalScrollGroup.group("totalRowResizePlaceholder")
            }
            drawTotalRow()
        }
        function drawTotalRow() {
            if (!layout.totalRow.height)
                return;
            var totalRow = layout.totalRow;
            var dividerLine = chart.get("dataGridProperties.columnTotals.dividerLine");
            if (isLineVisible(totalBorder))
                totalGroup.rect(0, 0, layout.totalRow.width, layout.totalRow.height, lineToSceneLine(totalBorder));
            if (isLineVisible(dividerLine))
                totalGroup.line(0, 0, totalRow.width, 0, lineToSceneLine(dividerLine));
            var defaultStyle = {
                color: null,
                tooltip: null,
                labels: tdg.cloneObject(chart.get("dataGridProperties.columnTotals.cellLabel"))
            };
            defaultStyle.labels = tdg.mergeObjects(defaultStyle.labels, tdg.cloneObject(cellStyle.labels));
            for (c = 0; c < cols.length; c++) {
                var style = getExceptionalFormat(layout.exceptionalList, "total", c) || defaultStyle;
                if (style.color)
                    totalGroup.rect(cols[c], 0, layout.colHeader.widthList[c], totalRow.height, {
                        color: style.color
                    });
                drawLabelInBox(cellPad, totalGroup, layout.totalRow.labels[c] || "", cols[c], 0, layout.colHeader.widthList[c], totalRow.height, style.labels, layout.cells.singleTotalCharWidth);
                if (c > 0 && c < cols.length - 1)
                    totalGroup.line(cols[c], 0, cols[c], totalRow.height, lineToSceneLine(cellBorderStyle.vertical))
            }
        }
        var mousePt, mouseTarget;
        function dragColResize(dx) {
            if (!mouseTarget || mouseTarget.colIdx == null || tdg.eq(dx, 0))
                return true;
            if (layout.colHeader.widthList[mouseTarget.colIdx] + dx < layout.cells.minColWidth)
                return false;
            if (layout.scroll.horizontal)
                chart.resizeScrollPanel(hScrollBar, dx, 0);
            else {
                var i, found = false;
                if (dx > 0 && cols[cols.length - 1] + dx > layout.maxWidth - layout.rowHeader.width) {
                    for (i = layout.colHeader.widthList.length - 1; i > 0; i--)
                        if (layout.colHeader.widthList[i] > layout.cells.minColWidth) {
                            layout.colHeader.widthList[i] -= dx;
                            found = true;
                            break
                        }
                    if (!found)
                        return false
                } else if (dx < 0)
                    for (i = mouseTarget.colIdx + 1; i < layout.colHeader.widthList.length; i++)
                        if (layout.colHeader.widthList[i] < layout.colHeader.originalWidthList[i]) {
                            layout.colHeader.widthList[i] -= dx;
                            break
                        }
            }
            layout.colHeader.widthList[mouseTarget.colIdx] += dx;
            cols = [0].concat(tdg.accumulate(layout.colHeader.widthList));
            var newWidth = tdg.sum(layout.colHeader.widthList);
            layout.colHeader.width = layout.totalRow.width = layout.innerTable.width = newWidth;
            redrawGroup(scene, backgroundGroup, drawBackground);
            redrawGroup(scene, hLineGroup, drawHGrid);
            redrawGroup(scene, vLineGroup, drawVGrid);
            redrawGroup(scene, colGroup, drawColHeader);
            redrawGroup(scene, innerLabelGroup, drawInnerLabels);
            redrawGroup(scene, totalGroup, drawTotalRow);
            if (sortedColumn != null && sortedColumn.sortDirection !== "none")
                sortRows(null, sortedColumn);
            return true
        }
        function sortRowHandler(owner, props, e) {
            if (!e || e.button > 0)
                return;
            if (typeof e.preventDefault === "function")
                e.preventDefault();
            if (typeof e.stopPropagation === "function")
                e.stopPropagation();
            sortRows(owner)
        }
        function sortRows(arrowMark, colInfo) {
            var sortIconMarks = scene.linked[0].group.selectChildren("sortIcon");
            var colIdx;
            if (arrowMark == null && colInfo != null)
                arrowMark = sortIconMarks.find(function(el) {
                    return el.getAttr("colIdx") === colInfo.colIdx
                });
            var i, sortOrder, newRowHeaders = [];
            var sortDirection;
            if (colInfo != null)
                sortDirection = colInfo.sortDirection;
            else {
                var currentSortDirection = arrowMark.getAttr("direction");
                sortDirection = currentSortDirection === "none" ? "up" : currentSortDirection === "up" ? "down" : "none"
            }
            colIdx = arrowMark.getAttr("colIdx");
            sortedColumn = {
                colIdx: colIdx,
                sortDirection: sortDirection
            };
            if (sortDirection === "none") {
                sortOrder = tdg.range(chart._internalData.length);
                newRowHeaders = layout.rowHeader.labels
            } else {
                var sortAscending = sortDirection === "up";
                if (typeof colIdx === "number")
                    sortOrder = chart._internalData.map(function(el, idx) {
                        return {
                            value: el[colIdx].value,
                            originalRow: idx
                        }
                    }).sort(function(a, b) {
                        a = a.value || 0;
                        b = b.value || 0;
                        if (a > b)
                            return sortAscending ? 1 : -1;
                        else if (a < b)
                            return sortAscending ? -1 : 1;
                        return 0
                    });
                else {
                    colIdx = parseInt(colIdx, 10);
                    sortOrder = layout.rowHeader.labels[colIdx].map(function(el, idx) {
                        return {
                            value: el,
                            originalRow: idx
                        }
                    }).sort(function(a, b) {
                        a = a.value || "";
                        b = b.value || "";
                        return a.localeCompare(b) * (sortAscending ? 1 : -1)
                    })
                }
                sortOrder = tdg.map(sortOrder, "originalRow");
                var tmp = tdg.transpose(layout.rowHeader.labels);
                for (i = 0; i < sortOrder.length; i++)
                    newRowHeaders.push(tmp[sortOrder[i]]);
                newRowHeaders = tdg.transpose(newRowHeaders)
            }
            if (innerLabelGroup)
                for (i = 0; i < innerLabelGroup.childs.length; i++)
                    innerLabelGroup.childs[i].moveTo(0, sortOrder.indexOf(i) * layout.rowHeader.rowHeight);
            if (layout.rowHeader.labelGroup) {
                layout.rowHeader.labelGroup.empty();
                layout.rowHeader.lineGroup.empty();
                drawNestedRowLabels(newRowHeaders, layout.rowHeader);
                scene.renderGroup(layout.rowHeader.labelGroup);
                scene.renderGroup(layout.rowHeader.lineGroup)
            }
            sortIconMarks.forEach(function(el) {
                el.borderColor(sortIconUnSelColor);
                el.markerShape(doubleSortArrowPath);
                el.setAttr("direction", "none");
                el.rotate(0)
            });
            if (sortDirection !== "none") {
                arrowMark.borderColor(sortIconSelColor);
                arrowMark.markerShape(sortArrowPath);
                if (sortDirection === "up")
                    arrowMark.setAttr("direction", "up");
                else if (sortDirection === "down") {
                    arrowMark.setAttr("direction", "down");
                    arrowMark.rotate(180)
                }
            }
        }
        function onMouseDown(owner, props, e) {
            if (e.button > 0)
                return;
            var cls = owner.props.attrs.className;
            if (!cls.startsWith("colResizeHandle"))
                return;
            mouseTarget = owner;
            mousePt = props;
            chart._disableSelection = true
        }
        function onMouseMove(e) {
            if (mousePt == null || mouseTarget == null)
                return;
            var res, newMousePos = tdg.getMousePosition(e);
            if (mousePt.x === newMousePos.x && mousePt.y === newMousePos.y)
                return;
            if (mouseTarget.props.attrs.className.startsWith("colResizeHandle"))
                res = dragColResize(newMousePos.x - mousePt.x);
            if (res)
                mousePt = newMousePos
        }
        function onMouseUp() {
            if (mousePt != null) {
                chart.addHTMLToolTips();
                chart.doMouseHover();
                chart.processEvents();
                chart.processSelection()
            }
            mousePt = mouseTarget = null;
            chart._disableSelection = false
        }
        chart.globalMouseUpAdd(onMouseUp, "drawDataGridChart");
        chart.globalMouseMoveAdd(onMouseMove, "drawDataGridChart")
    }
    ;
    function addLocalScrollGroup(group, className, scrollBox, panelSize) {
        var x = scrollBox.freezeRow ? null : group.x;
        var y = scrollBox.freezeCol ? null : group.y;
        group.w = scrollBox.freezeRow ? panelSize.width : scrollBox.width;
        group.h = scrollBox.freezeCol ? panelSize.height : scrollBox.height;
        group.x = scrollBox.freezeRow ? group.x : scrollBox.x;
        group.y = scrollBox.freezeCol ? group.y : scrollBox.y;
        group.clip = true;
        return group.group(className, x, y)
    }
    function nestedLabelObjectToArray(labels, count, depth, mergeMatching) {
        labels = tdg.flattenNestedLabels(labels, " -!- ");
        labels = labels.map(function(el) {
            return el.split(" -!- ").slice(0, depth)
        });
        labels = tdg.transpose(labels.slice(0, count || labels.length));
        if (mergeMatching) {
            var res = [];
            for (var r = 0; r < labels.length - 1; r++) {
                res.push([]);
                for (var c = 0; c < labels[r].length; c++)
                    res[r].push(labels[r][c] === labels[r][c + 1] ? null : labels[r][c])
            }
            res.push(labels[labels.length - 1]);
            labels = res
        }
        return labels
    }
    function isLineVisible(props) {
        return props && props.width > 0 && tdg.color.isVisible(props.color)
    }
    function lineToSceneLine(props) {
        return {
            lineWidth: props.width,
            border: props.color,
            antialias: false,
            lineCap: props.dash == null ? "square" : null,
            dash: props.dash || ""
        }
    }
    function drawLabelInBox(cellPad, group, label, x, y, width, height, props, minWidth) {
        if (tdg.isEmpty(label))
            return;
        var dx = x + width / 2;
        var dy = y + height / 2;
        if (props.align === "left")
            dx = cellPad.left + x;
        else if (props.align === "right")
            dx = x + width - cellPad.right;
        else
            props.align = "middle";
        if (props.valign === "top")
            dy = cellPad.top + y;
        else if (props.valign === "bottom")
            dy = y + height - cellPad.bottom;
        else
            props.valign = "middle";
        if (minWidth != null) {
            var lblWidth = minWidth * label.length;
            if (width < cellPad.left + lblWidth + cellPad.right) {
                var count = Math.max(1, Math.floor(width / minWidth) - 1);
                label = "#".repeat(count)
            }
        }
        props["pointer-events"] = "none";
        group.label(dx, dy, label, props)
    }
    function normalizeExceptionalList(formatList, rowCount, colCount, defaultStyle, defaultTotalStyle) {
        var res = {
            rowList: [],
            colList: [],
            cellList: []
        };
        for (var i = 0; i < formatList.length; i++) {
            var f = formatList[i];
            if (tdg.isANumber(f.repeat) && f.repeat > 0) {
                var r, c;
                if (f.row != null && f.col == null)
                    for (r = f.row; r < rowCount; r += f.repeat)
                        appendOneFormat(res, r, null, f, defaultStyle, defaultTotalStyle);
                else if (f.row == null && f.col != null)
                    for (c = f.col; c < colCount; c += f.repeat)
                        appendOneFormat(res, null, c, f, defaultStyle, defaultTotalStyle);
                else
                    for (r = f.row,
                    c = f.col; r < rowCount && c < colCount; r += f.repeat,
                    c += f.repeat)
                        appendOneFormat(res, r, c, f, defaultStyle, defaultTotalStyle)
            } else
                appendOneFormat(res, f.row, f.col, f, defaultStyle, defaultTotalStyle)
        }
        return res
    }
    function appendOneFormat(formatInfo, r, c, format, defaultStyle, defaultTotalStyle) {
        var f = format;
        var style = r === "total" ? defaultTotalStyle : defaultStyle;
        if (r != null && c != null) {
            if (formatInfo.cellList[r] == null)
                formatInfo.cellList[r] = [];
            if (formatInfo.cellList[r][c] == null)
                formatInfo.cellList[r][c] = tdg.mergeObjects(f, tdg.cloneObject(style));
            else
                tdg.mergeObjects(f, formatInfo.cellList[r][c])
        } else if (r != null && c == null)
            if (formatInfo.rowList[r] == null)
                formatInfo.rowList[r] = tdg.mergeObjects(f, tdg.cloneObject(style));
            else
                tdg.mergeObjects(f, formatInfo.rowList[r]);
        else if (r == null && c != null) {
            if (formatInfo.colList[c] == null)
                formatInfo.colList[c] = tdg.mergeObjects(f, tdg.cloneObject(defaultStyle));
            else
                tdg.mergeObjects(f, formatInfo.colList[c]);
            if (formatInfo.cellList.total == null)
                formatInfo.cellList.total = [];
            if (formatInfo.cellList.total[c] == null)
                formatInfo.cellList.total[c] = tdg.mergeObjects(f, tdg.cloneObject(defaultTotalStyle));
            else
                tdg.mergeObjects(f, formatInfo.cellList.total[c])
        }
    }
    function getExceptionalFormat(fmtList, row, col) {
        var eFormat;
        if (fmtList.rowList[row])
            eFormat = fmtList.rowList[row];
        if (fmtList.colList[col])
            if (eFormat)
                eFormat = tdg.merge(fmtList.colList[col], tdg.cloneObject(eFormat));
            else
                eFormat = fmtList.colList[col];
        if (fmtList.cellList[row] && fmtList.cellList[row][col])
            if (eFormat)
                eFormat = tdg.merge(fmtList.cellList[row][col], tdg.cloneObject(eFormat));
            else
                eFormat = fmtList.cellList[row][col];
        return eFormat
    }
    function getTotalLabelList(chart, data, exceptionalList) {
        var tableData = tdg.transpose(data);
        var calculation = chart.get("dataGridProperties.columnTotals.calculation", "sum").toLowerCase();
        calculation = calculation in tdg ? tdg[calculation] : tdg.sum;
        var defaultFormat = chart.get("dataGridProperties.columnTotals.cellLabel.numberFormat");
        if (!defaultFormat)
            defaultFormat = chart.get("dataGridProperties.cell.labels.numberFormat", "auto");
        return tdg.map(tableData, function(el, c) {
            var format = tdg.flattenProperty("labels.numberFormat", getExceptionalFormat(exceptionalList, "total", c));
            format = format || defaultFormat;
            var sum = calculation(el, function(el2) {
                return typeof el2.value === "number" ? el2.value : 0
            });
            var ids = {
                series: c,
                group: 0
            };
            var config = format === "auto" ? null : {
                bucketID: "value",
                ids: ids
            };
            return chart.formatNumber(sum, format, config)
        })
    }
    function redrawGroup(scene, group, renderFn) {
        if (group) {
            group.empty();
            renderFn();
            scene.renderGroup(group)
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.drawControl = function(panel, chartLayout) {
        var chart = this;
        var data = (chart._internalData || [])[0];
        var stats = chart.cache.get("stats", [])[0];
        var mean = stats.mean
          , dev = stats.clDeviation;
        var controlLines = {
            sigmaN3: Math.max(0, mean - dev - dev - dev),
            sigmaN2: Math.max(0, mean - dev - dev),
            sigmaN1: Math.max(0, mean - dev),
            mean: mean,
            sigma1: mean + dev,
            sigma2: mean + dev + dev,
            sigma3: mean + dev + dev + dev
        };
        var rules = chart.get("controlProperties.stabilityRules", []);
        var defaultMarker = tdg.merge(chart.get("controlProperties.defaultStabilityMarker", {}), {
            color: "red",
            shape: "diamond",
            size: 20
        });
        rules.forEach(function(rule) {
            if (typeof rule === "string" && stabilityRuleCalculations.hasOwnProperty(rule))
                stabilityRuleCalculations[rule](chart, data, controlLines, null, defaultMarker);
            else if (rule && typeof rule === "object") {
                var style = tdg.merge(rule.marker || {}, tdg.clone(defaultMarker));
                if (stabilityRuleCalculations.hasOwnProperty(rule.name))
                    stabilityRuleCalculations[rule.name](chart, data, controlLines, rule.n, style);
                else if (typeof rule.ruleCallback === "function") {
                    var highlightList = rule.ruleCallback.call(chart, data, controlLines, style);
                    highlight(chart, highlightList, null, style)
                }
            }
        });
        var chartPanels = chart.createBLAScrollXYPanels(panel, chartLayout.chartSize, chartLayout);
        function addLine(panel, data, x, y1, y2) {
            var chart = this;
            var scene = chart.cache.get("tdgscene");
            var w = panel.computedSize.width;
            var h = panel.computedSize.height;
            var baseGroup = scene.group(panel, "eventPanel");
            baseGroup.rect(0, 0, w, h, {
                color: "transparent",
                "pointer-events": "all"
            });
            var group = baseGroup.group("groupPanel");
            chart.addLineArea(group, w, h, data, x, y1, y2, null, "line")
        }
        chart.drawXOrdinalYChart(chartPanels, chartLayout, chart._internalData, addLine)
    }
    ;
    function highlight(chart, i, count, markerStyle) {
        var c;
        if (Array.isArray(i))
            for (c = 0; c < i.length; c++) {
                chart.addExceptionalProperty("marker.color", markerStyle.color, 0, i[c]);
                chart.addExceptionalProperty("marker.shape", markerStyle.shape, 0, i[c]);
                chart.addExceptionalProperty("marker.size", markerStyle.size, 0, i[c])
            }
        else if (typeof i === "number")
            for (c = 0; c < count; c++) {
                chart.addExceptionalProperty("marker.color", markerStyle.color, 0, i + c);
                chart.addExceptionalProperty("marker.shape", markerStyle.shape, 0, i + c);
                chart.addExceptionalProperty("marker.size", markerStyle.size, 0, i + c)
            }
    }
    function inARow(chart, data, n, markerStyle, conditionFn, condition2Fn) {
        condition2Fn = condition2Fn || conditionFn;
        var i, j;
        for (i = 0; i < data.length; i++) {
            var d = data[i];
            if (conditionFn(d.y)) {
                for (j = 1; j <= n; j++) {
                    var d2 = data[i + j];
                    if (!d2 || d2.y == null || !condition2Fn(d2.y))
                        break
                }
                if (j >= n)
                    highlight(chart, i, j, markerStyle)
            }
        }
    }
    function nOutOfN1(chart, data, n, markerStyle, min, max) {
        var i, j;
        for (i = 0; i < data.length; i++) {
            var d = data[i]
              , skip = 0;
            var isAbove, outPoints = [];
            if (d.y != null && (d.y > max || d.y < min)) {
                isAbove = d.y > max;
                outPoints.push(i)
            }
            for (j = 1; j <= data.length; j++) {
                var d2 = data[i + j];
                if (d2 != null && d2.y != null) {
                    if (d2.y > max || d2.y < min) {
                        if (isAbove == null)
                            isAbove = d2.y > max;
                        if (isAbove && d2.y > max || !isAbove && d2.y < min)
                            outPoints.push(i + j);
                        else
                            skip++
                    } else
                        skip++;
                    if (skip >= 2 || j > n && d2.y < max && d2.y > min)
                        break
                }
            }
            if (outPoints.length >= n) {
                highlight(chart, outPoints, null, markerStyle);
                i += j
            }
            outPoints = [];
            isAbove = null
        }
    }
    var stabilityRuleCalculations = {
        rule1: function(chart, data, controlLines, n, markerStyle) {
            n = n == null ? 1 : n;
            return inARow(chart, data, n, markerStyle, function(v) {
                return v > controlLines.sigma3 || v < controlLines.sigmaN3
            })
        },
        rule2: function(chart, data, controlLines, n, markerStyle) {
            var isAbove = null;
            n = n == null ? 9 : n;
            return inARow(chart, data, n, markerStyle, function(v) {
                isAbove = v > controlLines.mean;
                return true
            }, function(v) {
                return !(isAbove && v < controlLines.mean || !isAbove && v > controlLines.mean)
            })
        },
        rule3: function(chart, data, controlLines, n, markerStyle) {
            n = n == null ? 6 : n;
            var i, j;
            for (i = 0; i < data.length; i++) {
                var d = data[i]
                  , isIncreasing = null;
                for (j = 1; j <= n; j++) {
                    var d2 = data[i + j];
                    if (!d2 || d2.y == null)
                        break;
                    if (isIncreasing == null)
                        isIncreasing = d2.y > d.y;
                    else if (isIncreasing && d2.y < d.y || !isIncreasing && d2.y > d.y)
                        break;
                    d = d2
                }
                if (j >= n)
                    highlight(chart, i, j, markerStyle)
            }
        },
        rule4: function(chart, data, controlLines, n, markerStyle) {
            n = n == null ? 14 : n;
            var i, j;
            for (i = 0; i < data.length; i++) {
                var d = data[i]
                  , isIncreasing = null;
                for (j = 1; j <= n; j++) {
                    var d2 = data[i + j];
                    if (!d2 || d2.y == null)
                        break;
                    if (isIncreasing == null)
                        isIncreasing = d2.y > d.y;
                    else if (isIncreasing && d2.y > d.y || !isIncreasing && d2.y < d.y)
                        break;
                    isIncreasing = d2.y > d.y;
                    d = d2
                }
                if (j >= n)
                    highlight(chart, i, j, markerStyle)
            }
        },
        rule5: function(chart, data, controlLines, n, markerStyle) {
            n = n == null ? 2 : n;
            return nOutOfN1(chart, data, n, markerStyle, controlLines.sigmaN2, controlLines.sigma2)
        },
        rule6: function(chart, data, controlLines, n, markerStyle) {
            n = n == null ? 4 : n;
            return nOutOfN1(chart, data, n, markerStyle, controlLines.sigmaN1, controlLines.sigma1)
        },
        rule7: function(chart, data, controlLines, n, markerStyle) {
            n = n == null ? 15 : n;
            return inARow(chart, data, n, markerStyle, function(v) {
                return v < controlLines.sigma1 && v > controlLines.sigmaN1
            })
        },
        rule8: function(chart, data, controlLines, n, markerStyle) {
            n = n == null ? 8 : n;
            return inARow(chart, data, n, markerStyle, function(v) {
                return v > controlLines.sigma1 || v < controlLines.sigmaN1
            })
        }
    };
    tdgchart.prototype.addControlLines = function() {
        var chart = this;
        var data = chart._internalData;
        var controlMode = chart.get("controlProperties.mode");
        var needVariableControlLine = controlMode === "u" || controlMode === "p";
        data[0].forEach(function(el) {
            el.y = el.sampleSize == null ? el.value : el.value / el.sampleSize;
            if (needVariableControlLine && el.sampleSize == null)
                el.sampleSize = 1
        });
        var s0 = chart.getSeries(0);
        s0.trendline = s0.trendline || [];
        addStatLine(s0.trendline, "mean", "green");
        addStatLine(s0.trendline, "ucl", "red", needVariableControlLine ? "" : "20 8");
        addStatLine(s0.trendline, "lcl", "red", needVariableControlLine ? "" : "20 8")
    }
    ;
    function addStatLine(trendlines, mode, color, dash) {
        for (var i = 0; i < trendlines.length; i++) {
            var line = trendlines[i];
            if (line && line.mode === mode)
                if (line.mode === "mean" || line.order === 3)
                    return
        }
        trendlines.push({
            enabled: true,
            mode: mode,
            order: 3,
            lineStyle: {
                color: color,
                width: 1,
                dash: dash
            },
            equationLabel: {
                visible: true,
                position: "end",
                mode: "labelAndValue",
                font: "8pt Sans-Serif",
                color: "black"
            }
        })
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.layoutPictogram = function(overallChartSize) {
        var chart = this;
        var lock = chart.get("pictogramProperties.lockToGrid");
        var groupFit = chart.get("axisList.x1.groupFit");
        if (!lock || groupFit && groupFit.rule !== "auto")
            return chart.layoutXOrdYChart(overallChartSize);
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        var axisLayout = chart.getXOrdYAxisLayout(overallChartSize);
        var x = axisLayout.xScalesList[0];
        var y = axisLayout.yScalesList.y1;
        var cellSize = {
            x: x.range().band / x.seriesCount,
            y: y(y.grid[1]) - y(y.grid[0])
        };
        if (cellSize.y < cellSize.x) {
            var scale = isHorizontal ? x.computedSize.height : x.computedSize.width;
            scale = scale / x.groupCount / x.range().band * x.seriesCount;
            chart.cache.setProperty("axisList.x1.groupFit.rule", "exactSize");
            chart.cache.setProperty("axisList.x1.groupFit.value", cellSize.y * scale);
            chart.cache.setProperty("axisList.x1.inset", "");
            if (isHorizontal)
                chart.cache.setProperty("axisList.x1.position", "end")
        } else if (cellSize.x < cellSize.y) {
            chart.cache.setProperty("axisList.y1.groupFit.rule", "exactSize");
            chart.cache.setProperty("axisList.y1.groupFit.value", x.range().band / x.seriesCount)
        }
        return chart.layoutXOrdYChart(overallChartSize)
    }
    ;
    tdgchart.prototype.addPictogram = function(rootPanel, odata, x, y) {
        var chart = this;
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        var pictogramMode = chart.get("pictogramProperties.fillMode") || "clip";
        var lockToGrid = !!chart.get("pictogramProperties.lockToGrid");
        chart.blaProperties.seriesLayout = "sideBySide";
        var scene = chart.cache.get("tdgscene");
        var groupPanel = scene.group(rootPanel, "groupPanel");
        var bars = chart.addBar(groupPanel, rootPanel.computedSize.width, rootPanel.computedSize.height, odata, x, y, null);
        var yDomain = y.domain();
        var posBarLength = y(yDomain[1]) - y(0);
        var negBarLength = y(0) - y(yDomain[0]);
        if (!bars)
            return;
        for (var s = 0; s < bars.length; s++) {
            var seriesBars = bars[s];
            if (!seriesBars)
                continue;
            for (var g = 0; g < seriesBars.length; g++) {
                var bar = seriesBars[g];
                if (!bar)
                    continue;
                var markerShape = chart.getSerDepProperty("marker.shape", bar.d);
                if (markerShape) {
                    bar.parent.attrs.antialias = true;
                    var markerStyle = {
                        color: chart.getSerDepProperty("marker.color", bar.d),
                        lineStyle: chart.getSerDepProperty("marker.border", bar.d),
                        "pointer-events": "none"
                    };
                    if (pv.SvgScene.pathRequiresStroke(markerShape)) {
                        markerStyle.lineStyle.color = markerStyle.color;
                        markerStyle.color = null
                    }
                    var direction;
                    var rect = tdg.clone(bar.props);
                    if (bar.d.value >= 0) {
                        direction = isHorizontal ? "right" : "up";
                        if (isHorizontal)
                            rect = {
                                x: bar.props.x,
                                y: bar.props.y,
                                w: posBarLength,
                                h: bar.props.h
                            };
                        else
                            rect = {
                                x: bar.props.x,
                                y: 0,
                                w: bar.props.w,
                                h: posBarLength
                            }
                    } else {
                        direction = isHorizontal ? "left" : "down";
                        if (isHorizontal)
                            rect = {
                                x: 0,
                                y: bar.props.y,
                                w: negBarLength,
                                h: bar.props.h
                            };
                        else
                            rect = {
                                x: bar.props.x,
                                y: bar.props.y,
                                w: bar.props.w,
                                h: negBarLength
                            }
                    }
                    if (pictogramMode === "stretch")
                        if (typeof markerShape === "string" && markerShape.startsWith("url(")) {
                            markerStyle.attributes = {
                                preserveAspectRatio: "none"
                            };
                            bar.parent.image(bar.props.x, bar.props.y, bar.props.w, bar.props.h, markerShape, markerStyle)
                        } else {
                            var markerSize = 100;
                            markerStyle.scale = {
                                x: bar.props.w / markerSize,
                                y: bar.props.h / markerSize
                            };
                            bar.parent.dot(bar.props.x + bar.props.w / 2, bar.props.y + bar.props.h / 2, markerSize, markerShape, markerStyle)
                        }
                    else {
                        var backFill = chart.get("pictogramProperties.backFill");
                        if (backFill && !markerShape.startsWith("url(") && tdg.color.isVisible(backFill)) {
                            var style = tdg.clone(markerStyle);
                            style.color = backFill;
                            fillOneBar(bar.parent, rect, markerShape, style, direction, y, lockToGrid)
                        }
                        fillOneBar(bar.parent, bar.props, markerShape, markerStyle, direction, y, lockToGrid)
                    }
                }
            }
        }
    }
    ;
    function fillOneBar(group, rect, markerShape, markerStyle, direction, y, lock) {
        var gridSize = lock ? y(y.grid[1]) - y(y.grid[0]) : null;
        var barGroup = group.group("cls", rect.x, rect.y, rect.w, rect.h, true);
        if (direction === "right" || direction === "left") {
            var dx, h = gridSize || rect.h, h2 = h / 2;
            if (direction === "right") {
                dx = h2;
                while (dx < rect.w + h2) {
                    barGroup.dot(dx, h2, h, markerShape, markerStyle);
                    dx += h
                }
            } else if (direction === "left") {
                dx = rect.w - h2;
                while (dx > -h2) {
                    barGroup.dot(dx, h2, h, markerShape, markerStyle);
                    dx -= h
                }
            }
        } else {
            var dy, w = gridSize || rect.w, w2 = w / 2;
            if (direction === "up") {
                dy = rect.h - w2;
                while (dy >= -w2) {
                    barGroup.dot(rect.w / 2, dy, w, markerShape, markerStyle);
                    dy -= w
                }
            } else if (direction === "down") {
                dy = w2;
                while (dy < rect.h + w2) {
                    barGroup.dot(rect.w / 2, dy, w, markerShape, markerStyle);
                    dy += w
                }
            }
        }
    }
    tdgchart.prototype.drawPictogram = function(panel, chartLayout) {
        var chart = this;
        var chartPanels = chart.createBLAScrollXYPanels(panel, chartLayout.chartSize, chartLayout);
        var data = chart.adjustData(chart._internalData);
        chart.drawXOrdinalYChart(chartPanels, chartLayout, data, chart.addPictogram)
    }
}
)();
(function() {
    tdgchart.prototype.drawIntroAnimation = drawIntroAnimation;
    tdgchart.prototype.drawLeafletIntro = drawLeafletIntro;
    var tdg = tdgchart.util;
    var o, seriesCount, groupCount, root, pos, chartsCount;
    function baselineSVGPos(root) {
        var baseline = root.selectAll('path[class*="baseLine"]').attr("d");
        return /M\s*(\d+\.?\d*)\s*,?\s*(\d+\.?\d*)\s*L/.exec(baseline)
    }
    function hideSelection(selector) {
        return root.selectAll(selector).attr("visibility", "hidden")
    }
    function showSelection(selection) {
        return function() {
            selection.attr("visibility", null)
        }
    }
    function hideDataText() {
        return hideSelection("text[class^=dataLabels]")
    }
    function showDataText(datatext) {
        return showSelection(datatext)
    }
    function drawBarInto(chart, endOperation) {
        var risers = root.selectAll('rect[class^=riser][class*="!mbar"], rect[class^=tinyPlaceholder][class*="!mbar"], rect[class^=riser][class*="!mbevel"], rect[class^=tinyPlaceholder][class*="!mbevel"]');
        if (risers.empty() || !pos)
            return null;
        var datatext = hideDataText();
        var shadows = hideSelection('rect[class^=riser][class*="!mshadow"]');
        var sizeAttr = o ? "width" : "height";
        var heights = risers[0].map(function(el) {
            return el.getAttribute(sizeAttr)
        });
        var groupDelta = (chart.introAnimation.duration - 400) / groupCount;
        function finalHeight(a, b) {
            return heights[b]
        }
        var transition = risers.attr(sizeAttr, 0).transition().duration(chart.introAnimation.duration).ease("back-out").delay(function() {
            var g = chart.classNameToIds(this.getAttribute("class")).group;
            return 200 + g * groupDelta
        }).each("end", showDataText(datatext)).each("end", showSelection(shadows));
        if (typeof endOperation !== "undefined")
            transition.each("end", endOperation);
        if (o) {
            transition.attr("width", finalHeight);
            if (chart.chartType !== "gantt")
                transition.attr("x", pos[1], true)
        } else {
            transition.attr("height", finalHeight);
            if (chart.chartType !== "gantt")
                transition.attr("y", pos[2], true)
        }
        transition.count = groupCount;
        return transition
    }
    function drawBar25dInto(chart) {
        var risers = root.selectAll("g[class=bar25d]");
        if (risers.empty() || !pos)
            return;
        var datatext = hideDataText();
        var groupDelta = (chart.introAnimation.duration - 400) / groupCount;
        risers.attr("transform", o ? "translate(" + pos[1] + ", 0) scale(0.001, 1)" : "translate(0, " + pos[2] + ") scale(1, 0.001)").transition().duration(chart.introAnimation.duration).delay(function(d, i) {
            return 200 + i % groupCount * groupDelta
        }).ease("back-out").attr("transform", "translate(0, 0) scale(1, 1)").each("end", showDataText(datatext))
    }
    function drawLineInto(chart) {
        var i, selection = root.selectAll('path[class^=riser][class*="!mline"]');
        if (selection.empty())
            return null;
        for (i = 0; i < chartsCount * seriesCount; i++)
            root.select("svg defs").append("svg:clipPath").attr("id", root.documentRoot + "_rectClip_" + i).append("svg:rect").attr("class", "animationClipRect").attr("x", 0).attr("y", 0).attr("width", o ? chart.width : 0).attr("height", o ? 0 : chart.height);
        var datatext = hideDataText();
        var markers = hideSelection("[class^=marker]");
        var fill = hideSelection("[class^=lineFill]", "fill-opacity");
        var shadows = hideSelection('*[class^=riser][class*="!mshadow"]');
        var duration = chart.introAnimation.duration / seriesCount * 2;
        var seriesDelta = duration / 4;
        var base = document.getElementsByTagName("base").length ? location.href : "";
        base = navigator.userAgent.indexOf("MSIE") >= 0 ? "" : base;
        for (i = 0; i < seriesCount; i++)
            root.selectAll('path[class^="riser!s' + i + '"][class*="!mline"]').attr("clip-path", "url(" + base + "#" + root.documentRoot + "_rectClip_" + i + ")");
        var transition = root.selectAll("defs rect.animationClipRect").transition().duration(duration).ease("linear-in-out").delay(function(d, i) {
            return i % seriesCount * seriesDelta
        }).attr(o ? "height" : "width", o ? chart.height : chart.width).each("end", endTransition);
        function endTransition() {
            transitionCount -= 1;
            if (transitionCount <= 0) {
                root.selectAll('path[class^="riser!s"]').attr("clip-path", null);
                showDataText(datatext)();
                showSelection(markers)();
                showSelection(fill)();
                showSelection(shadows)()
            }
        }
        var transitionCount = transition.count = seriesCount;
        return transition
    }
    function drawAreaInto(chart) {
        var risers = root.selectAll('path[class^=riser][class*="!marea"]');
        if (risers.empty() || !pos)
            return null;
        var datatext = hideDataText();
        var topEdge = hideSelection("[class^=areaEdge]", ["fill-opacity", "stroke-opacity"]);
        var markers = hideSelection("[class^=marker]", ["fill-opacity", "stroke-opacity"]);
        var transition;
        for (var i = 0; i < seriesCount; i++)
            transition = root.selectAll('path[class^="riser!s' + i + '"][class*="!marea"]').attr("transform", o ? "translate(" + pos[1] + ", 0) scale(0, 1)" : "translate(0, " + pos[2] + ") scale(1, 0)").transition().duration(chart.introAnimation.duration).delay(i % seriesCount * chart.introAnimation.duration / 5).ease("back-out").attr("transform", "translate(0, 0) scale(1, 1)").each("end", showDataText(datatext)).each("end", showSelection(topEdge)).each("end", showSelection(markers));
        transition.count = 1;
        return transition
    }
    function drawBLAIntro(chart) {
        var transition = [];
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        if (chartType === "bar" || chart.series.some(function(el) {
            return el.riserShape === "bar"
        }))
            if (chart.depth25d())
                transition.push(drawBar25dInto(chart));
            else
                transition.push(drawBarInto(chart));
        if (chartType === "line" || chart.series.some(function(el) {
            return el.riserShape === "line"
        }))
            transition.push(drawLineInto(chart));
        if (chartType === "area" || chart.series.some(function(el) {
            return el.riserShape === "area"
        }))
            transition.push(drawAreaInto(chart));
        return transition.filter(function(el) {
            return el != null
        })
    }
    function drawMekkoIntro(chart) {
        if (chart.chartType === "mekko")
            if (chart.depth25d())
                drawBar25dInto(chart);
            else
                drawBarInto(chart)
    }
    function drawPieInto(chart) {
        var arc = tdgchart.d3.svg.arc().innerRadius(0).outerRadius(chart.width).startAngle(0).endAngle(0);
        var datatext = hideDataText();
        var feelers = hideSelection('path[class*="!mfeeler"]', "stroke-opacity", 0);
        var groupDelta = (chart.introAnimation.duration - 400) / groupCount;
        var base = document.getElementsByTagName("base").length ? location.href : "";
        base = navigator.userAgent.indexOf("MSIE") >= 0 ? "" : base;
        for (var i = 0; i < groupCount; i++) {
            root.select("svg defs").append("svg:clipPath").attr("id", root.documentRoot + "_sliceClip_" + i).append("svg:path").attr("class", "path" + i).attr("d", arc());
            root.selectAll('path[class^="riser!s"][class*="g' + i + '!mwedge"], path[class^="riser!s"][class*="g' + i + '!mother"], path[class^="riser!s"][class*="!g' + i + '!mbevel"]').attr("clip-path", "url(" + base + "#" + root.documentRoot + "_sliceClip_" + i + ")")
        }
        function arcTween() {
            var i = tdgchart.d3.interpolate(0, 360 * (Math.PI / 180));
            return function(t) {
                return arc.endAngle(i(t))()
            }
        }
        var transition = root.selectAll("defs path").transition().duration(chart.introAnimation.duration).delay(function(d, i) {
            return i * groupDelta
        }).ease("cubic-in-out").attrTween("d", arcTween).each("end", endTransition);
        function endTransition() {
            transitionCount -= 1;
            if (transitionCount <= 0) {
                showDataText(datatext)();
                showSelection(feelers)();
                root.select('[id^="' + root.documentRoot + '_sliceClip_"]').remove();
                root.selectAll('path[class^="riser!s"][class*="!mwedge"], path[class^="riser!s"][class*="!mother"], path[class^="riser!s"][class*="!mbevel"]').attr("clip-path", null)
            }
        }
        var transitionCount = transition.count = groupCount;
        return transition
    }
    function drawXYIntro(chart) {
        var originalScale = " scale(0)";
        var datatext = hideDataText();
        var groupDelta = (chart.introAnimation.duration - 200) / groupCount;
        var initialTransform = function() {
            var transform = this.getAttribute("transform");
            return transform == null ? originalScale : transform + originalScale
        };
        var finalTransform = function() {
            var transform = this.getAttribute("transform");
            return transform.replace(originalScale, " scale(1)")
        };
        var transition = root.selectAll("[class^=riser]").attr("transform", initialTransform).transition().duration(chart.introAnimation.duration).ease("back-out").delay(function() {
            var g = chart.classNameToIds(this.getAttribute("class")).group;
            return g * groupDelta
        }).each("end", showDataText(datatext)).attr("transform", finalTransform);
        transition.count = groupCount;
        return transition
    }
    function drawLeafletIntro(chart) {
        var originalScale = " scale(0)";
        var datatext = hideDataText();
        var groupDelta = (chart.introAnimation.duration - 200) / groupCount;
        var initialTransform = function() {
            var transform = this.getAttribute("transform");
            var xMov = this.getAttribute("d").split(/[A-Z]/)[1].split(",")[0];
            var yOffSet = this.getAttribute("d").split(/[A-Z]/)[2] ? this.getAttribute("d").split(/[A-Z]/)[2].split(",")[1] : 0;
            var yMov = parseFloat(this.getAttribute("d").split(/[A-Z]/)[1].split(",")[1], 10) + yOffSet / 2;
            return transform == null ? "translate(" + xMov + "," + yMov + ") " + originalScale : transform + originalScale
        };
        function getRandomArbitrary(min, max) {
            return Math.random() * (max - min) + min
        }
        var finalTransform = function() {
            return "translate(0,0) scale(1)"
        };
        var transition = root.selectAll("[class^=riser]").attr("transform", initialTransform).transition().duration(chart.introAnimation.duration).ease("back-out").delay(function() {
            var g = getRandomArbitrary(0, groupCount);
            return g * groupDelta
        }).each("end", showDataText(datatext)).attr("transform", finalTransform);
        transition.count = groupCount;
        return transition
    }
    function drawSimpleGaugeIntro(chart) {
        var startAngle = tdg.radians(chart.gaugeProperties.startAngle + 90);
        var endAngle = startAngle + Math.PI + Math.PI;
        var arc = tdgchart.d3.svg.arc().innerRadius(0).outerRadius(chart.width).startAngle(startAngle).endAngle(endAngle);
        var base = document.getElementsByTagName("base").length ? location.href : "";
        base = navigator.userAgent.indexOf("MSIE") >= 0 ? "" : base;
        for (var i = 0; i < groupCount; i++) {
            root.select("svg defs").append("svg:clipPath").attr("id", root.documentRoot + "_sliceClip_" + i).append("svg:path").attr("class", "path" + i).attr("d", arc());
            root.selectAll('path[class^="riser"]').attr("clip-path", "url(" + base + "#" + root.documentRoot + "_sliceClip_" + i + ")")
        }
        function arcTween() {
            var i = tdgchart.d3.interpolate(startAngle, endAngle);
            return function(t) {
                return arc.endAngle(i(t))()
            }
        }
        var transition = root.selectAll("defs path").transition().duration(chart.introAnimation.duration * 2).ease("cubic-in-out").attrTween("d", arcTween).each("end", endTransition);
        function endTransition() {
            transitionCount -= 1;
            if (transitionCount <= 0) {
                root.select('[id^="' + root.documentRoot + '_sliceClip_"]').remove();
                root.selectAll('path[class^="riser"]').attr("clip-path", null)
            }
        }
        var transitionCount = transition.count = groupCount;
        return transition
    }
    function drawGaugeIntro(chart) {
        if (chart.gaugeProperties.layout === "simple")
            return drawSimpleGaugeIntro(chart);
        var risers = root.selectAll('[class^=riser][class*="!mneedle"]');
        var groupDelta = (chart.introAnimation.duration - 400) / (groupCount * seriesCount);
        var transforms = risers[0].map(function(el) {
            return el.getAttribute("transform")
        });
        var initialTransform = function() {
            return (this.getAttribute("transform") || "").replace(/rotate\([0-9.]+\)/, "rotate(0)")
        };
        var finalTransform = function(a, b) {
            return transforms[b]
        };
        var transition = risers.attr("transform", initialTransform).transition().duration(chart.introAnimation.duration).ease("back-in-out").delay(function(d, i) {
            return i * groupDelta
        }).attr("transform", finalTransform);
        transition.count = risers[0].length;
        return transition
    }
    function drawIntroAnimation() {
        var chart = this;
        if (!chart.introAnimation || !chart.introAnimation.enabled)
            return false;
        o = chart.blaProperties.orientation === "horizontal";
        seriesCount = chart.seriesCount();
        chartsCount = chart.chartType === "matrix" ? chart.data.length * tdg.max(chart.data, "length") : 1;
        groupCount = chart.visibleGroupCount();
        root = tdgchart.d3.select("#" + chart.documentRoot);
        pos = baselineSVGPos(root);
        root.documentRoot = chart.documentRoot;
        var transition;
        switch (chart.chartType) {
        case "bar":
        case "line":
        case "area":
            transition = drawBLAIntro(chart);
            break;
        case "gantt":
            transition = drawBarInto(chart);
            break;
        case "mekko":
            transition = drawMekkoIntro(chart);
            break;
        case "pie":
            transition = drawPieInto(chart);
            break;
        case "scatter":
        case "bubble":
            transition = drawXYIntro(chart);
            break;
        case "waterfall":
            var lines = hideSelection('[class^="waterfallProperties-connectorLine"]', "stroke-opacity");
            transition = drawBarInto(chart, showSelection(lines));
            break;
        case "map":
            if (chart.mapProperties.engine !== "leaflet" && chart.mapProperties.markerType === "bubble")
                transition = drawXYIntro(chart);
            break;
        case "gauge":
            transition = drawGaugeIntro(chart);
            break;
        case "matrix":
            switch (chart.matrixProperties.chartType) {
            case "bar":
            case "line":
            case "area":
                transition = drawBLAIntro(chart);
                break;
            case "pie":
                transition = drawPieInto(chart);
                break
            }
            break
        }
        if (transition) {
            if (!Array.isArray(transition))
                transition = [transition];
            if (transition.some(function(el) {
                return el.hasOwnProperty("count")
            })) {
                chart._disableHover = true;
                transition.forEach(function(t) {
                    t.each("end", function(d, idx) {
                        if (idx === t.count - 1)
                            chart._disableHover = false
                    })
                });
                chart.processRenderComplete(transition)
            }
        }
        if (chart.introAnimation.animateOnce)
            chart.introAnimation.enabled = false;
        return !!transition
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.registerEvent = function(callback, event, object, userInfo, series, group, misc, context, row, col, axis) {
        var chart = this;
        chart._callbackList = chart._callbackList || [];
        if (object === "series")
            object = "riser";
        if (typeof callback === "object" && arguments.length === 1) {
            chart._callbackList.push(callback);
            if (callback && callback.immediate)
                processEvents(chart, null, [callback])
        } else
            chart._callbackList.push({
                callback: callback,
                event: event,
                object: object,
                userInfo: userInfo,
                series: series,
                group: group,
                misc: misc,
                context: context,
                row: row,
                col: col,
                axis: axis
            })
    }
    ;
    tdgchart.prototype.unregisterAllEvents = function() {
        this._callbackList = []
    }
    ;
    tdgchart.prototype.handleRenderComplete = function(animationResult) {
        var chart = this;
        var cache = chart.cache.set("renderComplete", {
            timer: null,
            hasRendered: false
        });
        if (animationResult || chart._isMorphing || this.cache.hasKey("narrative_text_result"))
            return;
        if (chart.isExtension() || chart.isLeaflet()) {
            cache.timer = window.setTimeout(function() {
                var cache = chart.cache.get("renderComplete", {});
                if (!cache || !cache.hasRendered)
                    chart.processRenderComplete();
                cache.timer = null;
                cache.hasRendered = true
            }, 3E3);
            chart._callbackList = chart._callbackList || [];
            if (!chart._callbackList[0] || !chart._callbackList[0]._internalCallbackCancel)
                chart._callbackList.unshift({
                    _internalCallbackCancel: true,
                    event: "renderComplete",
                    callback: function() {
                        var cache = chart.cache.get("renderComplete", {});
                        window.clearTimeout(cache.timer);
                        cache.timer = null
                    }
                })
        } else
            chart.processRenderComplete()
    }
    ;
    tdgchart.prototype.processRenderComplete = function(transition) {
        var chart = this;
        if (!chart._callbackList)
            return;
        var cache = chart.cache.get_or_set("renderComplete", {});
        if (cache && cache.hasRendered)
            return;
        var renderEvents = chart._callbackList.filter(function(el) {
            return el.event === "renderComplete" ? el : null
        });
        if (!renderEvents.length)
            return;
        var callbackObj = {
            chart: chart,
            event: "renderComplete"
        };
        for (var i = 0; i < renderEvents.length; i++) {
            var e = renderEvents[i];
            if (transition == null) {
                e.callback.call(e.context || chart, callbackObj);
                cache.hasRendered = true
            } else {
                if (!Array.isArray(transition))
                    transition = [transition];
                transition.forEach(function(t) {
                    t.each("end", function() {
                        var c = e.callback;
                        return function(data, idx) {
                            if (idx === t.count - 1) {
                                c.call(e.context || chart, callbackObj);
                                cache.hasRendered = true
                            }
                        }
                    }())
                })
            }
        }
    }
    ;
    function getAreaGroupID(chart, chartPanel, root, e) {
        var o = chart.blaProperties.orientation === "horizontal";
        var mousePos = chart.mousePosition(root, e);
        var x = mousePos.x - chartPanel.computedSize.x;
        var y = mousePos.y - chartPanel.computedSize.y;
        var groupSize = (o ? chartPanel.computedSize.height : chartPanel.computedSize.width) / chart.groupCount();
        return Math.floor((o ? y : x) / groupSize)
    }
    function eventKey(event) {
        return ["event", "object", "series", "group", "misc", "row", "col", "axis"].map(function(el) {
            return event[el] == null ? "" : event[el]
        }).join("")
    }
    function registerEventsFromJSON(chart) {
        if (!chart.eventDispatcher || tdg.isEmpty(chart.eventDispatcher.events))
            return;
        chart._callbackList = chart._callbackList || [];
        chart.eventDispatcher.events.forEach(function(el) {
            el._eventKey = eventKey(el);
            if (chart._callbackList.every(function(e) {
                return e._eventKey !== el._eventKey
            }))
                if (typeof el.callback === "function")
                    chart.registerEvent(el);
                else if (el.url || typeof el.event === "string" && el.event.toLowerCase().startsWith("seturl"))
                    chart.setURL(el)
        })
    }
    tdgchart.prototype.processEvents = function(chartPanel) {
        var chart = this;
        registerEventsFromJSON(chart);
        processEvents(chart, chartPanel, chart._callbackList)
    }
    ;
    function processEvents(chart, chartPanel, eventList) {
        if (!Array.isArray(eventList) || eventList.length <= 0)
            return;
        var root = tdgchart.d3.select("#" + chart.documentRoot);
        function callbackWrapper(callbackElement) {
            return function(data, index, event) {
                if (chart._disableEvents)
                    return;
                var ids = chart.classNameToIds(this.getAttribute("class"));
                var callbackObj = {
                    chartObj: chart.stringToProperty(ids.object),
                    userInfo: callbackElement.userInfo,
                    chartObjName: ids.object,
                    series: ids.series,
                    group: ids.group,
                    misc: ids.misc,
                    row: ids.row,
                    col: ids.col,
                    axis: ids.axis,
                    svgElement: this,
                    chart: chart,
                    event: event
                };
                if (chart.chartType === "area" || chart.chartType === "streamgraph") {
                    callbackObj.group = getAreaGroupID(chart, chartPanel, root, event);
                    for (var i = 0; i < eventList.length; i++) {
                        var cb = eventList[i];
                        if (parseInt(cb.series, 10) === callbackObj.series && parseInt(cb.group, 10) === callbackObj.group) {
                            callbackElement.callback = cb.callback;
                            callbackObj.userInfo = cb.userInfo;
                            callbackObj.chartObjName = cb.object
                        }
                    }
                }
                try {
                    callbackElement.callback.call(callbackElement.context || chart, callbackObj)
                } catch (e$12) {
                    tdg.logError("Error in event callback: " + e$12.message, e$12.stack || "")
                }
            }
        }
        var leaflet_data = chart.cache.get("leaflet_full_dataset");
        for (var i = 0; i < eventList.length; i++) {
            var el = eventList[i];
            var obj = (el.object || "").replace(/\./g, "-");
            var selector = buildOneSelector(chart, el, obj, leaflet_data);
            if (!selector)
                continue;
            selector += ':not([class*="!mbevel"])';
            selector += ':not([class="risers"])';
            selector += ':not([class*="hover"])';
            selector += ':not([class^="riser-group"])';
            if (obj === "riser") {
                selector += ", [class^=marker]";
                if (el.series != null)
                    selector += '[class*="!s' + el.series + '!"]';
                if (el.group != null)
                    selector += '[class*="!g' + el.group + '!"]';
                selector += '[class*="!mmarker!"]'
            }
            var sel = root.selectAll(selector);
            if (el.event.toLowerCase().startsWith("seturl")) {
                el.event = "click";
                chart.registerLongTouch(sel, function(cb) {
                    return function(event) {
                        cb.call(event.target)
                    }
                }(callbackWrapper(el)))
            }
            sel.attr("pointer-events", "visiblePainted").on(el.event, callbackWrapper(el)).each(function() {
                if (this instanceof HTMLElement)
                    this.style.cursor = "pointer";
                else
                    this.setAttribute("cursor", "pointer")
            });
            if (el.event === "click")
                sel.on("touchend", callbackWrapper(el))
        }
    }
    function buildOneSelector(chart, callbackElement, obj, leaflet_data) {
        var selector = ""
          , el = callbackElement;
        if (chart.chartType === "datagrid" && tdg.isANumber(el.repeat) && el.repeat > 0) {
            var r, c, selectorList = [];
            var rowCount = chart.seriesCount()
              , colCount = chart.groupCount();
            var elCopy = tdg.clone(el);
            elCopy.repeat = null;
            if (el.row != null && el.col == null)
                for (r = el.row; r < rowCount; r += el.repeat) {
                    elCopy.row = r;
                    selectorList.push(buildOneSelector(chart, elCopy, obj, leaflet_data))
                }
            else if (el.row == null && el.col != null)
                for (c = el.col; c < colCount; c += el.repeat) {
                    elCopy.col = c;
                    selectorList.push(buildOneSelector(chart, elCopy, obj, leaflet_data))
                }
            else
                for (r = el.row,
                c = el.col; r < rowCount && c < colCount; r += el.repeat,
                c += el.repeat) {
                    elCopy.row = r;
                    elCopy.col = c;
                    selectorList.push(buildOneSelector(chart, elCopy, obj, leaflet_data))
                }
            return selectorList.join(", ")
        }
        if (el.object != null)
            selector += '[class^="' + obj + '"]';
        if (el.series != null) {
            var seriesID = el.series;
            if (chart.chartType === "treemap") {
                var sep = chart.get("treemapProperties.internalLabelSeparator") || "-";
                seriesID = tdg.replaceAll(seriesID, sep, tdgchart.getTreemapLabelSeparator())
            }
            selector += '[class*="!s' + seriesID + '!"]'
        }
        if (el.group != null) {
            var groupID = el.group;
            if (typeof groupID === "string" && chart.isLeaflet() && leaflet_data && leaflet_data.length)
                for (var j = 0; j < leaflet_data.length; j++)
                    if (leaflet_data[j].data && leaflet_data[j].data.name === groupID) {
                        groupID = leaflet_data[j].data.groupID;
                        break
                    }
            selector += '[class*="!g' + groupID + '!"]'
        }
        if (el.misc != null) {
            el.misc = el.misc + "";
            if (el.misc.startsWith("!"))
                selector += ':not([class*="!m' + el.misc.substring(1) + '!"])';
            else
                selector += '[class*="!m' + el.misc + '!"]'
        }
        if (el.row != null)
            selector += '[class*="!r' + el.row + '!"]';
        if (el.col != null)
            selector += '[class*="!c' + el.col + '!"]';
        if (el.axis != null)
            selector += '[class*="!a' + el.axis + '!"]';
        return selector
    }
    tdgchart.prototype.setURL = function(object, url, target, series, group, misc, row, col) {
        var chart = this;
        var obj = object;
        if (typeof object !== "object" || arguments.length > 1)
            obj = {
                object: object,
                series: series,
                group: group,
                misc: misc,
                row: row,
                col: col,
                url: url,
                target: target
            };
        obj.event = "setURL";
        obj.callback = function(url, target) {
            return function(callbackObj) {
                var chartData = chart._internalData || chart.data;
                var nearestData = chart.cache.get("isNearestNeighbor");
                if (nearestData && nearestData.nearest && nearestData.nearest.series != undefined && nearestData.nearest.group != undefined) {
                    callbackObj = tdg.cloneObject(callbackObj);
                    callbackObj.series = nearestData.nearest.series;
                    callbackObj.group = nearestData.nearest.group
                }
                var data = chart.getDataFromIds(callbackObj, chartData, chart.chartType);
                var localURL = chart.parseTemplate(url, data.d, data.data, callbackObj);
                if (target)
                    window.open(localURL, target);
                else
                    document.location = localURL
            }
        }(obj.url, obj.target);
        function urlGlobalKeyUpHandler(e, chart, root) {
            if (e.keyCode === 13 || e.keyCode === 32) {
                if (document.activeElement) {
                    var target = document.activeElement;
                    var className = target.getAttribute("class");
                    var ids = chart.classNameToIds(className);
                    if (ids.object === "riser")
                        target.dispatchEvent(new Event("click"))
                }
                return
            }
        }
        chart.registerEvent(obj);
        if (chart.accessibility.navigation.enabled) {
            var root = tdgchart.d3.select("#" + chart.documentRoot);
            chart.globalKeyUpAdd(tdg.partial(urlGlobalKeyUpHandler, [null, chart, root]), "riserKey")
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    var defaultHoverColor = "rgba(255, 255, 255, 0.47)";
    tdgchart._markerZoomFactor = 1.35;
    var defautlHoverMarkerBorder = {
        widthOffset: 1,
        color: "rgba(64,64,64,0.68)"
    };
    function applyAttributes(dest, src, attrs) {
        for (var i = 0, l = attrs.length; i < l; i++) {
            var a = attrs[i];
            if (src.getAttribute)
                if (src.hasAttribute(a))
                    dest.setAttribute(a, src.getAttribute(a));
                else
                    dest.removeAttribute(a);
            else if (src[a] != null)
                dest.setAttribute(a, src[a])
        }
    }
    function isStickyContent(chart, tooltip) {
        if (chart.htmlToolTip.sticky === "auto")
            return chart.tooltipContainsClickItems(tooltip);
        return chart.htmlToolTip.sticky
    }
    tdgchart.prototype.nearestNeighborMouseHandler = function(hoverNode, hoverColor) {
        var chart = this;
        if (chart.cache.hasKey("isNearestNeighbor"))
            return;
        else
            chart.cache.set("isNearestNeighbor", {});
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        var o = chart.blaProperties.orientation === "horizontal";
        var haveToolTips = chart.htmlToolTip.enabled;
        var haveLine = chart.isBLA() && (chartType === "line" || chart.series.some(function(el) {
            return el.riserShape && el.riserShape === "line"
        }));
        haveLine = haveLine || chartType === "radar";
        var root = tdgchart.d3.select("#" + chart.documentRoot);
        var groupPanelSel = root.selectAll(".eventPanel");
        if (groupPanelSel.node() == null)
            return;
        var groupPanelBox = {
            left: Infinity,
            right: -Infinity,
            top: Infinity,
            bottom: -Infinity
        };
        groupPanelSel[0].forEach(function(el) {
            var panelCTM = tdg.dom.ctm(el);
            var panelBox = tdg.dom.bbox(el);
            var tmpBox = {
                x: panelBox.x + panelCTM.e,
                y: panelBox.y + panelCTM.f,
                width: panelBox.width,
                height: panelBox.height
            };
            groupPanelBox = tdg.geom.union(groupPanelBox, tmpBox)
        });
        var isTracking = false;
        var isTrackingWhat;
        var toolTipDiv, mousePos, pageMousePos;
        var minMarker;
        function markerTouch() {
            if (minMarker)
                changeMarker(minMarker, false);
            minMarker = this;
            changeMarker(minMarker, true);
            drawTooltip()
        }
        function groupPanelTouch(d, data, e) {
            if (chart._disableHover || !this.ownerSVGElement) {
                chart.hideHoverNode();
                return
            }
            if (chartType !== "bar" && chartType !== "line" && chartType !== "area" && chartType !== "control")
                return;
            e.preventDefault();
            chart.htmlToolTip.sticky = false;
            if (chart.__refreshMarkerList) {
                markers = buildMarkerList();
                delete chart.__refreshMarkerList
            }
            var dt, localBar, minDistance = Infinity;
            var localMinMarker;
            mousePos = chart.mousePosition(root, e);
            pageMousePos = tdg.getMousePosition(e);
            markers.forEach(function(el) {
                dt = Math.sqrt(Math.pow(mousePos.x - el.x, 2) + Math.pow(mousePos.y - el.y, 2));
                if (Math.abs(dt) < minDistance) {
                    localMinMarker = el;
                    minDistance = Math.abs(dt)
                }
            });
            if (barList)
                barList.forEach(function(el) {
                    if (tdg.geom.intersect(pageMousePos, el.getBoundingClientRect()))
                        localBar = el
                });
            if (!localMinMarker && !localBar)
                return;
            else if (!localMinMarker && localBar)
                localMinMarker = {
                    svgEl: localBar
                };
            else if (localMinMarker) {
                var markerSize = parseFloat(localMinMarker.svgEl.getAttribute("tdg:radius") || localMinMarker.svgEl.getAttribute("r") || 0);
                if (localBar && minDistance > 5 + markerSize)
                    localMinMarker = {
                        svgEl: localBar
                    };
                else if (minDistance > 20 + markerSize) {
                    if (minMarker) {
                        changeMarker(minMarker, false);
                        minMarker = null
                    }
                    chart.hideHoverNode();
                    chart.hideToolTip();
                    return
                }
            }
            if (localMinMarker.svgEl !== minMarker) {
                if (minMarker && minMarker.originalTransform)
                    changeMarker(minMarker, false);
                minMarker = localMinMarker.svgEl;
                if (localBar && localBar === minMarker)
                    highlightBar(localBar);
                else
                    changeMarker(minMarker, true)
            }
            if (haveToolTips && !chart._disableToolTips)
                drawTooltip()
        }
        var areaList, mouseMoveDelegate = mouseMove;
        if (chart.interaction.mousemove && chart.interaction.mousemove.toLowerCase() !== "nearestneighbor") {
            areaList = root.selectAll('path[class^="riser!s"][class*="marea"]')[0];
            if (areaList.length > 0)
                mouseMoveDelegate = function(d, data, e) {
                    chart.__refreshMarkerList = true;
                    isTracking = true;
                    return mouseMove.call(this, d, data, e)
                }
                ;
            else
                areaList = null
        }
        var markerList = root.selectAll("*[class*=marker]:not(g):not([class*=legend]):not([class*=shadow]):not([class*=sizeLegend])").on("mousemove.hover", mouseMoveDelegate).on("touchend.hover", markerTouch);
        groupPanelSel.on("mousemove.hover", mouseMoveDelegate).on("touchend.hover", groupPanelTouch);
        var paths = root.selectAll('path[class^="riser!s"][class*="mline"], path[class^="riser!s"][class*="marea"], path[class^="lineFill"]');
        paths.on("mouseover.hover", function() {
            isTracking = true;
            isTrackingWhat = chart.classNameToIds(this)
        });
        if (chart.htmlToolTip.sticky && !chart.htmlToolTip.snap)
            root.select("svg").on("mouseout.tooltip", stickyMouseOut);
        if (chartType === "map")
            root.selectAll("path").on("mousemove.hover", mouseMoveDelegate);
        var riserShapeList = [], barList;
        if (chart.isBLA()) {
            riserShapeList = chart.getSeriesPropertyList("riserShape", chartType);
            barList = root.selectAll("[class^=riser][class*=mbar]");
            barList = barList.node() == null ? null : barList[0]
        }
        if (!barList && !markerList[0].some(function(el) {
            return el.getAttribute("tdgtitle")
        }))
            haveToolTips = false;
        function buildMarkerList(target, n) {
            var markers = [], el;
            for (var i = 0; i < markerList[0].length; i++) {
                el = markerList[0][i];
                var dsp = el.getAttribute("display");
                if (dsp === "none")
                    el.setAttribute("display", "inline");
                var ctm = el.getCTM();
                if (ctm == null) {
                    markers[i] = undefined;
                    continue
                }
                if (dsp === "none")
                    el.setAttribute("display", dsp);
                if (!el.hasOwnProperty("originalTransform"))
                    el.originalTransform = el.getAttribute("transform");
                if (el.hasAttribute("x"))
                    ctm.e += parseFloat(el.getAttribute("x")) || 0;
                if (el.hasAttribute("y"))
                    ctm.f += parseFloat(el.getAttribute("y")) || 0;
                var ids = chart.classNameToIds(el);
                markers[i] = {
                    svgEl: el,
                    x: ctm.e,
                    y: ctm.f,
                    r: el.getAttribute("tdg:radius"),
                    series: ids.series,
                    group: ids.group,
                    riserShape: riserShapeList[ids.series]
                }
            }
            markers = markers.filter(function(el) {
                return el != null
            });
            if (target && areaList && areaList.includes(target) && chart.interaction.mousemove && chart.interaction.mousemove.toLowerCase() !== "nearestneighbor") {
                var areaSeries = chart.classNameToIds(target).series;
                markers = markers.filter(function(el) {
                    return el.series === areaSeries ? el : null
                })
            }
            return markers
        }
        var visibleDelayTimer, hideDelayTimer;
        var markers;
        if (markerList[0].length < 1E3) {
            markers = buildMarkerList();
            if (tdg.isEmpty(markers))
                return
        } else {
            setTimeout(function() {
                markers = buildMarkerList()
            }, 300);
            return
        }
        var useZoom = !chart.isDataDrivenMarkerSize() || chart.chartType === "scatter";
        var zoom = useZoom ? " scale(" + tdgchart._markerZoomFactor + ", " + tdgchart._markerZoomFactor + ")" : "";
        function hideHoverAndToolTip() {
            if (minMarker) {
                isTracking = false;
                isTrackingWhat = undefined;
                chart.hideHoverNode();
                changeMarker(minMarker, false);
                minMarker = null
            }
            if (toolTipDiv && (chart.htmlToolTip.snap || !isStickyContent(chart, toolTipDiv)))
                chart.hideToolTip(toolTipDiv)
        }
        window.onmouseout = hideHoverAndToolTip;
        chart.globalMouseMoveAdd(function(e) {
            mousePos = chart.mousePosition(root, e);
            pageMousePos = tdg.getMousePosition(e);
            if (minMarker && !tdg.geom.intersect(mousePos, groupPanelBox))
                hideHoverAndToolTip()
        }, "nearestNeighborMouseHandler");
        function hideStickyToolTip() {
            if (visibleDelayTimer) {
                window.clearTimeout(visibleDelayTimer);
                visibleDelayTimer = null
            }
            if (toolTipDiv) {
                if (toolTipDiv.newInnerHTML && toolTipDiv.newInnerHTML !== "placeholder") {
                    chart.setToolTipContent(toolTipDiv, toolTipDiv.newInnerHTML);
                    toolTipDiv.newInnerHTML = undefined
                }
                chart.hideToolTip(toolTipDiv)
            }
        }
        function showToolTipTimerCallback(mp) {
            return function() {
                if (!document.body.contains(toolTipDiv))
                    return;
                var box = {
                    x: 0,
                    y: 0,
                    width: root.node().clientWidth,
                    height: root.node().clientHeight
                };
                if (!tdg.geom.intersect(mousePos, box))
                    return;
                if (mp) {
                    var tooltipPos = chart.tooltipPosition(toolTipDiv, mp);
                    toolTipDiv.style.left = tooltipPos.x;
                    toolTipDiv.style.top = tooltipPos.y;
                    toolTipDiv.isBelow = tooltipPos.isBelow
                }
                if (chart.htmlToolTip.enabled)
                    toolTipDiv.style.visibility = "visible";
                hideDelayTimer = window.setTimeout(hideToolTipTimerCallback, 1200)
            }
        }
        var lastMousePos = {
            x: 0,
            y: 0
        }
          , inCount = 0;
        function hideToolTipTimerCallback() {
            if (!toolTipDiv || !document.body.contains(toolTipDiv))
                return;
            if (chart.mouseNearTooltip(toolTipDiv, pageMousePos) && inCount < 3) {
                hideDelayTimer = window.setTimeout(hideToolTipTimerCallback, 1200);
                inCount = tdg.geom.equal(lastMousePos, mousePos) ? inCount + 1 : 0
            } else {
                chart.hideToolTip(toolTipDiv);
                inCount = 0
            }
            lastMousePos = mousePos
        }
        function hideMarker(marker) {
            if (chart.mouseOverIndicator.enabled && marker && marker.originalTransform)
                if (marker.getAttribute("display"))
                    marker.setAttribute("display", "none");
                else
                    marker.setAttribute("transform", marker.originalTransform + "")
        }
        function changeMarker(marker, isHovered) {
            if (!chart.mouseOverIndicator.enabled || !marker)
                return;
            if (marker.originalTransform) {
                var r = parseFloat(marker.getAttribute("tdg:radius") || marker.getAttribute("r") || 0);
                if (useZoom && r * tdgchart._markerZoomFactor - r < 3) {
                    var s = Math.max(4 / r, tdgchart._markerZoomFactor);
                    zoom = " scale(" + s + ", " + s + ")"
                }
                if (marker.getAttribute("display"))
                    marker.setAttribute("display", isHovered ? "inline" : "none");
                else
                    marker.setAttribute("transform", marker.originalTransform + (isHovered ? zoom : ""));
                if (hoverNode) {
                    var ids = chart.classNameToIds(marker);
                    if (isHovered && ids.object !== "marker") {
                        var t = marker.getCTM();
                        hoverNode.setAttribute("transform", "translate(" + t.e + ", " + t.f + ")" + zoom);
                        hoverNode.setAttribute("display", "inline");
                        if (!hoverNode.parentNode)
                            marker.ownerSVGElement.appendChild(hoverNode);
                        var stroke = parseInt(marker.getAttribute("stroke-width"), 10) || 1;
                        hoverNode.setAttribute("stroke-width", stroke + defautlHoverMarkerBorder.widthOffset);
                        if (marker.tagName === "circle") {
                            r = marker.getAttribute("r");
                            var p = tdg.formatString("m -{0} 0 a {0} {0} 0 1 0 {1} 0 a {0} {0} 0 1 0 -{1} 0", r, r * 2);
                            hoverNode.setAttribute("d", p)
                        } else {
                            applyAttributes(hoverNode, marker, ["d"]);
                            r = marker.getAttribute("transform").match(/rotate\([-.0-9]*?\)/ig);
                            if (r && r.length > 0)
                                hoverNode.setAttribute("transform", hoverNode.getAttribute("transform") + r[0])
                        }
                        if (hoverColor && isHovered)
                            hoverNode.setAttribute("fill", hoverColor(marker))
                    } else if (!isHovered)
                        hoverNode.setAttribute("display", "none")
                }
            } else if (hoverNode && !isHovered)
                hoverNode.setAttribute("display", "none")
        }
        function distancePointLine(pt, lPt1, lPt2) {
            return Math.abs(pt.x * (lPt2.y - lPt1.y) - pt.y * (lPt2.x - lPt1.x) + lPt2.x * lPt1.y - lPt2.y * lPt1.x) / tdg.geom.distance(lPt1, lPt2)
        }
        function mouseNearLine(mousePos, minMarker, markers) {
            for (var i = 0; i < markers.length; i++) {
                var m = markers[i];
                if (m.series === minMarker.series && Math.abs(m.group - minMarker.group) === 1) {
                    var dt = distancePointLine(mousePos, minMarker, m);
                    if (dt < 10 && tdg.geom.ptInBox(mousePos, minMarker, m))
                        return true
                }
            }
            return false
        }
        function mouseMove(d, data, e) {
            if (chart._disableHover || !this.ownerSVGElement) {
                chart.hideHoverNode();
                return
            }
            if (chart.__refreshMarkerList) {
                markers = buildMarkerList(e.target);
                delete chart.__refreshMarkerList
            }
            var dt, dx, minX = Infinity, minDistance = Infinity;
            var localMinMarker, localBar;
            mousePos = chart.mousePosition(root, e);
            pageMousePos = tdg.getMousePosition(e);
            if (markers)
                for (var i = markers.length - 1; i >= 0; i--) {
                    var el = markers[i];
                    if (isTracking && (haveLine || areaList || chartType === "streamgraph")) {
                        if (isTracking && haveLine && isTrackingWhat && isTrackingWhat.object == "riser" && isTrackingWhat.misc == "line")
                            if (el.series != undefined && el.series != isTrackingWhat.series)
                                continue;
                        dt = Math.sqrt(Math.pow(mousePos.x - el.x, 2) + Math.pow(mousePos.y - el.y, 2)) - el.r;
                        dx = Math.abs(o ? mousePos.y - el.y : mousePos.x - el.x);
                        if (chartType == "radar" || Math.abs(dx - minX) < 1) {
                            if (dt < minDistance) {
                                localMinMarker = el;
                                minDistance = dt
                            }
                        } else if (dx < minX) {
                            localMinMarker = el;
                            minDistance = dt;
                            minX = dx
                        }
                    } else {
                        dt = Math.sqrt(Math.pow(mousePos.x - el.x, 2) + Math.pow(mousePos.y - el.y, 2));
                        if (Math.abs(dt) < minDistance) {
                            localMinMarker = el;
                            minDistance = Math.abs(dt)
                        }
                    }
                }
            if (barList)
                barList.forEach(function(el) {
                    if (tdg.geom.intersect(pageMousePos, el.getBoundingClientRect()))
                        localBar = el
                });
            if (!localMinMarker || localBar && localBar === e.target) {
                if (localBar) {
                    isTracking = true;
                    localMinMarker = {
                        svgEl: localBar
                    }
                } else {
                    minMarker = null;
                    chart.hideHoverNode();
                    chart.hideToolTip()
                }
                if (!localMinMarker)
                    return
            }
            var markerSize = parseFloat(localMinMarker.svgEl.getAttribute("tdg:radius") || localMinMarker.svgEl.getAttribute("r") || 0);
            var targetClass = e.target ? e.target.getAttribute("class") || "" : "";
            if (minDistance < 17 + markerSize)
                isTracking = true;
            else if (haveLine && targetClass.indexOf("mline") >= 0)
                isTracking = true;
            else if (areaList && localBar) {
                isTracking = true;
                localMinMarker = {
                    svgEl: localBar
                }
            } else if (areaList && !barList && !haveLine && chart.interaction.mousemove && chart.interaction.mousemove.toLowerCase() !== "nearestneighbor") {
                if (!areaList.includes(e.target)) {
                    isTracking = false;
                    isTrackingWhat = undefined;
                    if (minMarker) {
                        changeMarker(minMarker, false);
                        minMarker = null
                    }
                    chart.hideHoverNode();
                    chart.hideToolTip()
                }
            } else if (haveLine && chart.interaction.mousemove && chart.interaction.mousemove.toLowerCase() !== "nearestneighbor") {
                if (mouseNearLine(mousePos, localMinMarker, markers))
                    isTracking = true;
                else if (localBar) {
                    isTracking = true;
                    localMinMarker = {
                        svgEl: localBar
                    }
                } else {
                    isTracking = false;
                    isTrackingWhat = undefined;
                    if (minMarker) {
                        changeMarker(minMarker, false);
                        minMarker = null
                    }
                    if (chart.cache.get("forceNearestNeighbor") && isStickyContent(chart, toolTipDiv))
                        ;
                    else {
                        chart.hideHoverNode();
                        chart.hideToolTip()
                    }
                }
                if (isTracking)
                    chart.cache.set("isNearestNeighbor", {
                        nearest: {
                            type: "line",
                            series: localMinMarker.series,
                            group: localMinMarker.group
                        }
                    });
                else
                    chart.cache.set("isNearestNeighbor", {
                        nearest: null
                    })
            }
            if (!isTracking)
                return;
            if (localMinMarker.svgEl !== minMarker) {
                if (minMarker && minMarker.originalTransform)
                    if (areaList && areaList.includes(e.target))
                        hideMarker(minMarker);
                    else
                        changeMarker(minMarker, false);
                minMarker = localMinMarker.svgEl;
                if (localBar && localBar === minMarker)
                    highlightBar(localBar);
                else
                    changeMarker(minMarker, true);
                chart.cache.set("isNearestNeighbor", {
                    nearest: {
                        type: "line",
                        series: localMinMarker.series,
                        group: localMinMarker.group
                    }
                })
            }
            if (haveToolTips && !chart._disableToolTips)
                drawTooltip()
        }
        function highlightBar(bar) {
            if (hoverNode == null)
                hoverNode = createHoverNode(chart, bar);
            var ctm = bar.getCTM();
            var vb = bar.ownerSVGElement.viewBox.baseVal || {
                x: 0,
                y: 0
            };
            var t = "translate(" + (ctm.e + vb.x) + ", " + (ctm.f + vb.y) + ")";
            hoverNode.setAttribute("transform", t);
            if (chart.mouseOverIndicator.border) {
                var b = chart.mouseOverIndicator.border;
                hoverNode.setAttribute("stroke", b.color || null);
                hoverNode.setAttribute("stroke-width", b.width || null);
                hoverNode.setAttribute("stroke-dasharray", pv.SvgScene.dashLookup(b.dash))
            } else
                hoverNode.setAttribute("stroke", null);
            hoverNode.setAttribute("fill", hoverNode.hoverColor(bar));
            hoverNode.setAttribute("display", "inline");
            if (!hoverNode.parentNode)
                bar.ownerSVGElement.appendChild(hoverNode);
            if (hoverNode.nodeName === "rect")
                applyAttributes(hoverNode, bar, ["x", "y", "width", "height", "rx", "ry"]);
            else if (hoverNode.nodeName === "path") {
                var x1 = Math.round(bar.getAttribute("x"));
                var y1 = Math.round(bar.getAttribute("y"));
                var x2 = x1 + Math.round(bar.getAttribute("width"));
                var y2 = y1 + Math.round(bar.getAttribute("height"));
                var p = tdg.formatString("M{0},{1}L{2},{1}L{2},{3}L{0},{3}Z", x1, y1, x2, y2);
                hoverNode.setAttribute("d", p)
            }
            var isRound = parseFloat(bar.getAttribute("rx")) > 0 || parseFloat(bar.getAttribute("ry")) > 0;
            hoverNode.setAttribute("shape-rendering", isRound ? "auto" : "crispEdges")
        }
        function drawTooltip() {
            if (!minMarker.hasAttribute("tdgtitle") && !minMarker.parentNode.hasAttribute("tdgtitle"))
                return;
            if (toolTipDiv == null)
                toolTipDiv = chart.createHTMLToolTip(root);
            if (isStickyContent(chart, toolTipDiv) && chart.mouseNearTooltip(toolTipDiv, pageMousePos)) {
                toolTipDiv.newInnerHTML = minMarker.getAttribute("tdgtitle") || minMarker.parentNode.getAttribute("tdgtitle");
                if (hideDelayTimer) {
                    window.clearTimeout(hideDelayTimer);
                    hideDelayTimer = null
                }
                hideDelayTimer = window.setTimeout(hideToolTipTimerCallback, 1200);
                return
            }
            chart.setToolTipContent(toolTipDiv, minMarker.getAttribute("tdgtitle"), minMarker);
            if (!isStickyContent(chart, toolTipDiv) || chart.htmlToolTip.snap)
                if (chart.htmlToolTip.enabled)
                    toolTipDiv.style.visibility = "visible";
            if (chart.htmlToolTip.snap)
                chart.snapToolTip(chartType, minMarker, toolTipDiv);
            else {
                if (visibleDelayTimer) {
                    window.clearTimeout(visibleDelayTimer);
                    visibleDelayTimer = null
                }
                if (hideDelayTimer) {
                    window.clearTimeout(hideDelayTimer);
                    hideDelayTimer = null
                }
                if (isStickyContent(chart, toolTipDiv))
                    if (toolTipDiv.style.visibility === "visible")
                        if (chart.mouseNearTooltip(toolTipDiv, pageMousePos))
                            hideDelayTimer = window.setTimeout(hideToolTipTimerCallback, 1200);
                        else
                            hideStickyToolTip();
                    else
                        visibleDelayTimer = window.setTimeout(showToolTipTimerCallback(mousePos), 270);
                else {
                    var tooltipPos = chart.tooltipPosition(toolTipDiv, mousePos);
                    toolTipDiv.style.left = tooltipPos.x;
                    toolTipDiv.style.top = tooltipPos.y
                }
            }
        }
        function stickyMouseOut() {
            if (hideDelayTimer) {
                window.clearTimeout(hideDelayTimer);
                hideDelayTimer = null
            }
            if (visibleDelayTimer) {
                window.clearTimeout(visibleDelayTimer);
                visibleDelayTimer = null
            }
            if (chart.mouseNearTooltip(toolTipDiv, pageMousePos))
                hideDelayTimer = window.setTimeout(hideToolTipTimerCallback, 1200);
            else
                hideStickyToolTip()
        }
    }
    ;
    function createHoverNode(chart, riser, i) {
        var c = chart.mouseOverIndicator.color || defaultHoverColor;
        if (chart.chartType === "gauge")
            c = "black";
        var hoverColor = function() {
            return c
        };
        if (tdg.isPercentString(c)) {
            var lerp = tdg.parsePercent(c, -1);
            hoverColor = function(riser) {
                var riserColor = riser.getAttribute("fill") || riser.getAttribute("stroke");
                return tdg.color(riserColor).alpha(lerp).toString()
            }
        }
        var tagName = riser.tagName === "circle" ? "path" : riser.tagName;
        var hoverNode = getHoverNode(chart, i);
        if (hoverNode == null) {
            hoverNode = document.createElementNS(tdg.ns.svg, tagName);
            hoverNode.setAttribute("pointer-events", "none");
            hoverNode.setAttribute("display", "none");
            hoverNode.setAttribute("class", "hoverFill")
        }
        riser.ownerSVGElement.appendChild(hoverNode);
        hoverNode.hoverColor = hoverColor;
        hoverNode._relatedHoverTarget = riser;
        return hoverNode
    }
    function getHoverNodes(chart) {
        var root = document.getElementById(chart.documentRoot);
        if (root && root.getElementsByClassName)
            return root.getElementsByClassName("hoverFill");
        return []
    }
    function getHoverNode(chart, i) {
        var root = document.getElementById(chart.documentRoot);
        if (root && root.getElementsByClassName)
            return root.getElementsByClassName("hoverFill")[i || 0];
        return null
    }
    tdgchart.prototype.hideHoverNode = function() {
        var nodes = getHoverNodes(this);
        for (var i = 0; i < nodes.length; i++)
            nodes[i].setAttribute("display", "none")
    }
    ;
    function chartHaveLineAreaMarkers(chart) {
        var ctype = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        if (ctype === "line" || ctype === "radar" || ctype === "control" || ctype === "area" || ctype === "streamgraph")
            return true;
        if (ctype === "map" && chart.mapProperties.engine !== "leaflet" && chart.mapProperties.markerType !== "choropleth")
            return true;
        if (chart._internalData && chart._internalData.seriesMap && chart.series.some(function(el) {
            return el.riserShape && el.riserShape === "line" && (el.series === "all" || chart._internalData.seriesMap.includes(el.series))
        }))
            return true;
        return false
    }
    function chartIsScatter(chart) {
        return chart.chartType === "scatter" || chart.chartType === "bubble" || chart.chartType === "matrix" && (chart.matrixProperties.chartType === "bubble" || chart.matrixProperties.chartType === "scatter")
    }
    tdgchart.prototype.doMouseHover = function() {
        var chart = this;
        if (!chart.mouseOverIndicator.enabled)
            return;
        var legendMarkers = [];
        var legendMarkersArr = [];
        var haveLineAreaMarkers = chartHaveLineAreaMarkers(chart);
        var wantOverLegend = chart.isLegendVisible() && chart.mouseOverIndicator.overLegend == "series";
        var wantJustNearest = haveLineAreaMarkers && chart.htmlToolTip.enabled && !chart.isDataDrivenMarkerSize();
        if (wantJustNearest && !wantOverLegend) {
            chart.nearestNeighborMouseHandler();
            return
        }
        var haveMarkers = haveLineAreaMarkers || chartIsScatter(chart);
        var root = tdgchart.d3.select("#" + chart.documentRoot);
        var risers;
        if (chart.chartType === "pie") {
            risers = root.selectAll('path[class^="riser!s"]');
            if (chart.depth)
                risers = risers.filter(function() {
                    return this.getAttribute("tdg:part") === "top"
                })
        } else if (chart.chartType === "bar" && chart.depth)
            risers = root.selectAll('g[class="bar25d"] > :last-child');
        else if (chart.chartType === "map")
            risers = root.selectAll('path[class^="riser!s"]');
        else if (chart.chartType === "treemap")
            risers = root.selectAll('rect[class^="riser!s"][class*="!mnode"], rect[class^="group-header"]');
        else if (chart.chartType === "scatter" || chart.chartType === "bubble")
            risers = root.selectAll('*[class^="riser!s"][class*="!mmarker"]');
        else if (chart.chartType === "tagcloud")
            risers = root.selectAll('*[class^="riser!s"][class*="!mtag"]');
        else if (chart.chartType === "line")
            if (chart.anySeriesHaveMarkers(chart._internalData))
                risers = root.selectAll('*[class^="marker!s"][class*="!mmarker"]');
            else
                risers = root.selectAll('*[class^="riser!s"][class*="!mline"]');
        else if (chart.chartType === "area")
            if (chart.anySeriesHaveMarkers(chart._internalData))
                risers = root.selectAll('*[class^="marker!s"][class*="!mmarker"]');
            else
                risers = root.selectAll('*[class^="riser!s"][class*="!marea"]');
        else if (chart.chartType === "radar")
            risers = root.selectAll('*[class^="riser!s"][class*="!mline"]');
        else if (chart.chartType === "control")
            risers = root.selectAll('*[class^="marker!s"][class*="!mmarker"]');
        else if (chart.chartType === "parabox")
            risers = root.selectAll('path[class^="riser!s"]');
        else
            risers = root.selectAll('[class^="riser!s"]:not([class*="!mline"]), [class^="riser!s"][class*="!mmarker"]');
        risers = risers.filter(function() {
            var c = this.getAttribute("class");
            return !c || c.includes("shadow") || c.includes("bevel") ? null : this
        });
        var firstRiser = risers.node();
        if (!firstRiser)
            return;
        var hoverNodes = [createHoverNode(chart, firstRiser)];
        if (haveMarkers)
            if (chart.chartType !== "scatter")
                hoverNodes[0].setAttribute("stroke", defautlHoverMarkerBorder.color);
        function onMouseOver() {
            var riser = this;
            hoverElement(riser)
        }
        function hoverElements(risers, startID) {
            risers.forEach(function(el, i) {
                hoverOneElement(el, startID + i)
            })
        }
        function hoverElement(riser) {
            return hoverOneElement(riser)
        }
        function hoverOneElement(riser, i) {
            if (!riser)
                return;
            if (chart._disableHover || !riser.ownerSVGElement) {
                chart.hideHoverNode();
                return
            }
            i = i || 0;
            var ctm = riser.getCTM();
            var vb = riser.ownerSVGElement.viewBox.baseVal || {
                x: 0,
                y: 0
            };
            var cx = parseFloat(riser.getAttribute("cx")) || 0;
            var cy = parseFloat(riser.getAttribute("cy")) || 0;
            var r, t = "translate(" + (ctm.e + vb.x + cx) + ", " + (ctm.f + vb.y + cy) + ")";
            hoverNodes[i] = hoverNodes[i] || createHoverNode(chart, riser, i);
            var hoverNode = hoverNodes[i];
            hoverNode._relatedHoverTarget = riser;
            var thisTransform = riser.getAttribute("transform");
            if (thisTransform) {
                r = thisTransform.match(/rotate\([-.0-9]*?\)/ig);
                if (r && r.length > 0)
                    t += r[0]
            }
            var parentTransform = riser.parentNode.getAttribute("transform");
            if (parentTransform && parentTransform.indexOf("scale") >= 0)
                t += " " + parentTransform.match(/scale\([-.0-9, ]*?\)/ig);
            if (hoverNode.isAnimating)
                tdgchart.d3.select(hoverNode).transition().duration(0).attr("transform", t);
            else
                hoverNode.setAttribute("transform", t);
            function wantFill(relatedHoverTarget) {
                var clsName = relatedHoverTarget.getAttribute("class");
                return clsName.indexOf("mline") < 0 && chart.chartType !== "gauge"
            }
            if (wantFill(riser)) {
                hoverNode.setAttribute("fill", hoverNode.hoverColor(riser));
                if (chart.mouseOverIndicator.border) {
                    var b = chart.mouseOverIndicator.border;
                    hoverNode.setAttribute("stroke", b.color || null);
                    hoverNode.setAttribute("stroke-width", b.width || null);
                    hoverNode.setAttribute("stroke-dasharray", pv.SvgScene.dashLookup(b.dash))
                } else
                    hoverNode.setAttribute("stroke", null);
                hoverNode.setAttribute("fill", hoverNode.hoverColor(riser))
            } else {
                if (!chart.mouseOverIndicator.border.color) {
                    lineColor = riser.getAttribute("stroke");
                    if (chart.mouseOverIndicator.border.width != undefined)
                        lineWidth = chart.mouseOverIndicator.border.width;
                    else {
                        lineWidth = parseFloat(riser.getAttribute("stroke-width"));
                        lineWidth += 2
                    }
                } else {
                    lineColor = chart.mouseOverIndicator.border.color;
                    if (chart.mouseOverIndicator.border.width != undefined)
                        lineWidth = chart.mouseOverIndicator.border.width;
                    else
                        lineWidth = parseFloat(riser.getAttribute("stroke-width"))
                }
                hoverNode.setAttribute("fill", null);
                hoverNode.setAttribute("stroke", lineColor);
                hoverNode.setAttribute("stroke-width", lineWidth)
            }
            hoverNode.setAttribute("display", "inline");
            if (!hoverNode.parentNode)
                riser.ownerSVGElement.appendChild(hoverNode);
            var className = riser.getAttribute("class") || "";
            if (className.includes("group-header")) {
                var miscID = chart.classNameToIds(riser).misc;
                var subnodes = risers.filter(function() {
                    var mID = chart.classNameToIds(riser);
                    return typeof mID.series === "string" && mID.series.includes(miscID) ? riser : null
                });
                var maxY;
                if (riser.hasOwnProperty("maxY"))
                    maxY = riser.maxY;
                else
                    maxY = riser.maxY = tdg.max(subnodes[0], function(el) {
                        return parseFloat(el.getAttribute("y")) + parseFloat(el.getAttribute("height"))
                    });
                applyAttributes(hoverNode, riser, ["x", "y", "width"]);
                hoverNode.setAttribute("height", maxY - parseFloat(riser.getAttribute("y")));
                hoverNode.setAttribute("fill", null);
                hoverNode.setAttribute("stroke", "black");
                hoverNode.setAttribute("stroke-width", 2)
            } else if (className.includes("title")) {
                applyAttributes(hoverNode, tdg.geom.grow(riser.getBBox(), 4), ["x", "y", "width", "height"]);
                hoverNode.setAttribute("shape-rendering", "crispEdges")
            } else
                switch (riser.tagName) {
                case "rect":
                    applyAttributes(hoverNode, riser, ["x", "y", "width", "height", "rx", "ry"]);
                    var isRound = parseFloat(riser.getAttribute("rx")) > 0 || parseFloat(riser.getAttribute("ry")) > 0;
                    hoverNode.setAttribute("shape-rendering", isRound ? "auto" : "crispEdges");
                    break;
                case "path":
                    var attrs = ["d", "fill-rule"];
                    if (className.indexOf("legend-markers") == 0) {
                        attrs.push("shape-rendering");
                        attrs.push("stroke-width")
                    }
                    applyAttributes(hoverNode, riser, attrs);
                    break;
                case "text":
                    applyAttributes(hoverNode, riser, ["x", "y", "dy", "text-anchor", "style", "font-size", "font-weight", "font-family"]);
                    hoverNode.textContent = riser.textContent;
                    break;
                case "circle":
                    r = riser.getAttribute("r");
                    var p = tdg.formatString("m -{0} 0 a {0} {0} 0 1 0 {1} 0 a {0} {0} 0 1 0 -{1} 0", r, r * 2);
                    hoverNode.setAttribute("d", p);
                    var stroke = parseInt(riser.getAttribute("stroke-width"), 10) || 1;
                    hoverNode.setAttribute("stroke-width", stroke + defautlHoverMarkerBorder.widthOffset);
                    if (className.indexOf("legend-markers") == 0) {
                        var attrs = [];
                        attrs.push("stroke-width");
                        applyAttributes(hoverNode, riser, attrs)
                    }
                    break
                }
        }
        function mouseOut(d, data, e) {
            if (e && e.relatedTarget && hoverNodes[0]) {
                var c = e.relatedTarget.getAttribute("class");
                if (!c && e.relatedTarget.parentNode && typeof e.relatedTarget.parentNode.getAttribute === "function")
                    c = e.relatedTarget.parentNode.getAttribute("class");
                if (!c || !c.includes("tooltipCallout") && !c.includes("selectionRect") && !c.includes("dataLabel"))
                    hoverNodes[0].setAttribute("display", "none")
            }
        }
        function touchEnd(d, data, riser) {
            chart.hideHoverNode();
            if (risers[0].indexOf(riser.target) >= 0)
                onMouseOver.call(riser.target);
            else if (legendMarkers[0] && legendMarkers[0].indexOf(riser.target) >= 0)
                if (chart.mouseOverIndicator.overLegend == "series")
                    onLegendOver.call(riser.target)
        }
        function onLegendOver(ev) {
            var el = this;
            var ids = chart.classNameToIds(el);
            hoverOneElement(legendMarkersArr[ids.series], 0);
            var selRisers = risers[0].filter(function(riser) {
                var rIds = chart.classNameToIds(riser);
                return (ids.series == null || rIds.series == null || ids.series == rIds.series) && (ids.group == null || rIds.group == null || ids.group == rIds.group)
            });
            hoverElements(selRisers, 1)
        }
        function onLegendOut() {
            chart.hideHoverNode()
        }
        var mainChartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        if (haveMarkers && chart.htmlToolTip.enabled && (chart.isDataDrivenMarkerSize() || mainChartType === "scatter") && chart.interaction.mousemove && chart.interaction.mousemove.toLowerCase() === "nearestneighbor")
            chart.nearestNeighborMouseHandler(hoverNodes[0], hoverNodes[0].hoverColor);
        else if (wantJustNearest)
            ;
        else {
            chart.nearestNeighborMouseHandler();
            risers.on("mouseover.hover", onMouseOver).on("mouseout.hover", mouseOut);
            root.on("touchend.hover", touchEnd)
        }
        if (wantOverLegend) {
            root.selectAll('[class^="legend-markers!s"]')[0].forEach(function(marker) {
                var ids = chart.classNameToIds(marker);
                legendMarkersArr[ids.series] = marker
            });
            legendMarkers = root.selectAll('[class^="legend-markers!"],[class^="legend-labels!"]');
            legendMarkers.on("mouseover.legendhover", onLegendOver);
            legendMarkers.on("mouseout.legendhover", onLegendOut)
        }
    }
    ;
    tdgchart.prototype.mousePosition = function(root, e) {
        if (e.type.indexOf("touch") >= 0 && e.changedTouches && e.changedTouches.length > 0)
            e = e.changedTouches[0];
        var svg = root ? root.select("svg").node() : null;
        if (!svg)
            return {
                x: e.offsetX,
                y: e.offsetY
            };
        var pt = tdgchart.d3.svg.mouse(svg, e);
        return {
            x: pt[0],
            y: pt[1]
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.doAccessibilityNavigation = doAccessibilityNavigation;
    function doAccessibilityNavigation(root) {
        var chart = this;
        root = root || tdgchart.d3.select("#" + chart.documentRoot);
        var risers = root.selectAll('rect[class^=riser][class*="!mbar"], ' + 'rect[class^=riser][class*="!mbox"], ' + 'rect[class^=riser][class*="!mnode"], ' + 'path[class^="riser!"][class*="!mwedge"], ' + 'path[class^="riser!"][class*="!mrange"], ' + 'path[class^="riser!"][class*="!mregion"], ' + '[class^="riser!"][class*="!mmarker"], ' + 'g[class="markers"] [class^="marker!"], ' + 'g[class="outliers"] [class^="outlier!"]');
        if (risers.empty())
            return null;
        var index = 0;
        root.select(".rootPanel").attr("tabindex", 0);
        var ARIADESC_ON_TOOLTIP = false;
        function hideTooltipFn() {
            return function(e) {
                var ignore = chart.cache.get("accessibility_menu_move");
                if (!ignore) {
                    var tt = chart.getInternalToolTip();
                    tt.hide()
                }
            }
        }
        function showTooltipFn() {
            var prefix = chart.documentRoot ? chart.documentRoot + "_" : "";
            return function(e) {
                var target = e.target || e.srcElement;
                if (ARIADESC_ON_TOOLTIP)
                    target.setAttribute("aria-labelledby", prefix + "tdgchart-tooltip");
                var tooltipsFunctions = chart.cache.get("tooltipsFunctions");
                if (tooltipsFunctions)
                    tooltipsFunctions.displayTooltip.call(chart, target, true)
            }
        }
        var risersIndexed = risers[0];
        if (chart.accessibility.navigation.tabLimit != undefined)
            risersIndexed = risersIndexed.slice(0, chart.accessibility.navigation.tabLimit);
        var prefix = chart.documentRoot ? chart.documentRoot + "_" : "";
        risersIndexed.forEach(function(r, i) {
            r.setAttribute("tabindex", 0);
            if (ARIADESC_ON_TOOLTIP)
                ;
            else {
                var desc = document.createElement("div");
                desc.setAttribute("visible", "none");
                desc.setAttribute("aria-hidden", "true");
                var id = prefix + "aria-desc-n" + i;
                desc.setAttribute("id", id);
                r.setAttribute("aria-labelledby", id);
                r.parentNode.insertBefore(desc, r);
                var className = r.className.baseVal || r.className;
                var ids = chart.classNameToIds(className);
                var dataInfo = chart.getDataFromIds(ids, chart.data, chart.chartType);
                var lookup = chart.seriesPropertyLookup("tooltip");
                var tooltipInfo = lookup(dataInfo.d);
                var content = chart.resolveToolTipSeriesContent(tooltipInfo, dataInfo.d, dataInfo.data, ids, null);
                if (content) {
                    content.querySelectorAll("tr").forEach(function(tr, i) {
                        var space = document.createElement("tr");
                        if (i > 0) {
                            var td = document.createElement("td");
                            td.innerHTML = ",\n";
                            space.appendChild(td)
                        }
                        tr.parentNode.insertBefore(space, tr)
                    });
                    var entries = content.querySelectorAll("DIV > UL > LI");
                    var count = 0;
                    entries.forEach(function(li) {
                        var table = li.querySelector("table");
                        if (table) {
                            desc.appendChild(document.createTextNode(table.textContent));
                            return
                        }
                        var hr = li.querySelector("hr");
                        if (hr)
                            return;
                        count++
                    })
                }
            }
        })
    }
    function tableToAria(table) {
        var desc = "";
        table.querySelectorAll("tr").forEach(function(tr, i) {
            if (desc)
                desc += ", ";
            desc += tr.innerText
        });
        return desc
    }
    var ariaUniqueSeq = 0;
    tdgchart.prototype.buildAriaDescription = function(menuentry, isNewTooltip) {
        var chart = this;
        var ariaUniqueId = ++ariaUniqueSeq;
        var prefix = chart.documentRoot ? chart.documentRoot + "_e" : "";
        var labelledby = menuentry.getAttribute("aria-labelledby");
        var desc;
        if (labelledby)
            desc = document.getElementById(labelledby);
        if (!desc) {
            var desc = document.createElement("div");
            desc.setAttribute("style", "display:none");
            desc.setAttribute("aria-hidden", "true");
            var id = prefix + "aria-desc-n" + ariaUniqueId;
            desc.setAttribute("id", id);
            menuentry.setAttribute("aria-labelledby", id);
            menuentry.parentNode.insertBefore(desc, menuentry)
        }
        var text;
        if (menuentry.getAttribute("aria-haspopup") == "true") {
            text = menuentry.innerText.replace(/^>/, "");
            text = text
        } else {
            text = menuentry.innerText;
            text = text + " " + "menu entry"
        }
        var fullDesc = false;
        if (isNewTooltip)
            fullDesc = true;
        if (fullDesc) {
            var table = menuentry.parentNode.childNodes[0].childNodes[0];
            var menuItems = Array.from(menuentry.parentNode.childNodes).filter(function(li) {
                return li.getAttribute("role") === "menuitem"
            });
            var pre = "";
            if (table && table.nodeName.toLowerCase() == "table")
                pre = tableToAria(table) + ", ";
            if (menuItems.length)
                pre += "Menu of " + menuItems.length + " " + (menuItems.length > 1 ? "entries" : "entry") + ", ";
            text = pre + text
        }
        desc.innerText = text;
        menuentry.focus()
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    function buildGradient(gradientType, x1, y1, x2, y2, stops) {
        return {
            type: gradientType,
            start: {
                x: x1 + "%",
                y: y1 + "%"
            },
            end: {
                x: x2 + "%",
                y: y2 + "%"
            },
            stops: stops
        }
    }
    var barCylinderStops = [[0, "rgba(0, 0, 0, 0.6)"], [.5, "rgba(0, 0, 0, 0.0)"], [1, "rgba(0, 0, 0, 0.6)"]];
    var barCylinder = buildGradient("linear", 0, 0, 100, 0, barCylinderStops);
    var barHCylinder = buildGradient("linear", 0, 0, 0, 100, barCylinderStops);
    var lightenStops = [[0, "rgba(255, 255, 255, 0.5)"], [1, "rgba(255, 255, 255, 0.01)"]];
    var barLightenUp = buildGradient("linear", 0, 100, 0, 0, lightenStops);
    var barLightenDown = buildGradient("linear", 0, 0, 0, 100, lightenStops);
    var barLightenLeft = buildGradient("linear", 0, 0, 100, 0, lightenStops);
    var barLightenRight = buildGradient("linear", 100, 0, 0, 0, lightenStops);
    var darkenStops = [[0, "rgba(0, 0, 0, 0.5)"], [.7, "rgba(0, 0, 0, 0)"]];
    var barDarkenUp = buildGradient("linear", 0, 100, 0, 0, darkenStops);
    var barDarkenDown = buildGradient("linear", 0, 0, 0, 100, darkenStops);
    var barDarkenLeft = buildGradient("linear", 0, 0, 100, 0, darkenStops);
    var barDarkenRight = buildGradient("linear", 100, 0, 0, 0, darkenStops);
    var barLightenInvUp = buildGradient("linear", 0, 0, 0, 100, lightenStops);
    var barLightenInvDown = buildGradient("linear", 0, 100, 0, 0, lightenStops);
    var barLightenInvLeft = buildGradient("linear", 100, 0, 0, 0, lightenStops);
    var barLightenInvRight = buildGradient("linear", 0, 0, 100, 0, lightenStops);
    var barDarkenInvUp = buildGradient("linear", 0, 0, 0, 100, darkenStops);
    var barDarkenInvDown = buildGradient("linear", 0, 100, 0, 0, darkenStops);
    var barDarkenInvLeft = buildGradient("linear", 100, 0, 0, 0, darkenStops);
    var barDarkenInvRight = buildGradient("linear", 0, 0, 100, 0, darkenStops);
    var barBevelStops = [[0, "rgba(0, 0, 0, 0.4)"], [.15, "rgba(0, 0, 0, 0)"], [.85, "rgba(0, 0, 0, 0)"], [1, "rgba(0, 0, 0, 0.4)"]];
    var barBevel = buildGradient("linear", 0, 0, 100, 0, barBevelStops);
    var barHBevel = buildGradient("linear", 0, 0, 0, 100, barBevelStops);
    var wedgeBevel = {
        type: "radial",
        start: {
            x: 0,
            y: 0
        },
        stops: [[.87, "rgba(0, 0, 0, 0)"], [1, "rgba(0, 0, 0, 0.4)"]]
    };
    var wedgeDonut = {
        type: "radial",
        start: {
            x: 0,
            y: 0
        },
        stops: [[0, "rgba(255, 255, 255, 0.001)"], [.25, "rgba(255, 255, 255, 0.2)"], [.5, "rgba(255, 255, 255, 0.001)"], [.75, "rgba(255, 255, 255, 0.4)"], [1, "rgba(255, 255, 255, 0.001)"]]
    };
    var wedgeCylinder = {
        type: "radial",
        start: {
            x: 0,
            y: 0
        },
        stops: [[0, "rgba(0, 0, 0, 0.5)"], [.5, "rgba(0, 0, 0, 0.0)"], [1, "rgba(0, 0, 0, 0.5)"]]
    };
    var dotDarken = {
        type: "radial",
        start: {
            x: 0,
            y: 0
        },
        stops: [[0, "rgba(0, 0, 0, 0.3)"], [1, "rgba(0, 0, 0, 0.0)"]]
    };
    var dotLighten = {
        type: "radial",
        start: {
            x: 0,
            y: 0
        },
        stops: [[0, "rgba(255, 255, 255, 0.8)"], [.9, "rgba(255, 255, 255, 0.001)"]]
    };
    var barBevels = ["bevel", "cylinder", "lighten", "darken", "lightenInverted", "darkenInverted"];
    var wedgeBevels = ["bevel", "cylinder", "donut"];
    var dotBevels = ["lighten", "darken"];
    var areaBevels = ["darken"];
    var sceneTypeMap = {
        rect: "bar",
        arc: "wedge",
        circle: "wedge",
        area: "area"
    };
    function getMarkType(mark) {
        if (tdgchart.tdgscene.isTDGSceneMark(mark)) {
            var m = tdgchart.tdgscene.getMarkType(mark);
            return sceneTypeMap[m] || m
        } else {
            if (mark instanceof pv.Trapezoid)
                return "trapezoid";
            else if (mark instanceof pv.Bar)
                return "bar";
            else if (mark instanceof pv.Wedge)
                return "wedge";
            return "dot"
        }
    }
    function isValidBevel(markType, bevel) {
        if (markType === "trapezoid" || markType === "bar")
            return barBevels.includes(bevel);
        else if (markType === "wedge")
            return wedgeBevels.includes(bevel);
        else if (markType === "dot")
            return dotBevels.includes(bevel);
        else if (markType === "area")
            return areaBevels.includes(bevel);
        return false
    }
    function bevelWedgeGradient(riserBevel, ri, ro, xoff, yoff) {
        var newBevel;
        switch (riserBevel) {
        case "cylinder":
            newBevel = tdg.cloneObject(wedgeCylinder);
            if (ri > 0) {
                newBevel.stops[0][0] = ri / ro;
                newBevel.stops[1][0] = (ri + ro) / 2 / ro
            }
            break;
        case "donut":
            newBevel = tdg.cloneObject(wedgeDonut);
            if (ri > 0) {
                newBevel.stops.shift();
                newBevel.stops.shift();
                newBevel.stops[0][0] = ri / ro;
                newBevel.stops[1][0] = (ri + ro) / 2 / ro
            }
            break;
        case "bevel":
            newBevel = tdg.cloneObject(wedgeBevel);
            if (ri > 0) {
                newBevel.stops.unshift([ri / ro + .15, "rgba(0, 0, 0, 0)"]);
                newBevel.stops.unshift([ri / ro, "rgba(0, 0, 0, 0.4)"])
            }
            break
        }
        if (newBevel) {
            newBevel.radius = ro;
            if (xoff)
                newBevel.start.x += xoff;
            if (yoff)
                newBevel.start.y += yoff
        }
        return newBevel
    }
    function bevelBarGradient(riserBevel, isHorizontal, isPositive) {
        switch (riserBevel) {
        case "bevel":
            return isHorizontal ? barHBevel : barBevel;
        case "cylinder":
            return isHorizontal ? barHCylinder : barCylinder;
        case "lighten":
            return isHorizontal ? isPositive ? barLightenLeft : barLightenRight : isPositive ? barLightenUp : barLightenDown;
        case "darken":
            return isHorizontal ? isPositive ? barDarkenLeft : barDarkenRight : isPositive ? barDarkenUp : barDarkenDown;
        case "lightenInverted":
            return isHorizontal ? isPositive ? barLightenInvLeft : barLightenInvRight : isPositive ? barLightenInvUp : barLightenInvDown;
        case "darkenInverted":
            return isHorizontal ? isPositive ? barDarkenInvLeft : barDarkenInvRight : isPositive ? barDarkenInvUp : barDarkenInvDown
        }
        return null
    }
    function bevelDotGradient(riserBevel, radius) {
        var newBevel;
        switch (riserBevel) {
        case "darken":
            newBevel = tdg.cloneObject(dotDarken);
            break;
        case "lighten":
            newBevel = tdg.cloneObject(dotLighten);
            break
        }
        if (newBevel == null)
            return null;
        newBevel.radius = radius;
        newBevel.focalPoint = {
            x: -(radius * .45),
            y: -(radius * .45)
        };
        return newBevel
    }
    tdgchart.prototype.addBevel = function(mark, group, markTypeOverride) {
        var chart = this;
        if (!mark || !chart.riserBevel || chart.riserBevel === "none")
            return null;
        if (Array.isArray(mark)) {
            var groupStyle = {
                antialias: false
            };
            var bevelGroup = group.group("bevels", null, null, null, null, null, groupStyle);
            for (var s = 0; s < mark.length; s++)
                if (Array.isArray(mark[s])) {
                    var seriesGroup = bevelGroup.group();
                    for (var g = 0; g < mark[s].length; g++)
                        chart.addBevel(mark[s][g], seriesGroup)
                }
            return null
        }
        var markType = markTypeOverride || getMarkType(mark);
        if (!isValidBevel(markType, chart.riserBevel))
            return null;
        if (chart.depth25d() && chart.riserBevel !== "lighten" && chart.riserBevel !== "darken")
            return null;
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        if (chart.chartType === "funnel")
            isHorizontal = false;
        function barBevelLookup(parentMark) {
            return function(d) {
                var c = parentMark.fillStyle();
                if (c.color === "none" || !c.isVisible())
                    return null;
                var value = d.hasOwnProperty("y") ? d.y : d.value;
                return bevelBarGradient(chart.riserBevel, isHorizontal, value > 0)
            }
        }
        function wedgeBevelLookup(parentMark) {
            return function(d) {
                if (d.isDeleted || d.noLabel)
                    return null;
                var c = parentMark.fillStyle();
                if (c.color === "none" || !c.isVisible())
                    return null;
                return bevelWedgeGradient(chart.riserBevel, this.innerRadius(), this.outerRadius())
            }
        }
        function dotBevelLookup(parentMark) {
            return function() {
                var c = parentMark.fillStyle();
                if (c.color === "none")
                    return null;
                return bevelDotGradient(chart.riserBevel, this.radius())
            }
        }
        function classNameLookUp(parentMark) {
            return function() {
                var lookUpObject = chart.classNameToIds(parentMark.className());
                lookUpObject.misc = "bevel";
                return chart.buildClassName(lookUpObject)
            }
        }
        var bevel;
        if (tdgchart.tdgscene.isTDGSceneMark(mark)) {
            var bevelMark = mark.duplicate();
            var className = mark.getAttr("className");
            if (className != null) {
                var ids = chart.classNameToIds(className);
                ids.misc = "bevel";
                bevelMark.setAttr("className", chart.buildClassName(ids))
            }
            bevelMark.setAttr("id", null);
            bevelMark.setAttr("pointer-events", "none");
            var gradient, xy;
            switch (markType) {
            case "trapezoid":
            case "rect":
            case "bar":
                var d = mark.getClientData();
                var value = d && d.data ? d.data.hasOwnProperty("y") ? d.data.y : d.data.value : null;
                gradient = bevelBarGradient(chart.riserBevel, isHorizontal, value == null || value > 0);
                break;
            case "circle":
            case "arc":
            case "wedge":
                xy = mark.getPosition();
                gradient = bevelWedgeGradient(chart.riserBevel, mark.getInnerRadius(), mark.getRadius(), xy.x, xy.y);
                gradient.gradientUnits = "userSpaceOnUse";
                break;
            case "dot":
                xy = mark.getPosition();
                gradient = bevelDotGradient(chart.riserBevel, mark.getRadius());
                gradient.gradientUnits = "userSpaceOnUse";
                break;
            default:
                return null
            }
            if (gradient) {
                bevelMark.color(gradient);
                group.insertAfter(bevelMark, mark)
            }
        } else {
            switch (markType) {
            case "trapezoid":
                bevel = mark.add(pv.Trapezoid).fillStyle(barBevelLookup(mark));
                break;
            case "bar":
                bevel = mark.add(pv.Bar).fillStyle(barBevelLookup(mark));
                break;
            case "wedge":
                bevel = mark.add(pv.Wedge).fillStyle(wedgeBevelLookup(mark));
                break;
            case "dot":
                bevel = mark.add(pv.Dot).fillStyle(dotBevelLookup(mark));
                break
            }
            bevel.strokeStyle(null).events("none").shadow(null).title(null).className(classNameLookUp(mark))
        }
        return bevel
    }
}
)();
Date.CultureInfo = {
    name: "en-US",
    englishName: "English (United States)",
    nativeName: "English (United States)",
    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    abbreviatedDayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    shortestDayNames: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    firstLetterDayNames: ["S", "M", "T", "W", "T", "F", "S"],
    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    abbreviatedMonthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    amDesignator: "AM",
    pmDesignator: "PM",
    firstDayOfWeek: 0,
    twoDigitYearMax: 2029,
    dateElementOrder: "mdy",
    formatPatterns: {
        shortDate: "M/d/yyyy",
        longDate: "dddd, MMMM dd, yyyy",
        shortTime: "h:mm tt",
        longTime: "h:mm:ss tt",
        fullDateTime: "dddd, MMMM dd, yyyy h:mm:ss tt",
        sortableDateTime: "yyyy-MM-ddTHH:mm:ss",
        universalSortableDateTime: "yyyy-MM-dd HH:mm:ssZ",
        rfc1123: "ddd, dd MMM yyyy HH:mm:ss GMT",
        monthDay: "MMMM dd",
        yearMonth: "MMMM, yyyy"
    },
    regexPatterns: {
        jan: /^jan(uary)?/i,
        feb: /^feb(ruary)?/i,
        mar: /^mar(ch)?/i,
        apr: /^apr(il)?/i,
        may: /^may/i,
        jun: /^jun(e)?/i,
        jul: /^jul(y)?/i,
        aug: /^aug(ust)?/i,
        sep: /^sep(t(ember)?)?/i,
        oct: /^oct(ober)?/i,
        nov: /^nov(ember)?/i,
        dec: /^dec(ember)?/i,
        sun: /^su(n(day)?)?/i,
        mon: /^mo(n(day)?)?/i,
        tue: /^tu(e(s(day)?)?)?/i,
        wed: /^we(d(nesday)?)?/i,
        thu: /^th(u(r(s(day)?)?)?)?/i,
        fri: /^fr(i(day)?)?/i,
        sat: /^sa(t(urday)?)?/i,
        future: /^next/i,
        past: /^last|past|prev(ious)?/i,
        add: /^(\+|aft(er)?|from|hence)/i,
        subtract: /^(\-|bef(ore)?|ago)/i,
        yesterday: /^yes(terday)?/i,
        today: /^t(od(ay)?)?/i,
        tomorrow: /^tom(orrow)?/i,
        now: /^n(ow)?/i,
        millisecond: /^ms|milli(second)?s?/i,
        second: /^sec(ond)?s?/i,
        minute: /^mn|min(ute)?s?/i,
        hour: /^h(our)?s?/i,
        week: /^w(eek)?s?/i,
        month: /^m(onth)?s?/i,
        day: /^d(ay)?s?/i,
        year: /^y(ear)?s?/i,
        shortMeridian: /^(a|p)/i,
        longMeridian: /^(a\.?m?\.?|p\.?m?\.?)/i,
        timezone: /^((e(s|d)t|c(s|d)t|m(s|d)t|p(s|d)t)|((gmt)?\s*(\+|\-)\s*\d\d\d\d?)|gmt|utc)/i,
        ordinalSuffix: /^\s*(st|nd|rd|th)/i,
        timeContext: /^\s*(:|a(?!u|p)|p)/i
    },
    timezones: [{
        name: "UTC",
        offset: "-000"
    }, {
        name: "GMT",
        offset: "-000"
    }, {
        name: "EST",
        offset: "-0500"
    }, {
        name: "EDT",
        offset: "-0400"
    }, {
        name: "CST",
        offset: "-0600"
    }, {
        name: "CDT",
        offset: "-0500"
    }, {
        name: "MST",
        offset: "-0700"
    }, {
        name: "MDT",
        offset: "-0600"
    }, {
        name: "PST",
        offset: "-0800"
    }, {
        name: "PDT",
        offset: "-0700"
    }]
};
(function() {
    var $D = Date
      , $P = $D.prototype
      , $C = $D.CultureInfo
      , p = function(s, l) {
        if (!l)
            l = 2;
        return ("000" + s).slice(l * -1)
    };
    $P.clearTime = function() {
        this.setHours(0);
        this.setMinutes(0);
        this.setSeconds(0);
        this.setMilliseconds(0);
        return this
    }
    ;
    $P.setTimeToNow = function() {
        var n = new Date;
        this.setHours(n.getHours());
        this.setMinutes(n.getMinutes());
        this.setSeconds(n.getSeconds());
        this.setMilliseconds(n.getMilliseconds());
        return this
    }
    ;
    $D.today = function() {
        return (new Date).clearTime()
    }
    ;
    $D.compare = function(date1, date2) {
        if (isNaN(date1) || isNaN(date2))
            throw new Error(date1 + " - " + date2);
        else if (date1 instanceof Date && date2 instanceof Date)
            return date1 < date2 ? -1 : date1 > date2 ? 1 : 0;
        else
            throw new TypeError(date1 + " - " + date2);
    }
    ;
    $D.equals = function(date1, date2) {
        return date1.compareTo(date2) === 0
    }
    ;
    $D.getDayNumberFromName = function(name) {
        var n = $C.dayNames
          , m = $C.abbreviatedDayNames
          , o = $C.shortestDayNames
          , s = name.toLowerCase();
        for (var i = 0; i < n.length; i++)
            if (n[i].toLowerCase() == s || m[i].toLowerCase() == s || o[i].toLowerCase() == s)
                return i;
        return -1
    }
    ;
    $D.getMonthNumberFromName = function(name) {
        var n = $C.monthNames
          , m = $C.abbreviatedMonthNames
          , s = name.toLowerCase();
        for (var i = 0; i < n.length; i++)
            if (n[i].toLowerCase() == s || m[i].toLowerCase() == s)
                return i;
        return -1
    }
    ;
    $D.isLeapYear = function(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0
    }
    ;
    $D.getDaysInMonth = function(year, month) {
        return [31, $D.isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month]
    }
    ;
    $D.getTimezoneAbbreviation = function(offset) {
        var z = $C.timezones, p;
        for (var i = 0; i < z.length; i++)
            if (z[i].offset === offset)
                return z[i].name;
        return null
    }
    ;
    $D.getTimezoneOffset = function(name) {
        var z = $C.timezones, p;
        for (var i = 0; i < z.length; i++)
            if (z[i].name === name.toUpperCase())
                return z[i].offset;
        return null
    }
    ;
    $P.clone = function() {
        return new Date(this.getTime())
    }
    ;
    $P.compareTo = function(date) {
        return Date.compare(this, date)
    }
    ;
    $P.equals = function(date) {
        return Date.equals(this, date || new Date)
    }
    ;
    $P.between = function(start, end) {
        return this.getTime() >= start.getTime() && this.getTime() <= end.getTime()
    }
    ;
    $P.isAfter = function(date) {
        return this.compareTo(date || new Date) === 1
    }
    ;
    $P.isBefore = function(date) {
        return this.compareTo(date || new Date) === -1
    }
    ;
    $P.isToday = $P.isSameDay = function(date) {
        return this.clone().clearTime().equals((date || new Date).clone().clearTime())
    }
    ;
    $P.addMilliseconds = function(value) {
        this.setMilliseconds(this.getMilliseconds() + value * 1);
        return this
    }
    ;
    $P.addSeconds = function(value) {
        return this.addMilliseconds(value * 1E3)
    }
    ;
    $P.addMinutes = function(value) {
        return this.addMilliseconds(value * 6E4)
    }
    ;
    $P.addHours = function(value) {
        return this.addMilliseconds(value * 36E5)
    }
    ;
    $P.addDays = function(value) {
        this.setDate(this.getDate() + value * 1);
        return this
    }
    ;
    $P.addWeeks = function(value) {
        return this.addDays(value * 7)
    }
    ;
    $P.addMonths = function(value) {
        var n = this.getDate();
        this.setDate(1);
        this.setMonth(this.getMonth() + value * 1);
        this.setDate(Math.min(n, $D.getDaysInMonth(this.getFullYear(), this.getMonth())));
        return this
    }
    ;
    $P.addYears = function(value) {
        return this.addMonths(value * 12)
    }
    ;
    $P.add = function(config) {
        if (typeof config == "number") {
            this._orient = config;
            return this
        }
        var x = config;
        if (x.milliseconds)
            this.addMilliseconds(x.milliseconds);
        if (x.seconds)
            this.addSeconds(x.seconds);
        if (x.minutes)
            this.addMinutes(x.minutes);
        if (x.hours)
            this.addHours(x.hours);
        if (x.weeks)
            this.addWeeks(x.weeks);
        if (x.months)
            this.addMonths(x.months);
        if (x.years)
            this.addYears(x.years);
        if (x.days)
            this.addDays(x.days);
        return this
    }
    ;
    var $y, $m, $d;
    $P.getWeek = function() {
        var a, b, c, d, e, f, g, n, s, w;
        $y = !$y ? this.getFullYear() : $y;
        $m = !$m ? this.getMonth() + 1 : $m;
        $d = !$d ? this.getDate() : $d;
        if ($m <= 2) {
            a = $y - 1;
            b = (a / 4 | 0) - (a / 100 | 0) + (a / 400 | 0);
            c = ((a - 1) / 4 | 0) - ((a - 1) / 100 | 0) + ((a - 1) / 400 | 0);
            s = b - c;
            e = 0;
            f = $d - 1 + 31 * ($m - 1)
        } else {
            a = $y;
            b = (a / 4 | 0) - (a / 100 | 0) + (a / 400 | 0);
            c = ((a - 1) / 4 | 0) - ((a - 1) / 100 | 0) + ((a - 1) / 400 | 0);
            s = b - c;
            e = s + 1;
            f = $d + (153 * ($m - 3) + 2) / 5 + 58 + s
        }
        g = (a + b) % 7;
        d = (f + g - e) % 7;
        n = f + 3 - d | 0;
        if (n < 0)
            w = 53 - ((g - s) / 5 | 0);
        else if (n > 364 + s)
            w = 1;
        else
            w = (n / 7 | 0) + 1;
        $y = $m = $d = null;
        return w
    }
    ;
    $P.getISOWeek = function() {
        $y = this.getUTCFullYear();
        $m = this.getUTCMonth() + 1;
        $d = this.getUTCDate();
        return p(this.getWeek())
    }
    ;
    $P.setWeek = function(n) {
        return this.moveToDayOfWeek(1).addWeeks(n - this.getWeek())
    }
    ;
    $P.getQuarter = function() {
        return Math.floor(this.getMonth() / 3) + 1
    }
    ;
    $P.setQuarter = function(n) {
        this.setDate(1);
        this.setHours(0, 0, 0, 0);
        this.setMonth((n - 1) * 3)
    }
    ;
    var validate = function(n, min, max, name) {
        if (typeof n == "undefined")
            return false;
        else if (typeof n != "number")
            throw new TypeError(n + " is not a Number.");
        else if (n < min || n > max)
            throw new RangeError(n + " is not a valid value for " + name + ".");
        return true
    };
    $D.validateMillisecond = function(value) {
        return validate(value, 0, 999, "millisecond")
    }
    ;
    $D.validateSecond = function(value) {
        return validate(value, 0, 59, "second")
    }
    ;
    $D.validateMinute = function(value) {
        return validate(value, 0, 59, "minute")
    }
    ;
    $D.validateHour = function(value) {
        return validate(value, 0, 23, "hour")
    }
    ;
    $D.validateDay = function(value, year, month) {
        return validate(value, 1, $D.getDaysInMonth(year, month), "day")
    }
    ;
    $D.validateMonth = function(value) {
        return validate(value, 0, 11, "month")
    }
    ;
    $D.validateYear = function(value) {
        return validate(value, 0, 9999, "year")
    }
    ;
    $P.set = function(config) {
        if ($D.validateMillisecond(config.millisecond))
            this.addMilliseconds(config.millisecond - this.getMilliseconds());
        if ($D.validateSecond(config.second))
            this.addSeconds(config.second - this.getSeconds());
        if ($D.validateMinute(config.minute))
            this.addMinutes(config.minute - this.getMinutes());
        if ($D.validateHour(config.hour))
            this.addHours(config.hour - this.getHours());
        if ($D.validateMonth(config.month))
            this.addMonths(config.month - this.getMonth());
        if ($D.validateYear(config.year))
            this.addYears(config.year - this.getFullYear());
        if ($D.validateDay(config.day, this.getFullYear(), this.getMonth()))
            this.addDays(config.day - this.getDate());
        if (config.timezone)
            this.setTimezone(config.timezone);
        if (config.timezoneOffset)
            this.setTimezoneOffset(config.timezoneOffset);
        if (config.week && validate(config.week, 0, 53, "week"))
            this.setWeek(config.week);
        return this
    }
    ;
    $P.moveToFirstDayOfMonth = function() {
        return this.set({
            day: 1
        })
    }
    ;
    $P.moveToLastDayOfMonth = function() {
        return this.set({
            day: $D.getDaysInMonth(this.getFullYear(), this.getMonth())
        })
    }
    ;
    $P.moveToNthOccurrence = function(dayOfWeek, occurrence) {
        var shift = 0;
        if (occurrence > 0)
            shift = occurrence - 1;
        else if (occurrence === -1) {
            this.moveToLastDayOfMonth();
            if (this.getDay() !== dayOfWeek)
                this.moveToDayOfWeek(dayOfWeek, -1);
            return this
        }
        return this.moveToFirstDayOfMonth().addDays(-1).moveToDayOfWeek(dayOfWeek, +1).addWeeks(shift)
    }
    ;
    $P.moveToDayOfWeek = function(dayOfWeek, orient) {
        var diff = (dayOfWeek - this.getDay() + 7 * (orient || +1)) % 7;
        return this.addDays(diff === 0 ? diff += 7 * (orient || +1) : diff)
    }
    ;
    $P.moveToMonth = function(month, orient) {
        var diff = (month - this.getMonth() + 12 * (orient || +1)) % 12;
        return this.addMonths(diff === 0 ? diff += 12 * (orient || +1) : diff)
    }
    ;
    $P.getOrdinalNumber = function() {
        return Math.ceil((this.clone().clearTime() - new Date(this.getFullYear(),0,1)) / 864E5) + 1
    }
    ;
    $P.getTimezone = function() {
        return $D.getTimezoneAbbreviation(this.getUTCOffset())
    }
    ;
    $P.setTimezoneOffset = function(offset) {
        var here = this.getTimezoneOffset()
          , there = Number(offset) * -6 / 10;
        return this.addMinutes(there - here)
    }
    ;
    $P.setTimezone = function(offset) {
        return this.setTimezoneOffset($D.getTimezoneOffset(offset))
    }
    ;
    $P.hasDaylightSavingTime = function() {
        return Date.today().set({
            month: 0,
            day: 1
        }).getTimezoneOffset() !== Date.today().set({
            month: 6,
            day: 1
        }).getTimezoneOffset()
    }
    ;
    $P.isDaylightSavingTime = function() {
        return Date.today().set({
            month: 0,
            day: 1
        }).getTimezoneOffset() != this.getTimezoneOffset()
    }
    ;
    $P.getUTCOffset = function() {
        var n = this.getTimezoneOffset() * -10 / 6, r;
        if (n < 0) {
            r = (n - 1E4).toString();
            return r.charAt(0) + r.substr(2)
        } else {
            r = (n + 1E4).toString();
            return "+" + r.substr(1)
        }
    }
    ;
    $P.getElapsed = function(date) {
        return (date || new Date) - this
    }
    ;
    if (!$P.toISOString)
        $P.toISOString = function() {
            function f(n) {
                return n < 10 ? "0" + n : n
            }
            return '"' + this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + 'Z"'
        }
        ;
    if ($P._toString == null)
        $P._toString = $P.toString;
    var formatTokens = /(\\)?(DD?D?D?o?|dd?d?d?o?|MM?M?M?o?|YY?Y?Y?|yy?y?y?|GG?G?G?|gg?g?g?|hh?|HH?|mm?|ss?|tt?|S|QQ?o?|A|a|kk?|X|x|e|E|ww?o?|WW?o?|zz?|ZZ?)/g;
    $P.toString = function(format) {
        var x = this;
        if (format && format.length == 1) {
            var c = $C.formatPatterns;
            x.t = x.toString;
            switch (format) {
            case "d":
                return x.t(c.shortDate);
            case "D":
                return x.t(c.longDate);
            case "F":
                return x.t(c.fullDateTime);
            case "m":
                return x.t(c.monthDay);
            case "r":
                return x.t(c.rfc1123);
            case "s":
                return x.t(c.sortableDateTime);
            case "t":
                return x.t(c.shortTime);
            case "T":
                return x.t(c.longTime);
            case "u":
                return x.t(c.universalSortableDateTime);
            case "y":
                return x.t(c.yearMonth)
            }
        }
        var ord = function(n) {
            switch (n % 10) {
            case 1:
                return "st";
            case 2:
                return "nd";
            case 3:
                return "rd";
            default:
                return "th"
            }
        };
        return format ? format.replace(formatTokens, function(m) {
            if (m.charAt(0) === "\\")
                return m.replace("\\", "");
            x.h = x.getHours;
            switch (m) {
            case "hh":
                return p(x.h() < 13 ? x.h() === 0 ? 12 : x.h() : x.h() - 12);
            case "h":
                return x.h() < 13 ? x.h() === 0 ? 12 : x.h() : x.h() - 12;
            case "HH":
                return p(x.h());
            case "kk":
                return p(x.h() + 1);
            case "H":
                return x.h();
            case "k":
                return x.h() + 1;
            case "mm":
                return p(x.getMinutes());
            case "m":
                return x.getMinutes();
            case "ss":
                return p(x.getSeconds());
            case "s":
                return x.getSeconds();
            case "gggg":
            case "GGGG":
            case "YYYY":
            case "yyyy":
                return p(x.getFullYear(), 4);
            case "gg":
            case "GG":
            case "YY":
            case "yy":
                return p(x.getFullYear());
            case "e":
            case "d":
                return x.getDay();
            case "E":
                return x.getDay() + 1;
            case "do":
                return x.getDay() + ord(x.getDay());
            case "dd":
                return $C.shortestDayNames[x.getDay()];
            case "ddd":
                return $C.abbreviatedDayNames[x.getDay()];
            case "dddd":
                return $C.dayNames[x.getDay()];
            case "DDD":
                return x.getOrdinalNumber();
            case "DDDD":
                return p(x.getOrdinalNumber(), 3);
            case "DDDo":
                return x.getOrdinalNumber() + ord(x.getOrdinalNumber());
            case "DD":
                return p(x.getDate());
            case "D":
                return x.getDate();
            case "Do":
                return x.getDate() + ord(x.getDate());
            case "MMMM":
                return $C.monthNames[x.getMonth()];
            case "MMM":
                return $C.abbreviatedMonthNames[x.getMonth()];
            case "MM":
                return p(x.getMonth() + 1);
            case "Mo":
                return x.getMonth() + 1 + ord(x.getMonth() + 1);
            case "M":
                return x.getMonth() + 1;
            case "w":
                return x.getWeek();
            case "wo":
                return x.getWeek() + ord(x.getWeek());
            case "ww":
                return p(x.getWeek());
            case "W":
                return x.getISOWeek();
            case "Wo":
                return x.getISOWeek() + ord(x.getISOWeek());
            case "WW":
                return p(x.getISOWeek());
            case "t":
                return x.h() < 12 ? $C.amDesignator.substring(0, 1) : $C.pmDesignator.substring(0, 1);
            case "tt":
                return x.h() < 12 ? $C.amDesignator : $C.pmDesignator;
            case "A":
                return x.h() < 12 ? $C.amDesignator : $C.pmDesignator;
            case "a":
                return (x.h() < 12 ? $C.amDesignator : $C.pmDesignator).toLowerCase();
            case "S":
                return ord(x.getDate());
            case "Q":
                return x.getQuarter();
            case "Qo":
                return x.getQuarter() + ord(x.getQuarter());
            case "QQ":
                return "Q" + x.getQuarter();
            case "X":
                return Math.floor(x.valueOf() / 1E3);
            case "x":
                return x.valueOf();
            default:
                return m
            }
        }) : this._toString()
    }
}
)();
(function() {
    var $D = Date
      , $P = $D.prototype
      , $C = $D.CultureInfo
      , $f = []
      , p = function(s, l) {
        if (!l)
            l = 2;
        return ("000" + s).slice(l * -1)
    };
    $D.normalizeFormat = function(format) {
        $f = [];
        var t = (new Date).$format(format);
        return $f.join("")
    }
    ;
    $D.strftime = function(format, time) {
        return (new Date(time * 1E3)).$format(format)
    }
    ;
    $D.strtotime = function(time) {
        var d = $D.parse(time);
        d.addMinutes(d.getTimezoneOffset() * -1);
        return Math.round($D.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds()) / 1E3)
    }
    ;
    $P.$format = function(format) {
        var x = this, y, t = function(v) {
            $f.push(v);
            return x.toString(v)
        };
        return format ? format.replace(/(%|\\)?.|%%/g, function(m) {
            if (m.charAt(0) === "\\" || m.substring(0, 2) === "%%")
                return m.replace("\\", "").replace("%%", "%");
            switch (m) {
            case "d":
            case "%d":
                return t("dd");
            case "D":
            case "%a":
                return t("ddd");
            case "j":
            case "%e":
                return t("d");
            case "l":
            case "%A":
                return t("dddd");
            case "N":
            case "%u":
                return x.getDay() + 1;
            case "S":
                return t("S");
            case "w":
            case "%w":
                return x.getDay();
            case "z":
                return x.getOrdinalNumber();
            case "%j":
                return p(x.getOrdinalNumber(), 3);
            case "%U":
                var d1 = x.clone().set({
                    month: 0,
                    day: 1
                }).addDays(-1).moveToDayOfWeek(0)
                  , d2 = x.clone().addDays(1).moveToDayOfWeek(0, -1);
                return d2 < d1 ? "00" : p((d2.getOrdinalNumber() - d1.getOrdinalNumber()) / 7 + 1);
            case "W":
            case "%V":
                return x.getISOWeek();
            case "%W":
                return p(x.getWeek());
            case "F":
            case "%B":
                return t("MMMM");
            case "m":
            case "%m":
                return t("MM");
            case "M":
            case "%b":
            case "%h":
                return t("MMM");
            case "n":
                return t("M");
            case "t":
                return $D.getDaysInMonth(x.getFullYear(), x.getMonth());
            case "L":
                return $D.isLeapYear(x.getFullYear()) ? 1 : 0;
            case "o":
            case "%G":
                return x.setWeek(x.getISOWeek()).toString("yyyy");
            case "%g":
                return x.$format("%G").slice(-2);
            case "Y":
            case "%Y":
                return t("yyyy");
            case "y":
            case "%y":
                return t("yy");
            case "a":
            case "%p":
                return t("tt").toLowerCase();
            case "A":
                return t("tt").toUpperCase();
            case "g":
            case "%I":
                return t("h");
            case "G":
                return t("H");
            case "h":
                return t("hh");
            case "H":
            case "%H":
                return t("HH");
            case "i":
            case "%M":
                return t("mm");
            case "s":
            case "%S":
                return t("ss");
            case "u":
                return p(x.getMilliseconds(), 3);
            case "I":
                return x.isDaylightSavingTime() ? 1 : 0;
            case "O":
                return x.getUTCOffset();
            case "P":
                y = x.getUTCOffset();
                return y.substring(0, y.length - 2) + ":" + y.substring(y.length - 2);
            case "e":
            case "T":
            case "%z":
            case "%Z":
                return x.getTimezone();
            case "Z":
                return x.getTimezoneOffset() * -60;
            case "B":
                var now = new Date;
                return Math.floor((now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds() + (now.getTimezoneOffset() + 60) * 60) / 86.4);
            case "c":
                return x.toISOString().replace(/"/g, "");
            case "U":
                return $D.strtotime("now");
            case "%c":
                return t("d") + " " + t("t");
            case "%C":
                return Math.floor(x.getFullYear() / 100 + 1);
            case "%D":
                return t("MM/dd/yy");
            case "%n":
                return "\\n";
            case "%t":
                return "\\t";
            case "%r":
                return t("hh:mm tt");
            case "%R":
                return t("H:mm");
            case "%T":
                return t("H:mm:ss");
            case "%x":
                return t("d");
            case "%X":
                return t("t");
            default:
                $f.push(m);
                return m
            }
        }) : this._toString()
    }
    ;
    if (!$P.format)
        $P.format = $P.$format
}
)();
(function() {
    var $D = Date
      , $P = $D.prototype
      , $C = $D.CultureInfo
      , $N = Number.prototype;
    $P._orient = +1;
    $P._nth = null;
    $P._is = false;
    $P._same = false;
    $P._isSecond = false;
    $N._dateElement = "day";
    $P.next = function() {
        this._orient = +1;
        return this
    }
    ;
    $D.next = function() {
        return $D.today().next()
    }
    ;
    $P.last = $P.prev = $P.previous = function() {
        this._orient = -1;
        return this
    }
    ;
    $D.last = $D.prev = $D.previous = function() {
        return $D.today().last()
    }
    ;
    $P.is = function() {
        this._is = true;
        return this
    }
    ;
    $P.same = function() {
        this._same = true;
        this._isSecond = false;
        return this
    }
    ;
    $P.today = function() {
        return this.same().day()
    }
    ;
    $P.weekday = function() {
        if (this._is) {
            this._is = false;
            return !this.is().sat() && !this.is().sun()
        }
        return false
    }
    ;
    $P.at = function(time) {
        return typeof time === "string" ? $D.parse(this.toString("d") + " " + time) : this.set(time)
    }
    ;
    $N.fromNow = $N.after = function(date) {
        var c = {};
        c[this._dateElement] = this;
        return (!date ? new Date : date.clone()).add(c)
    }
    ;
    $N.ago = $N.before = function(date) {
        var c = {};
        c[this._dateElement] = this * -1;
        return (!date ? new Date : date.clone()).add(c)
    }
    ;
    var dx = "sunday monday tuesday wednesday thursday friday saturday".split(/\s/), mx = "january february march april may june july august september october november december".split(/\s/), px = "Millisecond Second Minute Hour Day Week Month Year".split(/\s/), pxf = "Milliseconds Seconds Minutes Hours Date Week Month FullYear".split(/\s/), nth = "final first second third fourth fifth".split(/\s/), de;
    $P.toObject = function() {
        var o = {};
        for (var i = 0; i < px.length; i++)
            o[px[i].toLowerCase()] = this["get" + pxf[i]]();
        return o
    }
    ;
    $D.fromObject = function(config) {
        config.week = null;
        return Date.today().set(config)
    }
    ;
    var df = function(n) {
        return function() {
            if (this._is) {
                this._is = false;
                return this.getDay() == n
            }
            if (this._nth !== null) {
                if (this._isSecond)
                    this.addSeconds(this._orient * -1);
                this._isSecond = false;
                var ntemp = this._nth;
                this._nth = null;
                var temp = this.clone().moveToLastDayOfMonth();
                this.moveToNthOccurrence(n, ntemp);
                if (this > temp)
                    throw new RangeError($D.getDayName(n) + " does not occur " + ntemp + " times in the month of " + $D.getMonthName(temp.getMonth()) + " " + temp.getFullYear() + ".");
                return this
            }
            return this.moveToDayOfWeek(n, this._orient)
        }
    };
    var sdf = function(n) {
        return function() {
            var t = $D.today()
              , shift = n - t.getDay();
            if (n === 0 && $C.firstDayOfWeek === 1 && t.getDay() !== 0)
                shift = shift + 7;
            return t.addDays(shift)
        }
    };
    for (var i = 0; i < dx.length; i++) {
        $D[dx[i].toUpperCase()] = $D[dx[i].toUpperCase().substring(0, 3)] = i;
        $D[dx[i]] = $D[dx[i].substring(0, 3)] = sdf(i);
        $P[dx[i]] = $P[dx[i].substring(0, 3)] = df(i)
    }
    var mf = function(n) {
        return function() {
            if (this._is) {
                this._is = false;
                return this.getMonth() === n
            }
            return this.moveToMonth(n, this._orient)
        }
    };
    var smf = function(n) {
        return function() {
            return $D.today().set({
                month: n,
                day: 1
            })
        }
    };
    for (var j = 0; j < mx.length; j++) {
        $D[mx[j].toUpperCase()] = $D[mx[j].toUpperCase().substring(0, 3)] = j;
        $D[mx[j]] = $D[mx[j].substring(0, 3)] = smf(j);
        $P[mx[j]] = $P[mx[j].substring(0, 3)] = mf(j)
    }
    var ef = function(j) {
        return function() {
            if (this._isSecond) {
                this._isSecond = false;
                return this
            }
            if (this._same) {
                this._same = this._is = false;
                var o1 = this.toObject()
                  , o2 = (arguments[0] || new Date).toObject()
                  , v = ""
                  , k = j.toLowerCase();
                for (var m = px.length - 1; m > -1; m--) {
                    v = px[m].toLowerCase();
                    if (o1[v] != o2[v])
                        return false;
                    if (k == v)
                        break
                }
                return true
            }
            if (j.substring(j.length - 1) != "s")
                j += "s";
            return this["add" + j](this._orient)
        }
    };
    var nf = function(n) {
        return function() {
            this._dateElement = n;
            return this
        }
    };
    for (var k = 0; k < px.length; k++) {
        de = px[k].toLowerCase();
        $P[de] = $P[de + "s"] = ef(px[k]);
        $N[de] = $N[de + "s"] = nf(de)
    }
    $P._ss = ef("Second");
    var nthfn = function(n) {
        return function(dayOfWeek) {
            if (this._same)
                return this._ss(arguments[0]);
            if (dayOfWeek || dayOfWeek === 0)
                return this.moveToNthOccurrence(dayOfWeek, n);
            this._nth = n;
            if (n === 2 && (dayOfWeek === undefined || dayOfWeek === null)) {
                this._isSecond = true;
                return this.addSeconds(this._orient)
            }
            return this
        }
    };
    for (var l = 0; l < nth.length; l++)
        $P[nth[l]] = l === 0 ? nthfn(-1) : nthfn(l)
}
)();
(function() {
    Date.Parsing = {
        Exception: function(s) {
            this.message = "Parse error at '" + s.substring(0, 10) + " ...'"
        }
    };
    var $P = Date.Parsing;
    var _ = $P.Operators = {
        rtoken: function(r) {
            return function(s) {
                var mx = s.match(r);
                if (mx)
                    return [mx[0], s.substring(mx[0].length)];
                else
                    throw new $P.Exception(s);
            }
        },
        token: function(s) {
            return function(s) {
                return _.rtoken(new RegExp("^s*" + s + "s*"))(s)
            }
        },
        stoken: function(s) {
            return _.rtoken(new RegExp("^" + s))
        },
        until: function(p) {
            return function(s) {
                var qx = []
                  , rx = null;
                while (s.length) {
                    try {
                        rx = p.call(this, s)
                    } catch (e$13) {
                        qx.push(rx[0]);
                        s = rx[1];
                        continue
                    }
                    break
                }
                return [qx, s]
            }
        },
        many: function(p) {
            return function(s) {
                var rx = []
                  , r = null;
                while (s.length) {
                    try {
                        r = p.call(this, s)
                    } catch (e$14) {
                        return [rx, s]
                    }
                    rx.push(r[0]);
                    s = r[1]
                }
                return [rx, s]
            }
        },
        optional: function(p) {
            return function(s) {
                var r = null;
                try {
                    r = p.call(this, s)
                } catch (e$15) {
                    return [null, s]
                }
                return [r[0], r[1]]
            }
        },
        not: function(p) {
            return function(s) {
                try {
                    p.call(this, s)
                } catch (e$16) {
                    return [null, s]
                }
                throw new $P.Exception(s);
            }
        },
        ignore: function(p) {
            return p ? function(s) {
                var r = null;
                r = p.call(this, s);
                return [null, r[1]]
            }
            : null
        },
        product: function() {
            var px = arguments[0]
              , qx = Array.prototype.slice.call(arguments, 1)
              , rx = [];
            for (var i = 0; i < px.length; i++)
                rx.push(_.each(px[i], qx));
            return rx
        },
        cache: function(rule) {
            var cache = {}
              , r = null;
            return function(s) {
                try {
                    r = cache[s] = cache[s] || rule.call(this, s)
                } catch (e$17) {
                    r = cache[s] = e$17
                }
                if (r instanceof $P.Exception)
                    throw r;
                else
                    return r
            }
        },
        any: function() {
            var px = arguments;
            return function(s) {
                var r = null;
                for (var i = 0; i < px.length; i++) {
                    if (px[i] == null)
                        continue;
                    try {
                        r = px[i].call(this, s)
                    } catch (e$18) {
                        r = null
                    }
                    if (r)
                        return r
                }
                throw new $P.Exception(s);
            }
        },
        each: function() {
            var px = arguments;
            return function(s) {
                var rx = []
                  , r = null;
                for (var i = 0; i < px.length; i++) {
                    if (px[i] == null)
                        continue;
                    try {
                        r = px[i].call(this, s)
                    } catch (e$19) {
                        throw new $P.Exception(s);
                    }
                    rx.push(r[0]);
                    s = r[1]
                }
                return [rx, s]
            }
        },
        all: function() {
            var px = arguments
              , _ = _;
            return _.each(_.optional(px))
        },
        sequence: function(px, d, c) {
            d = d || _.rtoken(/^\s*/);
            c = c || null;
            if (px.length == 1)
                return px[0];
            return function(s) {
                var r = null
                  , q = null;
                var rx = [];
                for (var i = 0; i < px.length; i++) {
                    try {
                        r = px[i].call(this, s)
                    } catch (e$20) {
                        break
                    }
                    rx.push(r[0]);
                    try {
                        q = d.call(this, r[1])
                    } catch (ex) {
                        q = null;
                        break
                    }
                    s = q[1]
                }
                if (!r)
                    throw new $P.Exception(s);
                if (q)
                    throw new $P.Exception(q[1]);
                if (c)
                    try {
                        r = c.call(this, r[1])
                    } catch (ey) {
                        throw new $P.Exception(r[1]);
                    }
                return [rx, r ? r[1] : s]
            }
        },
        between: function(d1, p, d2) {
            d2 = d2 || d1;
            var _fn = _.each(_.ignore(d1), p, _.ignore(d2));
            return function(s) {
                var rx = _fn.call(this, s);
                return [[rx[0][0], rx[0][2]], rx[1]]
            }
        },
        list: function(p, d, c) {
            d = d || _.rtoken(/^\s*/);
            c = c || null;
            return p instanceof Array ? _.each(_.product(p.slice(0, -1), _.ignore(d)), p.slice(-1), _.ignore(c)) : _.each(_.many(_.each(p, _.ignore(d))), p, _.ignore(c))
        },
        set: function(px, d, c) {
            d = d || _.rtoken(/^\s*/);
            c = c || null;
            return function(s) {
                var r = null
                  , p = null
                  , q = null
                  , rx = null
                  , best = [[], s]
                  , last = false;
                for (var i = 0; i < px.length; i++) {
                    q = null;
                    p = null;
                    r = null;
                    last = px.length == 1;
                    try {
                        r = px[i].call(this, s)
                    } catch (e$21) {
                        continue
                    }
                    rx = [[r[0]], r[1]];
                    if (r[1].length > 0 && !last)
                        try {
                            q = d.call(this, r[1])
                        } catch (ex) {
                            last = true
                        }
                    else
                        last = true;
                    if (!last && q[1].length === 0)
                        last = true;
                    if (!last) {
                        var qx = [];
                        for (var j = 0; j < px.length; j++)
                            if (i != j)
                                qx.push(px[j]);
                        p = _.set(qx, d).call(this, q[1]);
                        if (p[0].length > 0) {
                            rx[0] = rx[0].concat(p[0]);
                            rx[1] = p[1]
                        }
                    }
                    if (rx[1].length < best[1].length)
                        best = rx;
                    if (best[1].length === 0)
                        break
                }
                if (best[0].length === 0)
                    return best;
                if (c) {
                    try {
                        q = c.call(this, best[1])
                    } catch (ey) {
                        throw new $P.Exception(best[1]);
                    }
                    best[1] = q[1]
                }
                return best
            }
        },
        forward: function(gr, fname) {
            return function(s) {
                return gr[fname].call(this, s)
            }
        },
        replace: function(rule, repl) {
            return function(s) {
                var r = rule.call(this, s);
                return [repl, r[1]]
            }
        },
        process: function(rule, fn) {
            return function(s) {
                var r = rule.call(this, s);
                return [fn.call(this, r[0]), r[1]]
            }
        },
        min: function(min, rule) {
            return function(s) {
                var rx = rule.call(this, s);
                if (rx[0].length < min)
                    throw new $P.Exception(s);
                return rx
            }
        }
    };
    var _generator = function(op) {
        return function() {
            var args = null
              , rx = [];
            if (arguments.length > 1)
                args = Array.prototype.slice.call(arguments);
            else if (arguments[0]instanceof Array)
                args = arguments[0];
            if (args) {
                for (var i = 0, px = args.shift(); i < px.length; i++) {
                    args.unshift(px[i]);
                    rx.push(op.apply(null, args));
                    args.shift()
                }
                return rx
            } else
                return op.apply(null, arguments)
        }
    };
    var gx = "optional not ignore cache".split(/\s/);
    for (var i = 0; i < gx.length; i++)
        _[gx[i]] = _generator(_[gx[i]]);
    var _vector = function(op) {
        return function() {
            if (arguments[0]instanceof Array)
                return op.apply(null, arguments[0]);
            else
                return op.apply(null, arguments)
        }
    };
    var vx = "each any all".split(/\s/);
    for (var j = 0; j < vx.length; j++)
        _[vx[j]] = _vector(_[vx[j]])
}
)();
(function() {
    var $D = Date
      , $P = $D.prototype
      , $C = $D.CultureInfo;
    var flattenAndCompact = function(ax) {
        var rx = [];
        for (var i = 0; i < ax.length; i++)
            if (ax[i]instanceof Array)
                rx = rx.concat(flattenAndCompact(ax[i]));
            else if (ax[i])
                rx.push(ax[i]);
        return rx
    };
    $D.Grammar = {};
    $D.Translator = {
        hour: function(s) {
            return function() {
                this.hour = Number(s)
            }
        },
        minute: function(s) {
            return function() {
                this.minute = Number(s)
            }
        },
        second: function(s) {
            return function() {
                this.second = Number(s)
            }
        },
        meridian: function(s) {
            return function() {
                this.meridian = s.slice(0, 1).toLowerCase()
            }
        },
        timezone: function(s) {
            return function() {
                var n = s.replace(/[^\d\+\-]/g, "");
                if (n.length)
                    this.timezoneOffset = Number(n);
                else
                    this.timezone = s.toLowerCase()
            }
        },
        day: function(x) {
            var s = x[0];
            return function() {
                this.day = Number(s.match(/\d+/)[0])
            }
        },
        month: function(s) {
            return function() {
                this.month = s.length == 3 ? "jan feb mar apr may jun jul aug sep oct nov dec".indexOf(s) / 4 : Number(s) - 1
            }
        },
        year: function(s) {
            return function() {
                var n = Number(s);
                this.year = s.length > 2 ? n : n + (n + 2E3 < $C.twoDigitYearMax ? 2E3 : 1900)
            }
        },
        rday: function(s) {
            return function() {
                switch (s) {
                case "yesterday":
                    this.days = -1;
                    break;
                case "tomorrow":
                    this.days = 1;
                    break;
                case "today":
                    this.days = 0;
                    break;
                case "now":
                    this.days = 0;
                    this.now = true;
                    break
                }
            }
        },
        finishExact: function(x) {
            x = x instanceof Array ? x : [x];
            for (var i = 0; i < x.length; i++)
                if (x[i])
                    x[i].call(this);
            var now = new Date;
            if ((this.hour || this.minute) && (!this.month && !this.year && !this.day))
                this.day = now.getDate();
            if (!this.year)
                this.year = now.getFullYear();
            if (!this.month && this.month !== 0)
                this.month = now.getMonth();
            if (!this.day)
                this.day = 1;
            if (!this.hour)
                this.hour = 0;
            if (!this.minute)
                this.minute = 0;
            if (!this.second)
                this.second = 0;
            if (this.meridian && this.hour)
                if (this.meridian == "p" && this.hour < 12)
                    this.hour = this.hour + 12;
                else if (this.meridian == "a" && this.hour == 12)
                    this.hour = 0;
            if (this.day > $D.getDaysInMonth(this.year, this.month))
                throw new RangeError(this.day + " is not a valid value for days.");
            var r = new Date(this.year,this.month,this.day,this.hour,this.minute,this.second);
            if (this.timezone)
                r.set({
                    timezone: this.timezone
                });
            else if (this.timezoneOffset)
                r.set({
                    timezoneOffset: this.timezoneOffset
                });
            return r
        },
        finish: function(x) {
            x = x instanceof Array ? flattenAndCompact(x) : [x];
            if (x.length === 0)
                return null;
            for (var i = 0; i < x.length; i++)
                if (typeof x[i] == "function")
                    x[i].call(this);
            var today = $D.today();
            if (this.now && !this.unit && !this.operator)
                return new Date;
            else if (this.now)
                today = new Date;
            var expression = !!(this.days && this.days !== null || this.orient || this.operator);
            var gap, mod, orient;
            orient = this.orient == "past" || this.operator == "subtract" ? -1 : 1;
            if (!this.now && "hour minute second".indexOf(this.unit) != -1)
                today.setTimeToNow();
            if (this.month || this.month === 0)
                if ("year day hour minute second".indexOf(this.unit) != -1) {
                    this.value = this.month + 1;
                    this.month = null;
                    expression = true
                }
            if (!expression && this.weekday && !this.day && !this.days) {
                var temp = Date[this.weekday]();
                this.day = temp.getDate();
                if (!this.month)
                    this.month = temp.getMonth();
                this.year = temp.getFullYear()
            }
            if (expression && this.weekday && this.unit != "month") {
                this.unit = "day";
                gap = $D.getDayNumberFromName(this.weekday) - today.getDay();
                mod = 7;
                this.days = gap ? (gap + orient * mod) % mod : orient * mod
            }
            if (this.month && this.unit == "day" && this.operator) {
                this.value = this.month + 1;
                this.month = null
            }
            if (this.value != null && this.month != null && this.year != null)
                this.day = this.value * 1;
            if (this.month && !this.day && this.value) {
                today.set({
                    day: this.value * 1
                });
                if (!expression)
                    this.day = this.value * 1
            }
            if (!this.month && this.value && this.unit == "month" && !this.now) {
                this.month = this.value;
                expression = true
            }
            if (expression && (this.month || this.month === 0) && this.unit != "year") {
                this.unit = "month";
                gap = this.month - today.getMonth();
                mod = 12;
                this.months = gap ? (gap + orient * mod) % mod : orient * mod;
                this.month = null
            }
            if (!this.unit)
                this.unit = "day";
            if (!this.value && this.operator && this.operator !== null && this[this.unit + "s"] && this[this.unit + "s"] !== null)
                this[this.unit + "s"] = this[this.unit + "s"] + (this.operator == "add" ? 1 : -1) + (this.value || 0) * orient;
            else if (this[this.unit + "s"] == null || this.operator != null) {
                if (!this.value)
                    this.value = 1;
                this[this.unit + "s"] = this.value * orient
            }
            if (this.meridian && this.hour)
                if (this.meridian == "p" && this.hour < 12)
                    this.hour = this.hour + 12;
                else if (this.meridian == "a" && this.hour == 12)
                    this.hour = 0;
            if (this.weekday && !this.day && !this.days) {
                var temp = Date[this.weekday]();
                this.day = temp.getDate();
                if (temp.getMonth() !== today.getMonth())
                    this.month = temp.getMonth()
            }
            if ((this.month || this.month === 0) && !this.day)
                this.day = 1;
            if (!this.orient && !this.operator && this.unit == "week" && this.value && !this.day && !this.month)
                return Date.today().setWeek(this.value);
            if (expression && this.timezone && this.day && this.days)
                this.day = this.days;
            return expression ? today.add(this) : today.set(this)
        }
    };
    var _ = $D.Parsing.Operators, g = $D.Grammar, t = $D.Translator, _fn;
    g.datePartDelimiter = _.rtoken(/^([\s\-\.,\/\x27]+)/);
    g.timePartDelimiter = _.stoken(":");
    g.whiteSpace = _.rtoken(/^\s*/);
    g.generalDelimiter = _.rtoken(/^(([\s,]|at|@|on)+)/);
    var _C = {};
    g.ctoken = function(keys) {
        var fn = _C[keys];
        if (!fn) {
            var c = $C.regexPatterns;
            var kx = keys.split(/\s+/)
              , px = [];
            for (var i = 0; i < kx.length; i++)
                px.push(_.replace(_.rtoken(c[kx[i]]), kx[i]));
            fn = _C[keys] = _.any.apply(null, px)
        }
        return fn
    }
    ;
    g.ctoken2 = function(key) {
        return _.rtoken($C.regexPatterns[key])
    }
    ;
    g.h = _.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2]|[1-9])/), t.hour));
    g.hh = _.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2])/), t.hour));
    g.H = _.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3]|[0-9])/), t.hour));
    g.HH = _.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3])/), t.hour));
    g.m = _.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/), t.minute));
    g.mm = _.cache(_.process(_.rtoken(/^[0-5][0-9]/), t.minute));
    g.s = _.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/), t.second));
    g.ss = _.cache(_.process(_.rtoken(/^[0-5][0-9]/), t.second));
    g.hms = _.cache(_.sequence([g.H, g.m, g.s], g.timePartDelimiter));
    g.t = _.cache(_.process(g.ctoken2("shortMeridian"), t.meridian));
    g.tt = _.cache(_.process(g.ctoken2("longMeridian"), t.meridian));
    g.z = _.cache(_.process(_.rtoken(/^((\+|\-)\s*\d\d\d\d)|((\+|\-)\d\d:?\d\d)/), t.timezone));
    g.zz = _.cache(_.process(_.rtoken(/^((\+|\-)\s*\d\d\d\d)|((\+|\-)\d\d:?\d\d)/), t.timezone));
    g.zzz = _.cache(_.process(g.ctoken2("timezone"), t.timezone));
    g.timeSuffix = _.each(_.ignore(g.whiteSpace), _.set([g.tt, g.zzz]));
    g.time = _.each(_.optional(_.ignore(_.stoken("T"))), g.hms, g.timeSuffix);
    g.d = _.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1]|\d)/), _.optional(g.ctoken2("ordinalSuffix"))), t.day));
    g.dd = _.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1])/), _.optional(g.ctoken2("ordinalSuffix"))), t.day));
    g.ddd = g.dddd = _.cache(_.process(g.ctoken("sun mon tue wed thu fri sat"), function(s) {
        return function() {
            this.weekday = s
        }
    }));
    g.M = _.cache(_.process(_.rtoken(/^(1[0-2]|0\d|\d)/), t.month));
    g.MM = _.cache(_.process(_.rtoken(/^(1[0-2]|0\d)/), t.month));
    g.MMM = g.MMMM = _.cache(_.process(g.ctoken("jan feb mar apr may jun jul aug sep oct nov dec"), t.month));
    g.y = _.cache(_.process(_.rtoken(/^(\d\d?)/), t.year));
    g.yy = _.cache(_.process(_.rtoken(/^(\d\d)/), t.year));
    g.yyy = _.cache(_.process(_.rtoken(/^(\d\d?\d?\d?)/), t.year));
    g.yyyy = _.cache(_.process(_.rtoken(/^(\d\d\d\d)/), t.year));
    _fn = function() {
        return _.each(_.any.apply(null, arguments), _.not(g.ctoken2("timeContext")))
    }
    ;
    g.day = _fn(g.d, g.dd);
    g.month = _fn(g.M, g.MMM);
    g.year = _fn(g.yyyy, g.yy);
    g.orientation = _.process(g.ctoken("past future"), function(s) {
        return function() {
            this.orient = s
        }
    });
    g.operator = _.process(g.ctoken("add subtract"), function(s) {
        return function() {
            this.operator = s
        }
    });
    g.rday = _.process(g.ctoken("yesterday tomorrow today now"), t.rday);
    g.unit = _.process(g.ctoken("second minute hour day week month year"), function(s) {
        return function() {
            this.unit = s
        }
    });
    g.value = _.process(_.rtoken(/^\d\d?(st|nd|rd|th)?/), function(s) {
        return function() {
            this.value = s.replace(/\D/g, "")
        }
    });
    g.expression = _.set([g.rday, g.operator, g.value, g.unit, g.orientation, g.ddd, g.MMM]);
    _fn = function() {
        return _.set(arguments, g.datePartDelimiter)
    }
    ;
    g.mdy = _fn(g.ddd, g.month, g.day, g.year);
    g.ymd = _fn(g.ddd, g.year, g.month, g.day);
    g.dmy = _fn(g.ddd, g.day, g.month, g.year);
    g.date = function(s) {
        return (g[$C.dateElementOrder] || g.mdy).call(this, s)
    }
    ;
    g.format = _.process(_.many(_.any(_.process(_.rtoken(/^(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?)/), function(fmt) {
        if (g[fmt])
            return g[fmt];
        else
            throw $D.Parsing.Exception(fmt);
    }), _.process(_.rtoken(/^[^dMyhHmstz]+/), function(s) {
        return _.ignore(_.stoken(s))
    }))), function(rules) {
        return _.process(_.each.apply(null, rules), t.finishExact)
    });
    var _F = {};
    var _get = function(f) {
        return _F[f] = _F[f] || g.format(f)[0]
    };
    g.formats = function(fx) {
        if (fx instanceof Array) {
            var rx = [];
            for (var i = 0; i < fx.length; i++)
                rx.push(_get(fx[i]));
            return _.any.apply(null, rx)
        } else
            return _get(fx)
    }
    ;
    g._formats = g.formats(['"yyyy-MM-ddTHH:mm:ssZ"', "yyyy-MM-ddTHH:mm:ssZ", "yyyy-MM-ddTHH:mm:ssz", "yyyy-MM-ddTHH:mm:ss", "yyyy-MM-ddTHH:mmZ", "yyyy-MM-ddTHH:mmz", "yyyy-MM-ddTHH:mm", "ddd, MMM dd, yyyy H:mm:ss tt", "ddd MMM d yyyy HH:mm:ss zzz", "MMddyyyy", "ddMMyyyy", "Mddyyyy", "ddMyyyy", "Mdyyyy", "dMyyyy", "yyyy", "Mdyy", "dMyy", "d"]);
    g._start = _.process(_.set([g.date, g.time, g.expression], g.generalDelimiter, g.whiteSpace), t.finish);
    g.start = function(s) {
        try {
            var r = g._formats.call({}, s);
            if (r[1].length === 0)
                return r
        } catch (e$22) {}
        return g._start.call({}, s)
    }
    ;
    $D._parse = $D.parse;
    $D.parse = function(s) {
        var r = null;
        if (!s)
            return null;
        if (s instanceof Date)
            return s;
        try {
            r = $D.Grammar.start.call({}, s.replace(/^\s*(\S*(\s+\S+)*)\s*$/, "$1"))
        } catch (e$23) {
            return null
        }
        return r[1].length === 0 ? r[0] : null
    }
    ;
    $D.getParseFunction = function(fx) {
        var fn = $D.Grammar.formats(fx);
        return function(s) {
            var r = null;
            try {
                r = fn.call({}, s)
            } catch (e$24) {
                return null
            }
            return r[1].length === 0 ? r[0] : null
        }
    }
    ;
    $D.parseExact = function(s, fx) {
        return $D.getParseFunction(fx)(s)
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.loadRemoteProperties = function(url, requestType, config) {
        if (typeof config === "function")
            config = {
                onLoad: config
            };
        config = config || {};
        var chart = this;
        config.async = config.async == null ? true : config.async;
        tdg.ajax(url, {
            async: config.async,
            requestMethod: config.requestMethod,
            onError: function(res) {
                if (chart._haveErrorContent && chart._isDrawing) {
                    delete chart._haveErrorContent;
                    delete chart._isDrawing
                }
                if (typeof config.onError === "function") {
                    res = res || {};
                    if (res.status === 404)
                        config.onError.call(chart, {
                            msg: res.statusText,
                            type: "file_not_found"
                        }, res);
                    else
                        config.onError.call(chart, {
                            msg: res.statusText,
                            type: "unknown"
                        }, res)
                }
            },
            onLoad: function(res) {
                if (chart._haveErrorContent && chart._isDrawing) {
                    delete chart._haveErrorContent;
                    delete chart._isDrawing
                }
                chart.documentRoot = chart.documentRoot || chart.containerID;
                var width, height;
                if (config.preserveSize) {
                    width = chart.width;
                    height = chart.height
                }
                try {
                    if (config.resetDefaultProperties && (config.onLoad === "redraw" || config.onLoad === "morph"))
                        chart.resetProperties();
                    chart.loadPropertiesPage(requestType, res);
                    if (config.preserveSize) {
                        chart.width = width;
                        chart.height = height
                    }
                    if (typeof config.onLoad === "function")
                        config.onLoad.call(chart, res);
                    else if (config.onLoad === "redraw")
                        chart.redraw();
                    else if (config.onLoad === "morph")
                        chart.morph()
                } catch (e$25) {
                    if (config.preserveSize) {
                        chart.width = width;
                        chart.height = height
                    }
                    if (typeof config.onError === "function")
                        if (e$25 && e$25.msg && e$25.type)
                            config.onError.call(chart, e$25, res);
                        else
                            config.onError.call(chart, {
                                msg: e$25 + "",
                                type: "unknown"
                            }, res);
                    else if (config.onError === "redraw")
                        chart.redraw();
                    else if (config.onError === "morph")
                        chart.morph();
                    else if (config.onError === "drawResult") {
                        chart._haveErrorContent = chart._isDrawing = true;
                        drawResult(chart, res)
                    }
                }
            }
        })
    }
    ;
    tdgchart.prototype.loadDataStream = function() {
        var chart = this;
        if (!chart.dataStream.enabled || !chart.dataStream.url)
            return;
        var config = {
            preserveSize: true,
            onLoad: function() {
                var url = chart.dataStream.url;
                chart.dataStream.url = null;
                if (chart.dataStream.useMorph)
                    chart.morph();
                else
                    chart.redraw();
                chart.dataStream.url = url;
                var tid = chart.dataStream.timerId;
                if (tid != null) {
                    chart.cache.setProperty("dataStream.timerId", null);
                    clearTimeout(tid)
                }
                if (chart.dataStream.refreshTimeout != null) {
                    tid = setTimeout(function() {
                        chart.cache.setProperty("dataStream.timerId", null);
                        chart.redraw()
                    }, chart.dataStream.refreshTimeout);
                    chart.cache.setProperty("dataStream.timerId", tid)
                }
            },
            onError: function() {
                var url = chart.dataStream.url;
                chart.dataStream.url = null;
                chart.errorMessage = new tdgchart.UserError(tdgchart.translations.FailedToLoadError + " " + url);
                chart.redraw();
                chart.dataStream.url = url
            }
        };
        chart.loadRemoteProperties(chart.dataStream.url, "jschart", config)
    }
    ;
    tdgchart.prototype.loadPropertiesPage = function(requestType, page, config) {
        config = config || {};
        var chart = this;
        requestType = (requestType || "").toLowerCase();
        if (!(requestType in parsers))
            if (config.onError === "drawResult") {
                chart._haveErrorContent = chart._isDrawing = true;
                drawResult(chart, page)
            } else
                throw {
                    msg: 'Invalid request type "' + requestType + '".  Valid types are ["' + tdg.keys(parsers).join('", "') + '"]',
                    type: "bad_request_type"
                };
        var propertyBlocks = parsers[requestType](page);
        if (!propertyBlocks || !propertyBlocks.length)
            if (config.onError === "drawResult") {
                chart._haveErrorContent = chart._isDrawing = true;
                drawResult(chart, page)
            } else
                throw {
                    msg: "No chart properties found on page",
                    type: "empty_page"
                };
        for (var i = 0; i < propertyBlocks.length; i++) {
            var block = propertyBlocks[i];
            if (block.pfj) {
                chart.parsePFJString(block.pfj);
                block.pfj = null
            } else if (block.pfjDefaults)
                chart.applyPFJDefaults();
            else if (block.json) {
                chart.set(block.json);
                block.json = null
            }
        }
    }
    ;
    var parsers = {
        json: function(res) {
            return [{
                json: res
            }]
        },
        jschart: function(res) {
            var i, json, match;
            var lines = res.split(/\r?\n/);
            var currentPFJScript;
            var isJSONBlock = false;
            var propertyBlocks = [];
            for (i = 0; i < lines.length; i++) {
                var line = lines[i].trim();
                if (line.startsWith("/*") || line.startsWith("//"))
                    continue;
                else if (line.startsWith("var script = ''") || line.startsWith("script = ''"))
                    currentPFJScript = "";
                else if (currentPFJScript != null && line.startsWith("script += "))
                    currentPFJScript += (line.match(/'(.*)'/) || ["", ""])[1];
                else if (line.includes("chart.parsePFJString(script);"))
                    propertyBlocks.push({
                        pfj: currentPFJScript
                    });
                else if (line.includes("chart.applyPFJDefaults();"))
                    propertyBlocks.push({
                        pfjDefaults: true
                    });
                else if (line.startsWith("chart.set({")) {
                    isJSONBlock = true;
                    propertyBlocks.push({
                        jsonString: ""
                    })
                } else if (line.startsWith("});"))
                    isJSONBlock = false;
                else if (isJSONBlock)
                    propertyBlocks[propertyBlocks.length - 1].jsonString += line + "\n";
                else if (line.startsWith("tdgchart.templateEngine.macros.")) {
                    match = line.match(/^tdgchart.templateEngine.macros.(\w*)\s*=\s*(.*?);?$/);
                    if (match && match.length >= 3)
                        tdgchart.templateEngine.macros[match[1]] = eval(match[2])
                } else if (line.startsWith("chart.") && !isJSONBlock) {
                    match = line.match(/^chart\.([\w.]*)\s*=\s*(.*?);?$/);
                    if (match && match.length >= 3) {
                        var target = {};
                        var child = target;
                        var propList = match[1].split(".");
                        for (var j = 0; j < propList.length - 1; j++) {
                            var prop = propList[j];
                            child[prop] = child[prop] || {};
                            child = child[prop]
                        }
                        child[propList[propList.length - 1]] = eval(match[2]);
                        propertyBlocks.push({
                            json: target
                        })
                    }
                } else
                    isJSONBlock = false;
                line = null;
                lines[i] = null
            }
            for (i = 0; i < propertyBlocks.length; i++) {
                this.newProps = null;
                var block = propertyBlocks[i];
                var jsonToParse = "{" + block.jsonString + "}";
                if (block.jsonString) {
                    try {
                        this.newProps = JSON.parse(jsonToParse);
                        if (this.newProps)
                            propertyBlocks[i] = {
                                json: this.newProps
                            }
                    } catch (e$27) {
                        try {
                            jsonToParse = "this.newProps = " + jsonToParse;
                            json = eval(jsonToParse);
                            if (this.newProps)
                                propertyBlocks[i] = {
                                    json: this.newProps
                                }
                        } catch (e$26) {
                            tdg.logError("Failed to parse JSON properties in JSCHART request")
                        }
                    }
                    block.jsonString = null;
                    jsonToParse = null
                }
            }
            return propertyBlocks
        }
    };
    function drawResult(chart, content) {
        var container = document.getElementById(chart.documentRoot);
        if (container) {
            tdg.dom.empty(container);
            tdg.dom.insertIFrame(container, content, chart.width, chart.height)
        }
    }
}
)();
(function() {
    tdgchart.prototype.mapLibrary = [{
        auto: 0,
        file: "worldhq",
        "domain": [{
            "lng": -180,
            "lat": -59
        }, {
            "lng": 180,
            "lat": 84
        }]
    }, {
        auto: 0,
        file: "world",
        "domain": [{
            "lng": -180,
            "lat": -56
        }, {
            "lng": 180,
            "lat": 84
        }]
    }, {
        auto: 1,
        file: "us",
        "domain": [{
            "lng": -127,
            "lat": 24
        }, {
            "lng": -66,
            "lat": 50
        }],
        places: ["Alabama", "Arizona", "Arkansas", "Atlanta", "Augusta", "Austin", "Baton Rouge", "Bismarck", "Boise", "Boston", "California", "Charleston", "Cheyenne", "Chicago", "Colorado", "Columbia", "Connecticut", "Dallas", "Delaware", "Denver", "Des Moines", "Detroit", "Florida", "Georgia", "Helena", "Houston", "Idaho", "Illinois", "Indiana", "Indianapolis", "Iowa", "Jackson", "Kansas", "Kentucky", "Los Angeles", "Louisiana", "Maine", "Maryland", "Massachusetts", "Miami", "Michigan", "Minneapolis", "Minnesota", "Mississippi", "Missouri", "Montana", "Montgomery", "Nashville", "Nebraska", "Nevada", "New Hampshire", "New Jersey", "New Mexico", "New Orleans", "New York", "North Carolina", "North Dakota", "Ohio", "Oklahoma", "Oklahoma City", "Olympia", "Oregon", "Pennsylvania", "Philadelphia", "Phoenix", "Pierre", "Raleigh", "Rhode Island", "Richmond", "Sacramento", "Salem", "Salt Lake City", "San Diego", "San Francisco", "Santa Fe", "Seattle", "South Carolina", "South Dakota", "St. Louis", "St. Paul", "Tallahassee", "Tampa", "Tennessee", "Texas", "Topeka", "Utah", "Vermont", "Virginia", "Washington", "Washington, D.C.", "West Virginia", "Wisconsin", "Wyoming"]
    }, {
        auto: 1,
        file: "usall",
        "domain": [{
            "lng": -125,
            "lat": 21
        }, {
            "lng": -66,
            "lat": 50
        }],
        places: ["Alabama", "Alaska", "Anchorage", "Arizona", "Arkansas", "Atlanta", "Augusta", "Austin", "Baton Rouge", "Bismarck", "Boise", "Boston", "California", "Charleston", "Cheyenne", "Chicago", "Colorado", "Columbia", "Connecticut", "Dallas", "Delaware", "Denver", "Des Moines", "Detroit", "Florida", "Georgia", "Hawaii", "Helena", "Honolulu", "Houston", "Idaho", "Illinois", "Indiana", "Indianapolis", "Iowa", "Jackson", "Juneau", "Kansas", "Kentucky", "Los Angeles", "Louisiana", "Maine", "Maryland", "Massachusetts", "Miami", "Michigan", "Minneapolis", "Minnesota", "Mississippi", "Missouri", "Montana", "Montgomery", "Nashville", "Nebraska", "Nevada", "New Hampshire", "New Jersey", "New Mexico", "New Orleans", "New York", "North Carolina", "North Dakota", "Ohio", "Oklahoma", "Oklahoma City", "Olympia", "Oregon", "Pennsylvania", "Philadelphia", "Phoenix", "Pierre", "Raleigh", "Rhode Island", "Richmond", "Sacramento", "Salem", "Salt Lake City", "San Diego", "San Francisco", "Santa Fe", "Seattle", "South Carolina", "South Dakota", "St. Louis", "St. Paul", "Tallahassee", "Tampa", "Tennessee", "Texas", "Topeka", "Utah", "Vermont", "Virginia", "Washington", "Washington, D.C.", "West Virginia", "Wisconsin", "Wyoming"]
    }, {
        auto: 1,
        file: "canada",
        "domain": [{
            "lng": -142,
            "lat": 41
        }, {
            "lng": -52,
            "lat": 84
        }],
        places: ["Alberta", "Arctic Bay", "British Columbia", "Calgary", "Charlottetown", "Churchill", "Edmonton", "Fort Good Hope", "Fort Severn", "Halifax", "Manitoba", "Montr\u00e9al", "Nain", "New Brunswick", "Newfoundland and Labrador", "Northwest Territories", "Nova Scotia", "Nunavut", "Ontario", "Ottawa", "Prince Edward Island", "Prince Rupert", "Quebec", "Qu\u00e9bec", "Regina", "Repulse Bay", "Resolute", "Saskatchewan", "Saskatoon", "St. John", "St. John's", "Thunder Bay", "Toronto", "Vancouver", "Victoria", "Whitehorse", "Winnipeg", "Yellowknife", "Yukon"]
    }, {
        auto: 1,
        file: "europe",
        "domain": [{
            "lng": -10,
            "lat": 34.5
        }, {
            "lng": 35,
            "lat": 71.5
        }],
        places: ["Aland", "Albania", "Amsterdam", "Andorra", "Ankara", "Armenia", "Athens", "Austria", "Azerbaijan", "Barcelona", "Belarus", "Belgium", "Belgrade", "Berlin", "Bern", "Bosnia and Herz.", "Bratislava", "Brussels", "Bucharest", "Budapest", "Bulgaria", "Chisinau", "Croatia", "Cyprus", "Czech Rep.", "Dakar", "Denmark", "Dublin", "Estonia", "Faeroe Is.", "Finland", "France", "Frankfurt", "Geneva", "Georgia", "Germany", "Greece", "Guernsey", "Hamburg", "Helsinki", "Hungary", "Iceland", "Ireland", "Isle of Man", "Istanbul", "Italy", "Jersey", "Kazakhstan", "Kiev", "Kosovo", "K\u00f8benhavn", "Latvia", "Liechtenstein", "Lisbon", "Lithuania", "Ljubljana", "London", "Luxembourg", "Macedonia", "Madrid", "Malta", "Milan", "Minsk", "Moldova", "Monaco", "Montenegro", "Moscow", "Munich", "N. Cyprus", "Naples", "Netherlands", "Nicosia", "Norway", "Oslo", "Paris", "Podgorica", "Poland", "Portugal", "Prague", "Riga", "Romania", "Rome", "Russia", "San Marino", "Sarajevo", "Serbia", "Skopje", "Slovakia", "Slovenia", "Sofia", "Spain", "St. Petersburg", "Stockholm", "Sweden", "Switzerland", "Tallinn", "The Hague", "Tirana", "Turkey", "Ukraine", "United Kingdom", "Vaduz", "Valletta", "Vatican", "Vatican City", "Vienna", "Vilnius", "Warsaw", "Zagreb", "Zurich", "Z\u00fcrich"]
    }, {
        auto: 1,
        file: "northamerica",
        "domain": [{
            "lng": -172,
            "lat": 7
        }, {
            "lng": -12,
            "lat": 84
        }],
        places: ["Antigua and Barbuda", "Bahamas", "Barbados", "Belize", "Canada", "Costa Rica", "Cuba", "Dominica", "Dominican Republic", "El Salvador", "Grenada", "Guatemala", "Haiti", "Honduras", "Jamaica", "Mexico", "Nicaragua", "Panama", "Puerto Rico", "St. Kitts and Nevis", "St. Lucia", "St. Vincent and the Grenadines", "Trinidad and Tobago", "United States"]
    }]
}
)();
(function() {
    tdgchart.prototype.mapNormalizeName = normalize;
    tdgchart.prototype.drawMap = drawMap;
    var tdg = tdgchart.util;
    var ASPECT_RATIO_MAGIC = 1.36;
    var normalize_regexp = new RegExp("[-,.'\u2019, ]","g");
    function normalize(s) {
        s = s + "";
        return s ? s.replace(normalize_regexp, "").toLowerCase() : undefined
    }
    function getLatLng(data, mapobject) {
        var n, lookup;
        if (data.lng && data.lat)
            return {
                lng: data.lng,
                lat: data.lat
            };
        if (data.name) {
            lookup = mapobject._lookup.point;
            if (lookup) {
                n = lookup.exact ? data.name : normalize(data.name);
                if (lookup.index[n] !== undefined)
                    return {
                        lng: lookup.index[n].position[0],
                        lat: lookup.index[n].position[1]
                    }
            }
            return undefined
        }
        if (data.position)
            return {
                lng: data.position[0],
                lat: data.position[1]
            };
        if (typeof data[0] === "string") {
            lookup = mapobject._lookup.point;
            if (lookup) {
                n = lookup.exact ? data[0] : normalize(data[0]);
                if (lookup.index[n] !== undefined)
                    return {
                        lng: lookup.index[n].position[0],
                        lat: lookup.index[n].position[1]
                    }
            }
            return undefined
        }
        return {
            lng: data[0],
            lat: data[1]
        }
    }
    function drawPolygonLayer(panel, chart, data, mapobject, scales, baseLayer, mapProperties, drawLabels, labelsPanel) {
        panel.data(baseLayer.features);
        var teritoryPanel = panel.add(pv.Panel).data(function(c) {
            return c.borders
        });
        var teritoryLine = teritoryPanel.add(pv.Line).className(function(l, data, mapObj) {
            return "riser!s0!g" + (mapObj[chart.mapProperties.geocode.geocode] || mapObj[baseLayer.primary_id_field]) + "!mstate"
        }).data(function(l) {
            return l
        }).left(function(l) {
            return scales.region[this.parent.parent.index].x(l)
        }).top(function(l) {
            return scales.region[this.parent.parent.index].y(l)
        }).title(function() {
            return baseLayer.features[this.parent.parent.index][baseLayer.primary_name_field]
        }).lineStyle(mapProperties.region.border).fillStyle(mapProperties.region.color).antialias(mapProperties.antiAlias);
        if (0)
            panel.add(pv.Panel).visible(function(l) {
                return l.destRect !== undefined
            }).left(function(l) {
                var n = scales.base.x({
                    lat: l.destRect[0][1],
                    lng: l.destRect[0][0]
                });
                return n
            }).width(function(l) {
                return scales.base.x({
                    lat: l.destRect[1][1],
                    lng: l.destRect[1][0]
                }) - scales.base.x({
                    lat: l.destRect[0][1],
                    lng: l.destRect[0][0]
                })
            }).top(function(l) {
                var n = scales.base.y({
                    lat: l.destRect[0][1],
                    lng: l.destRect[0][0]
                });
                return n
            }).height(function(l) {
                return scales.base.y({
                    lat: l.destRect[1][1],
                    lng: l.destRect[1][0]
                }) - scales.base.y({
                    lat: l.destRect[0][1],
                    lng: l.destRect[0][0]
                })
            }).strokeStyle("red").lineWidth(1);
        if (data !== undefined && mapProperties.markerType === "choropleth") {
            mapobject._lookup.polygon.layer.features.map(function(el) {
                var name = el[mapobject._lookup.polygon.field];
                return normalize(name)
            });
            var rdata = {};
            if (typeof data[0].name === "string")
                data.forEach(function(d) {
                    if (typeof d.name === "string") {
                        var region = mapobject._lookup.polygon.index[mapobject._lookup.polygon.exact ? d.name : normalize(d.name)];
                        if (region)
                            rdata[region[mapobject._lookup.polygon.layer.primary_id_field]] = d
                    }
                });
            else
                data[0].forEach(function(d, i) {
                    if (i < mapobject._lookup.polygon.layer.features.length)
                        rdata[mapobject._lookup.polygon.layer.features[i][mapobject._lookup.polygon.layer.primary_id_field]] = d
                });
            mapobject._minMax = chart.getScaleMinMax(chart.yaxis, "y1", data);
            var colors = chart.colorScale.colors;
            var domain = tdg.rangeCount(mapobject._minMax.min, mapobject._minMax.max, colors.length);
            var colorScale = pv.Scale.linear.apply(null, domain).range(colors);
            teritoryLine.fillStyle(function(d, f, a) {
                var id = a[mapobject._lookup.polygon.layer.primary_id_field];
                var v = rdata[id] && rdata[id].value;
                return v === undefined ? mapProperties.region.color : colorScale(v)
            });
            teritoryLine.title(function(d, f, a) {
                var fmt = "[<-1000000000000]-#,,,B;[<-10000000000]-#,,,.#B;[<-1000000000]-#,,M;[<-10000000]-#,,.#M;[<-100000]-#,K;[<-10000]-#,.#K;[<0]-#;[<1000]#;[<10000]#,.#K;[<1000000]#,K;[<10000000]#,,.#M;[<1000000000]#,,M;[<10000000000]#,,,.#B;[<1000000000000]#,,,B;#";
                var id = a[mapobject._lookup.polygon.layer.primary_id_field];
                var v = rdata[id] && rdata[id].value;
                if (v === undefined)
                    return a[baseLayer.primary_name_field];
                else
                    return a[baseLayer.primary_name_field] + ": " + chart.formatNumber(v, fmt)
            })
        }
        if (drawLabels) {
            var which_label = [];
            labelsPanel.add(pv.Label).data(baseLayer.features).visible(function(c) {
                if (isNaN(c.centLatLon.lng))
                    return false;
                var labelsize;
                var min = scales.region[this.index](c.brect.min);
                var max = scales.region[this.index](c.brect.max);
                if (baseLayer.primary_name_field && c[baseLayer.primary_name_field]) {
                    var dataLabelFont = chart.getSeriesAndGroupProperty(0, null, "dataLabels.font");
                    labelsize = chart.measureLabel(c[baseLayer.primary_name_field], dataLabelFont);
                    if (labelsize.width <= max.x - min.x && labelsize.height <= min.y - max.y || drawLabels === "forceName") {
                        which_label[this.index] = baseLayer.primary_name_field;
                        return true
                    }
                }
                if (baseLayer.primary_abbr_field && baseLayer.primary_abbr_field != baseLayer.primary_name_field && c[baseLayer.primary_abbr_field]) {
                    var dataLabelFont = chart.getSeriesAndGroupProperty(0, null, "dataLabels.font");
                    labelsize = chart.measureLabel(c[baseLayer.primary_abbr_field], dataLabelFont);
                    if (labelsize.width <= max.x - min.x && labelsize.height <= min.y - max.y || drawLabels === "force" || drawLabels === "forceAbbr") {
                        which_label[this.index] = baseLayer.primary_abbr_field;
                        return true
                    }
                }
                return false
            }).left(function(c) {
                return scales.region[this.index](c.centLatLon).x
            }).top(function(c) {
                return scales.region[this.index](c.centLatLon).y
            }).text(function(c) {
                return c[which_label[this.index]]
            }).textAlign("center").textBaseline("middle").font(this.seriesPropertyLookup("dataLabels.font")).textStyle(chart.seriesPropertyLookup("dataLabels.color"))
        }
    }
    function drawPointLayer(panel, chart, mapobject, scales, landmarksLayer, landmarksProps) {
        var landmarksPanel = panel.add(pv.Panel).def("landmarksCount", 0).data(landmarksLayer.features);
        if (landmarksProps.marker.size > 0) {
            var lcount = 0;
            landmarksPanel.add(pv.Dot).visible(function(d) {
                var p = getLatLng(d, mapobject);
                var s = getScaleForPosition(scales, p, d[landmarksLayer.primary_name_field]);
                var pos = s(p);
                var in_range = pos.x >= 0 && pos.x < panel.computedSize.width && pos.y >= 0 && pos.y < panel.computedSize.height;
                if (this.parent.index == 0)
                    this.parent.landmarksCount(0);
                lcount = this.parent.landmarksCount();
                if (!in_range)
                    return false;
                this.parent.landmarksCount(lcount + 1);
                return landmarksProps.maxCount === undefined || lcount < landmarksProps.maxCount
            }).left(function(d) {
                var p = getLatLng(d, mapobject);
                var s = getScaleForPosition(scales, p, d[landmarksLayer.primary_name_field]);
                return s.x(p)
            }).top(function(d) {
                var p = getLatLng(d, mapobject);
                var s = getScaleForPosition(scales, p, d[landmarksLayer.primary_name_field]);
                return s.y(p)
            }).shape(landmarksProps.marker.shape || "circle").radius(landmarksProps.marker.size / 2 || 5).angle(landmarksProps.marker.rotation).fillStyle(landmarksProps.marker.color || "transparent").lineStyle(landmarksProps.marker.border).anchor("bottom").add(pv.Label).textAlign("center").textBaseline("top").text(function(d) {
                return d[landmarksLayer.primary_name_field]
            }).font(landmarksProps.label.font).textStyle(landmarksProps.label.color)
        }
    }
    function drawBubbleMarkers(panel, chart, mapobject, scales, data) {
        var bubblePanel = panel.add(pv.Panel).data(data);
        var classLookup;
        if (typeof data[0][0].name === "string")
            classLookup = function(d) {
                return chart.buildClassName("riser", this.parent.index || 0, d.name, "marker")
            }
            ;
        else
            classLookup = chart.classNameLookup("marker", "riser");
        var dot = bubblePanel.add(pv.Dot).className(classLookup).data(function(d) {
            return d
        }).visible(function(d) {
            return getLatLng(d, mapobject) ? true : false
        }).left(function(d) {
            var p = getLatLng(d, mapobject);
            var s = getScaleForPosition(scales, p);
            return s.x(p)
        }).top(function(d) {
            var p = getLatLng(d, mapobject);
            var s = getScaleForPosition(scales, p);
            return s.y(p)
        }).fillStyle(chart.seriesColorLookup()).includeRadius(chart.mouseOverIndicator.enabled || chart.needHTMLToolTip()).shape(chart.seriesPropertyLookup("marker.shape")).angle(chart.markerRotationLookup()).radius(chart.dataDrivenMarkerSize()).lineStyle(chart.seriesPropertyLookup("marker.border")).title(chart.seriesToolTipLookup());
        chart.addBevel(dot)
    }
    function getMapScales(chart, panel, mapobject, layer, data) {
        var scales = {
            base: undefined,
            region: [],
            moved: []
        };
        var w = panel.computedSize.width;
        var h = panel.computedSize.height;
        var vOffset = 0
          , hOffset = 0;
        if (h / w < mapobject.aspectRatio)
            w = h * (1 / mapobject.aspectRatio);
        else
            h = w * mapobject.aspectRatio;
        function grow(box, pt) {
            if (pt.lng < box.left)
                box.left = pt.lng;
            if (pt.lng > box.right)
                box.right = pt.lng;
            if (pt.lat < box.top)
                box.top = pt.lat;
            if (pt.lat > box.bottom)
                box.bottom = pt.lat
        }
        function within(pt, box) {
            return pt.lng >= box.left && pt.lng <= box.right && pt.lat <= box.top && pt.lat >= box.bottom
        }
        var viewBox;
        if (chart.mapProperties.viewBox === "auto") {
            var viewBox_show_whole_region = true;
            var dataBox = {
                left: 180,
                right: -180,
                top: 90,
                bottom: -90
            };
            var margin = .1;
            var hasResult = false;
            data.forEach(function(group) {
                group.forEach(function(d) {
                    var pos = getLatLng(d, mapobject);
                    if (!pos)
                        return;
                    grow(dataBox, pos);
                    hasResult = true
                })
            });
            if (hasResult) {
                viewBox = {};
                viewBox.left = dataBox.left - (dataBox.right - dataBox.left) * margin;
                viewBox.right = dataBox.right + (dataBox.right - dataBox.left) * margin;
                viewBox.top = dataBox.top - (dataBox.bottom - dataBox.top) * margin;
                viewBox.bottom = dataBox.bottom + (dataBox.bottom - dataBox.top) * margin;
                if (viewBox_show_whole_region)
                    data.forEach(function(group) {
                        group.forEach(function(d) {
                            var pos = getLatLng(d, mapobject);
                            if (!pos)
                                return;
                            layer.features.forEach(function(feature) {
                                var feature_coord = {
                                    left: feature.brect.min.lng,
                                    right: feature.brect.max.lng,
                                    bottom: feature.brect.min.lat,
                                    top: feature.brect.max.lat
                                };
                                if (within(pos, feature_coord)) {
                                    grow(viewBox, feature.brect.min);
                                    grow(viewBox, feature.brect.max)
                                }
                            })
                        })
                    })
            }
        } else
            viewBox = chart.mapProperties.viewBox;
        if (viewBox && viewBox.left !== "auto" && viewBox.right !== "auto" && viewBox.top !== "auto" && viewBox.bottom !== "auto") {
            var dlng = Math.abs(mapobject.domain[1].lng - mapobject.domain[0].lng);
            var dlat = Math.abs(mapobject.domain[1].lat - mapobject.domain[0].lat);
            var vB_cy = (viewBox.top + viewBox.bottom) / 2;
            var vB_cx = (viewBox.left + viewBox.right) / 2;
            var zoom = Math.min(panel.computedSize.width / w * dlng / Math.abs(viewBox.right - viewBox.left), panel.computedSize.height / h * dlat / Math.abs(viewBox.top - viewBox.bottom));
            w *= zoom;
            h *= zoom;
            vOffset = panel.computedSize.height / 2 - (Math.max(mapobject.domain[1].lat, mapobject.domain[0].lat) - vB_cy) * (h / dlat);
            hOffset = panel.computedSize.width / 2 - (vB_cx - Math.min(mapobject.domain[1].lng, mapobject.domain[0].lng)) * (w / dlng)
        } else {
            hOffset = (panel.computedSize.width - w) / 2;
            vOffset = (panel.computedSize.height - h) / 2
        }
        var dp = [{
            lat: mapobject.domain[0].lat,
            lng: mapobject.domain[0].lng
        }, {
            lat: mapobject.domain[0].lat,
            lng: mapobject.domain[1].lng
        }, {
            lat: mapobject.domain[1].lat,
            lng: mapobject.domain[0].lng
        }, {
            lat: mapobject.domain[1].lat,
            lng: mapobject.domain[1].lng
        }];
        scales.base = pv.Geo.scale(mapobject.projection ? mapobject.projection : "none").domain(dp).range({
            x: hOffset,
            y: vOffset
        }, {
            x: w + hOffset,
            y: h + vOffset
        });
        layer.features.forEach(function(r, i) {
            if (r.rect) {
                var range1 = scales.base(r.rect.min);
                var range2 = scales.base(r.rect.max);
                var range_min = {
                    x: Math.min(range1.x, range2.x),
                    y: Math.min(range1.y, range2.y)
                };
                var range_max = {
                    x: Math.max(range1.x, range2.x),
                    y: Math.max(range1.y, range2.y)
                };
                var rw = range_max.x - range_min.x;
                var rh = range_max.y - range_min.y;
                var vOffset = 0
                  , hOffset = 0;
                if (rh / rw < r._aspectRatio) {
                    rw = rh * (1 / r._aspectRatio);
                    hOffset = (range_max.x - range_min.x - rw) / 2
                } else {
                    rh = rw * r._aspectRatio;
                    vOffset = (range_max.y - range_min.y - rh) / 2
                }
                scales.region[i] = pv.Geo.scale().domain(r.brect.min, r.brect.max).range({
                    x: range_min.x + hOffset,
                    y: range_min.y + vOffset
                }, {
                    x: range_max.x - hOffset,
                    y: range_max.y - vOffset
                });
                scales.moved.push(i)
            } else
                scales.region[i] = scales.base
        });
        return scales
    }
    function getScaleForPosition(scales, pos) {
        for (var m = 0; m < scales.moved.length; m++) {
            var domain = scales.region[scales.moved[m]].domain();
            if (pos.lat >= domain[0].lat && pos.lat <= domain[1].lat && pos.lng >= domain[0].lng && pos.lng <= domain[1].lng)
                return scales.region[scales.moved[m]]
        }
        return scales.base
    }
    function drawMap(rootpanel) {
        var chart = this;
        var data = chart._internalData || chart.data;
        if (chart.mapProperties.engine == "leaflet")
            return;
        var panel = rootpanel.add(pv.Panel);
        panel.computedSize = rootpanel.computedSize;
        panel.overflow("hidden");
        var eventPanel = panel.add(pv.Panel).className("eventPanel").events("all");
        var contentPanel = eventPanel.add(pv.Panel).className("contentPanel");
        contentPanel.computedSize = rootpanel.computedSize;
        var groupPanel = contentPanel.add(pv.Panel).className("groupPanel");
        groupPanel.computedSize = rootpanel.computedSize;
        var mapobject;
        if (chart.mapProperties.map === "auto" || typeof chart.mapProperties.map === "undefined")
            mapobject = loadMap(chart, mapAutoSelect(chart, data));
        else
            mapobject = loadMap(chart, chart.mapProperties.map);
        if (!mapobject)
            return;
        var scales = getMapScales(chart, panel, mapobject, mapobject._baseLayer, data);
        var secscales;
        drawPolygonLayer(groupPanel, chart, data, mapobject, scales, mapobject._baseLayer, chart.mapProperties, chart.areDataLabelsVisible(), contentPanel);
        if (mapobject._layerIndex.polygon["states"] && mapobject._layerIndex.polygon["states"] != mapobject._baseLayer) {
            var secondary_layer = mapobject._layerIndex.polygon["states"];
            compute_brects_and_label_positions(secondary_layer);
            secscales = getMapScales(chart, panel, mapobject, secondary_layer);
            var props = {
                region: chart.mapProperties.secondaryRegion,
                antiAlias: chart.mapProperties.antiAlias
            };
            drawPolygonLayer(contentPanel.add(pv.Panel), chart, undefined, mapobject, secscales, secondary_layer, props, false, contentPanel)
        }
        if (chart.mapProperties.landmarks && chart.mapProperties.landmarks.visible && mapobject._landmarks)
            drawPointLayer(contentPanel, chart, mapobject, scales, mapobject._landmarks, chart.mapProperties.landmarks);
        if (chart.mapProperties.markerType === "bubble")
            drawBubbleMarkers(contentPanel, chart, mapobject, scales, data);
        chart.drawChartFrameAnnotations({
            riser: {
                fg: rootpanel
            }
        }, scales.base.x, scales.base.y, "left");
        if (secscales)
            addInteraction(chart, panel, [scales, secscales], eventPanel);
        else
            addInteraction(chart, panel, [scales], eventPanel)
    }
    function addPanInteraction(chart, panel, scales_array, eventPanel) {
        var base_ranges = [];
        scales_array.forEach(function(scales, i) {
            base_ranges[i] = scales.base.range()
        });
        var region_custom_ranges = [];
        function rwidth(range) {
            return range[1].x - range[0].x
        }
        function rheight(range) {
            return range[1].y - range[0].y
        }
        var xoff = [];
        var yoff = [];
        var zoomlevel = 0;
        var zoomdiv = 1.3;
        scales_array.forEach(function(scales, i) {
            xoff[i] = -base_ranges[i][0].x;
            yoff[i] = -base_ranges[i][0].y;
            region_custom_ranges[i] = [];
            scales.region.forEach(function(scale, r) {
                region_custom_ranges[i][r] = scales.region[r].range()
            })
        });
        function resetTransform() {
            this.transform(pv.Transform());
            scales_array.forEach(function(scales, i) {
                scales.base.range(base_ranges[i][0], base_ranges[i][1]);
                scales.region.forEach(function(range, r) {
                    if (scales.region[r] != scales.base)
                        scales.region[r].range(region_custom_ranges[i][r][0], region_custom_ranges[i][r][1])
                });
                xoff[i] = -base_ranges[i][0].x;
                yoff[i] = -base_ranges[i][0].y
            });
            zoomlevel = 0;
            this.root.render();
            chart.processEvents()
        }
        function recompute_range(panel, newzoomlevel, cx, cy) {
            chart.__refreshMarkerList = true;
            var t = panel.transform();
            if (newzoomlevel === undefined)
                newzoomlevel = zoomlevel;
            var ozoom = Math.pow(zoomdiv, zoomlevel);
            var nzoom = Math.pow(zoomdiv, newzoomlevel);
            scales_array.forEach(function(scales, i) {
                var ws = rwidth(base_ranges[i]);
                var hs = rheight(base_ranges[i]);
                var w = ws * nzoom;
                var h = hs * nzoom;
                if (cx === undefined)
                    cx = ws / 2 - t.x;
                if (cy === undefined)
                    cy = hs / 2 - t.y;
                xoff[i] = (xoff[i] + cx) * nzoom / ozoom - cx;
                yoff[i] = (yoff[i] + cy) * nzoom / ozoom - cy;
                scales.base.range({
                    x: -xoff[i] + t.x,
                    y: -yoff[i] + t.y
                }, {
                    x: w - xoff[i] + t.x,
                    y: h - yoff[i] + t.y
                });
                scales.region.forEach(function(range, r) {
                    if (scales.region[r] != scales.base) {
                        var x1 = -xoff[i] + t.x + (region_custom_ranges[i][r][0].x - base_ranges[i][0].x) * nzoom;
                        var y1 = -yoff[i] + t.y + (region_custom_ranges[i][r][0].y - base_ranges[i][0].y) * nzoom;
                        var x2 = -xoff[i] + t.x + (region_custom_ranges[i][r][1].x - base_ranges[i][0].x) * nzoom;
                        var y2 = -yoff[i] + t.y + (region_custom_ranges[i][r][1].y - base_ranges[i][0].y) * nzoom;
                        scales.region[r].range({
                            x: x1,
                            y: y1
                        }, {
                            x: x2,
                            y: y2
                        })
                    }
                })
            });
            zoomlevel = newzoomlevel;
            panel.root.render();
            chart.processEvents()
        }
        function transform() {
            recompute_range(this)
        }
        function wheelzoom() {
            var m = this._mouse;
            if (m.k < 0)
                recompute_range(this, zoomlevel - 1, m.x, m.y);
            else if (m.k > 0)
                recompute_range(this, zoomlevel + 1, m.x, m.y)
        }
        function addZoomButtons(chart, panel) {
            var buttonPanel = panel.add(pv.Panel).className("zoomButtons");
            buttonPanel.add(pv.Bar).left(9.5).width(18).top(9.5).height(18).fillStyle("rgba(90,90,90,0.2)");
            var zoomIn = buttonPanel.add(pv.Bar).left(6.5).width(18).top(6.5).height(18).fillStyle("#ccc").strokeStyle("black").lineWidth(1);
            buttonPanel.add(pv.Bar).left(9.5).width(18).top(31.5).height(18).fillStyle("rgba(90,90,90,0.2)");
            var zoomOut = buttonPanel.add(pv.Bar).left(6.5).width(18).top(28.5).height(18).fillStyle("#ccc").strokeStyle("black").lineWidth(1);
            zoomIn.anchor("center").add(pv.Label).text("+").textStyle("#666").font("14pt sans-serif");
            zoomOut.anchor("center").add(pv.Label).text("\u2013").textStyle("#666").font("14pt sans-serif");
            zoomIn.event("click", function() {
                recompute_range(eventPanel, zoomlevel + 1)
            });
            zoomOut.event("click", function() {
                recompute_range(eventPanel, zoomlevel - 1)
            })
        }
        eventPanel.event("dblclick", chart.interaction.dblclick === "resetView" ? resetTransform : undefined).event("mousedown", pv.Behavior.pan()).event("mousewheel", pv.Behavior.zoom2()).event("touchstart", pv.Behavior.pan()).event("pan", transform).event("zoom", wheelzoom);
        addZoomButtons(chart, panel)
    }
    pv.Behavior.zoom2 = function(speed) {
        if (!arguments.length)
            speed = 1;
        var mousewheel = function() {
            var v = this.mouse();
            this._mouse = {
                x: v.x,
                y: v.y,
                k: pv.event.wheel
            };
            pv.Mark.dispatch("zoom", this.scene, this.index)
        };
        return mousewheel
    }
    ;
    function addInteraction(chart, panel, scales_array, eventPanel) {
        if (chart.interaction.mousedrag === "pan")
            addPanInteraction(chart, panel, scales_array, eventPanel)
    }
    function findArea(pts) {
        var area = 0;
        var nPts = pts.length;
        var j = nPts - 1;
        var p1;
        var p2;
        for (var i = 0; i < nPts; j = i++) {
            p1 = pts[i];
            p2 = pts[j];
            area += p1.lng * p2.lat;
            area -= p1.lat * p2.lng
        }
        area /= 2;
        return area
    }
    function centroid(pts) {
        var nPts = pts.length;
        var lng = 0;
        var lat = 0;
        var f;
        var j = nPts - 1;
        var p1;
        var p2;
        for (var i = 0; i < nPts; j = i++) {
            p1 = pts[i];
            p2 = pts[j];
            f = p1.lng * p2.lat - p2.lng * p1.lat;
            lng += (p1.lng + p2.lng) * f;
            lat += (p1.lat + p2.lat) * f
        }
        f = findArea(pts) * 6;
        if (f == 0)
            return {
                lng: pts[0].lng,
                lat: pts[0].lat
            };
        else
            return {
                lng: lng / f,
                lat: lat / f
            }
    }
    function loadMap(chart, map) {
        var mapobject = null;
        if (typeof map === "object")
            mapobject = map;
        else if (typeof map === "string")
            if (tdgchart._internalMaps && tdgchart._internalMaps[normalize(map)])
                mapobject = tdg.cloneObject(tdgchart._internalMaps[normalize(map)]);
            else {
                var path;
                if (chart.mapProperties.hasOwnProperty("mapPath") && chart.mapProperties.mapPath)
                    path = chart.mapProperties.mapPath;
                else if (chart.hasOwnProperty("tdgPath") && chart.tdgPath)
                    path = chart.tdgPath;
                else
                    path = tdgchart.getScriptPath();
                if (path.charAt(path.length - 1) !== "/")
                    path += "/";
                var request = new XMLHttpRequest;
                request.open("GET", path + "map/" + map + ".json", false);
                request.send(null);
                if (request.status === 200)
                    if (typeof JSON === "object")
                        mapobject = JSON.parse(request.responseText);
                    else
                        eval("mapobject = " + request.responseText)
            }
        if (!mapobject)
            return;
        if (Array.isArray(mapobject))
            mapobject = {
                name: typeof map === "string" ? map : "map",
                landmarks: [],
                regions: mapobject
            };
        return prepare_mapobject(chart, mapobject)
    }
    function prepare_lookup_index(layer, field, exact) {
        var index = {};
        layer.features.forEach(function(landmark) {
            if (exact)
                index[landmark[field]] = landmark;
            else {
                index[normalize(landmark[field])] = landmark;
                if (landmark.alias)
                    if (typeof landmark.alias === "string")
                        index[normalize(landmark.alias)] = landmark;
                    else
                        landmark.alias.forEach(function(alias) {
                            index[normalize(alias)] = landmark
                        })
            }
        });
        return index
    }
    function compute_brects_and_label_positions(layer) {
        layer.features.forEach(function(c) {
            c.brect = {
                min: {},
                max: {}
            };
            c.borders.forEach(function(b) {
                b.forEach(function(p, i) {
                    var lng = p[0];
                    function country(code) {
                        return c.hasOwnProperty("iso_a2") && c.iso_a2 == code || c.hasOwnProperty("iso_3166_2") && c.iso_3166_2.slice(0, 2) == code
                    }
                    if (country("US") && lng >= 0)
                        p[0] -= 360;
                    if (country("RU") && lng < 0)
                        p[0] += 360;
                    if ((country("AS") || country("PF") || country("FJ") || country("NZ") || country("KI") || country("CK") || country("NU") || country("PN") || country("TO") || country("WF") || country("WS")) && lng < 0)
                        p[0] += 360;
                    var pt = {
                        lat: p[1],
                        lng: p[0]
                    };
                    b[i] = {
                        lat: p[1],
                        lng: p[0]
                    };
                    if (c.brect.min.lat === undefined || pt.lat < c.brect.min.lat)
                        c.brect.min.lat = pt.lat;
                    if (c.brect.max.lat === undefined || pt.lat > c.brect.max.lat)
                        c.brect.max.lat = pt.lat;
                    if (c.brect.min.lng === undefined || pt.lng < c.brect.min.lng)
                        c.brect.min.lng = pt.lng;
                    if (c.brect.max.lng === undefined || pt.lng > c.brect.max.lng)
                        c.brect.max.lng = pt.lng
                })
            });
            var idx = c.mainArea && c.mainArea < c.borders.length ? c.mainArea : 0;
            c.centLatLon = centroid(c.borders[idx]);
            if (c.labelpos) {
                if (c.labelpos.lat !== undefined)
                    c.centLatLon.lat = c.labelpos.lat;
                if (c.labelpos.latoffset)
                    c.centLatLon.lat += c.labelpos.latoffset;
                if (c.labelpos.lng !== undefined)
                    c.centLatLon.lng = c.labelpos.lng;
                if (c.labelpos.lngoffset)
                    c.centLatLon.lng += c.labelpos.lngoffset
            }
        })
    }
    function compute_domains_and_aspect(layer) {
        var rmin = {};
        var rmax = {};
        layer.features.forEach(function(r) {
            if (!r.destRect) {
                if (rmin.lat === undefined || r.brect.min.lat < rmin.lat)
                    rmin.lat = r.brect.min.lat;
                if (rmax.lat === undefined || r.brect.max.lat > rmax.lat)
                    rmax.lat = r.brect.max.lat;
                if (rmin.lng === undefined || r.brect.min.lng < rmin.lng)
                    rmin.lng = r.brect.min.lng;
                if (rmax.lng === undefined || r.brect.max.lng > rmax.lng)
                    rmax.lng = r.brect.max.lng
            } else {
                r.rect = {};
                r.rect.min = {
                    lng: Math.min(r.destRect[0][0], r.destRect[1][0]),
                    lat: Math.min(r.destRect[0][1], r.destRect[1][1])
                };
                r.rect.max = {
                    lng: Math.max(r.destRect[0][0], r.destRect[1][0]),
                    lat: Math.max(r.destRect[0][1], r.destRect[1][1])
                };
                if (rmin.lat === undefined || r.rect.min.lat < rmin.lat)
                    rmin.lat = r.rect.min.lat;
                if (rmax.lat === undefined || r.rect.max.lat > rmax.lat)
                    rmax.lat = r.rect.max.lat;
                if (rmin.lng === undefined || r.rect.min.lng < rmin.lng)
                    rmin.lng = r.rect.min.lng;
                if (rmax.lng === undefined || r.rect.max.lng > rmax.lng)
                    rmax.lng = r.rect.max.lng;
                if (r.aspectRatio)
                    r._aspectRatio = r.aspectRatio;
                else
                    r._aspectRatio = Math.abs((r.brect.max.lat - r.brect.min.lat) / (r.brect.max.lng - r.brect.min.lng) * ASPECT_RATIO_MAGIC)
            }
        });
        layer._domain = [{
            lat: Math.floor(rmin.lat),
            lng: Math.floor(rmin.lng)
        }, {
            lat: Math.ceil(rmax.lat),
            lng: Math.ceil(rmax.lng)
        }];
        layer._aspectRatio = Math.abs((layer._domain[1].lat - layer._domain[0].lat) / (layer._domain[1].lng - layer._domain[0].lng) * ASPECT_RATIO_MAGIC)
    }
    function prepare_mapobject_v2(chart, mapobject) {
        return mapobject
    }
    function prepare_mapobject_v1(chart, mapobject) {
        mapobject.primary_layer = "regions";
        var r = {
            type: "regions",
            geocode: ["name", "code"],
            units: "decimal_degrees",
            geometry_type: "polygon",
            primary_name_field: "name",
            primary_id_field: "code",
            primary_abbr_field: "code",
            features: mapobject.regions
        };
        mapobject.layers = [r];
        if (mapobject.landmarks) {
            var l = {
                type: "cities",
                geocode: ["name"],
                units: "decimal_degrees",
                geometry_type: "point",
                primary_name_field: "name",
                features: mapobject.landmarks
            };
            mapobject.layers.push(l)
        }
        if (r.features[0].name == "Z3" && r.features[1].name == "Z3")
            r.primary_name_field = "code";
        if (chart.mapProperties.precision)
            mapSimplify(mapobject, chart.mapProperties.precision);
        r.features.sort(function(a, b) {
            var an = a[r.primary_name_field];
            var bn = b[r.primary_name_field];
            return an < bn ? -1 : an > bn ? 1 : 0
        });
        return mapobject
    }
    function create_lookups(mapobject, geocode) {
        var lookup = {
            point: {},
            polygon: {}
        };
        if (!geocode)
            geocode = {};
        if (geocode.type) {
            if (mapobject._layerIndex.point[geocode.type])
                lookup.point = {
                    layer: mapobject._layerIndex.point[geocode.type],
                    exact: geocode.exact,
                    field: geocode.geocode
                };
            if (mapobject._layerIndex.polygon[geocode.type])
                lookup.polygon = {
                    layer: mapobject._layerIndex.polygon[geocode.type],
                    exact: geocode.exact,
                    field: geocode.geocode
                }
        }
        if (!lookup.point.layer)
            lookup.point.layer = mapobject._landmarks;
        if (!lookup.point.field || lookup.point.layer.geocode.indexOf(lookup.point.field) == -1)
            lookup.point.field = lookup.point.layer.primary_name_field;
        if (!lookup.polygon.layer)
            lookup.polygon.layer = mapobject._baseLayer;
        if (!lookup.polygon.field || lookup.polygon.layer.geocode.indexOf(lookup.polygon.field) == -1)
            lookup.polygon.field = lookup.polygon.layer.primary_id_field;
        lookup.point.index = prepare_lookup_index(lookup.point.layer, lookup.point.field, lookup.point.exact);
        lookup.polygon.index = prepare_lookup_index(lookup.polygon.layer, lookup.polygon.field, lookup.polygon.exact);
        return lookup
    }
    function prepare_mapobject(chart, mapobject) {
        if (mapobject.fileformat === 2)
            mapobject = prepare_mapobject_v2(chart, mapobject);
        else
            mapobject = prepare_mapobject_v1(chart, mapobject);
        mapobject._layerIndex = {
            point: {},
            polygon: {}
        };
        mapobject.layers.forEach(function(layer) {
            if (mapobject.primary_layer === undefined && layer.geometry_type === "polygon")
                mapobject.primary_layer = layer.type;
            if (layer.type == mapobject.primary_layer)
                mapobject._baseLayer = layer;
            if (layer.type == "cities" && layer.geometry_type === "point")
                mapobject._landmarks = layer;
            mapobject._layerIndex[layer.geometry_type][layer.type] = layer;
            if (layer.primary_name_field === undefined)
                layer.primary_name_field = "name";
            if (layer.primary_id_field === undefined)
                layer.primary_id_field = layer.primary_abbr_field !== undefined ? layer.primary_abbr_field : "code";
            if (layer.primary_abbr_field === undefined)
                layer.primary_abbr_field = layer.primary_id
        });
        mapobject._lookup = create_lookups(mapobject, chart.mapProperties.geocode);
        compute_brects_and_label_positions(mapobject._baseLayer);
        compute_domains_and_aspect(mapobject._baseLayer);
        if (mapobject.domain === undefined)
            mapobject.domain = mapobject._baseLayer._domain;
        if (mapobject.aspectRatio === undefined)
            mapobject.aspectRatio = mapobject._baseLayer._aspectRatio;
        return mapobject
    }
    function mapAutoSelect(chart, data) {
        var placesMap = {};
        tdgchart.prototype.mapLibrary.forEach(function(m, i) {
            if (m.auto)
                m.places.forEach(function(p) {
                    var name = normalize(p);
                    if (Array.isArray(placesMap[name]))
                        placesMap[name].push(i);
                    else
                        placesMap[name] = [i]
                })
        });
        var placesMatch = tdgchart.prototype.mapLibrary.map(function(m) {
            return {
                count: 0,
                area: (m.domain[1].lng - m.domain[0].lng) * (m.domain[1].lat - m.domain[0].lat)
            }
        });
        var noMatches = false;
        data.forEach(function(group) {
            group.forEach(function(d) {
                if (d.name)
                    d = d.name;
                else if (Array.isArray(d) && typeof d[0] === "string")
                    d = d[0];
                if (typeof d === "string") {
                    var maps = placesMap[normalize(d)];
                    if (maps)
                        maps.forEach(function(idx) {
                            placesMatch[idx].count++
                        });
                    else
                        noMatches = true
                }
            })
        });
        if (noMatches) {
            noMatches = false;
            if (Array.isArray(chart.groupLabels))
                chart.groupLabels.forEach(function(d) {
                    if (typeof d === "string") {
                        var maps = placesMap[normalize(d)];
                        if (maps)
                            maps.forEach(function(idx) {
                                placesMatch[idx].count++
                            });
                        else
                            noMatches = true
                    }
                })
        }
        if (noMatches)
            return tdgchart.prototype.mapLibrary[1].file;
        var selected;
        placesMatch.forEach(function(mm, mapIdx) {
            if (!mm.count)
                return;
            if (!selected || mm.count > placesMatch[selected].count || mm.count == placesMatch[selected].count && mm.area < placesMatch[selected].area)
                selected = mapIdx
        });
        return tdgchart.prototype.mapLibrary[selected || 1].file
    }
    function mapSimplify(mapobject, precision) {
        var pre = 0
          , post = 0;
        mapobject.regions.forEach(function(r) {
            for (var b = 0; b < r.borders.length; b++) {
                var filtered = GDouglasPeucker(r.borders[b], precision);
                pre += r.borders[b].length;
                post += filtered.length;
                r.borders[b] = filtered
            }
        })
    }
    function GDouglasPeucker(source, kink) {
        var n_source, n_stack, n_dest, start, end, i, sig;
        var dev_sqr, max_dev_sqr, band_sqr;
        var x12, y12, d12, x13, y13, d13, x23, y23, d23;
        var F = Math.PI / 180 * .5;
        var index = new Array;
        var sig_start = new Array;
        var sig_end = new Array;
        if (source.length < 3)
            return source;
        n_source = source.length;
        band_sqr = kink * 360 / (2 * Math.PI * 6378137);
        band_sqr *= band_sqr;
        n_dest = 0;
        sig_start[0] = 0;
        sig_end[0] = n_source - 1;
        n_stack = 1;
        while (n_stack > 0) {
            start = sig_start[n_stack - 1];
            end = sig_end[n_stack - 1];
            n_stack--;
            if (end - start > 1) {
                x12 = source[end][0] - source[start][0];
                y12 = source[end][1] - source[start][1];
                if (Math.abs(x12) > 180)
                    x12 = 360 - Math.abs(x12);
                x12 *= Math.cos(F * (source[end][1] + source[start][1]));
                d12 = x12 * x12 + y12 * y12;
                for (i = start + 1,
                sig = start,
                max_dev_sqr = -1; i < end; i++) {
                    x13 = source[i][0] - source[start][0];
                    y13 = source[i][1] - source[start][1];
                    if (Math.abs(x13) > 180)
                        x13 = 360 - Math.abs(x13);
                    x13 *= Math.cos(F * (source[i][1] + source[start][1]));
                    d13 = x13 * x13 + y13 * y13;
                    x23 = source[i][0] - source[end][0];
                    y23 = source[i][1] - source[end][1];
                    if (Math.abs(x23) > 180)
                        x23 = 360 - Math.abs(x23);
                    x23 *= Math.cos(F * (source[i][1] + source[end][1]));
                    d23 = x23 * x23 + y23 * y23;
                    if (d13 >= d12 + d23)
                        dev_sqr = d23;
                    else if (d23 >= d12 + d13)
                        dev_sqr = d13;
                    else
                        dev_sqr = (x13 * y12 - y13 * x12) * (x13 * y12 - y13 * x12) / d12;
                    if (dev_sqr > max_dev_sqr) {
                        sig = i;
                        max_dev_sqr = dev_sqr
                    }
                }
                if (max_dev_sqr < band_sqr) {
                    index[n_dest] = start;
                    n_dest++
                } else {
                    n_stack++;
                    sig_start[n_stack - 1] = sig;
                    sig_end[n_stack - 1] = end;
                    n_stack++;
                    sig_start[n_stack - 1] = start;
                    sig_end[n_stack - 1] = sig
                }
            } else {
                index[n_dest] = start;
                n_dest++
            }
        }
        index[n_dest] = n_source - 1;
        n_dest++;
        var r = new Array;
        for (i = 0; i < n_dest; i++)
            r.push(source[index[i]]);
        return r
    }
}
)();
(function() {
    var TOOLTIP_DEFAULT_TIMEOUT = 1200;
    var tdg = tdgchart.util;
    var calloutOffset = .2;
    var arrowWidth = 20;
    var padding = 0;
    var halfArrowWidth = arrowWidth / 2;
    var defaultBackgroundColor = "rgba(250, 241, 179, 0.93)";
    var defaultBorderColor = "rgba(243, 219, 63, 0.93)";
    var defaultBorderWidth = 2;
    var defaultBorderRadius = 6;
    var tooltipScrollBackgroundColor = "lightgray";
    var tooltipScrollColor = "gray";
    var tooltipScrollTreshold = 7;
    var currentTarget;
    tdgchart.prototype.needHTMLToolTip = function() {
        return this.htmlToolTip.enabled && this.series.some(function(el) {
            return !!el.tooltip
        })
    }
    ;
    tdgchart.prototype.getInternalToolTip = function() {
        function f() {}
        return {
            content: f,
            position: f,
            snap: f,
            show: f,
            hide: f,
            toggle: f,
            arrow: f
        }
    }
    ;
    tdgchart.createExternalToolTip = function(container, id) {
        if (typeof container === "string")
            container = document.getElementById(container);
        if (container == null)
            container = document.body;
        var chart = new tdgchart;
        chart.documentRoot = container.getAttribute("id");
        var toolTipDiv = chart.createHTMLToolTip(tdgchart.d3.select(container), null, true);
        toolTipDiv.setAttribute("id", id || "tdgchart-tooltip-user");
        toolTipDiv.isMoonbeamTooltip = false;
        toolTipDiv.chartRoot = null;
        var tooltip = createToolTipObject(chart, toolTipDiv);
        tooltip._container = container;
        tooltip.position(0, 0).content("Empty Tooltip");
        return tooltip
    }
    ;
    function createToolTipObject(chart, tooltip) {
        return {
            dom: tooltip,
            content: function(html, d, data, ids) {
                if (!html)
                    return this.dom.innerHTML;
                html = chart.resolveToolTipSeriesContent(html, d, data, ids, tooltip.parentNode);
                tdg.dom.empty(this.dom);
                this.dom.appendChild(html);
                return this
            },
            style: function(style) {
                var sheet = this._container.getElementsByTagName("style")[0];
                if (!sheet || !sheet.sheet && !sheet.styleSheet)
                    return this;
                sheet = sheet.sheet || sheet.styleSheet;
                var rules = sheet.cssRules || sheet.rules;
                var styleSheet;
                var rootID = this._container.getAttribute("id");
                var selector = (rootID == null ? "" : "." + rootID) + ".tdgchart-tooltip";
                for (var i = 0; i < rules.length; i++)
                    if (rules[i].selectorText === selector) {
                        styleSheet = rules[i].style;
                        break
                    }
                if (styleSheet) {
                    if (!style)
                        return styleSheet;
                    for (var el in style)
                        if (style.hasOwnProperty(el))
                            styleSheet[el] = style[el]
                }
                return this
            },
            clipToViewport: function(clip) {
                if (clip == null)
                    return this._clipToViewport;
                this.dom.chartRoot = document.documentElement;
                this._clipToViewport = clip;
                return this
            },
            position: function(x, y) {
                if (x == null && y == null)
                    return {
                        x: this.dom.offsetLeft,
                        y: this.dom.offsetTop + this.dom.parentNode.offsetTop
                    };
                var containerBox = this._container.getBoundingClientRect();
                x = tdg.applyNumOrPercent(x, containerBox.width);
                y = tdg.applyNumOrPercent(y, containerBox.height);
                if (this._arrowSide) {
                    var box = this.dom.getBoundingClientRect();
                    x -= this._arrowSide === "right" ? box.width + halfArrowWidth : -halfArrowWidth;
                    y -= box.height * calloutOffset + halfArrowWidth / 2
                }
                if (this._clipToViewport) {
                    var originalTooltipBox = this.dom.getBoundingClientRect();
                    var tooltipBox = tdg.geom.normalizeRect(originalTooltipBox);
                    tdg.dom.walk(this.dom, function(node) {
                        var cls = node && node.getAttribute ? node.getAttribute("class") : "";
                        if (cls && cls.includes("tdgchart-submenu"))
                            tooltipBox = tdg.geom.union(tooltipBox, node.getBoundingClientRect())
                    });
                    if (x != null) {
                        var viewportWidth = document.body.getBoundingClientRect().width;
                        var maxX = Math.max(0, viewportWidth - originalTooltipBox.width - 1) + window.pageXOffset;
                        x = tdg.bound(x, 0, maxX)
                    }
                    if (y != null) {
                        var viewportHeight = document.documentElement.clientHeight;
                        var maxY = Math.max(0, viewportHeight - tooltipBox.height - 1) + window.pageYOffset;
                        y = tdg.bound(y, 0, maxY)
                    }
                }
                if (y != null)
                    y -= this.dom.parentNode.offsetTop;
                if (x != null)
                    this.dom.style.left = x + "px";
                if (y != null)
                    this.dom.style.top = y + "px";
                if (this._clipToViewport) {
                    var docRight = document.body.getBoundingClientRect().right;
                    tdg.dom.walk(this.dom, function(node) {
                        var cls = node && node.getAttribute ? node.getAttribute("class") : "";
                        if (cls && cls.includes("tdgchart-submenu"))
                            if (docRight < node.getBoundingClientRect().right)
                                node.style.left = "-50%"
                    })
                }
                return this
            },
            properties: function(props) {
                if (props == null)
                    return chart.htmlToolTip;
                tdg.mergeObjects(props, chart.htmlToolTip);
                modifyCascadeToolTipCSS(chart, tooltip.parentNode.parentNode);
                if (props.style)
                    this.style(props.style);
                return this
            },
            snap: function(target, side) {
                if (typeof target === "string")
                    target = document.getElementById(target);
                snapUserToolTip(target, this.dom, side || "right");
                return this
            },
            show: function() {
                this.dom._lastActiveElement = document.activeElement;
                showAndFocusMenu(this.dom);
                return this
            },
            hide: function() {
                this.dom.isMoonbeamTooltip = true;
                chart.hideToolTip(this.dom);
                this.dom.isMoonbeamTooltip = false;
                return this
            },
            toggle: function() {
                if (this.dom.style.visibility === "hidden")
                    this.show();
                else
                    this.hide();
                return this
            },
            arrow: function(side) {
                side = side || "right";
                this._arrowSide = side;
                addCalloutArrow(this.dom, side);
                return this
            },
            autoHide: function(hide) {
                this._autoHideEnabled = hide;
                if (this._autoHideInitialized)
                    return this;
                var lastPos, tooltip = this;
                chart.globalMouseMoveAdd(function(e) {
                    if (tooltip.dom.style.visibility !== "visible" || !tooltip._autoHideEnabled)
                        return this;
                    var mousePos = tdg.getMousePosition(e);
                    if (!lastPos) {
                        lastPos = mousePos;
                        return this
                    }
                    if (tdg.geom.equal(lastPos, mousePos))
                        return this;
                    var toolTipBox = tooltip.dom.getBoundingClientRect();
                    var dx = mousePos.x - lastPos.x
                      , dy = mousePos.y - lastPos.y;
                    if (mousePos.x < toolTipBox.left - 8 && dx < 0 || mousePos.x > toolTipBox.right || mousePos.y < toolTipBox.top - 8 || mousePos.y > toolTipBox.bottom + 22 && dy > 0) {
                        var inChild = false;
                        tdg.dom.walk(tooltip.dom, function(node) {
                            var cls = node && node.getAttribute ? node.getAttribute("class") : "";
                            if (cls && cls.includes("tdgchart-submenu"))
                                if (tdg.geom.intersect(mousePos, node.getBoundingClientRect()))
                                    inChild = true
                        });
                        if (!inChild) {
                            tooltip.hide();
                            lastPos = null
                        }
                    } else
                        lastPos = mousePos;
                    return this
                }, "createToolTipObject");
                this._autoHideInitialized = true;
                return this
            }
        }
    }
    function cssLine(prop, val) {
        return "\t" + prop + ": " + val + ";\n"
    }
    function getToolTipBorder(chart) {
        var border = chart.htmlToolTip.border || {};
        return {
            color: border.color || defaultBorderColor,
            width: border.width == null ? defaultBorderWidth : border.width,
            cornerRadius: border.cornerRadius == null ? defaultBorderRadius : border.cornerRadius
        }
    }
    function isCSS(node) {
        return node && node.nodeName === "STYLE"
    }
    function createToolTipCSS(chart, cssContainer, cachedCallbacks) {
        if (isCSS(cssContainer.firstChild))
            return;
        var color = chart.htmlToolTip.fill || defaultBackgroundColor;
        var border = getToolTipBorder(chart);
        var css = chart.cache.get("css", "");
        var rootID = chart.documentRoot ? "." + chart.documentRoot : "";
        css += rootID;
        css += ".tdgchart-tooltip {\n";
        css += cssLine("font", "10pt Sans-Serif");
        css += cssLine("color", "black");
        css += cssLine("background", color);
        css += cssLine("border", tdg.formatString("{0}px solid {1}", border.width, border.color));
        css += cssLine("border-radius", border.cornerRadius + "px");
        var style = chart.htmlToolTip.style;
        if (typeof style === "object")
            for (var el in style) {
                if (style.hasOwnProperty(el))
                    if (typeof style[el] === "function")
                        cachedCallbacks[el] = style[el];
                    else
                        css += cssLine(el.replace(/([a-z\d])([A-Z])/g, "$1-$2").toLowerCase(), style[el])
            }
        else if (typeof style === "string" && style !== "seriesFill")
            css += style;
        css += "}\n";
        css += ".tdgchart-tooltip-pad {\n\tpadding: 3px .4em 3px .4em;\n}\n";
        css += ".tdgchart-tooltip-submenu-pad {\n\tpadding-right: 1em;\n}\n";
        css += ".tdgchart-tooltip ul.tdgchart-tooltip-list::-webkit-scrollbar {\n\twidth: 6px;  background-color: " + tooltipScrollBackgroundColor + ";\n}\n";
        css += ".tdgchart-tooltip ul.tdgchart-tooltip-list::-webkit-scrollbar-thumb {\n\t background-color: " + tooltipScrollColor + ";\n}\n";
        css += ".tdgchart-tooltip ul.tdgchart-tooltip-list {\n\t scrollbar-color: " + tooltipScrollColor + " " + tooltipScrollBackgroundColor + "; scrollbar-width: " + "thin" + ";\n}\n";
        var styleNode = document.createElement("style");
        styleNode.type = "text/css";
        if (styleNode.styleSheet)
            styleNode.styleSheet.cssText = css;
        else
            styleNode.appendChild(document.createTextNode(css));
        if (cssContainer.firstChild)
            cssContainer.insertBefore(styleNode, cssContainer.firstChild);
        else
            cssContainer.appendChild(styleNode)
    }
    function getToolTipContainerID(chart) {
        return chart.documentRoot + "_tdgchart-tooltip"
    }
    function resetTooltipContainer(chart) {
        if (chart.htmlToolTip.containerNode) {
            var tooltipParentDiv = document.getElementById(chart.htmlToolTip.containerNode + "-ttc");
            if (tooltipParentDiv)
                tooltipParentDiv.remove()
        }
    }
    tdgchart.prototype.createHTMLToolTip = function(root, cachedCallbacks, isUserToolTip) {
        var chart = this;
        var rootNode = root.node();
        var container = rootNode;
        if (chart.htmlToolTip.containerNode)
            container = document.getElementById(chart.htmlToolTip.containerNode);
        if (!isUserToolTip) {
            var existingTooltip = document.getElementById(getToolTipContainerID(chart));
            if (existingTooltip)
                return existingTooltip
        }
        var emptyParentDiv = document.createElement("div");
        if (chart.htmlToolTip.containerNode)
            emptyParentDiv.id = chart.htmlToolTip.containerNode + "-ttc";
        emptyParentDiv.style.display = "block";
        emptyParentDiv.style.position = "relative";
        emptyParentDiv.style.border = "none";
        emptyParentDiv.style.zIndex = 20;
        createToolTipCSS(chart, emptyParentDiv, cachedCallbacks);
        var toolTipDiv = document.createElement("span");
        toolTipDiv.id = getToolTipContainerID(chart);
        toolTipDiv.className = rootNode.getAttribute("id") + " tdgchart-tooltip";
        toolTipDiv.style.display = "inline-block";
        toolTipDiv.style.position = "absolute";
        toolTipDiv.style.visibility = "hidden";
        toolTipDiv.style.whiteSpace = "nowrap";
        toolTipDiv.style.left = "-20px";
        toolTipDiv.style.top = "-20px";
        toolTipDiv.chartRoot = rootNode;
        emptyParentDiv.appendChild(toolTipDiv);
        container.appendChild(emptyParentDiv);
        if (!isUserToolTip)
            chart.getInternalToolTip = function() {
                var res = createToolTipObject(chart, toolTipDiv);
                res._container = container;
                return res
            }
            ;
        return toolTipDiv
    }
    ;
    tdgchart.prototype.hideToolTip = function(toolTipDiv) {
        var chart = this;
        if (toolTipDiv == null)
            toolTipDiv = document.getElementById(getToolTipContainerID(chart));
        if (toolTipDiv && toolTipDiv.isMoonbeamTooltip) {
            var submenu = getSubmenuContent(toolTipDiv);
            if (submenu) {
                var children = getFocusableChildren(submenu) || [];
                hideChildren(children);
                children.forEach(function(child) {
                    child.tabIndex = -1
                })
            }
            toolTipDiv.style.visibility = "hidden"
        }
    }
    ;
    tdgchart.prototype.setToolTipContent = function(tooltip, content, target) {
        var chart = this;
        tdg.dom.empty(tooltip);
        tooltip.isMoonbeamTooltip = true;
        if (target && target.hasOwnProperty("tdgtitle_dom"))
            tooltip.appendChild(target.tdgtitle_dom);
        else if (chart && content === "placeholder" && target && target.hasOwnProperty("tdgtitle")) {
            var node = target;
            if (target instanceof SVGElement && target.nodeName === "title")
                node = target.parentNode;
            var className = node.getAttribute("class");
            var ids = chart.classNameToIds(className);
            var datum = chart.getDataFromIds(ids);
            content = chart.resolveToolTipSeriesContent(target.tdgtitle, datum.d, datum.data, ids, tooltip.parentNode);
            target.tdgtitle_dom = content;
            tooltip.appendChild(content)
        } else if (typeof content === "string")
            tooltip.appendChild(createNode("div", {
                "class": "tdgchart-tooltip-pad"
            }, content));
        else
            tooltip.innerHTML = content + ""
    }
    ;
    tdgchart.prototype.getToolTipSize = function(toolTipDiv) {
        if (!toolTipDiv || !toolTipDiv.getBoundingClientRect)
            return {
                width: 0,
                height: 0,
                overallWidth: 0,
                overallHeight: 0
            };
        var originalBox = toolTipDiv.getBoundingClientRect();
        var box = tdg.geom.normalizeRect(originalBox);
        tdg.dom.walk(toolTipDiv, function(node) {
            var cls = node && node.getAttribute ? node.getAttribute("class") : "";
            if (cls && cls.includes("tdgchart-submenu"))
                box = tdg.geom.union(box, node.getBoundingClientRect())
        });
        var res = tdg.clone(box);
        res.baseToolTip = tdg.clone(originalBox);
        return res
    }
    ;
    tdgchart.prototype.tooltipPosition = function(toolTipDiv, mousePos) {
        var res = {
            x: 0,
            y: 0
        };
        if (!toolTipDiv)
            return res;
        var chart = this;
        var tooltipOffset, margin, dh, hBound;
        var cursorHeight = 15;
        var topOffset = -chart.height;
        var toolTipSize = chart.getToolTipSize(toolTipDiv);
        if (isStickyContent(chart, toolTipDiv)) {
            tooltipOffset = 1;
            margin = 19;
            dh = toolTipSize.height + margin;
            if (mousePos.y - toolTipSize.baseToolTip.height - margin - 2 < 0)
                if (mousePos.y + dh + cursorHeight + 2 > chart.height) {
                    hBound = -mousePos.y + 2;
                    res.isBelow = false
                } else {
                    hBound = margin + cursorHeight;
                    res.isBelow = true
                }
            else {
                var offscreen = Math.max(0, mousePos.y - toolTipSize.baseToolTip.height - margin + toolTipSize.height - chart.height + 2);
                hBound = -(toolTipSize.baseToolTip.height + margin + offscreen);
                res.isBelow = false
            }
        } else {
            tooltipOffset = .8;
            margin = Math.max(chart.htmlToolTip.mouseMargin || 6, 6);
            dh = toolTipSize.height + margin;
            hBound = chart.height - dh - chart.getPadding("label", "aveVert") - cursorHeight < mousePos.y ? -dh : margin + cursorHeight
        }
        var dw = toolTipSize.baseToolTip.width;
        var lx = Math.max(mousePos.x - dw * (1 - tooltipOffset), Math.max(5, chart.getPadding("frame", "left")));
        var rx = Math.min(mousePos.x + dw * tooltipOffset, chart.width - dw - 5 - chart.getPadding("frame", "right"));
        res.x = Math.min(lx, rx);
        res.y = topOffset + hBound + mousePos.y;
        if (chart.htmlToolTip.containerNode) {
            var tooltipContainerPos = toolTipDiv.parentElement.getBoundingClientRect();
            var chartContainerPos = document.getElementById(chart.documentRoot).getBoundingClientRect();
            return {
                x: res.x + (chartContainerPos.left - tooltipContainerPos.left) + "px",
                y: res.y + (chartContainerPos.bottom - tooltipContainerPos.top) + "px",
                isBelow: res.isBelow
            }
        }
        res.x += "px";
        res.y += "px";
        return res
    }
    ;
    function isStickyContent(chart, tooltip) {
        if (chart.htmlToolTip.sticky === "auto")
            return chart.tooltipContainsClickItems(tooltip);
        return chart.htmlToolTip.sticky
    }
    function findToolTipParent(target) {
        while (target && !target.hasAttribute("tdgtitle"))
            target = target.parentNode;
        return target
    }
    tdgchart.prototype.addHTMLToolTips = function(svgContainer) {
        var chart = this;
        var chartType = chart.chartType;
        var isNearestNeighbor = false;
        var isTabbingOverride = false;
        resetTooltipContainer(chart);
        if (chartType === "map" && chart.mapProperties.engine === "leaflet")
            return;
        var mainChartType = chartType === "matrix" ? chart.matrixProperties.chartType : chartType;
        if (mainChartType === "line" || mainChartType == "radar" || mainChartType === "control" || mainChartType === "area" || mainChartType === "streamgraph" || mainChartType === "scatter" || mainChartType === "bubble" || chart.isComboChart())
            isNearestNeighbor = true;
        if (chart.interaction.mousemove && chart.interaction.mousemove.toLowerCase() !== "nearestneighbor" && (mainChartType === "scatter" || mainChartType === "bubble"))
            isNearestNeighbor = false;
        var cachedCallbacks = {};
        var root = tdgchart.d3.select("#" + chart.documentRoot);
        svgContainer = svgContainer || root.select("svg");
        var toolTipDiv, mousePos, pageMousePos;
        var selector = isNearestNeighbor ? "[tdgtitle]:not([class*=marker]):not([class*=riser])" : "[tdgtitle]";
        var risers = svgContainer.selectAll(selector).filter(function() {
            return this.getAttribute("tdgtitle") === "" ? null : this
        }).on("mouseover.tooltip", mouseOver);
        if (!chart.htmlToolTip.snap || chartType === "streamgraph") {
            risers.on("mousemove.tooltip", mouseMove);
            risers.on("mouseout.tooltip", mouseOut)
        }
        if (chart.htmlToolTip.sticky && chartType !== "area" && chartType !== "streamgraph")
            if (chart.htmlToolTip.snap) {
                risers.on("mouseout.tooltip", stickySnapMouseOut);
                var eventPanel = root.select(".eventPanel").on("mouseout.tooltip", stickySnapMouseOut);
                if (eventPanel.node())
                    eventPanel.node().firstChild.setAttribute("class", "eventPanel")
            } else
                svgContainer.on("mousemove.tooltip", stickyMouseMove);
        function getTooltipDelay(chart, toolTipDiv, context) {
            var timeout, hasInteractiveItems = toolTipDiv && chart.tooltipContainsClickItems(toolTipDiv);
            if (!hasInteractiveItems) {
                timeout = chart.htmlToolTip.hideTimeout.time || TOOLTIP_DEFAULT_TIMEOUT;
                if (context === "touch" && chart.htmlToolTip.hideTimeout.touch)
                    timeout = chart.htmlToolTip.hideTimeout.touch
            } else {
                timeout = chart.htmlToolTip.hideTimeout.clickable || 3 * TOOLTIP_DEFAULT_TIMEOUT;
                if (context === "touch" && chart.htmlToolTip.hideTimeout.touchClickable)
                    timeout = chart.htmlToolTip.hideTimeout.touchClickable
            }
            return timeout
        }
        function touchEnd(root, d, data, e) {
            var delay, toolTipList = root.node().getElementsByClassName("tdgchart-tooltip");
            for (var i = 0; i < toolTipList.length; i++)
                if (toolTipList[i].contains(e.target)) {
                    if (hideDelayTimer) {
                        window.clearTimeout(hideDelayTimer);
                        delay = getTooltipDelay(chart, toolTipDiv, "touch");
                        hideDelayTimer = window.setTimeout(tdg.partial(chart.hideToolTip, [toolTipDiv], chart), delay)
                    }
                    return
                }
            var isHtmlLink = e.target instanceof HTMLElement && e.target.tagName === "A";
            if (!isHtmlLink)
                e.preventDefault();
            if (hideDelayTimer) {
                window.clearTimeout(hideDelayTimer);
                hideDelayTimer = null
            }
            chart.htmlToolTip.sticky = false;
            if (risers[0].indexOf(e.target) >= 0) {
                var mouseNear = tdgchart.prototype.mouseNearTooltip;
                tdgchart.prototype.mouseNearTooltip = function() {
                    return false
                }
                ;
                mouseOver.call(e.target, d, data, e);
                tdgchart.prototype.mouseNearTooltip = mouseNear;
                delay = getTooltipDelay(chart, toolTipDiv, "touch");
                hideDelayTimer = window.setTimeout(tdg.partial(chart.hideToolTip, [toolTipDiv], chart), delay)
            } else if (toolTipDiv)
                chart.hideToolTip(toolTipDiv)
        }
        root.on("touchend.tooltip", tdg.partial(touchEnd, [root, null, null, null]));
        if (isNearestNeighbor) {
            chart.cache.set("forceNearestNeighbor", true);
            chart.nearestNeighborMouseHandler()
        }
        function displayTooltip(riser, isTabbing) {
            if (chart._disableToolTips)
                return;
            if (toolTipDiv == null)
                toolTipDiv = chart.createHTMLToolTip(root, cachedCallbacks);
            var target = findToolTipParent(riser);
            if (chart.htmlToolTip.style === "seriesFill") {
                var seriesColor = target.getAttribute("fill") || target.fill;
                if (typeof seriesColor === "object")
                    seriesColor = seriesColor.color.value;
                if (seriesColor) {
                    if (seriesColor.startsWith("url(#")) {
                        seriesColor = (seriesColor.match(/^url\(#([a-zA-Z0-9_]*)\)$/) || [])[1];
                        seriesColor = document.getElementById(seriesColor);
                        if (seriesColor)
                            seriesColor = seriesColor.querySelector("stop").getAttribute("stop-color")
                    }
                    seriesColor = tdg.color(seriesColor);
                    toolTipDiv.style.background = seriesColor.toString();
                    toolTipDiv.style.borderColor = seriesColor.lighter(-.2).toString()
                }
            }
            if (!tdg.isEmpty(cachedCallbacks)) {
                var ids = chart.classNameToIds(target.getAttribute("class") || target.getAttribute("className"));
                for (var el in cachedCallbacks)
                    if (cachedCallbacks.hasOwnProperty(el))
                        toolTipDiv.style[el] = cachedCallbacks[el].call(chart, ids.series, ids.group, ids.misc, target)
            }
            hideChildren(getFocusableChildren(getSubmenuContent(toolTipDiv)));
            chart.setToolTipContent(toolTipDiv, target.getAttribute("tdgtitle"), target);
            if (!isStickyContent(chart, toolTipDiv) || chart.htmlToolTip.snap)
                if (chart.htmlToolTip.enabled)
                    toolTipDiv.style.visibility = "visible";
            if (isTabbing) {
                isTabbingOverride = true;
                toolTipDiv.style.visibility = "visible";
                if (hideDelayTimer) {
                    window.clearTimeout(hideDelayTimer);
                    hideDelayTimer = null
                }
                chart.snapToolTip(chartType, target, toolTipDiv);
                var submenu = getSubmenuContent(toolTipDiv);
                if (submenu) {
                    var children = getFocusableChildren(submenu) || [];
                    children.forEach(unhighlight);
                    moveFocus(chart, null, children[0], true);
                    submenu.__focusTarget = 0
                }
            }
        }
        chart.cache.set("tooltipsFunctions", {
            displayTooltip: displayTooltip,
            hideToolTip: chart.hideToolTip
        });
        function mouseOver(d, data, e) {
            if (toolTipDiv == null)
                toolTipDiv = chart.createHTMLToolTip(root, cachedCallbacks);
            var target = e.target || e.srcElement;
            if (!target || chart._disableToolTips)
                return;
            if (chart.mouseNearTooltip(toolTipDiv, pageMousePos)) {
                toolTipDiv.newTarget = target;
                return
            }
            displayTooltip(target);
            if (chart.htmlToolTip.snap) {
                chart.snapToolTip(chartType, target, toolTipDiv);
                if (!chart.htmlToolTip.sticky)
                    tdgchart.d3.select(".tooltipCallout").on("mouseout.tooltip", mouseOut)
            } else
                mouseMove(d, data, e)
        }
        var visibleDelayTimer, hideDelayTimer;
        chart.globalMouseMoveAdd(function(e) {
            mousePos = chart.mousePosition(root, e);
            pageMousePos = tdg.getMousePosition(e)
        }, "addHTMLToolTips");
        chart.globalKeyUpAdd(tdg.partial(tooltipGlobalKeyUpHandler, [null, chart, root]), "tooltipKey");
        chart.globalKeyDownAdd(tdg.partial(tooltipGlobalKeyDownHandler, [null, chart, root]), "tooltipKey");
        function hideStickyToolTip() {
            if (visibleDelayTimer) {
                window.clearTimeout(visibleDelayTimer);
                visibleDelayTimer = null
            }
            if (toolTipDiv) {
                if (toolTipDiv.newTarget) {
                    chart.setToolTipContent(toolTipDiv, toolTipDiv.newTarget.getAttribute("tdgtitle"), toolTipDiv.newTarget);
                    toolTipDiv.newTarget = undefined
                }
                chart.hideToolTip(toolTipDiv)
            }
        }
        function showToolTipTimerCallback() {
            if (!document.body.contains(toolTipDiv))
                return;
            var chartBox = {
                x: 0,
                y: 0,
                width: root.node().clientWidth,
                height: root.node().clientHeight
            };
            if (!tdg.geom.intersect(mousePos, chartBox))
                return;
            var tooltipPos = chart.tooltipPosition(toolTipDiv, mousePos);
            toolTipDiv.style.left = tooltipPos.x;
            toolTipDiv.style.top = tooltipPos.y;
            toolTipDiv.style.bottom = "";
            if (chart.htmlToolTip.enabled)
                toolTipDiv.style.visibility = "visible";
            toolTipDiv.isBelow = tooltipPos.isBelow;
            hideDelayTimer = window.setTimeout(hideToolTipTimerCallback, getTooltipDelay(chart))
        }
        var lastMousePos = {
            x: 0,
            y: 0
        }
          , inCount = 0;
        function hideToolTipTimerCallback() {
            if (!toolTipDiv || !document.body.contains(toolTipDiv))
                return;
            var nearStatus = chart.mouseNearTooltip(toolTipDiv, pageMousePos);
            if (nearStatus == "scrollable")
                hideDelayTimer = window.setTimeout(hideToolTipTimerCallback, getTooltipDelay(chart));
            else if (nearStatus && inCount < 3) {
                hideDelayTimer = window.setTimeout(hideToolTipTimerCallback, getTooltipDelay(chart));
                inCount = tdg.geom.equal(lastMousePos, mousePos) ? inCount + 1 : 0
            } else {
                chart.hideToolTip(toolTipDiv);
                inCount = 0
            }
            lastMousePos = mousePos
        }
        function mouseMove(d, data, e) {
            if (chart._disableToolTips)
                return;
            mousePos = chart.mousePosition(root, e);
            pageMousePos = tdg.getMousePosition(e);
            if (toolTipDiv == null)
                toolTipDiv = chart.createHTMLToolTip(root);
            if (isTabbingOverride) {
                isTabbingOverride = false;
                displayTooltip(e.target || e.srcElement)
            }
            if (isStickyContent(chart, toolTipDiv) && !chart.htmlToolTip.snap) {
                if (e.stopPropagation)
                    e.stopPropagation();
                if (visibleDelayTimer) {
                    window.clearTimeout(visibleDelayTimer);
                    visibleDelayTimer = null
                }
                if (hideDelayTimer) {
                    window.clearTimeout(hideDelayTimer);
                    hideDelayTimer = null
                }
                if (toolTipDiv.style.visibility === "visible")
                    if (chart.mouseNearTooltip(toolTipDiv, pageMousePos))
                        hideDelayTimer = window.setTimeout(hideToolTipTimerCallback, getTooltipDelay(chart));
                    else
                        hideStickyToolTip();
                else
                    visibleDelayTimer = window.setTimeout(showToolTipTimerCallback, 270)
            } else {
                var tooltipPos = chart.tooltipPosition(toolTipDiv, mousePos);
                toolTipDiv.style.left = tooltipPos.x;
                toolTipDiv.style.top = tooltipPos.y;
                toolTipDiv.style.bottom = ""
            }
        }
        function mouseOut(d, data, e) {
            if (e && toolTipDiv && !isStickyContent(chart, toolTipDiv)) {
                var c;
                if (e.relatedTarget) {
                    c = e.relatedTarget.getAttribute("class");
                    if (!c && e.relatedTarget.parentNode && typeof e.relatedTarget.parentNode.getAttribute === "function")
                        c = e.relatedTarget.parentNode.getAttribute("class")
                }
                if (!c || !c.includes("tooltipCallout") && !c.includes("selectionRect") && !c.includes("dataLabel"))
                    chart.hideToolTip(toolTipDiv);
                if (e && e.target && e.target.getAttribute("class") === "tooltipCallout")
                    tdgchart.d3.select(".hoverFill").attr("display", "none")
            }
        }
        function stickyMouseMove() {
            if (!toolTipDiv || !isStickyContent(chart, toolTipDiv))
                return;
            if (hideDelayTimer) {
                window.clearTimeout(hideDelayTimer);
                hideDelayTimer = null
            }
            if (chart.mouseNearTooltip(toolTipDiv, pageMousePos))
                hideDelayTimer = window.setTimeout(hideToolTipTimerCallback, getTooltipDelay(chart));
            else
                hideStickyToolTip()
        }
        function stickySnapMouseOut(d, data, e) {
            if (e && e.relatedTarget && toolTipDiv) {
                var c = e.relatedTarget.getAttribute("class");
                if (c && c.indexOf("tooltip") >= 0)
                    return;
                if (!c || c === "background" || c.indexOf("baseLine") >= 0 || !e.relatedTarget.ownerSVGElement)
                    chart.hideToolTip(toolTipDiv)
            }
        }
    }
    ;
    tdgchart.prototype.mouseNearTooltip = function(toolTipDiv, mousePos) {
        var chart = this;
        if (!mousePos || !toolTipDiv || toolTipDiv.style.visibility !== "visible")
            return false;
        var inChild = false;
        var isChildScrollable;
        tdg.dom.walk(toolTipDiv, function(node) {
            var cls = node && node.getAttribute ? node.getAttribute("class") : "";
            if (cls && cls.includes("tdgchart-submenu"))
                if (tdg.geom.intersect(mousePos, node.getBoundingClientRect())) {
                    inChild = true;
                    if (node.style.visibility === "visible" && node.getAttribute("tdgscrollable") === "1")
                        isChildScrollable = true
                }
        });
        if (inChild)
            return isChildScrollable ? "scrollable" : true;
        var toolTipBox = chart.getToolTipSize(toolTipDiv);
        if (mousePos.x < toolTipBox.left - 8 || mousePos.x > toolTipBox.right)
            return false;
        var top = toolTipBox.top
          , bottom = toolTipBox.bottom;
        if (toolTipDiv.isBelow)
            top -= 22 + 15;
        else
            bottom += 22;
        if (mousePos.y < top || mousePos.y > bottom)
            return false;
        if (tdgchart.d3.select(toolTipDiv).select(".root_container").attr("tdgscrollable") == "1")
            return "scrollable";
        return true
    }
    ;
    function snapUserToolTip(target, toolTipDiv, side) {
        var tooltipBox = toolTipDiv.parentNode.getBoundingClientRect();
        var targetBox = target.getBoundingClientRect();
        var arrowOffset = getArrowOffset(toolTipDiv).offset;
        var top = -tooltipBox.top + targetBox.top - arrowOffset + targetBox.height / 2;
        var left = -tooltipBox.left + targetBox.left;
        var bounds = {
            left: 0,
            width: 0
        };
        toolTipDiv.style.top = top + "px";
        if (side === "left")
            toolTipLeft(null, toolTipDiv, targetBox.width, left, bounds.width, false, bounds.left);
        else
            toolTipRight(null, toolTipDiv, targetBox.width, left, bounds.width, false, bounds.left)
    }
    tdgchart.prototype.snapToolTip = function(chartType, target, toolTipDiv, additionalOffset) {
        var chart = this;
        var o = chart.blaProperties.orientation === "horizontal";
        var arrowOffset = getArrowOffset(toolTipDiv).offset;
        var tooltipHeight = arrowOffset - toolTipDiv.offsetHeight + toolTipDiv.clientTop;
        var svgWidth = chart.width;
        var svgHeight = chart.height;
        var bbox, transform = {
            e: 0,
            f: 0
        };
        if (target.getCTM)
            transform = target.getCTM();
        var tx = transform.e;
        var ty = svgHeight - transform.f;
        var w, h, bottom;
        if (chartType === "map" && chart.mapProperties.engine === "leaflet" && additionalOffset) {
            bbox = target.getBBox();
            w = parseInt(bbox.width, 10);
            h = parseInt(bbox.height, 10);
            tx = additionalOffset.x + parseInt(bbox.x, 10);
            ty = svgHeight - additionalOffset.y - parseInt(bbox.y, 10);
            bottom = ty + tooltipHeight - h / 2;
            toolTipLeft(chart, toolTipDiv, w, tx, svgWidth, true)
        } else if (tdgchart.extensionManager.isExtension(chartType)) {
            var moonbeamSVG = document.getElementById(chart.documentRoot).getElementsByTagName("svg")[0];
            var svgCTM = moonbeamSVG.getScreenCTM();
            bbox = target.getBoundingClientRect();
            tx = bbox.left - svgCTM.e;
            ty = svgHeight - bbox.top + svgCTM.f;
            bottom = ty - bbox.height / 2 - (toolTipDiv.offsetHeight + toolTipDiv.clientTop) / 2;
            toolTipLeft(chart, toolTipDiv, bbox.width, tx, svgWidth, true)
        } else if (target.tagName === "rect" || target.tagName === "foreignObject") {
            w = parseInt(target.getAttribute("width"), 10) || 0;
            h = parseInt(target.getAttribute("height"), 10) || 0;
            tx += parseInt(target.getAttribute("x"), 10) || 0;
            ty -= parseInt(target.getAttribute("y"), 10) || 0;
            if (o && chartType === "bar" && target.tagName !== "foreignObject") {
                bottom = ty + tooltipHeight - h / 2;
                toolTipRight(chart, toolTipDiv, w, tx, svgWidth, false)
            } else {
                bottom = ty + tooltipHeight - halfArrowWidth;
                toolTipLeft(chart, toolTipDiv, w, tx, svgWidth, true)
            }
        } else if (target.tagName === "text") {
            tx += parseInt(target.getAttribute("x"), 10);
            ty -= parseInt(target.getAttribute("y"), 10);
            bottom = ty + tooltipHeight;
            toolTipLeft(chart, toolTipDiv, target.offsetWidth, tx - target.offsetWidth / 2, svgWidth, true)
        } else if (target.tagName === "path" && chartType === "pie") {
            var angle = tdg.boundAngle(parseFloat(target.getAttribute("tdg:angle")));
            var radius = parseFloat(target.getAttribute("tdg:outer-radius"));
            var dx = Math.cos(angle) * radius;
            var dy = Math.sin(angle) * radius;
            bottom = ty + tooltipHeight - dy;
            if (angle > Math.PI / 2 && angle <= 3 * Math.PI / 2)
                toolTipLeft(chart, toolTipDiv, 0, tx + dx, svgWidth, false);
            else
                toolTipRight(chart, toolTipDiv, 0, tx + dx, svgWidth, false)
        } else if (target.tagName === "path" && chartType === "bar") {
            target = target.parentNode.lastChild;
            bbox = target.getBBox();
            w = parseInt(bbox.width, 10);
            h = parseInt(bbox.height, 10);
            tx += parseInt(bbox.x, 10);
            ty -= parseInt(bbox.y, 10);
            if (o) {
                bottom = ty + tooltipHeight - h / 2;
                toolTipRight(chart, toolTipDiv, w, tx, svgWidth, false)
            } else {
                bottom = ty + tooltipHeight - halfArrowWidth;
                toolTipLeft(chart, toolTipDiv, w, tx, svgWidth, true)
            }
        } else if (target.tagName === "path" || target.tagName === "circle") {
            var r = parseInt(target.getAttribute("tdg:radius"), 10);
            if (isNaN(r))
                r = parseInt(target.getAttribute("r"), 10);
            if (isNaN(r)) {
                bbox = target.getBBox();
                w = parseInt(bbox.width, 10);
                h = parseInt(bbox.height, 10);
                tx += parseInt(bbox.x, 10);
                ty -= parseInt(bbox.y, 10);
                if ((target.getAttribute("class") || "").indexOf("mneedle") >= 0) {
                    var mtrx = target.getCTM();
                    tx += h * mtrx.c;
                    ty -= h * mtrx.a
                }
                bottom = ty - h / 2;
                toolTipLeft(chart, toolTipDiv, w, tx, svgWidth, true)
            } else {
                tx += parseInt(target.getAttribute("cx"), 10) || 0;
                ty -= parseInt(target.getAttribute("cy"), 10) || 0;
                if (chart.mouseOverIndicator.enabled && !chart.isDataDrivenMarkerSize() && chart.chartType !== "treemap" && chart.chartType !== "circlepack2")
                    r *= tdgchart._markerZoomFactor;
                bottom = ty + tooltipHeight;
                toolTipLeft(chart, toolTipDiv, r * 2, tx - r, svgWidth, true)
            }
        } else if (target instanceof HTMLElement)
            if (toolTipDiv.isMoonbeamTooltip) {
                bbox = target.getBoundingClientRect();
                tx = parseInt(target.style.left, 0);
                ty -= parseInt(target.style.top, 0);
                bottom = ty + tooltipHeight - halfArrowWidth;
                toolTipLeft(chart, toolTipDiv, bbox.width, tx, svgWidth, true)
            } else {
                bbox = target.getBoundingClientRect();
                tx = target.offsetLeft;
                bottom = toolTipDiv.parentNode.offsetTop - toolTipDiv.offsetHeight - target.offsetTop;
                toolTipRight(chart, toolTipDiv, bbox.width, tx, svgWidth, true)
            }
        toolTipDiv.style.top = null;
        if (chart.htmlToolTip.containerNode) {
            var tooltipContainerPos = toolTipDiv.parentElement.getBoundingClientRect();
            var chartContainerPos = document.getElementById(chart.documentRoot).getBoundingClientRect();
            toolTipDiv.style.bottom = bottom - (chartContainerPos.bottom - tooltipContainerPos.top) + "px"
        } else
            toolTipDiv.style.bottom = bottom + "px"
    }
    ;
    function toolTipLeft(chart, toolTipDiv, riserWidth, riserTransformX, maxWidth, checkSide, leftEdge) {
        leftEdge = leftEdge || 0;
        var left = riserTransformX - toolTipDiv.offsetWidth - halfArrowWidth - padding;
        if (checkSide && left < leftEdge) {
            toolTipRight(chart, toolTipDiv, riserWidth, riserTransformX, maxWidth, false);
            return
        }
        addCalloutArrow(toolTipDiv, "right");
        if (chart && chart.htmlToolTip.containerNode) {
            var tooltipContainerPos = toolTipDiv.parentElement.getBoundingClientRect();
            var chartContainerPos = document.getElementById(chart.documentRoot).getBoundingClientRect();
            toolTipDiv.style.left = left + (chartContainerPos.left - tooltipContainerPos.left) + "px"
        } else
            toolTipDiv.style.left = left + "px"
    }
    function toolTipRight(chart, toolTipDiv, riserWidth, riserTransformX, maxWidth, checkSide, leftEdge) {
        leftEdge = leftEdge || 0;
        var left = riserTransformX + riserWidth + halfArrowWidth + padding;
        if (checkSide && left + toolTipDiv.offsetWidth >= maxWidth + leftEdge) {
            toolTipLeft(chart, toolTipDiv, riserWidth, riserTransformX, maxWidth, false);
            return
        }
        addCalloutArrow(toolTipDiv, "left");
        if (chart && chart.htmlToolTip.containerNode) {
            var tooltipContainerPos = toolTipDiv.parentElement.getBoundingClientRect();
            var chartContainerPos = document.getElementById(chart.documentRoot).getBoundingClientRect();
            toolTipDiv.style.left = left + (chartContainerPos.left - tooltipContainerPos.left) + "px"
        } else
            toolTipDiv.style.left = left + "px"
    }
    function getArrowOffset(toolTipDiv) {
        var toolTipSize = parseInt(toolTipDiv.clientHeight, 10);
        var offset = calloutOffset * (1 - arrowWidth / toolTipSize);
        return {
            offset: offset * toolTipSize + halfArrowWidth,
            percentOffset: 100 * offset + "%"
        }
    }
    function addCalloutArrow(toolTipDiv, side) {
        var arrow = toolTipDiv.getElementsByClassName("tooltipCallout")[0];
        if (!arrow) {
            arrow = toolTipDiv.appendChild(document.createElement("span"));
            arrow.className = "tooltipCallout";
            arrow.style.position = "absolute";
            arrow.style.height = arrow.style.width = 0;
            arrow.style.content = " ";
            arrow.style.borderWidth = halfArrowWidth + "px";
            arrow.style.borderStyle = "solid";
            arrow.style.borderTopColor = "transparent";
            arrow.style.borderBottomColor = "transparent"
        }
        var percentOffset = getArrowOffset(toolTipDiv).percentOffset;
        if (side === "right") {
            arrow.style.borderLeftColor = "inherit";
            arrow.style.borderRightColor = "transparent";
            arrow.style.top = percentOffset;
            arrow.style.left = "100%";
            arrow.style.right = ""
        } else {
            arrow.style.borderRightColor = "inherit";
            arrow.style.borderLeftColor = "transparent";
            arrow.style.top = percentOffset;
            arrow.style.right = "100%";
            arrow.style.left = ""
        }
    }
    tdgchart.prototype.getDefaultToolTipField = function(d, shapeOverride) {
        var field, chart = this;
        if ((chart.chartType === "bubble" || chart.chartType === "scatter") && shapeOverride === "pie")
            field = chart.getDefaultDataField("pie");
        else
            field = chart.getDefaultDataField();
        if (field === "value" && d && d.hasOwnProperty("total"))
            field = "total";
        else if (field === "value" && d && d.hasOwnProperty("percent"))
            field = "percent";
        return field
    }
    ;
    tdgchart.prototype.resolveToolTipTitleContent = function(tooltip) {
        var chart = this;
        if (typeof tooltip === "string" && tooltip.indexOf("{") >= 0 && tooltip.indexOf("}") >= 0)
            return function() {
                var className;
                try {
                    className = this.className()
                } catch (e$28) {}
                var ids = chart.classNameToIds(className);
                var data = chart.data;
                if (ids.series != null && data[ids.series])
                    data = data[ids.series];
                var d = chart.data && chart.data[0] ? chart.data[0][0] : undefined;
                if (ids.series != null && ids.group != null && chart.data[ids.series] != null)
                    d = chart.data[ids.series][ids.group];
                return chart.parseTemplate(tooltip, d, data, ids)
            }
            ;
        return tooltip
    }
    ;
    tdgchart.prototype.resolveToolTipSeriesContent = function(tooltip, d, data, ids, cssContainer) {
        var chart = this;
        var res = tooltip;
        if (tooltip && typeof tooltip === "object" && !tdg.isEmpty(tooltip.regions))
            tooltip = tooltip.regions.map(function(el) {
                return tooltip[el]
            }).filter(function(el) {
                return el != null
            });
        if (Array.isArray(tooltip))
            res = cascadeTooltipContent(chart, tooltip, d, data, ids, cssContainer);
        else if (typeof tooltip === "function") {
            var val = d;
            if (typeof d === "object") {
                var shape = chart.getSeriesAndGroupProperty(ids.series, ids.group, "marker.shape");
                val = d[chart.getDefaultToolTipField(d, shape)]
            }
            res = tooltip.call(chart, val, ids.series, ids.group, d, data)
        } else if (typeof tooltip === "string")
            if (tooltip === "auto" && chart.htmlToolTip.enabled)
                res = chart.autoToolTipContent(d, data, ids.series, ids.group);
            else if (tdgchart.templateEngine.isTemplateString(tooltip))
                res = chart.parseTemplate(tooltip, d, data, ids);
        if (res && typeof res === "string")
            if (chart.htmlToolTip.enabled)
                res = createNode("div", {
                    "class": "tdgchart-tooltip-pad"
                }, res);
            else
                res = document.createTextNode(res);
        return res
    }
    ;
    function getDynamicCSSRules(chart) {
        var hoverColor = chart.htmlToolTip.cascadeMenuStyle.hover.fill || "rgba(220,220,220,0.9)";
        var hoverLabelColor = chart.htmlToolTip.cascadeMenuStyle.hover.labelColor || "black";
        var border = getToolTipBorder(chart);
        var labelStyle = chart.htmlToolTip.cascadeMenuStyle.label || {
            font: "",
            color: ""
        };
        var nameStyle = chart.htmlToolTip.cascadeMenuStyle.nameValue.name || {
            font: "",
            color: ""
        };
        var valueStyle = chart.htmlToolTip.cascadeMenuStyle.nameValue.value || {
            font: "",
            color: ""
        };
        var rules = [[".tdgchart-tooltip-highlight", "{\n\tbackground: " + hoverColor + ";\n\tcolor: " + hoverLabelColor + "; \n\toutline:0;\n}"], [".tdgchart-tooltip-hover:focus", "{\n\toutline:0;\n}"], [".tdgchart-tooltip-divider", "{\n\tmargin: 0;border: 0;\n\theight: " + border.width + "px;\n\tbackground-color: " + border.color + "\n}"], [".tdgchart-tooltip-label", "{\n\tfont: " + labelStyle.font + "; color: " + labelStyle.color + ";\n}"], [".tdgchart-tooltip-name", "{\n\tfont: " + nameStyle.font + "; color: " + nameStyle.color + ";\n}"], [".tdgchart-tooltip-value", "{\n\tfont: " + valueStyle.font + "; color: " + valueStyle.color + ";\n}"]];
        if (chart.documentRoot)
            rules.forEach(function(el) {
                el[0] = "." + chart.documentRoot + el[0]
            });
        return rules
    }
    function getCascadeTooltipCSSRules(chart) {
        var rules = [".tdgchart-tooltip-hover {\n\tposition: relative;\n}", ".tdgchart-tooltip-list {\n\tlist-style: none; padding: 0; margin: 0; display: block; outline: none;\n}", ".tdgchart-tooltip-pointer {\n\tcursor: pointer;\n}", ".tdgchart-submenu {\n\tvisibility: hidden; position: absolute; top: -1px;\n}", ".tdgchart-tooltip-arrow {\n\tfont: bold 12px Helvetica;\n\ttransform: scale(0.7,1.1);\n\tposition: absolute;\n\tleft: auto; right: 4px;\n\ttop: 50%;\n\tmargin-top:-6px\n}\n"];
        return rules.concat(getDynamicCSSRules(chart).map(function(el) {
            return el.join(" ")
        }))
    }
    function insertCSSRule(sheet, rule) {
        if (sheet.insertRule)
            sheet.insertRule(rule, 0);
        else if (sheet.addRule) {
            var tmp = rule.replace("}", "").split("{");
            sheet.addRule(tmp[0], tmp[1], 0)
        }
    }
    function modifyCascadeToolTipCSS(chart, root) {
        if (!isCSS(root.firstChild)) {
            initCascadeToolTipCSS(chart, root);
            return
        }
        var sheet = root.firstChild.sheet || root.firstChild.styleSheet;
        var rules = sheet.cssRules || sheet.rules;
        var newRules = getDynamicCSSRules(chart);
        var selectors = newRules.map(function(el) {
            return el[0]
        });
        for (var i = 0; i < rules.length; i++) {
            var selectorText = rules[i].selectorText;
            var index = selectors.indexOf(selectorText);
            if (index >= 0) {
                sheet.deleteRule(i);
                insertCSSRule(sheet, newRules[index].join(" "))
            } else if (selectorText && selectorText.endsWith(".tdgchart-tooltip")) {
                if (chart.htmlToolTip.fill)
                    rules[i].style.background = chart.htmlToolTip.fill;
                if (chart.htmlToolTip.border) {
                    var border = chart.htmlToolTip.border;
                    rules[i].style.border = tdg.formatString("{0}px solid {1}", border.width, border.color);
                    rules[i].style.borderRadius = border.cornerRadius + "px"
                }
            }
        }
    }
    function initCascadeToolTipCSS(chart, cssContainer) {
        var i, newRules;
        if (cssContainer && isCSS(cssContainer.firstChild)) {
            var sheet = cssContainer.firstChild.sheet || cssContainer.firstChild.styleSheet;
            var rules = sheet.cssRules || sheet.rules;
            var needRules = true;
            for (i = 0; i < rules.length && needRules; i++) {
                var text = rules[i].selectorText;
                if (text && text.includes("tdgchart-submenu"))
                    needRules = false
            }
            if (needRules) {
                newRules = getCascadeTooltipCSSRules(chart);
                for (i = 0; i < newRules.length; i++)
                    insertCSSRule(sheet, newRules[i])
            }
        } else {
            var css = chart.cache.get("css", "");
            if (css.indexOf("tdgchart-submenu") < 0) {
                newRules = getCascadeTooltipCSSRules(chart);
                css += newRules.join("\n") + "\n";
                chart.cache.set("css", css)
            }
        }
    }
    function createNode(type, attrs, innerHTML) {
        var node = document.createElement(type);
        for (var a in attrs)
            if (attrs.hasOwnProperty(a))
                node.setAttribute(a, attrs[a]);
        if (innerHTML)
            node.innerHTML = innerHTML;
        return node
    }
    function cascadeTooltipContent(chart, res, d, data, ids, cssContainer) {
        initCascadeToolTipCSS(chart, cssContainer);
        var templateParser = tdg.partial(chart.parseTemplate, [null, d, data, ids], chart);
        var div = createNode("div", {
            "class": "root_container"
        });
        div.addEventListener("keydown", tooltipKeyHandler);
        var menu = buildMenu(res, 5, templateParser, chart.documentRoot);
        menu.lists.forEach(function(ul) {
            div.appendChild(ul)
        });
        if (menu.hasScroll)
            div.setAttribute("tdgscrollable", "1");
        return div
    }
    function addClass(target, className) {
        if (!target.className.includes(className))
            target.className += " " + className
    }
    function removeClass(target, className) {
        if (target.className.includes(className)) {
            var regex = new RegExp("(^|\\s)" + className + "($|\\s)","g");
            target.className = target.className.replace(regex, "")
        }
    }
    var highlight = tdg.partial(addClass, [null, "tdgchart-tooltip-highlight"]);
    var unhighlight = tdg.partial(removeClass, [null, "tdgchart-tooltip-highlight"]);
    function tooltipMenuHoverHandler(e) {
        var target = this;
        e = e || window.event;
        if (e.target !== target)
            return null;
        var children = getFocusableChildren(target.parentNode) || [];
        tdg.map(children, unhighlight);
        hideChildren(children);
        moveFocus(undefined, null, target);
        target.parentNode.__focusTarget = children.indexOf(target);
        if (isSubmenu(target)) {
            target.tabIndex = -1;
            showAndFocusMenu(target.lastChild);
            var tooltip = target.lastChild;
            var parent;
            while (target && !target.chartRoot) {
                target = target.parentNode;
                if (target.getAttribute("class") === "tdgchart-submenu")
                    parent = target
            }
            parent = parent || target;
            tooltip.style.left = "100%";
            var chartBox = target.chartRoot.getBoundingClientRect();
            var tooltipBox = tooltip.getBoundingClientRect();
            var parentBox = parent.getBoundingClientRect();
            if (target && chartBox.right < tooltipBox.right) {
                var left = Math.min(parentBox.width / 2 - tooltipBox.right + chartBox.right - 5, parentBox.width - tooltipBox.width - 15);
                tooltip.style.left = left + "px"
            }
        }
        return false
    }
    function tooltipMouseOutHandler(e) {
        var target = this;
        e = e || window.event;
        while (target && target.getAttribute("class") !== "root_container")
            target = target.parentNode;
        target = target.firstChild;
        if (target && target.nodeName.toLowerCase() === "ul")
            if (!tdg.dom.ancestor(target, e.relatedTarget)) {
                unhighlight(target.firstChild);
                hideChildren(getFocusableChildren(target))
            }
    }
    var lastFocusedRiser;
    function tooltipGlobalKeyUpHandler(e, chart, root) {
        if (e.keyCode === 9) {
            if (document.activeElement) {
                var target = document.activeElement;
                var className = target.getAttribute("class");
                var ids = chart.classNameToIds(className);
                if (ids.object === "riser") {
                    lastFocusedRiser = document.activeElement;
                    var tooltipsFunctions = chart.cache.get("tooltipsFunctions");
                    if (tooltipsFunctions)
                        tooltipsFunctions.displayTooltip.call(chart, target, true)
                }
            }
            return
        }
    }
    function tooltipGlobalKeyDownHandler(e, chart, root) {
        if (e.keyCode === 9) {
            var target = lastFocusedRiser || document.activeElement;
            if (target) {
                var className = target.getAttribute("class");
                var ids = chart.classNameToIds(className);
                if (ids.object === "riser") {
                    var tooltipsFunctions = chart.cache.get("tooltipsFunctions");
                    if (tooltipsFunctions)
                        tooltipsFunctions.hideToolTip.call(chart)
                }
            }
            if (lastFocusedRiser) {
                target.focus();
                lastFocusedRiser = undefined
            }
        }
    }
    function moveFocus(chart, src, dest, isNewTooltip) {
        if (src) {
            unhighlight(src);
            src.tabIndex = -1;
            currentTarget = null
        }
        if (dest && dest.nodeName.toLowerCase() === "li") {
            dest.tabIndex = 0;
            highlight(dest);
            currentTarget = dest;
            chart = chart || walkForChartInstance(dest);
            if (chart)
                chart.buildAriaDescription(dest, isNewTooltip);
            dest.focus()
        }
    }
    function getFocusableChildren(target) {
        if (target && target.children)
            return tdg.filter(target.children, function(a) {
                var cls = a.getAttribute("class");
                return cls && cls.includes("tdgchart-tooltip-hover")
            });
        return null
    }
    function tooltipKeyHandler(e) {
        e = e || window.event;
        var chart = e.chart;
        var idx, target = e.target.parentNode;
        var activeElement;
        var menu = tdgchart.d3.select(e.menuDiv).select('[role="menu"]').node();
        if (currentTarget) {
            activeElement = currentTarget;
            target = currentTarget.parentNode
        } else {
            activeElement = tdgchart.d3.select(e.menuDiv).select('[role="menuitem"]').node();
            target = activeElement.parentNode;
            moveFocus(chart, null, activeElement, true)
        }
        var children = getFocusableChildren(target) || [];
        hideChildren(children);
        if (e.keyCode === 38 || e.keyCode === 40) {
            if (typeof target.__focusTarget == undefined || isNaN(target.__focusTarget))
                idx = 0;
            else if (e.keyCode === 38) {
                idx = target.__focusTarget - 1;
                if (idx < 0)
                    idx = children.length - 1
            } else {
                idx = target.__focusTarget + 1;
                if (idx >= children.length)
                    idx = 0
            }
            if (chart)
                chart.cache.set("accessibility_menu_move", true);
            moveFocus(chart, activeElement, children[idx]);
            if (chart)
                chart.cache.set("accessibility_menu_move", false);
            target.__focusTarget = idx;
            return false
        }
        if (isSubmenu(activeElement)) {
            if (e.keyCode === 39 || e.keyCode === 13 || e.keyCode === 32) {
                activeElement.tabIndex = -1;
                showAndFocusMenu(activeElement.lastChild);
                return false
            }
        } else if (e.keyCode === 13 || e.keyCode === 32) {
            activeElement.lastChild.click();
            return false
        }
        if (e.keyCode === 37 || e.keyCode === 27) {
            if (isSubmenu(activeElement))
                activeElement.lastChild.style.visibility = "hidden";
            var parent = activeElement.parentNode.parentNode.parentNode;
            parent.style.visibility = "hidden";
            if (parent._lastActiveElement) {
                activeElement.tabIndex = -1;
                parent._lastActiveElement.focus();
                currentTarget = parent._lastActiveElement
            } else
                moveFocus(chart, activeElement, parent.parentNode);
            return false
        }
        return true
    }
    function showAndFocusMenu(target) {
        target.style.visibility = "visible";
        var submenu = getSubmenuContent(target);
        if (submenu && submenu.nodeName.toLowerCase() === "ul") {
            var listNode = target.firstChild.firstChild;
            var children = getFocusableChildren(listNode) || [];
            listNode.__focusTarget = listNode.__focusTarget || 0;
            if (children[listNode.__focusTarget])
                moveFocus(undefined, null, children[listNode.__focusTarget])
        }
    }
    function hideChildren(children) {
        tdg.map(children, function(el) {
            if (isSubmenu(el)) {
                el.lastChild.style.visibility = "hidden";
                hideChildren(getFocusableChildren(getSubmenuContent(el.lastChild)))
            }
        })
    }
    function getSubmenuContent(target) {
        if (target && target.firstChild && target.firstChild.firstChild)
            return target.firstChild.firstChild;
        return null
    }
    function isSubmenu(target) {
        return target && target.hasAttribute("aria-haspopup")
    }
    function walkForChartInstance(target) {
        while (target && target.chart == null)
            target = target.parentNode;
        return target != null ? target.chart : undefined
    }
    function replaceDrillURL(target, url) {
        var originalTarget = target;
        while (target && target.chart == null)
            target = target.parentNode;
        if (target && target.chart) {
            var chart = target.chart;
            if (chart.__drillMenuRunning)
                return;
            var styleNodeID = "tdgchart_wait_spinner";
            chart.__drillMenuRunning = true;
            chart.hideToolTip();
            chart._postRenderCallbacks.push(function() {
                delete this.__drillMenuRunning;
                var spinnerCSS = document.getElementById(styleNodeID);
                if (spinnerCSS)
                    spinnerCSS.parentNode.removeChild(spinnerCSS)
            });
            var css = "body, *{cursor: wait !important;}";
            var styleNode = document.createElement("style");
            styleNode.type = "text/css";
            styleNode.id = styleNodeID;
            if (styleNode.styleSheet)
                styleNode.styleSheet.cssText = css;
            else
                styleNode.appendChild(document.createTextNode(css));
            document.head.appendChild(styleNode)
        }
        if (originalTarget && originalTarget._tdgToolTip)
            originalTarget._tdgToolTip.hide();
        document.location.replace(url)
    }
    function addClickHandler(li, url, target) {
        var click = function(url, target) {
            return function() {
                if (target) {
                    if (target === "_self" && url && url.includes("/contentDrill.vxl"))
                        target = "_replace$ibi";
                    if (target === "_replace$ibi")
                        replaceDrillURL(this, url);
                    else
                        window.open(url, target)
                } else
                    document.location = url
            }
        }(url, target);
        li.addEventListener("click", click);
        li.addEventListener("keydown", function(e) {
            if (e && e.keyCode === 13)
                click()
        })
    }
    function buildSubmenu(item, li, zIndex, templateParser, rootID) {
        var classes = rootID + " tdgchart-tooltip-pad tdgchart-tooltip-submenu-pad tdgchart-tooltip-hover tdgchart-tooltip-label";
        li.addEventListener("mouseover", tooltipMenuHoverHandler);
        li.addEventListener("touchend", tooltipMenuHoverHandler);
        li.addEventListener("mouseout", tooltipMouseOutHandler);
        if (item.url) {
            classes += " tdgchart-tooltip-pointer";
            addClickHandler(li, templateParser(item.url), item.target)
        }
        if (tdg.isEmpty(item.children))
            li.appendChild(createNode("span", {
                "class": rootID + " tdgchart-tooltip-label"
            }, templateParser(item.entry)));
        else {
            var childrenMenu = buildMenu(item.children, zIndex + 1, templateParser, rootID);
            li.appendChild(createNode("span", {
                "class": "tdgchart-tooltip-arrow"
            }, "&gt;"));
            li.appendChild(createNode("span", {}, templateParser(item.entry)));
            var div = createNode("div", {
                "class": "tdgchart-submenu",
                "aria-hidden": "true",
                style: "z-index: " + zIndex
            });
            var div2 = createNode("div", {
                "class": rootID + " tdgchart-tooltip"
            });
            childrenMenu.lists.forEach(function(ul) {
                div2.appendChild(ul)
            });
            if (childrenMenu.hasScroll)
                div.setAttribute("tdgscrollable", "1");
            div.appendChild(div2);
            li.appendChild(div);
            var childCount = item.children.filter(function(el) {
                return el && el.type !== "separator"
            }).length;
            li.setAttribute("aria-haspopup", "true");
            li.setAttribute("aria-label", "has " + childCount + " menu items for")
        }
        li.setAttribute("class", classes)
    }
    function buildOneMenuEntry(item, zIndex, templateParser, rootID) {
        var li = createNode("li", {
            "class": "tdgchart-tooltip-pad",
            role: "menuitem",
            tabindex: "-1"
        });
        if (typeof item === "string") {
            li.appendChild(createNode("span", {
                "class": rootID + " tdgchart-tooltip-label"
            }, templateParser(item)));
            li.removeAttribute("role")
        } else if (item.type === "separator") {
            li.removeAttribute("class");
            li.removeAttribute("role");
            li.appendChild(createNode("hr", {
                "class": rootID + " tdgchart-tooltip-divider"
            }))
        } else if (item.type === "nameValue") {
            var table = createNode("table", {
                style: "border:none; border-spacing:0px;"
            });
            item.entries.forEach(function(el) {
                var row = createNode("tr");
                row.appendChild(createNode("td", {
                    "class": rootID + " tdgchart-tooltip-name"
                }, templateParser(el.name) + ":&nbsp;"));
                row.appendChild(createNode("td", {
                    "class": rootID + " tdgchart-tooltip-value"
                }, templateParser(el.value)));
                table.appendChild(row)
            });
            li.removeAttribute("role");
            li.appendChild(table)
        } else if (item.hasOwnProperty("entry"))
            buildSubmenu(item, li, zIndex, templateParser, rootID);
        return li
    }
    function buildMenu(menuEntry, zIndex, templateParser, rootID) {
        var i, menu = [];
        var fixedUL = createNode("ul", {
            "class": "tdgchart-tooltip-list",
            role: "menu"
        });
        var scrollingUL;
        var lists = [fixedUL];
        var ul = fixedUL;
        var canScroll = true;
        var hasScroll;
        menuEntry = [].concat.apply([], menuEntry);
        for (i = 0; i < menuEntry.length; i++) {
            if (menuEntry[i].children && menuEntry[i].children.length > 0)
                canScroll = false;
            if (menuEntry[i].type === "nameValue") {
                var entry = {
                    name: menuEntry[i].name || "",
                    value: menuEntry[i].value || ""
                };
                if (i > 0 && menuEntry[i - 1].type === "nameValue")
                    menu[menu.length - 1].entries.push(entry);
                else
                    menu.push({
                        type: "nameValue",
                        entries: [entry]
                    })
            } else
                menu.push(menuEntry[i])
        }
        for (i = 0; i < menu.length; i++)
            if (menu[i]) {
                if (canScroll && !scrollingUL && menu.length > tooltipScrollTreshold && menu[i].type != "nameValue") {
                    scrollingUL = createNode("ul", {
                        "class": "tdgchart-tooltip-list",
                        role: "menu",
                        style: "overflow: hidden;overflow-y: auto"
                    });
                    scrollingUL.style.maxHeight = tooltipScrollTreshold * 1.5 + "em";
                    lists.push(scrollingUL);
                    ul = scrollingUL;
                    hasScroll = true
                }
                ul.appendChild(buildOneMenuEntry(menu[i], zIndex, templateParser, rootID))
            }
        return {
            lists: lists,
            hasScroll: hasScroll
        }
    }
    tdgchart.prototype.tooltipContainsClickItems = function(tooltip) {
        var chart = this;
        if (typeof tooltip === "function") {
            var d = (chart.data[0] || [])[0] || [];
            if (d && chart.chartType === "matrix")
                d = ((d || [])[0] || [])[0];
            d = d || {};
            var res = tooltip.call(chart, d[chart.getDefaultToolTipField(d)], 0, 0, d);
            return chart.tooltipContainsClickItems(res)
        }
        if (tooltip instanceof HTMLElement)
            tooltip = tooltip.innerHTML;
        if (typeof tooltip === "object" && !tdg.isEmpty(tooltip.regions))
            tooltip = tooltip.regions.map(function(el) {
                return tooltip[el]
            }).filter(function(el) {
                return el != null
            });
        if (Array.isArray(tooltip))
            return tooltip.some(function(el) {
                return chart.tooltipContainsClickItems(el)
            });
        if (typeof tooltip === "string") {
            tooltip = tooltip.toLowerCase();
            return tooltip.includes("onclick") || tooltip.includes("href") || tooltip.includes("tdgchart-tooltip-hover")
        }
        if (typeof tooltip === "object")
            if (tooltip.url || tooltip.entry && tooltip.children)
                return true;
            else if (tooltip.type === "nameValue" && tooltip.value)
                return chart.tooltipContainsClickItems(tooltip.value);
        return false
    }
    ;
    tdgchart.prototype.autoToolTipContent = function(d, data, s, g) {
        var t, sum, chart = this;
        if (chart.swapDataAndLabels) {
            t = s;
            s = g;
            g = t
        }
        var tooltipFormatter = tdg.partial(chart.formatNumber, [null, "auto", "tooltip"], chart);
        var tr = tdgchart.translations;
        d = d || {};
        function percentOfStr(value, total) {
            return tr && tr.PERCENTOFTOTAL ? tdg.formatString(tr.PERCENTOFTOTAL, value, total) : value + " of " + total
        }
        function getAxisTitle(axis, defaultTitle) {
            var existingTitle = chart.get(axis + "axis.title.text");
            if (!tdg.isEmpty(existingTitle) && typeof existingTitle === "string") {
                if (axis === "x" && existingTitle === "X Axis Title")
                    return tr.XTITLE;
                else if (axis === "y" && existingTitle === "Y Axis Title")
                    return tr.YTITLE;
                return existingTitle
            }
            return defaultTitle
        }
        if (chart.chartType === "map")
            if (chart.mapProperties.engine === "leaflet") {
                if (data && data.properties && data.properties.item && data.properties.item.hasOwnProperty("lng"))
                    return tdg.formatString('<span style="font: {0}">{1}<br />{2}</span><br /><span style="font: {3}">{4}: {5}<br />{6}: {7}<br />{8}: {9}</span>', chart.htmlToolTip.autoTitleFont || "", chart.getSeriesLabel(s), chart.getGroupLabel(g), chart.htmlToolTip.autoContentFont || "", getAxisTitle("z", tr.VALUE), tooltipFormatter(d.value || 0), getAxisTitle("y", tr.LATITUDE), data.properties.item.lat, getAxisTitle("x", tr.LONGITUDE), data.properties.item.lng);
                var name = data && data.data && data.data.name ? data.data.name : data.properties.name;
                return tdg.formatString('<span style="font: {0}">{1}</span><br /><span style="font: {2}">{3}: {4}</span>', chart.htmlToolTip.autoTitleFont || "", name || g || tr.SERIES + " " + data.id, chart.htmlToolTip.autoContentFont || "", chart.getSeriesLabel(s), tooltipFormatter(d.value || 0))
            } else if (chart.mapProperties.markerType === "bubble")
                return tdg.formatString('<span style="font: {0}">{1}<br />{2}</span><br /><span style="font: {3}">{4}: {5}</span>', chart.htmlToolTip.autoTitleFont || "", d.length === 2 && typeof d[0] === "string" ? d[0] : chart.getSeriesLabel(s), chart.getGroupLabel(g), chart.htmlToolTip.autoContentFont || "", getAxisTitle("z", "Z"), tooltipFormatter(d[d.length - 1]));
            else
                return tdg.formatString('<span style="font: {0}">{1}</span><br /><span style="font: {2}">{3}: {4}</span>', chart.htmlToolTip.autoTitleFont || "", chart.getSeriesLabel(s), chart.htmlToolTip.autoContentFont || "", getAxisTitle("x", "X"), tooltipFormatter(d[2]));
        else if (chart.chartType === "treemap") {
            if (d && d.isHeader)
                return tdg.formatString('<span style="font: {0}">{1}</span><br /><span style="font: {2}"> ' + tr.TOTAL + " {3}: {4}</span>", chart.htmlToolTip.autoTitleFont || "", d.nodeName, chart.htmlToolTip.autoContentFont || "", getAxisTitle("x", tr.VALUE), chart.formatNumber(d.size, "auto", "tooltip"));
            var nodeNameList = tdgchart.getTreemapNodePath(d);
            if (d.nodeValue && d.nodeValue[0] === d.nodeValue[1])
                return tdg.formatString('<span style="font: {0}">{1}</span><br /><span style="font: {2}">{3}: {4}</span>', chart.htmlToolTip.autoTitleFont || "", nodeNameList.join(" &gt; "), chart.htmlToolTip.autoContentFont || "", getAxisTitle("x", "X"), tooltipFormatter(d.nodeValue[0]));
            else
                return tdg.formatString('<span style="font: {0}">{1}</span><br /><span style="font: {2}">{3}: {4}<br />{5}: {6}</span>', chart.htmlToolTip.autoTitleFont || "", nodeNameList.join(" &gt; "), chart.htmlToolTip.autoContentFont || "", getAxisTitle("x", "X"), d.nodeValue ? tooltipFormatter(d.nodeValue[0]) : "NaN", getAxisTitle("y", "Y"), d.nodeValue ? tooltipFormatter(d.nodeValue[1]) : "NaN")
        } else if (chart.chartType === "scatter")
            return tdg.formatString('<span style="font: {0}">{1}</span><br /><span style="font: {2}">{3}: {4}<br />{5}: {6}</span>', chart.htmlToolTip.autoTitleFont || "", chart.getSeriesLabel(s), chart.htmlToolTip.autoContentFont || "", getAxisTitle("x", "X"), tooltipFormatter(d.x), getAxisTitle("y", "Y"), tooltipFormatter(d.y));
        else if (chart.chartType === "bubble")
            return tdg.formatString('<span style="font: {0}">{1}</span><br /><span style="font: {2}">{3}: {4}<br />{5}: {6}<br />{7}: {8}</span>', chart.htmlToolTip.autoTitleFont || "", chart.getSeriesLabel(s), chart.htmlToolTip.autoContentFont || "", getAxisTitle("x", "X"), tooltipFormatter(d.x), getAxisTitle("y", "Y"), tooltipFormatter(d.y), getAxisTitle("z", "Z"), tooltipFormatter(d.size));
        else if (chart.chartType === "pie") {
            data.total = data.total || tdg.sum(data, "value");
            if (d.isOtherSlice) {
                var otherCount = data.filter(function(el) {
                    return el.noLabel ? el : null
                }).length;
                return tdg.formatString('<span style="font: {0}">{1}</span><br /><span style="font: {2}">{3}: {4}<br />{5}</span>', chart.htmlToolTip.autoTitleFont || "", (chart.pieProperties.otherSlice.legendLabel || tr.OTHER) + " (" + otherCount + ")", chart.htmlToolTip.autoContentFont || "", chart.getGroupLabel(g), tooltipFormatter(d.value), percentOfStr(chart.formatNumber(d.value / data.total || 0, "#.#%", "tooltip"), tooltipFormatter(data.total)))
            } else
                return tdg.formatString('<span style="font: {0}">{1}</span><br /><span style="font: {2}">{3}: {4}<br />{5}</span>', chart.htmlToolTip.autoTitleFont || "", chart.getSeriesLabel(s), chart.htmlToolTip.autoContentFont || "", chart.getGroupLabel(g), tooltipFormatter(d.value), percentOfStr(chart.formatNumber(d.value / data.total || 0, "#.#%", "tooltip"), tooltipFormatter(data.total)))
        } else if (chart.chartType === "gauge" && (chart.gaugeProperties.layout === "simple" || chart.gaugeProperties.layout === "textArrow" || chart.gaugeProperties.layout === "simpleText"))
            return tdg.formatString('<span style="font: {0}">{1}: {2}</span>', chart.htmlToolTip.autoTitleFont || "", chart.getSeriesLabel(s), tooltipFormatter((Array.isArray(d) ? d[0] : d).value));
        else if (chart.chartType === "bar" && chart.blaProperties.seriesLayout === "stacked") {
            sum = chart.getGroupSum(g, s);
            return tdg.formatString('<span style="font: {0}">{1}</span><br /><span style="font: {2}">{3}: {4}<br />' + tr.VALUE + ": {5}<br />{6}</span>", chart.htmlToolTip.autoTitleFont || "", chart.getSeriesLabel(s), chart.htmlToolTip.autoContentFont || "", getAxisTitle("x", "X"), chart.getGroupLabel(g), tooltipFormatter(d.value), percentOfStr(chart.formatNumber(d.value / sum, "#.#%", "tooltip"), tooltipFormatter(sum)))
        } else if (chart.chartType === "mekko" || chart.chartType === "bar" && chart.blaProperties.seriesLayout === "percent") {
            sum = chart.getGroupSum(g, s);
            return tdg.formatString('<span style="font: {0}">{1}</span><br /><span style="font: {2}">{3}: {4}<br />' + tr.VALUE + ": {5}<br />{6}</span>", chart.htmlToolTip.autoTitleFont || "", chart.getSeriesLabel(s), chart.htmlToolTip.autoContentFont || "", getAxisTitle("x", "X"), chart.getGroupLabel(g), tooltipFormatter(d.value), percentOfStr(chart.formatNumber(d.y / 100, "#.#%", "tooltip"), tooltipFormatter(sum)))
        } else if (chart.chartType === "line" || chart.chartType === "bar" || chart.chartType === "area")
            return tdg.formatString('<span style="font: {0}">{1}: {2}</span><br /><span style="font: {3}">{4}: {5}</span>', chart.htmlToolTip.autoContentFont || "", chart.getSeriesLabel(s), tooltipFormatter(d.value), chart.htmlToolTip.autoContentFont || "", getAxisTitle("x", "X"), chart.getGroupLabel(g));
        else if (chart.chartType === "tagcloud")
            if (d.color == null)
                return tdg.formatString('<span style="font: {0}">{1}</span><br /><span style="font: {2}">{3}: {4}</span>', chart.htmlToolTip.autoTitleFont || "", d.nodeName, chart.htmlToolTip.autoContentFont || "", getAxisTitle("x", "X"), tooltipFormatter(d.value));
            else
                return tdg.formatString('<span style="font: {0}">{1}</span><br /><span style="font: {2}">{3}: {4}<br />{5}: {6}</span>', chart.htmlToolTip.autoTitleFont || "", d.nodeName || chart.getGroupLabel(g), chart.htmlToolTip.autoContentFont || "", getAxisTitle("x", "X"), tooltipFormatter(d.value), getAxisTitle("y", "Y"), tooltipFormatter(d.color));
        else if (chart.chartType === "matrix" && chart.matrixProperties.chartType === "marker") {
            var str = d.color == null ? '<span style="font: {0}">{1}</span><br /><span style="font: {2}">{3}: {4}</span>' : '<span style="font: {0}">{1}</span><br /><span style="font: {2}">{3}: {4}<br />{5}: {6}</span>';
            return tdg.formatString(str, chart.htmlToolTip.autoTitleFont || "", chart.getSeriesLabel(s), chart.htmlToolTip.autoContentFont || "", getAxisTitle("z", tr.SIZE), tooltipFormatter(d.size), chart.colorScale.title.text || tr.COLOR, tooltipFormatter(d.color))
        } else if (chart.chartType === "circlepack2") {
            var node = d.parent
              , nodeName = "";
            while (node && node.parent) {
                nodeName = node.name + " > " + nodeName;
                node = node.parent
            }
            if (nodeName)
                return tdg.formatString('<span style="font: {2}">{1}</span><br /><span style="font: {0}">{3}: {4}</span>', chart.htmlToolTip.autoTitleFont || "", nodeName, chart.htmlToolTip.autoContentFont || "", d.name, d.value);
            else
                return tdg.formatString('<span style="font: {0}">{1}: {2}</span>', chart.htmlToolTip.autoTitleFont || "", d.name, d.value)
        }
        var v;
        if (typeof d === "object") {
            var shapeOverride = chart.getSeriesAndGroupProperty(s, g, "marker.shape");
            var field = chart.getDefaultToolTipField(d, shapeOverride);
            v = d[field]
        } else
            v = d;
        return tdg.formatString('<span style="font: {0}">{1}</span><br /><span style="font: {2}">{3}: {4}<br />{5}: {6}</span>', chart.htmlToolTip.autoTitleFont || "", chart.getSeriesLabel(s), chart.htmlToolTip.autoContentFont || "", getAxisTitle("x", "X"), chart.getGroupLabel(g), getAxisTitle("y", "Y"), tooltipFormatter(v))
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    function highlightColor(color, baseColor) {
        if (baseColor == null || color == null)
            return "none";
        if (tdg.isPercentString(color) && !baseColor.includes("url")) {
            var hsl = tdg.color(baseColor).hsl();
            hsl.l = tdg.parsePercent(color);
            return hsl.rgb().color
        } else if (typeof color === "string" && color.toLowerCase().includes("% transparent")) {
            var alphaPercent = tdg.parsePercent(color.toLowerCase().replace(" transparent", ""));
            var rgb = tdg.color(baseColor);
            return rgb.alpha(rgb.a * (1 - alphaPercent)).toString()
        }
        return color
    }
    function getBorder(target) {
        return {
            width: target.getAttribute("stroke-width"),
            color: target.getAttribute("stroke"),
            dash: target.getAttribute("stroke-dasharray")
        }
    }
    function setBorder(target, border) {
        if (target && border) {
            target.setAttribute("stroke", border.color);
            target.setAttribute("stroke-width", border.width);
            target.setAttribute("stroke-dasharray", border.dash)
        }
    }
    function buttonMatches(button, selModes) {
        return button === 0 && selModes.includes("click") || button === 2 && selModes.includes("rightclick")
    }
    function markerBox(marker) {
        var dsp = marker.getAttribute("display");
        if (dsp === "none")
            marker.setAttribute("display", "inline");
        var pt = marker.getBoundingClientRect();
        if (dsp === "none")
            marker.setAttribute("display", "none");
        return pt
    }
    function createSelRect(style, svgSelection) {
        style = style || {
            fill: "rgba(120, 120, 120, 0.6)"
        };
        style.border = style.border || {
            width: 0,
            color: "black"
        };
        var selRect = svgSelection.append("svg:rect").attr("class", "selectionRect").attr("fill", style.fill).attr("shape-rendering", "crispEdges").attr("stroke", style.border.width > 0 ? style.border.color : "transparent").attr("stroke-width", style.border.width).attr("stroke-dasharray", style.border.dash).attr("width", 0).attr("height", 0);
        return selRect
    }
    function getSVGNode(chart) {
        var res;
        if (chart.isLeaflet() && chart.dataSelection.enabled)
            res = tdgchart.d3.select(".leafletContainer").select("svg");
        else if (tdgchart.extensionManager.isExtension(chart.chartType) && tdgchart.extensionManager.requiresModule(chart.chartType, "dataSelection")) {
            var tmp = tdgchart.extensionManager.getModuleProperty(chart, "dataSelection", "svgNode");
            if (tmp)
                res = tdgchart.d3.select(tmp)
        }
        if (!res)
            res = tdgchart.d3.select("#" + chart.documentRoot).select("svg");
        return res && res.node() ? res : null
    }
    function getRiserList(chart, svgSelection, selectionMode) {
        if (selectionMode === "preview")
            return getPreviewSelectionRiserList(svgSelection);
        else if (tdgchart.extensionManager.isExtension(chart.chartType) && tdgchart.extensionManager.requiresModule(chart.chartType, "dataSelection")) {
            var tmp = tdgchart.extensionManager.getModuleProperty(chart, "dataSelection", "getSelectedNodeWrapper");
            if (tmp)
                return tmp
        }
        return getDataSelectionRiserList(chart, svgSelection)
    }
    var doNotSelect = ["eventCatcher", "chartFrame", "background", "hoverFill", "selectionRect", "htmlLabelHolder", "rootPanel"];
    function getPreviewSelectionRiserList(svgSelection) {
        return svgSelection.selectAll("[class]")[0].filter(function(el) {
            var cls = el.getAttribute("class");
            return el.nodeName !== "g" && !doNotSelect.includes(cls)
        })
    }
    var selector = '[class^="riser!s"]:not([class$="!mbevel!"]):not(g), [class^=marker]:not([class$="!mbevel!"]):not(g)';
    function getDataSelectionRiserList(chart, svgSelection) {
        return (svgSelection || getSVGNode(chart)).selectAll(selector)[0]
    }
    function normCos(a) {
        if (tdg.eq(a % 360, 0) || tdg.eq(a % 360, 180) || tdg.eq(a % 360, 360))
            return 0;
        else if (tdg.eq(a % 360, 90))
            return 1;
        else if (tdg.eq(a % 360, 270))
            return -1;
        return Math.cos(tdg.radians(a - 90))
    }
    function normSin(a) {
        if (tdg.eq(a % 360, 90) || tdg.eq(a % 360, 270))
            return 0;
        else if (tdg.eq(a % 360, 180))
            return 1;
        else if (tdg.eq(a % 360, 0) || tdg.eq(a % 360, 360))
            return -1;
        return Math.sin(tdg.radians(a - 90))
    }
    function normCosSin(a) {
        return {
            x: normCos(a),
            y: normSin(a)
        }
    }
    function wedgePoints(x, y, as, ae, ri, ro, zeroPie) {
        var fullRing = ae - as >= 360;
        var largeRing = ae - as > 180 ? 1 : 0;
        var ps = normCosSin(as);
        var pe = normCosSin(ae);
        var p = new tdgchart.tdgscene.path;
        if (zeroPie)
            return undefined;
        else if (fullRing)
            return undefined;
        else {
            var step = Math.min(20, Math.ceil(3600 / ro) / 3);
            if (!ri) {
                var p = [x, y];
                for (var a = as; a <= ae; a += step) {
                    var pt = normCosSin(a);
                    if (a == as)
                        for (var rm = 10; rm < ro; rm += 10)
                            p.push([x + rm * pt.x, y + rm * pt.y]);
                    p.push([x + ro * pt.x, y + ro * pt.y])
                }
                if (a != ae) {
                    var pt = normCosSin(ae);
                    p.push([x + pt.x, y + pt.y])
                }
                for (; rm > 0; rm -= 10)
                    p.push([x + rm * pt.x, y + rm * pt.y])
            } else {
                var p = [];
                var r = [];
                for (var a = as; a <= ae; a += step) {
                    var pt = normCosSin(a);
                    if (a == as)
                        for (var rm = ri + 10; rm < ro; rm += 10)
                            p.push([x + rm * pt.x, y + rm * pt.y]);
                    p.push([x + ro * pt.x, y + ro * pt.y]);
                    r.push([x + ri * pt.x, y + ri * pt.y])
                }
                if (a != ae) {
                    var pt = normCosSin(ae);
                    p.push([x + ro * pt.x, y + ro * pt.y]);
                    r.push([x + ri * pt.x, y + ri * pt.y])
                }
                for (var rm = ri + 10; rm < ro; rm += 10)
                    r.push([x + rm * pt.x, y + rm * pt.y]);
                p = p.concat(r.reverse())
            }
            return p
        }
    }
    function createMouseHandlers(chart, svgSelection, selectionMode, selModes, clickHandler, triggerCallback, clearSelection, drawSelection) {
        chart._selectionIsDirty = false;
        chart._disableToolTips = false;
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        var isNearestNeighbor = selectionMode === "data" && chart.cache.hasKey("isNearestNeighbor");
        var selectionModeProps = chart[selectionMode + "Selection"];
        var downPt, isMoving = false;
        var selList = []
          , originalMouseDownSelList = [];
        var selRect = createSelRect(selectionModeProps.selectionRect, svgSelection);
        var risers = getRiserList(chart, svgSelection, selectionMode);
        var svgOffset = {
            x: 0,
            y: 0
        };
        if (chart.isLeaflet() && svgSelection.node())
            svgOffset = svgSelection.node().viewBox.animVal;
        var mouseInNarrativeText = function() {
            return false
        };
        if (chart.isNarrativeTextEnabled())
            mouseInNarrativeText = function() {
                var docRoot = document.getElementById(chart.documentRoot);
                return function(target) {
                    while (target && target !== docRoot) {
                        var cls = target.getAttribute("class");
                        if (cls && cls.includes("narrative"))
                            return true;
                        target = target.parentNode
                    }
                    return false
                }
            }();
        function mouseDownHandler(e) {
            if (chart._disableSelection)
                return;
            else if (e.button > 0 && !selModes.includes("rightclick"))
                return;
            else if (e.button < 1 && !selModes.includes("click") && !selModes.includes("ctrlclick"))
                return;
            else if (chart.isScrolling() || e && chart.isScrollBar(e.target) || mouseInNarrativeText(e.target))
                return;
            if (e && e.preventDefault)
                e.preventDefault();
            originalMouseDownSelList = selList;
            downPt = tdg.getMousePosition(e);
            if (e.ctrlKey || e.shiftKey)
                return;
            if (selModes.includes("dragrect"))
                svgSelection.attr("cursor", "crosshair");
            if (chartType !== "line" && chartType !== "area" && chartType !== "map") {
                chart._disableToolTips = chart._disableHover = true;
                chart.hideHoverNode();
                chart.hideToolTip()
            }
        }
        function mouseMoveHandler(e) {
            if (chart._disableSelection || downPt == null || selRect == null)
                return;
            if (!e || e.button > 0 || e.shiftKey)
                return;
            if (e.preventDefault)
                e.preventDefault();
            var localSelList = [];
            var upPt = tdg.getMousePosition(e);
            var x, y, width, height;
            if (downPt.x <= upPt.x) {
                x = downPt.x;
                width = upPt.x - downPt.x - 2
            } else {
                x = upPt.x + 2;
                width = downPt.x - upPt.x
            }
            if (downPt.y <= upPt.y) {
                y = downPt.y;
                height = upPt.y - downPt.y - 2
            } else {
                y = upPt.y + 2;
                height = downPt.y - upPt.y
            }
            width = Math.max(width, 0);
            height = Math.max(height, 0);
            var selBox = {
                x: x,
                y: y,
                width: width,
                height: height
            };
            if (width < 1 && height < 1)
                return;
            if (selectionMode === "preview") {
                if (selList.length) {
                    clearSelection(selList);
                    triggerCallback([], e)
                }
                return
            }
            var selRectOffset = svgSelection.node().getBoundingClientRect();
            selRect.attr("x", x - selRectOffset.left + svgOffset.x).attr("y", y - selRectOffset.top + svgOffset.y).attr("width", width).attr("height", height);
            if (width < 10 && height < 10)
                return;
            isMoving = true;
            chart._disableToolTips = chart._disableHover = true;
            chart.hideHoverNode();
            chart.hideToolTip();
            checkSelList(chart, selList);
            if (typeof risers === "function") {
                localSelList = risers(selBox);
                localSelList = localSelList.map(function(item) {
                    if (item instanceof Element)
                        return item;
                    else if (typeof item === "object" && item.hasOwnProperty("series")) {
                        var className = chart.buildClassName("riser", item.series, item.group, item.misc);
                        var elements = document.getElementsByClassName(className);
                        if (elements && elements.length > 0)
                            return elements[0]
                    }
                    return null
                });
                localSelList = localSelList.filter(function(el) {
                    return el != null
                })
            } else
                for (var i = 0; i < risers.length; i++) {
                    var box, riser = risers[i];
                    var cls = riser.getAttribute("class");
                    if (cls.includes("!marea") || cls.includes("!mline"))
                        continue;
                    box = cls.includes("!mmarker") ? markerBox(riser) : riser.getBoundingClientRect();
                    if (tdg.geom.intersect(selBox, box))
                        if (selectionMode === "preview" && selList.length) {
                            if (chart.classNameToIds(riser).object === chart.classNameToIds(selList[0]).object)
                                localSelList.push(riser)
                        } else if (!originalMouseDownSelList.includes(riser)) {
                            var wedgeInfo = riser.getAttribute("tdg:wedge");
                            if (wedgeInfo && !riser._wedgePoints) {
                                var points = wedgePoints.apply(undefined, wedgeInfo.split(" ").map(parseFloat));
                                if (points) {
                                    var wedgeBBoxStart = {};
                                    points.forEach(function(p) {
                                        if (wedgeBBoxStart.x == undefined || p[0] < wedgeBBoxStart.x)
                                            wedgeBBoxStart.x = p[0];
                                        if (wedgeBBoxStart.y == undefined || p[1] < wedgeBBoxStart.y)
                                            wedgeBBoxStart.y = p[1]
                                    });
                                    riser._wedgePoints = points.map(function(dpt) {
                                        return {
                                            x: dpt[0] + box.x - wedgeBBoxStart.x,
                                            y: dpt[1] + box.y - wedgeBBoxStart.y
                                        }
                                    })
                                }
                            }
                            if (riser._wedgePoints) {
                                if (riser._wedgePoints.some(function(pt) {
                                    return tdg.geom.intersect(selBox, pt)
                                }))
                                    localSelList.push(riser)
                            } else
                                localSelList.push(riser)
                        }
                }
            var hasSelectionChanged;
            if (localSelList.length + originalMouseDownSelList.length !== selList.length)
                hasSelectionChanged = true;
            else
                hasSelectionChanged = localSelList.some(function(el) {
                    return selList.indexOf(el) < 0
                });
            if (hasSelectionChanged) {
                if (selModes.includes("ctrlclick") && e.ctrlKey)
                    selList = originalMouseDownSelList.concat(localSelList);
                else {
                    clearSelection(selList);
                    selList = localSelList
                }
                drawSelection(selList, e)
            }
        }
        function mouseUpHandler(e) {
            if (chart._disableSelection)
                return;
            var upPt = tdg.getMousePosition(e);
            if (downPt && Math.abs(downPt.x - upPt.x) < 10 && Math.abs(downPt.y - upPt.y) < 10)
                if (selModes.includes("click") || selModes.includes("ctrlclick") || selModes.includes("rightclick"))
                    clickHandler(selList, e);
            if (isMoving)
                triggerCallback(selList, e);
            downPt = null;
            isMoving = false;
            originalMouseDownSelList = [];
            chart._disableToolTips = false;
            chart._disableHover = false;
            if (!chart.isLeaflet())
                svgSelection.attr("cursor", "");
            if (selRect)
                selRect.attr("width", 0).attr("height", 0);
            if (e && isNearestNeighbor)
                e.preventDefault()
        }
        var container = svgSelection.node();
        container.addEventListener("mousedown", mouseDownHandler);
        container.addEventListener("touchstart", mouseDownHandler);
        container.addEventListener("mouseup", mouseUpHandler);
        container.addEventListener("touchend", mouseUpHandler);
        if (selModes.includes("rightclick"))
            container.addEventListener("contextmenu", function(e) {
                e.preventDefault()
            });
        chart.globalMouseUpAdd(mouseUpHandler, selectionMode + "_selection_mouseup");
        var touchMoveHandler;
        if (selModes.includes("dragrect")) {
            container.addEventListener("mousemove", mouseMoveHandler);
            if (chart.isLeaflet())
                container.addEventListener("touchmove", mouseMoveHandler);
            else
                touchMoveHandler = mouseMoveHandler
        }
        if (!chart.isLeaflet()) {
            var i = chart.interaction;
            if (i.touchDrag === "select" || i.touchDrag === "pan" && !chart.cache.hasKey("haveScrollBars"))
                chart.registerShortDrag(svgSelection, null, function(d, data, e) {
                    touchMoveHandler(e)
                }, null);
            if (i.longTouchDrag === "select")
                chart.registerLongDrag(svgSelection, function(d, data, e) {
                    mouseDownHandler(e)
                }, function(d, data, e) {
                    touchMoveHandler(e)
                }, function(d, data, e) {
                    mouseUpHandler(e)
                })
        }
    }
    function doPreviewSelection(chart, overallLayout, svgSelection) {
        var selBorder = chart.previewSelection.selectedBorder || {
            width: 0,
            color: null,
            dash: ""
        };
        var selModes = (chart.previewSelection.selectionMode || []).map(function(el) {
            return el.toLowerCase()
        });
        var enableDualSelection = chart.get("globalSelection.enabled") || chart.get("dataSelection.enabled") && chart.get("previewSelection.enabled");
        var dataPreviewRisers, dataPreviewSelModes;
        if (enableDualSelection) {
            dataPreviewRisers = getDataSelectionRiserList(chart, svgSelection);
            dataPreviewSelModes = (chart.dataSelection.selectionMode || []).map(function(el) {
                return el.toLowerCase()
            });
            if (dataPreviewSelModes.includes("dragrect"))
                selModes.push("dragrect")
        }
        function triggerPreviewCallback(selList, e) {
            var callback = chart.get("previewSelection.eventCallback");
            if (typeof callback !== "function")
                return;
            var selIDList = selList.map(function(el) {
                var ids = chart.classNameToIds(el);
                ids.object = ids.object === "rootPanel" || ids.object === "eventCatcher" ? "background" : ids.object;
                return ids
            });
            var callbackObj = {
                chart: chart,
                event: e,
                mode: "preview"
            };
            callback.call(chart, selIDList, callbackObj)
        }
        function clearSelection(selList) {
            selList.splice(0, selList.length);
            svgSelection.selectAll(".selectionBorder").each(function() {
                this.parentNode.removeChild(this)
            })
        }
        function drawSelectionBox(box, color, target) {
            target = target ? tdgchart.d3.select(target.parentNode) : svgSelection;
            target.append("svg:rect").attr("class", "selectionBorder").attr("x", box.x).attr("y", box.y).attr("width", box.width).attr("height", box.height).attr("pointer-events", "none").attr("shape-rendering", "crispEdges").attr("stroke", selBorder.color).attr("stroke-width", selBorder.width).attr("stroke-dasharray", selBorder.dash).attr("fill", highlightColor(chart.previewSelection.selectedColor, color))
        }
        function drawSelectionNode(target, color) {
            var newNode = target.cloneNode();
            newNode.setAttribute("class", "selectionBorder");
            newNode.setAttribute("pointer-events", "none");
            newNode.setAttribute("stroke", selBorder.color);
            newNode.setAttribute("stroke-width", selBorder.width);
            newNode.setAttribute("stroke-dasharray", selBorder.dash);
            if (target.nodeName === "rect")
                newNode.setAttribute("fill", highlightColor(chart.previewSelection.selectedColor, color));
            target.parentNode.appendChild(newNode)
        }
        function drawHTMLSelectionNode(target, color) {
            var bbox = target.getBoundingClientRect();
            var newNode = target.cloneNode();
            newNode.innerHTML = "";
            newNode.setAttribute("class", "selectionBorder");
            newNode.style.left = parseFloat(newNode.style.left) - 5 + "px";
            newNode.style.top = parseFloat(newNode.style.top) - 3 + "px";
            newNode.style.width = bbox.width + 6 + "px";
            newNode.style.height = bbox.height + 2 + "px";
            newNode.style["pointer-events"] = "none";
            newNode.style["border-color"] = selBorder.color;
            newNode.style["border-width"] = selBorder.width + "px";
            newNode.style["border-style"] = selBorder.dash ? "dotted" : "solid";
            newNode.style["background-color"] = highlightColor(chart.previewSelection.selectedColor, color);
            target.parentNode.appendChild(newNode)
        }
        function drawSelectionRect(target) {
            var targetColor = target.getAttribute("fill") || target.getAttribute("stroke") || "rgb(255, 255, 255)";
            if (target instanceof HTMLElement) {
                drawHTMLSelectionNode(target, targetColor);
                return
            }
            var svgBox = target.ownerSVGElement.getBoundingClientRect();
            var targetBox = markerBox(target);
            var parentCTM = target.parentNode.getCTM();
            var bbox = {
                x: targetBox.left - svgBox.left - parentCTM.e,
                y: targetBox.top - svgBox.top - parentCTM.f,
                width: targetBox.width,
                height: targetBox.height
            };
            var grow = 6;
            if (target.nodeName === "text")
                bbox = tdg.geom.grow(bbox, grow);
            else if (target.nodeName === "line")
                bbox = tdg.geom.grow(bbox, parseFloat(target.getAttribute("stroke-width")) || grow);
            if (bbox.width <= 0) {
                bbox.x -= grow;
                bbox.width += grow * 2
            }
            if (bbox.height <= 0) {
                bbox.y -= grow;
                bbox.height += grow * 2
            }
            drawSelectionBox(bbox, targetColor, target)
        }
        function drawPreviewSelection(selList) {
            selList.forEach(function(el) {
                setSelected([], el)
            })
        }
        function setSelected(selList, target) {
            if (selList.length)
                if (selList.includes(target))
                    return;
            if (target.getAttribute("class") === "selectionRect")
                return;
            selList.push(target);
            var targetColor = target.getAttribute("fill") || target.getAttribute("stroke") || "rgb(255, 255, 255)";
            if (target.nodeName === "path" || target.nodeName === "rect")
                drawSelectionNode(target, targetColor);
            else
                drawSelectionRect(target)
        }
        function selectRelatedObjects(selList, target) {
            var ids = chart.classNameToIds(target);
            var selector;
            var selectionRoot = svgSelection;
            if (ids.object === "legend-markers" || ids.object === "legend-labels") {
                selectionRoot = tdgchart.d3.select(target.parentNode);
                selector = '[class^="legend-markers!s' + ids.series + '!"],[class^="legend-labels!s' + ids.series + '!"]'
            } else if (chart.chartType === "datagrid")
                selector = '[class^="' + ids.object + '"][class*="!c' + ids.col + '!"]';
            else if (ids.object === "riser" || ids.object === "dataLabels")
                selector = '[class^="' + ids.object + "!s" + ids.series + '!"]';
            else if (ids.object.includes("colorBand"))
                selector = '[class*="' + ids.object + "!m" + ids.misc + '"]';
            else {
                if (ids.object === "legend-background")
                    selectionRoot = tdgchart.d3.select(target.parentNode);
                selector = '[class^="' + ids.object + '!"], [class="' + ids.object + '"]'
            }
            selectionRoot.selectAll(selector).each(function() {
                setSelected(selList, this)
            })
        }
        var legendBox;
        if (chart.legend.visible && !tdg.color.isVisible(chart.legend.backgroundcolor)) {
            legendBox = svgSelection.select('[class^="LegendPanel"]').node();
            if (legendBox) {
                legendBox = legendBox.getBBox();
                legendBox = {
                    width: legendBox.width,
                    height: legendBox.height,
                    x: legendBox.x,
                    y: legendBox.y
                };
                legendBox = tdg.geom.grow(legendBox, 10)
            }
        }
        var chartFrameBox;
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        if (chartType !== "pie" && chartType !== "funnel" && chartType !== "gauge" && !tdg.color.isVisible(chart.chartFrame.fill.color) && overallLayout)
            chartFrameBox = overallLayout.chartFrame;
        function selectBorderlessObject(selList, cid, e) {
            if (cid !== "background" && cid !== "rootPanel" && !cid.includes("event"))
                return false;
            var pos = tdg.getMouseInViewPort(svgSelection.node(), e);
            if (legendBox && tdg.geom.intersect(pos, legendBox)) {
                clearSelection(selList);
                selList.push("legend-background");
                triggerPreviewCallback(selList, e);
                drawSelectionBox(legendBox, "rgb(255, 255, 255)");
                return true
            }
            if (chartFrameBox && tdg.geom.intersect(pos, chartFrameBox)) {
                clearSelection(selList);
                selList.push("chartFrame");
                triggerPreviewCallback(selList, e);
                drawSelectionBox(chartFrameBox, "rgb(255, 255, 255)");
                return true
            }
            return false
        }
        var dblClickTimer;
        function startDblClick() {
            window.clearTimeout(dblClickTimer);
            dblClickTimer = null
        }
        function foreignObjectTarget(target) {
            var t = target;
            while (t) {
                if (t.nodeName && t.nodeName.toLowerCase().startsWith("foreignobject"))
                    return t;
                else if (t.parentNode && t.parentNode.hasAttribute && t.parentNode.hasAttribute("class")) {
                    var cls = t.parentNode.getAttribute("class");
                    if (cls && cls.toLowerCase().startsWith("htmllabelholder"))
                        return t
                }
                t = t.parentNode
            }
            return null
        }
        function previewClickHandler(selList, e) {
            e.preventDefault();
            var target = e.target;
            if (!(target instanceof SVGElement))
                target = foreignObjectTarget(target);
            if (!target || !target.getAttribute || target === document || target.parentNode && target.parentNode === document)
                return;
            var cid = target.getAttribute("class") || "";
            if (!cid)
                return;
            else if (selectBorderlessObject(selList, cid, e))
                return;
            else if (enableDualSelection && buttonMatches(e.button, dataPreviewSelModes) && dataPreviewRisers.includes(target)) {
                clearSelection(selList);
                triggerPreviewCallback([], e);
                return
            }
            if (chart.previewSelection.clearBackgroundSelectOnNextSelect)
                if (e.type === "mouseup" && selList.includes(target) && (cid === "background" || cid === "chartFrame" || cid === "rootPanel" || cid === "eventCatcher" || cid === "")) {
                    clearSelection(selList);
                    triggerPreviewCallback([], e);
                    return
                }
            if (!selModes.includes("ctrlclick") || !(e.ctrlKey || e.shiftKey))
                clearSelection(selList);
            if (selModes.includes("ctrlclick") && selList.length > 0 && chart.classNameToIds(target).object !== chart.classNameToIds(selList[0]).object)
                return;
            if (chart.previewSelection.selectRelatedObjects)
                if (chart.previewSelection.selectRelatedObjects === "dblclick") {
                    setSelected(selList, target);
                    if (dblClickTimer) {
                        window.clearTimeout(dblClickTimer);
                        dblClickTimer = null;
                        clearSelection(selList);
                        selectRelatedObjects(selList, target)
                    } else
                        dblClickTimer = window.setTimeout(startDblClick, 200)
                } else
                    selectRelatedObjects(selList, target);
            else
                setSelected(selList, target);
            triggerPreviewCallback(selList, e)
        }
        createMouseHandlers(chart, svgSelection, "preview", selModes, previewClickHandler, triggerPreviewCallback, clearSelection, drawPreviewSelection)
    }
    function addSelectionPanel(svgSelection) {
        if (svgSelection.select(":first-child").attr("class") !== "dataSelectionPanel")
            svgSelection.insert("svg:rect", ":first-child").attr("class", "dataSelectionPanel").attr("x", -5E3).attr("y", -5E3).attr("width", 1E4).attr("height", 1E4).attr("fill", "transparent")
    }
    function doDataSelection(chart, svgSelection) {
        var chartType = chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType;
        var risers = getDataSelectionRiserList(chart, svgSelection);
        var selModes = (chart.dataSelection.selectionMode || []).map(function(el) {
            return el.toLowerCase()
        });
        function getNewRisers() {
            risers = getDataSelectionRiserList(chart)
        }
        if (risers == null || !risers.length)
            return;
        if (chart.isLeaflet()) {
            addSelectionPanel(svgSelection);
            var map = tdgchart.d3.select(".data-selection-button").node()._map;
            map.on("zoomend", getNewRisers)
        } else if (tdgchart.extensionManager.isExtension(chartType) && tdgchart.extensionManager.requiresModule(chartType, "dataSelection")) {
            var needPanel = tdgchart.extensionManager.getModuleProperty(chart, "dataSelection", "needSVGEventPanel");
            if (needPanel)
                addSelectionPanel(svgSelection)
        }
        risers.map(function(el) {
            el.isSelected = false
        });
        function notifyLinkedCharts(selList) {
            var linkedCharts = chart.dataSelection.linkedCharts || [];
            if (linkedCharts.length > 0) {
                var selIDList = selList.map(function(el) {
                    if (chartType === "treemap")
                        return {
                            groupLabel: el.getAttribute("class").split(tdgchart.getTreemapLabelSeparator()).pop()
                        };
                    else {
                        var seriesLabels = chart.getSeriesLabels();
                        var groupLabels = chart.getGroupLabels();
                        var ids = chart.classNameToIds(el);
                        ids.seriesLabel = seriesLabels[ids.series];
                        ids.groupLabel = groupLabels[ids.group];
                        return ids
                    }
                });
                linkedCharts.map(function(el) {
                    el.selectData(selIDList, true)
                })
            }
        }
        function triggerDataCallback(selList, e) {
            if (!chart.dataSelection.eventCallback || typeof chart.dataSelection.eventCallback !== "function")
                return;
            var dataRange = {};
            var selIDList = selList.map(function(el) {
                var ids = chart.classNameToIds(el);
                if (chart.data[ids.series] != null && chart.data[ids.series][ids.group] != null) {
                    var d = chart.data[ids.series][ids.group];
                    for (var prop in d)
                        if (d.hasOwnProperty(prop) && typeof d[prop] === "number") {
                            dataRange[prop] = dataRange[prop] || {
                                min: Infinity,
                                max: -Infinity
                            };
                            dataRange[prop].min = Math.min(dataRange[prop].min, d[prop]);
                            dataRange[prop].max = Math.max(dataRange[prop].max, d[prop])
                        }
                }
                if (chartType === "treemap")
                    ids.treemapLabelArray = ids.series.split(tdgchart.getTreemapLabelSeparator());
                return ids
            });
            var o = {
                chart: chart,
                event: e,
                dataRange: dataRange,
                mode: "data"
            };
            chart.dataSelection.eventCallback.call(chart, selIDList, o)
        }
        function selectRelatedObjects(selList) {
            var newSelections = [];
            if (chartType === "circlepack2")
                for (var i = 0; i < selList.length; i++) {
                    var series = chart.classNameToIds(selList[i]).series;
                    var children = svgSelection.selectAll('[class^="riser!s' + series + tdgchart.getTreemapLabelSeparator() + '"]');
                    if (children && children[0].length)
                        newSelections = newSelections.concat(children[0]);
                    while (series.indexOf(tdgchart.getTreemapLabelSeparator()) >= 0) {
                        series = series.slice(0, series.lastIndexOf(tdgchart.getTreemapLabelSeparator()));
                        var parent = svgSelection.select('[class^="riser!s' + series + '!"]');
                        if (parent && parent[0].length)
                            newSelections.push(parent.node())
                    }
                }
            if (newSelections.length)
                Array.prototype.push.apply(selList, newSelections)
        }
        function drawDataSelection(selList, e) {
            selectRelatedObjects(selList);
            if (selList.length <= 0)
                risers.map(function(el) {
                    el.clearSelect()
                });
            else {
                risers.map(function(el) {
                    el.unselect()
                });
                selList.map(function(el) {
                    el.select()
                })
            }
            triggerDataCallback(selList, e);
            notifyLinkedCharts(selList)
        }
        function clearSelection(selList) {
            if (selList.length <= 0)
                return;
            selList.splice(0, selList.length);
            risers.map(function(el) {
                el.clearSelect()
            })
        }
        function nearestMarker(mousePos, maxDistance) {
            var dt, minMarker, minDistance = Infinity;
            for (var i = 0; i < risers.length; i++) {
                var r = risers[i];
                if (r.getAttribute("class").includes("marker")) {
                    dt = tdg.geom.distance(markerBox(r), mousePos);
                    if (dt < minDistance) {
                        minMarker = r;
                        minDistance = dt
                    }
                }
            }
            return minDistance < maxDistance && minMarker ? minMarker : null
        }
        function dataClickHandler(selList, e) {
            checkSelList(chart, selList);
            var target;
            if (chartType === "line")
                target = nearestMarker(tdg.getMousePosition(e), 20);
            else if (chartType === "area" && e && e.target) {
                var cls = e.target.getAttribute("class");
                if (cls && (cls.includes("area") || cls.includes("marker")))
                    target = nearestMarker(tdg.getMousePosition(e), Infinity)
            } else
                target = e.target;
            if (chart.isScrolling() || chart.isScrollBar(target))
                return;
            var className = target ? target.getAttribute("class") : null;
            if (!className || !className.includes("riser") && !className.includes("marker!s")) {
                if (!e.ctrlKey || !e.shiftKey || !selModes.includes("ctrlclick")) {
                    clearSelection(selList);
                    triggerDataCallback(selList, e);
                    notifyLinkedCharts(selList)
                }
            } else if (risers.includes(target) && !e.type.toLowerCase().startsWith("touch")) {
                var idx = selList.indexOf(target);
                if ((e.ctrlKey || e.shiftKey) && selModes.includes("ctrlclick")) {
                    if (idx >= 0)
                        selList.splice(idx, 1);
                    else
                        selList.push(target);
                    drawDataSelection(selList, e)
                } else if (selList.length === 1 && selList[0] === target) {
                    clearSelection(selList);
                    triggerDataCallback(selList, e);
                    notifyLinkedCharts(selList)
                } else if (idx < 0 || selList.length > 1) {
                    selList.splice(0, selList.length);
                    selList.push(target);
                    drawDataSelection(selList, e)
                }
            }
        }
        createMouseHandlers(chart, svgSelection, "data", selModes, dataClickHandler, triggerDataCallback, clearSelection, drawDataSelection);
        var tinyPlaceholders;
        if (chart.cache.get("hasSmallRisers"))
            tinyPlaceholders = svgSelection.selectAll('[class^="tinyPlaceholder!"]');
        risers.map(function(el) {
            var selFill, selStroke, unselFill, unselStroke;
            var realFill = el.getAttribute("fill");
            var realStroke = getBorder(el);
            var realVisibility = el.getAttribute("display");
            if (chart.chartType === "circlepack2") {
                unselFill = tdg.color(realFill).toGreyScale().toString();
                unselStroke = tdg.color(realStroke).toGreyScale().toString();
                el.select = el.clearSelect = function() {
                    this.setAttribute("fill", realFill);
                    this.setAttribute("stroke", realStroke);
                    var ids = chart.classNameToIds(this);
                    svgSelection.selectAll('text[class^="dataLabels!s' + ids.series + '!"]').attr("visibility", null)
                }
                ;
                el.unselect = function() {
                    this.setAttribute("fill", unselFill);
                    this.setAttribute("stroke", unselStroke);
                    var ids = chart.classNameToIds(this);
                    svgSelection.selectAll('text[class^="dataLabels!s' + ids.series + '!"]').attr("visibility", "hidden")
                }
            } else {
                var unselectTreeNode = function(target) {
                    if (target.hasOwnProperty("originalY") && target.hasOwnProperty("originalHeight")) {
                        target.setAttribute("y", target.originalY);
                        target.setAttribute("height", target.originalHeight);
                        delete target.originalY;
                        delete target.originalHeight
                    }
                };
                var selectTreeNode = function(target) {
                    if (!tdg.color.isLineVisible(chart.dataSelection.selectedBorder))
                        return;
                    var selectedBorderSize = chart.dataSelection.selectedBorder.width;
                    var headerHeight = chart.get("treemapProperties.header.height");
                    if (!headerHeight && headerHeight != null)
                        return;
                    var series = chart.classNameToIds(target).series;
                    var sep = tdgchart.getTreemapLabelSeparator();
                    if (series.includes(sep))
                        series = series.split(sep)[0];
                    var header = target.parentNode.querySelector('[class^="group-header!"][class$="!m' + series + '!"]');
                    if (tdg.geom.intersect(header.getBBox(), target.getBBox())) {
                        target.originalY = target.getAttribute("y");
                        var newY = parseFloat(target.originalY) + selectedBorderSize;
                        target.setAttribute("y", newY);
                        target.originalHeight = target.getAttribute("height");
                        var newHeight = parseFloat(target.originalHeight) - selectedBorderSize;
                        target.setAttribute("height", newHeight)
                    }
                };
                var tinyRiser;
                if (el.nodeName === "rect" && (chart.chartType === "bar" || chart.chartType === "matrix" && chart.matrixProperties.chartType === "bar")) {
                    if (chart.cache.get("hasSmallRisers")) {
                        var tinyClass = el.getAttribute("class").replace("riser", "tinyPlaceholder");
                        tinyRiser = tinyPlaceholders.selectAll('[class="' + tinyClass + '"]').node();
                        if (tinyRiser) {
                            realFill = tinyRiser.getAttribute("fill");
                            realStroke = getBorder(tinyRiser)
                        }
                    }
                } else if (el.nodeName === "rect" && chart.chartType === "datagrid") {
                    var parent = el.parentNode.parentNode;
                    realFill = parent.getAttribute("fill");
                    realVisibility = parent.getAttribute("display");
                    realStroke = getBorder(parent)
                }
                if (chart.dataSelection.selectedColor != null)
                    selFill = highlightColor(chart.dataSelection.selectedColor, realFill);
                if (tdg.color.isLineVisible(chart.dataSelection.selectedBorder)) {
                    selStroke = tdg.clone(chart.dataSelection.selectedBorder);
                    selStroke.color = highlightColor(selStroke.color, realStroke || "black")
                }
                if (chart.dataSelection.unselectedColor != null)
                    unselFill = highlightColor(chart.dataSelection.unselectedColor, realFill);
                if (tdg.color.isLineVisible(chart.dataSelection.unselectedBorder)) {
                    unselStroke = tdg.clone(chart.dataSelection.unselectedBorder);
                    unselStroke.color = highlightColor(unselStroke.color, realStroke || "black")
                }
                el.select = function() {
                    var target = tinyRiser || this;
                    var className = target.getAttribute("class");
                    if (chart.chartType === "treemap" && className.endsWith("node"))
                        selectTreeNode(target);
                    if (selStroke)
                        setBorder(target, selStroke);
                    else if (realStroke)
                        setBorder(target, realStroke);
                    if (realFill)
                        target.setAttribute("fill", selFill || realFill);
                    if (realVisibility === "none")
                        target.setAttribute("display", "inline")
                }
                ;
                el.unselect = function() {
                    var target = tinyRiser || this;
                    var className = target.getAttribute("class");
                    if (chart.chartType === "treemap" && className.endsWith("node"))
                        unselectTreeNode(target);
                    if (unselStroke)
                        setBorder(target, unselStroke);
                    else if (realStroke)
                        setBorder(target, realStroke);
                    if (realFill)
                        target.setAttribute("fill", unselFill || realFill);
                    if (realVisibility === "none")
                        target.setAttribute("display", "none")
                }
                ;
                el.clearSelect = function() {
                    var target = tinyRiser || this;
                    var className = target.getAttribute("class");
                    if (chart.chartType === "treemap" && className.endsWith("node"))
                        unselectTreeNode(target);
                    setBorder(target, realStroke);
                    if (realFill)
                        target.setAttribute("fill", realFill);
                    if (realVisibility === "none")
                        target.setAttribute("display", "none")
                }
            }
        })
    }
    function doGlobalDispatch(url) {
        var urls = Array.isArray(url) ? url : [url];
        return function(selList, callbackObj) {
            var chart = this;
            var selData = selList.map(function(ids) {
                return chart.getDataFromIds(ids).d
            }).filter(function(d) {
                return d != null
            });
            urls.forEach(function(u) {
                var localURL = chart.applyTemplate(u, selData[0], selData, selList[0] || {});
                window.open(localURL, "_self")
            })
        }
    }
    function doGlobalSelection(chart, overallLayout, svgSelection) {
        var callback;
        if (chart.get("globalSelection.type") === "portalDispatch")
            callback = doGlobalDispatch(chart.get("globalSelection.url"));
        else {
            callback = chart.get("globalSelection.eventCallback");
            if (typeof callback !== "function")
                return
        }
        var lastEventType, dataSelList;
        function cb(selList, callbackObj) {
            var e = callbackObj.event;
            if (callbackObj.mode === "data" && e.type === "mousemove" || lastEventType === "mousemove" && e.type === "mouseup") {
                callback.call(chart, selList, callbackObj);
                lastEventType = e.type;
                return
            } else if (callbackObj.mode === "data")
                dataSelList = selList;
            else if (callbackObj.mode === "preview") {
                if (selList.length === 0 && typeof dataSelList === "undefined")
                    return;
                if (selList.length === 0 && dataSelList.length > 0)
                    callback.call(chart, dataSelList, callbackObj);
                else
                    callback.call(chart, selList, callbackObj)
            }
            lastEventType = e.type
        }
        if (typeof chart.dataSelection.eventCallback !== "function")
            chart.dataSelection.eventCallback = cb;
        chart.previewSelection.eventCallback = cb;
        doDataSelection(chart, svgSelection);
        doPreviewSelection(chart, overallLayout, svgSelection)
    }
    tdgchart.prototype.processSelection = function(overallLayout) {
        var chart = this;
        var svgSelection = getSVGNode(chart);
        if (svgSelection && svgSelection.node())
            if (chart.globalSelection.enabled)
                doGlobalSelection(chart, overallLayout, svgSelection);
            else {
                if (chart.dataSelection.enabled)
                    doDataSelection(chart, svgSelection);
                if (chart.previewSelection.enabled)
                    doPreviewSelection(chart, overallLayout, svgSelection)
            }
    }
    ;
    tdgchart.prototype.selectData = function(selList, preventCallback) {
        if (!this.dataSelection.enabled)
            return;
        if (selList && !Array.isArray(selList) && selList.hasOwnProperty("series") && selList.hasOwnProperty("group"))
            selList = [selList];
        if (preventCallback == null)
            preventCallback = false;
        var chart = this;
        chart._selList = selList;
        if (chart.chartType === "parabox") {
            chart.selectLines(selList);
            return
        }
        var risers = getDataSelectionRiserList(chart);
        if (!risers)
            return;
        if (!selList || selList.length <= 0) {
            risers.map(function(el) {
                el.isSelected = false;
                el.clearSelect()
            });
            if (chart.dataSelection.eventCallback && !preventCallback)
                chart.dataSelection.eventCallback.call(chart, []);
            return
        }
        risers.map(function(el) {
            el.isSelected = false;
            el.unselect()
        });
        var riserSelList = [];
        var riserList = risers.map(function(el) {
            return {
                ids: chart.classNameToIds(el),
                lblList: chart.chartType === "treemap" ? el.getAttribute("class").split(tdgchart.getTreemapLabelSeparator()).slice(1) : null,
                riser: el
            }
        });
        var groupLabels = chart.getGroupLabels();
        for (var i = 0; i < selList.length; i++) {
            if (!selList[i])
                continue;
            riserList.map(function(el) {
                if (el.ids.row != null && selList[i].hasOwnProperty("row") && el.ids.row !== selList[i].row)
                    return;
                if (el.ids.col != null && selList[i].hasOwnProperty("col") && el.ids.col !== selList[i].col)
                    return;
                if (chart.chartType === "treemap") {
                    if (el.lblList.indexOf(selList[i].groupLabel) >= 0)
                        riserSelList.push(el.riser)
                } else if (selList[i].series === el.ids.series && selList[i].group === el.ids.group)
                    riserSelList.push(el.riser);
                else if (!selList[i].hasOwnProperty("series") && selList[i].groupLabel && selList[i].groupLabel === groupLabels[el.ids.group])
                    riserSelList.push(el.riser)
            })
        }
        riserSelList.map(function(el) {
            el.isSelected = true;
            el.select()
        });
        if (chart.dataSelection.eventCallback && !preventCallback)
            chart.dataSelection.eventCallback.call(chart, selList);
        chart._selectionIsDirty = true
    }
    ;
    function checkSelList(chart, selList) {
        if (chart._selectionIsDirty) {
            selList.splice(0, selList.length);
            var newList = getDataSelectionRiserList(chart).filter(function(el) {
                return el.isSelected ? el : null
            });
            Array.prototype.push.apply(selList, newList)
        }
        chart._selectionIsDirty = false
    }
    tdgchart.prototype.getSelectedData = function() {}
    ;
    tdgchart.linkDataSelectionCharts = function(chartList) {
        if (!Array.isArray(chartList))
            chartList = Array.prototype.slice.call(arguments);
        for (var i = 0; i < chartList.length; i++)
            chartList[i].dataSelection.linkedCharts = chartList.filter(function(el) {
                return el !== chartList[i]
            })
    }
}
)();
(function() {
    tdgchart.prototype.isExtension = function() {
        return tdgchart.extensionManager.isExtension(this.chartType)
    }
    ;
    var extensionListLookupURL = "html5chart_extensions.json";
    var extensionLibsLookupURL = "libs/libs.json";
    var tdg = tdgchart.util;
    function queueDraw(ext, drawFn) {
        ext._renderQueue = ext._renderQueue || [];
        ext._renderQueue.push(drawFn)
    }
    function drawRenderQueue(ext, reloadResources) {
        if (ext._renderQueue && (ext._isResourcesLoaded() || reloadResources)) {
            var length = ext._renderQueue.length;
            for (var i = 0; i < length; i++) {
                if (typeof ext._renderQueue[i] === "function")
                    ext._renderQueue[i]();
                ext._renderQueue[i] = null
            }
            if (ext._renderQueue.every(function(el) {
                return el == null
            }))
                ext._renderQueue = null
        }
    }
    function clonePropsToChartInstance(chart, extID, defaultProperties) {
        var extProps = tdg.cloneObject(defaultProperties);
        if (chart.extensions[extID])
            chart.extensions[extID] = tdg.mergeObjects(chart.extensions[extID], extProps);
        else
            chart.extensions[extID] = extProps
    }
    tdgchart.extensionManager = {
        __extensionList: null,
        __externalLibraries: {},
        register: function(ext) {
            if (tdgchart.extensionManager.__extensionList == null)
                return;
            var extTemplate = tdgchart.extensionManager.__extensionList[ext.id];
            if (!extTemplate)
                return;
            ext._isResourcesLoaded = function() {
                if (this._requiresPropertyLoad)
                    return false;
                if (!this.resources || !this.resources.script || !this.resources.script.length)
                    return true;
                if (!this._loadedScripts)
                    return false;
                return this._loadedScripts.filter(tdg.isNotEmpty).length === this.resources.script.length
            }
            ;
            delete extTemplate._requiresRegistration;
            ext = tdg.mergeObjects(ext, extTemplate);
            ext.modules = ext.modules || {};
            ext.configuration = ext.configuration || {};
            tdgchart.extensionManager.__extensionList[ext.id] = ext;
            if (ext._renderQueue)
                tdgchart.extensionManager.loadExtensionResources(ext)
        },
        loadExtensionResources: function(ext, onError) {
            function onLoad(ext, idx, reloadResources) {
                ext._loadedScripts[idx] = true;
                drawRenderQueue(ext, reloadResources)
            }
            function buildPath(fn, extPath) {
                if (tdg.isAbsolutePath(fn))
                    return fn;
                return extPath + "/" + fn
            }
            var arg, i, id, entry, fn, qualifiedFn;
            fn = buildPath("properties.json", ext.loadPath);
            if (ext._requiresPropertyLoad) {
                delete ext._requiresPropertyLoad;
                var props = tdg.ajax(fn, {
                    asJSON: true
                });
                if (props) {
                    ext.info = props.info || {};
                    ext.properties = props.properties;
                    ext.propertyAnnotations = props.propertyAnnotations;
                    ext.dataBuckets = props.dataBuckets;
                    ext.translations = props.translations;
                    if (!tdg.isEmpty(ext.externalProperties)) {
                        tdg.mergeObjects(ext.externalProperties, ext.properties);
                        delete ext.externalProperties
                    }
                }
            }
            if (!ext.resources) {
                fireEvent("extensionLoadComplete");
                return true
            }
            if (ext._requiresCSSLoad) {
                delete ext._requiresCSSLoad;
                if (!tdg.isEmpty(ext.resources.css)) {
                    arg = {
                        properties: ext.properties
                    };
                    for (i = 0; i < ext.resources.css.length; i++) {
                        id = ext.id + "__css__" + i;
                        var cssUrl = ext.resources.css[i];
                        cssUrl = typeof cssUrl === "function" ? cssUrl(arg) : cssUrl;
                        fn = buildPath(cssUrl, ext.loadPath);
                        tdg.loadCSSFile(id, fn)
                    }
                }
            }
            if (ext._requiresScriptLoad && !tdg.isEmpty(ext.resources.script))
                for (i = 0; i < ext.resources.script.length; i++)
                    if (ext.resources.script[i] && ext.resources.script[i].name === "ibx") {
                        ext._loadedScripts = ext._loadedScripts || [];
                        if (!ext._loadedScripts[i]) {
                            entry = ext.resources.script[i];
                            var res = loadBundledLibrary(ext, entry, i, onLoad, onError);
                            if (!res)
                                return false
                        }
                    }
            if (ext._requiresScriptLoad) {
                delete ext._requiresScriptLoad;
                if (!tdg.isEmpty(ext.resources.script)) {
                    arg = {
                        properties: ext.properties
                    };
                    ext.resources.script = ext.resources.script.map(function(el) {
                        return (typeof el === "function" ? el(arg) : el) || ""
                    });
                    ext._loadedScripts = ext._loadedScripts || [];
                    for (i = 0; i < ext.resources.script.length; i++)
                        if (!ext._loadedScripts[i]) {
                            entry = ext.resources.script[i];
                            if (typeof entry === "object" && typeof entry.name === "string")
                                loadBundledLibrary(ext, entry, i, onLoad, onError)
                        }
                    for (i = 0; i < ext.resources.script.length; i++) {
                        entry = ext.resources.script[i];
                        if (entry === "")
                            ext._loadedScripts[i] = true;
                        else if (typeof entry === "string") {
                            qualifiedFn = buildPath(entry, ext.loadPath);
                            tdg.loadScriptFile(qualifiedFn, tdg.partial(onLoad, [ext, i]), onError);
                            ext._loadedScripts[i] = false
                        }
                    }
                }
            }
            fireEvent("extensionLoadComplete");
            if (ext._loadedScripts == null)
                return true;
            return !ext._loadedScripts.some(function(el) {
                return el === false
            })
        },
        registerEvent: function(eventType, fn) {
            tdgchart.extensionManager.__events = tdgchart.extensionManager.__events || {};
            tdgchart.extensionManager.__events[eventType] = tdgchart.extensionManager.__events[eventType] || [];
            tdgchart.extensionManager.__events[eventType].push(fn)
        },
        isExtensionListLoaded: function() {
            return tdgchart.extensionManager.__extensionList != null
        },
        isExtension: function(chartType) {
            // テスト用
            // return tdgchart.extensionManager.__extensionList && chartType in tdgchart.extensionManager.__extensionList
            return true;
        },
        isMatrix: function(chartType) {
            return chartType in tdgchart.extensionManager.__extensionList && tdgchart.extensionManager.__extensionList[chartType].dataBuckets && tdgchart.extensionManager.__extensionList[chartType].dataBuckets.matrix
        },
        requiresModule: function(chartType, moduleName) {
            return tdgchart.extensionManager.__extensionList && chartType in tdgchart.extensionManager.__extensionList && tdgchart.extensionManager.__extensionList[chartType].modules && moduleName in tdgchart.extensionManager.__extensionList[chartType].modules
        },
        getModuleProperty: function(chart, moduleName, prop) {
            if (chart.chartType in tdgchart.extensionManager.__extensionList && moduleName in tdgchart.extensionManager.__extensionList[chart.chartType].modules) {
                var ext = tdgchart.extensionManager.__extensionList[chart.chartType];
                var rootContainerID = chart.documentRoot;
                var config = ext.configuration[rootContainerID];
                var moduleProperty;
                if (config && config.modulePropertyCache && config.modulePropertyCache[moduleName] && config.modulePropertyCache[moduleName][prop])
                    moduleProperty = config.modulePropertyCache[moduleName][prop];
                else {
                    var arg = buildCallbackArg(chart, ext);
                    var resolveprop = tdgchart.extensionManager.__extensionList[chart.chartType].modules[moduleName][prop];
                    moduleProperty = resolveProperty(resolveprop, arg);
                    if (ext.configuration[rootContainerID] && ext.configuration[rootContainerID].modulePropertyCache) {
                        if (!ext.configuration[rootContainerID].modulePropertyCache[moduleName])
                            ext.configuration[rootContainerID].modulePropertyCache[moduleName] = {};
                        ext.configuration[rootContainerID].modulePropertyCache[moduleName][prop] = moduleProperty
                    }
                }
                return moduleProperty
            }
            return null
        },
        getExtensionMetadata: function(chartOrChartType) {
            var chartType = typeof chartOrChartType === "string" ? chartOrChartType : chartOrChartType.chartType;
            var ext = tdgchart.extensionManager.__extensionList[chartType];
            if (!ext || ext._requiresLoad || ext._isLoading)
                return null;
            return ext
        },
        getExtensionDataConfig: function(chart) {
            var required = []
              , optional = [];
            var ext = tdgchart.extensionManager.__extensionList[chart.chartType];
            if (!ext || !ext.dataBuckets || !Array.isArray(ext.dataBuckets.buckets) || tdg.isEmpty(ext.dataBuckets.buckets))
                return {
                    defaultField: "value",
                    baseFields: 1,
                    map: ["value", "size", "color"]
                };
            ext.dataBuckets.buckets.forEach(function(bucket) {
                if (bucket.count.min > 0)
                    required.push(bucket.id);
                else
                    optional.push(bucket.id)
            });
            return {
                defaultField: tdgchart.extensionManager.getModuleProperty(chart, "dataLabels", "defaultDataArrayEntry") || "value",
                baseFields: required.length,
                map: required.concat(optional)
            }
        },
        getExtensionProperty: function(chart, prop) {
            if (chart.chartType in tdgchart.extensionManager.__extensionList)
                return tdgchart.extensionManager.__extensionList[chart.chartType][prop];
            return null
        },
        getTranslationEntry: function(chartOrChartType, translationEntry, defaultString) {
            var ext = tdgchart.extensionManager.getExtensionMetadata(chartOrChartType);
            if (ext) {
                var locale = (document.documentElement.getAttribute("lang") || "en").split("-")[0];
                var translations = ext.translations[locale] || ext.translations["en"];
                return tdg.get(translationEntry, translations, defaultString)
            }
            return ""
        },
        initExtensionProperties: function(chart) {
            var extList = tdgchart.extensionManager.__extensionList;
            chart.extensions = chart.extensions || {};
            for (var extID in extList)
                if (extList.hasOwnProperty(extID))
                    chart.extensions[extID] = chart.extensions[extID] || {}
        },
        initModules: function(chart) {
            var rootContainerID = chart.documentRoot;
            var ext = tdgchart.extensionManager.__extensionList[chart.chartType];
            if (!ext || !ext.modules)
                return;
            ext.configuration = ext.configuration || {};
            ext.configuration[rootContainerID] = ext.configuration[rootContainerID] || {};
            ext.configuration[rootContainerID].modulePropertyCache = {};
            var arg = buildCallbackArg(chart, ext);
            var modules = ext.configuration[rootContainerID].modules = {};
            modules.activateAll = function() {
                var modules = this;
                for (var k in modules)
                    if (modules.hasOwnProperty(k)) {
                        var module = modules[k];
                        if (module.supported && typeof module.activate === "function")
                            module.activate()
                    }
            }
            ;
            modules.translate = {
                getString: function(key, defaultString) {
                    return tdgchart.extensionManager.getTranslationEntry(chart, key, defaultString)
                }
            };
            if (ext.modules.colorScale && ext.modules.colorScale.supported) {
                modules.colorScale = tdg.cloneObject(ext.modules.colorScale);
                var minMax = resolveProperty(ext.modules.colorScale.minMax, arg);
                var colorKey = resolveProperty(ext.modules.colorScale.colorDataArrayEntry, arg) || "color";
                chart.initColorScale(minMax, colorKey);
                modules.colorScale.getColorScale = function() {
                    return chart.cache.get("colorAxis", {}).scale
                }
            }
            var sizeMinMax, sizeScale, sizeRange;
            if (ext.modules.sizeScale && ext.modules.sizeScale.supported) {
                modules.sizeScale = tdg.cloneObject(ext.modules.sizeScale);
                var maxRadius = resolveProperty(ext.modules.sizeScale.maxDiameter, arg) / 2 || chart.bubbleMarkerRadius();
                sizeMinMax = resolveProperty(ext.modules.sizeScale.minMax, arg);
                chart.__ext_sizeScale = sizeScale = function(d) {
                    return Math.max(2, maxRadius * Math.sqrt(Math.abs(d || 0) / sizeMinMax.max))
                }
                ;
                sizeRange = {
                    min: sizeScale(sizeMinMax.min) / 2,
                    max: sizeScale(sizeMinMax.max) / 2
                };
                sizeScale.domain = function() {
                    return [sizeMinMax.min, sizeMinMax.max]
                }
                ;
                sizeScale.range = function() {
                    return [sizeRange.min, sizeRange.max]
                }
                ;
                modules.sizeScale.getSizeScale = function() {
                    return chart.__ext_sizeScale
                }
            }
            if (ext.modules.legend) {
                modules.legend = tdg.cloneObject(ext.modules.legend);
                var sizeMode = resolveProperty(ext.modules.legend.sizeMode, arg);
                if (sizeMode === "size" && sizeMinMax && sizeScale) {
                    var midValue = (sizeMinMax.min + sizeMinMax.max) / 2;
                    chart._sizeLegendMarkersInfo = [{
                        r: sizeRange.max,
                        value: sizeMinMax.max
                    }, {
                        r: sizeScale(midValue) / 2,
                        value: midValue
                    }, {
                        r: sizeRange.min,
                        value: sizeMinMax.min
                    }]
                }
            }
            if (ext.modules.dataLabels && ext.modules.dataLabels.supported) {
                modules.dataLabels = tdg.cloneObject(ext.modules.dataLabels);
                modules.dataLabels.getDataLabelContent = function(d, data, ids) {
                    var datum = chart.getDataFromIds(ids);
                    if (!datum || datum.d == null)
                        datum = {
                            d: {}
                        };
                    d = tdg.mergeObjects(d, tdg.cloneObject(datum.d));
                    return chart.resolveDataLabelContent(d, data, ids)
                }
                ;
                modules.dataLabels.getDataLabelProperties = function(d, data, ids) {
                    var lookup = tdg.partial(chart.getSeriesAndGroupProperty, [ids.series, ids.group, null], chart);
                    var content = modules.dataLabels.getDataLabelContent(d, data, ids);
                    if (content === "0" && lookup("dataLabels.displayZero") === false)
                        return null;
                    var visible = lookup("dataLabels.visible");
                    if (typeof visible === "function" && !visible.call(chart, d, ids.series, ids.group) || visible === false)
                        return null;
                    var color = lookup("dataLabels.color") || "black";
                    if (typeof color === "function")
                        color = color(d, data, ids);
                    return {
                        content: content,
                        position: lookup("dataLabels.position") || "center",
                        font: lookup("dataLabels.font"),
                        color: color
                    }
                }
                ;
                modules.dataLabels.addDataLabelToRiser = function(target, dataLabel, container) {
                    if (!dataLabel)
                        return;
                    var box = target.getBBox();
                    var el = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    el.appendChild(document.createTextNode(dataLabel.content));
                    var fontParts = tdg.fontToFontParts(dataLabel.font);
                    el.setAttribute("font-family", fontParts.fontFamily);
                    el.setAttribute("font-size", fontParts.fontSize);
                    el.setAttribute("font-weight", fontParts.fontWeight);
                    el.setAttribute("fill", dataLabel.color);
                    var align = "middle"
                      , valign = "middle";
                    if (dataLabel.position === "top")
                        valign = "top";
                    else if (dataLabel.position === "right")
                        align = "right";
                    else if (dataLabel.position === "bottom")
                        valign = "bottom";
                    else if (dataLabel.position === "left")
                        align = "left";
                    if (align === "left") {
                        el.setAttribute("text-anchor", "end");
                        el.setAttribute("x", box.x - 3)
                    } else if (align === "right") {
                        el.setAttribute("text-anchor", "start");
                        el.setAttribute("x", box.x + box.width)
                    } else {
                        el.setAttribute("text-anchor", "middle");
                        el.setAttribute("x", box.x + box.width / 2)
                    }
                    if (valign === "top")
                        el.setAttribute("y", box.y - 3);
                    else if (valign === "bottom") {
                        el.setAttribute("y", box.y + box.height);
                        el.setAttribute("dy", "1em")
                    } else {
                        el.setAttribute("y", box.y + box.height / 2);
                        el.setAttribute("dy", "0.35em")
                    }
                    container = container || target.parentNode;
                    container.appendChild(el)
                }
            }
            if (ext.modules.tooltip && ext.modules.tooltip.supported) {
                modules.tooltip = tdg.cloneObject(ext.modules.tooltip);
                modules.tooltip.updateToolTips = modules.tooltip.activate = function(root) {
                    chart.addHTMLToolTips(root ? tdgchart.d3.select(root) : null);
                    if (chart.accessibility.navigation.enabled)
                        chart.doAccessibilityNavigation(root ? tdgchart.d3.select(root) : null)
                }
                ;
                modules.tooltip.getToolTipContent = function(s, g, d, data) {
                    var ids = {
                        series: s,
                        group: g
                    };
                    var datum = chart.getDataFromIds(ids);
                    if (!datum || datum.d == null)
                        return "";
                    d = tdg.mergeObjects(d, tdg.cloneObject(datum.d));
                    var res = chart.getSeriesAndGroupProperty(s, g, "tooltip");
                    if (res === "auto")
                        return res;
                    res = chart.resolveToolTipSeriesContent(res, d, data, ids);
                    if (res instanceof HTMLElement && typeof res.outerHTML === "string")
                        if (!this || !this.supportDOMContent)
                            res = res.outerHTML;
                    return res
                }
                ;
                modules.tooltip.addDefaultToolTipContent = function(target, s, g, d, data) {
                    var ids = {
                        object: "riser",
                        misc: "bar"
                    };
                    if (target.hasAttribute("class"))
                        ids = chart.classNameToIds(target.getAttribute("class"));
                    if (s == null || g == null) {
                        s = s == null ? ids.series || 0 : s;
                        g = g == null ? ids.group || 0 : g
                    }
                    ids.series = s;
                    ids.group = g;
                    var datum = chart.getDataFromIds(ids);
                    d = d == null ? datum.d : d;
                    data = data == null ? datum.data : data;
                    d = tdg.merge(datum.d, tdg.clone(d));
                    var res = chart.getSeriesAndGroupProperty(s, g, "tooltip");
                    if (res === "auto" && typeof this.autoContent === "function")
                        res = this.autoContent(target, s, g, d, data);
                    if (!(res instanceof HTMLElement))
                        res = chart.resolveToolTipSeriesContent(res, d, data, ids);
                    this.setToolTipContent(target, res)
                }
                ;
                modules.tooltip.setToolTipContent = function(target, content) {
                    if (content instanceof HTMLElement) {
                        target.setAttribute("tdgtitle", "placeholder");
                        target.tdgtitle_dom = content
                    } else
                        target.setAttribute("tdgtitle", content)
                }
            }
            if (ext.modules.eventHandler && ext.modules.eventHandler.supported) {
                modules.eventHandler = tdg.cloneObject(ext.modules.eventHandler);
                modules.eventHandler.activate = function() {
                    chart.processEvents()
                }
            }
            if (ext.modules.dataSelection && ext.modules.dataSelection.supported) {
                modules.dataSelection = tdg.cloneObject(ext.modules.dataSelection);
                if (typeof ext.modules.dataSelection.getSelectedNodes === "function")
                    ext.modules.dataSelection.getSelectedNodeWrapper = function(arg) {
                        var innerCallback = ext.modules.dataSelection.getSelectedNodes(arg);
                        var containerBBox = arg.container.getBoundingClientRect();
                        return function(rect) {
                            rect.x -= containerBBox.left;
                            rect.y -= containerBBox.top;
                            return innerCallback(rect)
                        }
                    }
                    ;
                modules.dataSelection.activateSelection = modules.dataSelection.activate = function() {
                    chart.dataSelection.enabled = true;
                    chart.processSelection()
                }
            }
        },
        drawExtension: function(chart, drawFn) {
            chart.errorHandlerWrapper(tdgchart.extensionManager.drawExtensionWithErrors, [chart, drawFn])
        },
        drawExtensionWithErrors: function(chart, drawFn) {
            var ext = tdgchart.extensionManager.__extensionList[chart.chartType];
            if (!ext)
                return;
            if (chart.dataArrayMap == null && ext.defaultDataArrayMap != null)
                chart.dataArrayMap = ext.defaultDataArrayMap;
            if (ext._requiresLoad && !ext._isLoading) {
                ext._isLoading = true;
                tdg.loadScriptFile(ext.url, function() {
                    ext._requiresLoad = ext._isLoading = false;
                    delete ext._requiresLoad;
                    delete ext._isLoading;
                    tdgchart.extensionManager.drawExtension(chart, drawFn)
                });
                return
            }
            if (ext._requiresRegistration) {
                queueDraw(ext, tdg.partial(tdgchart.extensionManager.drawExtension, [chart, drawFn]));
                return
            }
            function onError(msg) {
                var err = tdgchart.translations.ExtensionLoadError;
                if (msg && msg.target && msg.target.attributes && msg.target.attributes.src)
                    err = err + ": " + msg.target.attributes.src.nodeValue;
                tdg.traceError(err);
                chart.errorMessage = new tdgchart.InternalError(err);
                chart.redraw();
                ext._requiresScriptLoad = true
            }
            if (!ext._isResourcesLoaded()) {
                var res = tdgchart.extensionManager.loadExtensionResources(ext, onError);
                if (!res) {
                    queueDraw(ext, tdg.partial(tdgchart.extensionManager.drawExtension, [chart, drawFn]));
                    return
                }
            }
            clonePropsToChartInstance(chart, chart.chartType, ext.properties);
            var callbackArg = buildCallbackArg(chart, ext);
            if (ext._requiresInitialization)
                if (typeof ext.initCallback === "function") {
                    ext.initCallback(function(success) {
                        if (success) {
                            delete ext._requiresInitialization;
                            tdgchart.extensionManager.drawExtension(chart, drawFn)
                        }
                    }, callbackArg);
                    return
                } else
                    delete ext._requiresInitialization;
            if (chart.noDataMode && typeof ext.noDataPreRenderCallback === "function")
                ext.noDataPreRenderCallback(callbackArg);
            else if (typeof ext.preRenderCallback === "function")
                ext.preRenderCallback(callbackArg);
            drawFn()
        },
        drawExtensionInternal: function(chart, panel, rootContainerID) {
            var ext = tdgchart.extensionManager.__extensionList[chart.chartType];
            var root = document.getElementById(rootContainerID);
            var id = rootContainerID + "_" + ext.id.replace(/\./g, "-") + "_" + pv.id();
            var container;
            if (ext.containerType === "html")
                container = createHTMLContainer(root, panel.computedSize);
            else
                container = createSVGContainer(panel.$dom, panel.computedSize);
            container.setAttribute("id", id);
            ext.configuration[rootContainerID] = ext.configuration[rootContainerID] || {};
            var config = ext.configuration[rootContainerID];
            config.container = container;
            config.width = panel.computedSize.width;
            config.height = panel.computedSize.height;
            config.containerIDPrefix = id;
            config.rootContainer = root;
            var arg = buildCallbackArg(chart, ext);
            arg.renderComplete = function() {
                this.modules.activateAll();
                this.moonbeamInstance.processRenderComplete()
            }
            ;
            if (chart.noDataMode && typeof ext.noDataRenderCallback === "function")
                ext.noDataRenderCallback(arg);
            else if (typeof ext.renderCallback === "function")
                ext.renderCallback(arg)
        },
        lookupBundledLibrary: function(name, version, minified) {
            name = (name + "").toLowerCase();
            var libs = tdgchart.extensionManager.__externalLibraries || {};
            if (!libs[name])
                return null;
            var localVersion;
            if (version)
                if (libs[name].libs[version])
                    localVersion = version;
                else if (libs[name].mappings[version])
                    localVersion = libs[name].mappings[version];
                else
                    return null;
            if (localVersion == null)
                localVersion = libs[name].mappings.latest;
            var lib = libs[name].libs[localVersion];
            if (lib == null)
                return null;
            var srcVersion = minified ? "min" : "src";
            if (lib[srcVersion] == null)
                srcVersion = srcVersion === "src" ? "min" : "src";
            return {
                name: name,
                version: localVersion,
                minified: srcVersion === "min"
            }
        },
        getBundledLibrary: function(name, version, minified) {
            var libInfo = tdgchart.extensionManager.lookupBundledLibrary(name, version, minified);
            var libs = tdgchart.extensionManager.__externalLibraries || {};
            try {
                var lib = libs[libInfo.name].libs[libInfo.version][libInfo.minified ? "min" : "src"];
                return lib.loaded && lib.libname ? window[lib.libname] : null
            } catch (e$29) {
                return null
            }
        },
        loadExtensionAPIResources: function() {
            var isInstantiated = false;
            return function loadList() {
                if (isInstantiated)
                    return;
                isInstantiated = true;
                console.log(tdgchart.getExtensionsPath() + extensionListLookupURL)
                tdg.ajax(tdgchart.getExtensionsPath() + extensionListLookupURL, {
                    asJSON: true,
                    async: true,
                    onLoad: loadExtensionListHandler,
                    onError: function() {
                        loadExtensionListHandler([])
                    }
                });
                tdg.ajax(tdgchart.getExtensionsPath() + extensionLibsLookupURL, {
                    asJSON: true,
                    async: true,
                    onLoad: loadExtensionLibListHandler,
                    onError: function() {
                        loadExtensionLibListHandler({})
                    }
                })
            }
        }()
    };
    function loadBundledLibrary(ext, entry, entryIndex, onLoad, onError) {
        var libs = tdgchart.extensionManager.__externalLibraries || {};
        var libInfo = tdgchart.extensionManager.lookupBundledLibrary(entry.name, entry.version, entry.minified);
        if (!libInfo)
            throw tdgchart.translations.NoBundledLibError + ": " + entry.name + (entry.version ? " version " + entry.version : "");
        var lib = libs[libInfo.name].libs[libInfo.version][libInfo.minified ? "min" : "src"];
        if (libInfo.name === "jquery" && window.jQuery)
            lib.loaded = true;
        else if (libInfo.name === "ibx" && typeof window.ibx === "function")
            lib.loaded = true;
        if (lib.loaded) {
            ext._loadedScripts[entryIndex] = true;
            ext.externalLibraries = ext.externalLibraries || {};
            ext.externalLibraries[entry.name] = window[lib.libname];
            return true
        } else {
            var libFn;
            if (lib.filename.startsWith("/"))
                libFn = tdgchart.getScriptBasePath() + lib.filename.slice(1);
            else {
                var libsScriptPath = tdgchart.getExtensionsPath() + "libs";
                libFn = [libsScriptPath, libInfo.name, libInfo.version, lib.filename].join("/")
            }
            ext._loadedScripts[entryIndex] = false;
            lib.loaded = true;
            tdg.loadScriptFile(libFn, function(ext, i, libname, name) {
                return function() {
                    ext.externalLibraries = ext.externalLibraries || {};
                    ext.externalLibraries[name] = window[libname];
                    if (libname === "ibx")
                        try {
                            initIBX(function(ext, i) {
                                return function() {
                                    onLoad(ext, i, true)
                                }
                            }(ext, i))
                        } catch (error) {}
                    else
                        onLoad(ext, i)
                }
            }(ext, entryIndex, lib.libname, entry.name), onError);
            return false
        }
    }
    function loadExtensionLibListHandler(extensionLibs) {
        tdgchart.extensionManager.__externalLibraries = extensionLibs
    }
    function loadExtensionListHandler(extensionList) {
        var extScriptPath = tdgchart.getExtensionsPath();
        tdgchart.extensionManager.__extensionList = {};
        for (var key in extensionList)
            if (extensionList.hasOwnProperty(key)) {
                if (!extensionList[key].enabled)
                    continue;
                var loadPath = extScriptPath + key;
                var url = loadPath + "/" + key + ".js";
                tdgchart.extensionManager.__extensionList[key] = {
                    _requiresLoad: true,
                    _isLoading: false,
                    _requiresPropertyLoad: true,
                    _requiresCSSLoad: true,
                    _requiresScriptLoad: true,
                    _requiresRegistration: true,
                    _requiresInitialization: true,
                    externalProperties: extensionList[key].properties,
                    loadPath: loadPath,
                    url: url
                }
            }
        fireEvent("extensionListLoad")
    }
    function fireEvent(eventType) {
        if (tdgchart.extensionManager.__events && !tdg.isEmpty(tdgchart.extensionManager.__events[eventType]))
            tdgchart.extensionManager.__events[eventType].forEach(function(el) {
                el()
            })
    }
    function resolveProperty(prop, arg) {
        return typeof prop === "function" ? prop(arg) : prop
    }
    function buildCallbackArg(chart, ext) {
        var rootContainerID = chart.documentRoot;
        ext = ext || tdgchart.extensionManager.__extensionList[chart.chartType];
        var arg = {
            baseColor: "rgb(144,144,144)",
            moonbeamInstance: chart,
            loadPath: ext.loadPath + "/",
            properties: chart.extensions[chart.chartType],
            externalLibraries: ext.externalLibraries,
            data: tdg.cloneObject(chart._internalData || chart.data),
            dataBuckets: {
                depth: 1
            }
        };
        arg = tdg.mergeObjects(ext.configuration[rootContainerID] || {}, arg);
        var i, j, k, b = convertAPI(chart.dataBuckets, latestAPI);
        var depth = 1 + (b.series_break ? 1 : 0) + (b.data_page ? 1 : 0) + (b.matrix ? 2 : 0);
        if (!chart.chartType.startsWith("com.esri.map") && b.series_break == null)
            if (depth === 1)
                arg.data = arg.data[0];
            else if (depth >= 3)
                for (i = 0; i < arg.data.length; i++)
                    for (j = 0; j < arg.data[i].length; j++) {
                        if (arg.data[i] == null || !Array.isArray(arg.data[i][j]))
                            continue;
                        if (depth === 4)
                            for (k = 0; k < arg.data[i][j].length; k++) {
                                if (arg.data[i][j] != null && Array.isArray(arg.data[i][j][k]))
                                    arg.data[i][j][k] = arg.data[i][j][k][0]
                            }
                        else
                            arg.data[i][j] = arg.data[i][j][0]
                    }
        arg.dataBuckets = convertAPI(chart.dataBuckets, ext.info.implements_api_version || 1);
        arg.dataBuckets.depth = depth;
        return arg
    }
    var latestAPI = 2;
    var upgradeAPI = {
        2: function(dataBuckets) {
            function fixOneBucket(bucket) {
                var fields = [];
                for (var k in bucket)
                    if (bucket.hasOwnProperty(k))
                        if (Array.isArray(bucket[k]))
                            bucket[k].forEach(function(fieldValue, i) {
                                fields[i] = fields[i] || {};
                                fields[i][k] = fieldValue
                            });
                        else {
                            fields[0] = fields[0] || {};
                            fields[0][k] = bucket[k]
                        }
                return fields
            }
            var newBuckets = [];
            for (var b in dataBuckets.buckets)
                if (dataBuckets.buckets.hasOwnProperty(b))
                    newBuckets.push({
                        id: b,
                        fields: fixOneBucket(dataBuckets.buckets[b])
                    });
            var res = {
                internal_api_version: 2,
                buckets: newBuckets
            };
            ["series_break", "matrix", "data_page", "tooltip"].forEach(function(el) {
                if (dataBuckets[el])
                    res[el] = {
                        fields: fixOneBucket(dataBuckets[el])
                    }
            });
            return res
        }
    };
    var downgradeAPI = {
        1: function(dataBuckets) {
            function fixOneBucket(b) {
                var newBucket = {};
                b.fields.forEach(function(field) {
                    for (var k in field)
                        if (field.hasOwnProperty(k))
                            if (newBucket[k] == null)
                                newBucket[k] = field[k];
                            else if (Array.isArray(newBucket[k]))
                                newBucket[k].push(field[k]);
                            else
                                newBucket[k] = [newBucket[k], field[k]]
                });
                return newBucket
            }
            var newBuckets = {};
            dataBuckets.buckets.forEach(function(b) {
                newBuckets[b.id] = fixOneBucket(b)
            });
            var res = {
                internal_api_version: 1,
                buckets: newBuckets
            };
            ["series_break", "matrix", "data_page", "tooltip"].forEach(function(el) {
                if (dataBuckets[el])
                    res[el] = fixOneBucket(dataBuckets[el])
            });
            return res
        }
    };
    function convertAPI(dataBuckets, targetVersion) {
        dataBuckets = dataBuckets || {};
        var sourceVersion = dataBuckets.internal_api_version || 1;
        if (sourceVersion > latestAPI || targetVersion > latestAPI)
            return dataBuckets;
        while (sourceVersion < targetVersion) {
            dataBuckets = upgradeAPI[sourceVersion + 1](dataBuckets);
            sourceVersion = dataBuckets.internal_api_version
        }
        while (sourceVersion > targetVersion) {
            dataBuckets = downgradeAPI[sourceVersion - 1](dataBuckets);
            sourceVersion = dataBuckets.internal_api_version
        }
        if (targetVersion === 1 && dataBuckets && dataBuckets.buckets)
            for (var k in dataBuckets.buckets)
                if (dataBuckets.buckets.hasOwnProperty(k))
                    dataBuckets.buckets[k].count = Array.isArray(dataBuckets.buckets[k].title) ? dataBuckets.buckets[k].title.length : 1;
        dataBuckets = dataBuckets || {};
        if (dataBuckets.buckets == null)
            dataBuckets.buckets = targetVersion === 1 ? [] : {};
        dataBuckets.getBucket = function(bucketName) {
            for (var i = 0; i < this.buckets.length; i++)
                if (this.buckets[i] && this.buckets[i].id === bucketName)
                    return this.buckets[i];
            return null
        }
        ;
        return dataBuckets
    }
    function createSVGContainer(parent, layout) {
        var container = document.createElementNS(tdg.ns.svg, "g");
        container.setAttribute("transform", "translate(" + layout.x + "," + layout.y + ")");
        parent.appendChild(container);
        return container
    }
    function createHTMLContainer(root, layout) {
        var svg = root.getElementsByTagName("svg")[0];
        var relContainer = document.createElement("div");
        relContainer.setAttribute("class", "chartHolder_relative_container");
        relContainer.style.position = "relative";
        relContainer.appendChild(svg);
        var container = document.createElement("div");
        container.style.width = layout.width + "px";
        container.style.height = layout.height + "px";
        container.style.position = "absolute";
        container.style.left = layout.x + "px";
        container.style.top = layout.y + "px";
        container.style.zIndex = 10;
        root.appendChild(relContainer);
        relContainer.appendChild(container);
        return container
    }
    function initIBX(onLoad) {
        window.applicationContext = "";
        var scripts = document.getElementsByTagName("script");
        for (var i = 0; i < scripts.length; ++i)
            if (scripts[i].src && scripts[i].src.endsWith("/ibx.js")) {
                var src = scripts[i].src;
                var x = src.indexOf("/");
                if (x >= 0)
                    src = src.substring(x);
                x = src.indexOf("/ibx/");
                if (x >= 0) {
                    window.applicationContext = src.substring(0, x);
                    break
                }
            }
        window.addEventListener("ibx_ibxresmgr_resolveuri", function(e) {
            var url = e.data.uri;
            if (/^\{res\}/.test(url)) {
                var lang = e.data.resourceMgr.language || document.documentElement.getAttribute("lang");
                url = "{context}/rb/ibx/" + lang + url.replace("{res}", "")
            }
            if (/^\{context\}/.test(url))
                e.data.uri = window.applicationContext + url.replace("{context}", "")
        });
        window.ibx(function() {
            onLoad()
        })
    }
}
)();
if (typeof window !== "undefined")
    !function(t, e, i) {
        var n = t.L
          , o = {};
        o.version = "0.6.4",
        o.noConflict = function() {
            return t.L = n,
            this
        }
        ,
        t.L = o,
        o.Util = {
            extend: function(t) {
                var e, i, n, o, s = Array.prototype.slice.call(arguments, 1);
                for (i = 0,
                n = s.length; n > i; i++) {
                    o = s[i] || {};
                    for (e in o)
                        o.hasOwnProperty(e) && (t[e] = o[e])
                }
                return t
            },
            bind: function(t, e) {
                var i = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
                return function() {
                    return t.apply(e, i || arguments)
                }
            },
            stamp: function() {
                var t = 0
                  , e = "_leaflet_id";
                return function(i) {
                    return i[e] = i[e] || ++t,
                    i[e]
                }
            }(),
            invokeEach: function(t, e, i) {
                var n, o;
                if ("object" == typeof t) {
                    o = Array.prototype.slice.call(arguments, 3);
                    for (n in t)
                        e.apply(i, [n, t[n]].concat(o));
                    return !0
                }
                return !1
            },
            limitExecByInterval: function(t, e, i) {
                var n, o;
                return function s() {
                    var a = arguments;
                    return n ? (o = !0,
                    void 0) : (n = !0,
                    setTimeout(function() {
                        n = !1,
                        o && (s.apply(i, a),
                        o = !1)
                    }, e),
                    t.apply(i, a),
                    void 0)
                }
            },
            falseFn: function() {
                return !1
            },
            formatNum: function(t, e) {
                var i = Math.pow(10, e || 5);
                return Math.round(t * i) / i
            },
            trim: function(t) {
                return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
            },
            splitWords: function(t) {
                return o.Util.trim(t).split(/\s+/)
            },
            setOptions: function(t, e) {
                return t.options = o.extend({}, t.options, e),
                t.options
            },
            getParamString: function(t, e, i) {
                var n = [];
                for (var o in t)
                    n.push(encodeURIComponent(i ? o.toUpperCase() : o) + "=" + encodeURIComponent(t[o]));
                return (e && -1 !== e.indexOf("?") ? "&" : "?") + n.join("&")
            },
            template: function(t, e) {
                return t.replace(/\{ *([\w_]+) *\}/g, function(t, n) {
                    var o = e[n];
                    if (o === i)
                        throw new Error("No value provided for variable " + t);
                    return "function" == typeof o && (o = o(e)),
                    o
                })
            },
            isArray: function(t) {
                return "[object Array]" === Object.prototype.toString.call(t)
            },
            emptyImageUrl: "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="
        },
        function() {
            function e(e) {
                var i, n, o = ["webkit", "moz", "o", "ms"];
                for (i = 0; i < o.length && !n; i++)
                    n = t[o[i] + e];
                return n
            }
            function i(e) {
                var i = +new Date
                  , o = Math.max(0, 16 - (i - n));
                return n = i + o,
                t.setTimeout(e, o)
            }
            var n = 0
              , s = t.requestAnimationFrame || e("RequestAnimationFrame") || i
              , a = t.cancelAnimationFrame || e("CancelAnimationFrame") || e("CancelRequestAnimationFrame") || function(e) {
                t.clearTimeout(e)
            }
            ;
            o.Util.requestAnimFrame = function(e, n, a, r) {
                return e = o.bind(e, n),
                a && s === i ? (e(),
                void 0) : s.call(t, e, r)
            }
            ,
            o.Util.cancelAnimFrame = function(e) {
                e && a.call(t, e)
            }
        }(),
        o.extend = o.Util.extend,
        o.bind = o.Util.bind,
        o.stamp = o.Util.stamp,
        o.setOptions = o.Util.setOptions,
        o.Class = function() {}
        ,
        o.Class.extend = function(t) {
            var e = function() {
                this.initialize && this.initialize.apply(this, arguments),
                this._initHooks && this.callInitHooks()
            }
              , i = function() {};
            i.prototype = this.prototype;
            var n = new i;
            n.constructor = e,
            e.prototype = n;
            for (var s in this)
                this.hasOwnProperty(s) && "prototype" !== s && (e[s] = this[s]);
            t.statics && (o.extend(e, t.statics),
            delete t.statics),
            t.includes && (o.Util.extend.apply(null, [n].concat(t.includes)),
            delete t.includes),
            t.options && n.options && (t.options = o.extend({}, n.options, t.options)),
            o.extend(n, t),
            n._initHooks = [];
            var a = this;
            return e.__super__ = a.prototype,
            n.callInitHooks = function() {
                if (!this._initHooksCalled) {
                    a.prototype.callInitHooks && a.prototype.callInitHooks.call(this),
                    this._initHooksCalled = !0;
                    for (var t = 0, e = n._initHooks.length; e > t; t++)
                        n._initHooks[t].call(this)
                }
            }
            ,
            e
        }
        ,
        o.Class.include = function(t) {
            o.extend(this.prototype, t)
        }
        ,
        o.Class.mergeOptions = function(t) {
            o.extend(this.prototype.options, t)
        }
        ,
        o.Class.addInitHook = function(t) {
            var e = Array.prototype.slice.call(arguments, 1)
              , i = "function" == typeof t ? t : function() {
                this[t].apply(this, e)
            }
            ;
            this.prototype._initHooks = this.prototype._initHooks || [],
            this.prototype._initHooks.push(i)
        }
        ;
        var s = "_leaflet_events";
        o.Mixin = {},
        o.Mixin.Events = {
            addEventListener: function(t, e, i) {
                if (o.Util.invokeEach(t, this.addEventListener, this, e, i))
                    return this;
                var n, a, r, h, l, u, c, d = this[s] = this[s] || {}, p = i && o.stamp(i);
                for (t = o.Util.splitWords(t),
                n = 0,
                a = t.length; a > n; n++)
                    r = {
                        action: e,
                        context: i || this
                    },
                    h = t[n],
                    i ? (l = h + "_idx",
                    u = l + "_len",
                    c = d[l] = d[l] || {},
                    c[p] || (c[p] = [],
                    d[u] = (d[u] || 0) + 1),
                    c[p].push(r)) : (d[h] = d[h] || [],
                    d[h].push(r));
                return this
            },
            hasEventListeners: function(t) {
                var e = this[s];
                return !!e && (t in e && e[t].length > 0 || t + "_idx"in e && e[t + "_idx_len"] > 0)
            },
            removeEventListener: function(t, e, i) {
                if (!this[s])
                    return this;
                if (!t)
                    return this.clearAllEventListeners();
                if (o.Util.invokeEach(t, this.removeEventListener, this, e, i))
                    return this;
                var n, a, r, h, l, u, c, d, p, _ = this[s], m = i && o.stamp(i);
                for (t = o.Util.splitWords(t),
                n = 0,
                a = t.length; a > n; n++)
                    if (r = t[n],
                    u = r + "_idx",
                    c = u + "_len",
                    d = _[u],
                    e) {
                        if (h = i && d ? d[m] : _[r]) {
                            for (l = h.length - 1; l >= 0; l--)
                                h[l].action !== e || i && h[l].context !== i || (p = h.splice(l, 1),
                                p[0].action = o.Util.falseFn);
                            i && d && 0 === h.length && (delete d[m],
                            _[c]--)
                        }
                    } else
                        delete _[r],
                        delete _[u];
                return this
            },
            clearAllEventListeners: function() {
                return delete this[s],
                this
            },
            fireEvent: function(t, e) {
                if (!this.hasEventListeners(t))
                    return this;
                var i, n, a, r, h, l = o.Util.extend({}, e, {
                    type: t,
                    target: this
                }), u = this[s];
                if (u[t])
                    for (i = u[t].slice(),
                    n = 0,
                    a = i.length; a > n; n++)
                        i[n].action.call(i[n].context || this, l);
                r = u[t + "_idx"];
                for (h in r)
                    if (i = r[h].slice())
                        for (n = 0,
                        a = i.length; a > n; n++)
                            i[n].action.call(i[n].context || this, l);
                return this
            },
            addOneTimeEventListener: function(t, e, i) {
                if (o.Util.invokeEach(t, this.addOneTimeEventListener, this, e, i))
                    return this;
                var n = o.bind(function() {
                    this.removeEventListener(t, e, i).removeEventListener(t, n, i)
                }, this);
                return this.addEventListener(t, e, i).addEventListener(t, n, i)
            }
        },
        o.Mixin.Events.on = o.Mixin.Events.addEventListener,
        o.Mixin.Events.off = o.Mixin.Events.removeEventListener,
        o.Mixin.Events.once = o.Mixin.Events.addOneTimeEventListener,
        o.Mixin.Events.fire = o.Mixin.Events.fireEvent,
        function() {
            var n = !!t.ActiveXObject
              , s = n && !t.XMLHttpRequest
              , a = n && !e.querySelector
              , r = n && !e.addEventListener
              , h = navigator.userAgent.toLowerCase()
              , l = -1 !== h.indexOf("webkit")
              , u = -1 !== h.indexOf("chrome")
              , c = -1 !== h.indexOf("phantom")
              , d = -1 !== h.indexOf("android")
              , p = -1 !== h.search("android [23]")
              , _ = typeof orientation != i + ""
              , m = t.navigator && t.navigator.msPointerEnabled && t.navigator.msMaxTouchPoints
              , f = "devicePixelRatio"in t && t.devicePixelRatio > 1 || "matchMedia"in t && t.matchMedia("(min-resolution:144dpi)") && t.matchMedia("(min-resolution:144dpi)").matches
              , g = e.documentElement
              , v = n && "transition"in g.style
              , y = "WebKitCSSMatrix"in t && "m11"in new t.WebKitCSSMatrix
              , L = "MozPerspective"in g.style
              , P = "OTransition"in g.style
              , x = !t.L_DISABLE_3D && (v || y || L || P) && !c
              , w = !t.L_NO_TOUCH && !c && function() {
                var t = "ontouchstart";
                if (m || t in g)
                    return !0;
                var i = e.createElement("div")
                  , n = !1;
                return i.setAttribute ? (i.setAttribute(t, "return;"),
                "function" == typeof i[t] && (n = !0),
                i.removeAttribute(t),
                i = null,
                n) : !1
            }();
            o.Browser = {
                ie: n,
                ie6: s,
                ie7: a,
                ielt9: r,
                webkit: l,
                android: d,
                android23: p,
                chrome: u,
                ie3d: v,
                webkit3d: y,
                gecko3d: L,
                opera3d: P,
                any3d: x,
                mobile: _,
                mobileWebkit: _ && l,
                mobileWebkit3d: _ && y,
                mobileOpera: _ && t.opera,
                touch: w,
                msTouch: m,
                retina: f
            }
        }(),
        o.Point = function(t, e, i) {
            this.x = i ? Math.round(t) : t,
            this.y = i ? Math.round(e) : e
        }
        ,
        o.Point.prototype = {
            clone: function() {
                return new o.Point(this.x,this.y)
            },
            add: function(t) {
                return this.clone()._add(o.point(t))
            },
            _add: function(t) {
                return this.x += t.x,
                this.y += t.y,
                this
            },
            subtract: function(t) {
                return this.clone()._subtract(o.point(t))
            },
            _subtract: function(t) {
                return this.x -= t.x,
                this.y -= t.y,
                this
            },
            divideBy: function(t) {
                return this.clone()._divideBy(t)
            },
            _divideBy: function(t) {
                return this.x /= t,
                this.y /= t,
                this
            },
            multiplyBy: function(t) {
                return this.clone()._multiplyBy(t)
            },
            _multiplyBy: function(t) {
                return this.x *= t,
                this.y *= t,
                this
            },
            round: function() {
                return this.clone()._round()
            },
            _round: function() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
            },
            floor: function() {
                return this.clone()._floor()
            },
            _floor: function() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this
            },
            distanceTo: function(t) {
                t = o.point(t);
                var e = t.x - this.x
                  , i = t.y - this.y;
                return Math.sqrt(e * e + i * i)
            },
            equals: function(t) {
                return t = o.point(t),
                t.x === this.x && t.y === this.y
            },
            contains: function(t) {
                return t = o.point(t),
                Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y)
            },
            toString: function() {
                return "Point(" + o.Util.formatNum(this.x) + ", " + o.Util.formatNum(this.y) + ")"
            }
        },
        o.point = function(t, e, n) {
            return t instanceof o.Point ? t : o.Util.isArray(t) ? new o.Point(t[0],t[1]) : t === i || null === t ? t : new o.Point(t,e,n)
        }
        ,
        o.Bounds = function(t, e) {
            if (t)
                for (var i = e ? [t, e] : t, n = 0, o = i.length; o > n; n++)
                    this.extend(i[n])
        }
        ,
        o.Bounds.prototype = {
            extend: function(t) {
                return t = o.point(t),
                this.min || this.max ? (this.min.x = Math.min(t.x, this.min.x),
                this.max.x = Math.max(t.x, this.max.x),
                this.min.y = Math.min(t.y, this.min.y),
                this.max.y = Math.max(t.y, this.max.y)) : (this.min = t.clone(),
                this.max = t.clone()),
                this
            },
            getCenter: function(t) {
                return new o.Point((this.min.x + this.max.x) / 2,(this.min.y + this.max.y) / 2,t)
            },
            getBottomLeft: function() {
                return new o.Point(this.min.x,this.max.y)
            },
            getTopRight: function() {
                return new o.Point(this.max.x,this.min.y)
            },
            getSize: function() {
                return this.max.subtract(this.min)
            },
            contains: function(t) {
                var e, i;
                return t = "number" == typeof t[0] || t instanceof o.Point ? o.point(t) : o.bounds(t),
                t instanceof o.Bounds ? (e = t.min,
                i = t.max) : e = i = t,
                e.x >= this.min.x && i.x <= this.max.x && e.y >= this.min.y && i.y <= this.max.y
            },
            intersects: function(t) {
                t = o.bounds(t);
                var e = this.min
                  , i = this.max
                  , n = t.min
                  , s = t.max
                  , a = s.x >= e.x && n.x <= i.x
                  , r = s.y >= e.y && n.y <= i.y;
                return a && r
            },
            isValid: function() {
                return !(!this.min || !this.max)
            }
        },
        o.bounds = function(t, e) {
            return !t || t instanceof o.Bounds ? t : new o.Bounds(t,e)
        }
        ,
        o.Transformation = function(t, e, i, n) {
            this._a = t,
            this._b = e,
            this._c = i,
            this._d = n
        }
        ,
        o.Transformation.prototype = {
            transform: function(t, e) {
                return this._transform(t.clone(), e)
            },
            _transform: function(t, e) {
                return e = e || 1,
                t.x = e * (this._a * t.x + this._b),
                t.y = e * (this._c * t.y + this._d),
                t
            },
            untransform: function(t, e) {
                return e = e || 1,
                new o.Point((t.x / e - this._b) / this._a,(t.y / e - this._d) / this._c)
            }
        },
        o.DomUtil = {
            get: function(t) {
                return "string" == typeof t ? e.getElementById(t) : t
            },
            getStyle: function(t, i) {
                var n = t.style[i];
                if (!n && t.currentStyle && (n = t.currentStyle[i]),
                (!n || "auto" === n) && e.defaultView) {
                    var o = e.defaultView.getComputedStyle(t, null);
                    n = o ? o[i] : null
                }
                return "auto" === n ? null : n
            },
            getViewportOffset: function(t) {
                var i, n = 0, s = 0, a = t, r = e.body, h = e.documentElement, l = o.Browser.ie7;
                do {
                    if (n += a.offsetTop || 0,
                    s += a.offsetLeft || 0,
                    n += parseInt(o.DomUtil.getStyle(a, "borderTopWidth"), 10) || 0,
                    s += parseInt(o.DomUtil.getStyle(a, "borderLeftWidth"), 10) || 0,
                    i = o.DomUtil.getStyle(a, "position"),
                    a.offsetParent === r && "absolute" === i)
                        break;
                    if ("fixed" === i) {
                        n += r.scrollTop || h.scrollTop || 0,
                        s += r.scrollLeft || h.scrollLeft || 0;
                        break
                    }
                    if ("relative" === i && !a.offsetLeft) {
                        var u = o.DomUtil.getStyle(a, "width")
                          , c = o.DomUtil.getStyle(a, "max-width")
                          , d = a.getBoundingClientRect();
                        ("none" !== u || "none" !== c) && (s += d.left + a.clientLeft),
                        n += d.top + (r.scrollTop || h.scrollTop || 0);
                        break
                    }
                    a = a.offsetParent
                } while (a);
                a = t;
                do {
                    if (a === r)
                        break;
                    n -= a.scrollTop || 0,
                    s -= a.scrollLeft || 0,
                    o.DomUtil.documentIsLtr() || !o.Browser.webkit && !l || (s += a.scrollWidth - a.clientWidth,
                    l && "hidden" !== o.DomUtil.getStyle(a, "overflow-y") && "hidden" !== o.DomUtil.getStyle(a, "overflow") && (s += 17)),
                    a = a.parentNode
                } while (a);
                return new o.Point(s,n)
            },
            documentIsLtr: function() {
                return o.DomUtil._docIsLtrCached || (o.DomUtil._docIsLtrCached = !0,
                o.DomUtil._docIsLtr = "ltr" === o.DomUtil.getStyle(e.body, "direction")),
                o.DomUtil._docIsLtr
            },
            create: function(t, i, n) {
                var o = e.createElement(t);
                return o.className = i,
                n && n.appendChild(o),
                o
            },
            hasClass: function(t, e) {
                return t.className.length > 0 && (new RegExp("(^|\\s)" + e + "(\\s|$)")).test(t.className)
            },
            addClass: function(t, e) {
                o.DomUtil.hasClass(t, e) || (t.className += (t.className ? " " : "") + e)
            },
            removeClass: function(t, e) {
                t.className = o.Util.trim((" " + t.className + " ").replace(" " + e + " ", " "))
            },
            setOpacity: function(t, e) {
                if ("opacity"in t.style)
                    t.style.opacity = e;
                else if ("filter"in t.style) {
                    var i = !1
                      , n = "DXImageTransform.Microsoft.Alpha";
                    try {
                        i = t.filters.item(n)
                    } catch (o$30) {
                        if (1 === e)
                            return
                    }
                    e = Math.round(100 * e),
                    i ? (i.Enabled = 100 !== e,
                    i.Opacity = e) : t.style.filter += " progid:" + n + "(opacity=" + e + ")"
                }
            },
            testProp: function(t) {
                for (var i = e.documentElement.style, n = 0; n < t.length; n++)
                    if (t[n]in i)
                        return t[n];
                return !1
            },
            getTranslateString: function(t) {
                var e = o.Browser.webkit3d
                  , i = "translate" + (e ? "3d" : "") + "("
                  , n = (e ? ",0" : "") + ")";
                return i + t.x + "px," + t.y + "px" + n
            },
            getScaleString: function(t, e) {
                var i = o.DomUtil.getTranslateString(e.add(e.multiplyBy(-1 * t)))
                  , n = " scale(" + t + ") ";
                return i + n
            },
            setPosition: function(t, e, i) {
                t._leaflet_pos = e,
                !i && o.Browser.any3d ? (t.style[o.DomUtil.TRANSFORM] = o.DomUtil.getTranslateString(e),
                o.Browser.mobileWebkit3d && (t.style.WebkitBackfaceVisibility = "hidden")) : (t.style.left = e.x + "px",
                t.style.top = e.y + "px")
            },
            getPosition: function(t) {
                return t._leaflet_pos
            }
        },
        o.DomUtil.TRANSFORM = o.DomUtil.testProp(["transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform"]),
        o.DomUtil.TRANSITION = o.DomUtil.testProp(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]),
        o.DomUtil.TRANSITION_END = "webkitTransition" === o.DomUtil.TRANSITION || "OTransition" === o.DomUtil.TRANSITION ? o.DomUtil.TRANSITION + "End" : "transitionend",
        function() {
            var i = o.DomUtil.testProp(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);
            o.extend(o.DomUtil, {
                disableTextSelection: function() {
                    if (o.DomEvent.on(t, "selectstart", o.DomEvent.preventDefault),
                    i) {
                        var n = e.documentElement.style;
                        this._userSelect = n[i],
                        n[i] = "none"
                    }
                },
                enableTextSelection: function() {
                    o.DomEvent.off(t, "selectstart", o.DomEvent.preventDefault),
                    i && (e.documentElement.style[i] = this._userSelect,
                    delete this._userSelect)
                },
                disableImageDrag: function() {
                    o.DomEvent.on(t, "dragstart", o.DomEvent.preventDefault)
                },
                enableImageDrag: function() {
                    o.DomEvent.off(t, "dragstart", o.DomEvent.preventDefault)
                }
            })
        }(),
        o.LatLng = function(t, e) {
            var i = parseFloat(t)
              , n = parseFloat(e);
            if (isNaN(i) || isNaN(n))
                throw new Error("Invalid LatLng object: (" + t + ", " + e + ")");
            this.lat = i,
            this.lng = n
        }
        ,
        o.extend(o.LatLng, {
            DEG_TO_RAD: Math.PI / 180,
            RAD_TO_DEG: 180 / Math.PI,
            MAX_MARGIN: 1E-9
        }),
        o.LatLng.prototype = {
            equals: function(t) {
                if (!t)
                    return !1;
                t = o.latLng(t);
                var e = Math.max(Math.abs(this.lat - t.lat), Math.abs(this.lng - t.lng));
                return e <= o.LatLng.MAX_MARGIN
            },
            toString: function(t) {
                return "LatLng(" + o.Util.formatNum(this.lat, t) + ", " + o.Util.formatNum(this.lng, t) + ")"
            },
            distanceTo: function(t) {
                t = o.latLng(t);
                var e = 6378137
                  , i = o.LatLng.DEG_TO_RAD
                  , n = (t.lat - this.lat) * i
                  , s = (t.lng - this.lng) * i
                  , a = this.lat * i
                  , r = t.lat * i
                  , h = Math.sin(n / 2)
                  , l = Math.sin(s / 2)
                  , u = h * h + l * l * Math.cos(a) * Math.cos(r);
                return 2 * e * Math.atan2(Math.sqrt(u), Math.sqrt(1 - u))
            },
            wrap: function(t, e) {
                var i = this.lng;
                return t = t || -180,
                e = e || 180,
                i = (i + e) % (e - t) + (t > i || i === e ? e : t),
                new o.LatLng(this.lat,i)
            }
        },
        o.latLng = function(t, e) {
            return t instanceof o.LatLng ? t : o.Util.isArray(t) ? new o.LatLng(t[0],t[1]) : t === i || null === t ? t : "object" == typeof t && "lat"in t ? new o.LatLng(t.lat,"lng"in t ? t.lng : t.lon) : new o.LatLng(t,e)
        }
        ,
        o.LatLngBounds = function(t, e) {
            if (t)
                for (var i = e ? [t, e] : t, n = 0, o = i.length; o > n; n++)
                    this.extend(i[n])
        }
        ,
        o.LatLngBounds.prototype = {
            extend: function(t) {
                return t ? (t = "number" == typeof t[0] || "string" == typeof t[0] || t instanceof o.LatLng ? o.latLng(t) : o.latLngBounds(t),
                t instanceof o.LatLng ? this._southWest || this._northEast ? (this._southWest.lat = Math.min(t.lat, this._southWest.lat),
                this._southWest.lng = Math.min(t.lng, this._southWest.lng),
                this._northEast.lat = Math.max(t.lat, this._northEast.lat),
                this._northEast.lng = Math.max(t.lng, this._northEast.lng)) : (this._southWest = new o.LatLng(t.lat,t.lng),
                this._northEast = new o.LatLng(t.lat,t.lng)) : t instanceof o.LatLngBounds && (this.extend(t._southWest),
                this.extend(t._northEast)),
                this) : this
            },
            pad: function(t) {
                var e = this._southWest
                  , i = this._northEast
                  , n = Math.abs(e.lat - i.lat) * t
                  , s = Math.abs(e.lng - i.lng) * t;
                return new o.LatLngBounds(new o.LatLng(e.lat - n,e.lng - s),new o.LatLng(i.lat + n,i.lng + s))
            },
            getCenter: function() {
                return new o.LatLng((this._southWest.lat + this._northEast.lat) / 2,(this._southWest.lng + this._northEast.lng) / 2)
            },
            getSouthWest: function() {
                return this._southWest
            },
            getNorthEast: function() {
                return this._northEast
            },
            getNorthWest: function() {
                return new o.LatLng(this.getNorth(),this.getWest())
            },
            getSouthEast: function() {
                return new o.LatLng(this.getSouth(),this.getEast())
            },
            getWest: function() {
                return this._southWest.lng
            },
            getSouth: function() {
                return this._southWest.lat
            },
            getEast: function() {
                return this._northEast.lng
            },
            getNorth: function() {
                return this._northEast.lat
            },
            contains: function(t) {
                t = "number" == typeof t[0] || t instanceof o.LatLng ? o.latLng(t) : o.latLngBounds(t);
                var e, i, n = this._southWest, s = this._northEast;
                return t instanceof o.LatLngBounds ? (e = t.getSouthWest(),
                i = t.getNorthEast()) : e = i = t,
                e.lat >= n.lat && i.lat <= s.lat && e.lng >= n.lng && i.lng <= s.lng
            },
            intersects: function(t) {
                t = o.latLngBounds(t);
                var e = this._southWest
                  , i = this._northEast
                  , n = t.getSouthWest()
                  , s = t.getNorthEast()
                  , a = s.lat >= e.lat && n.lat <= i.lat
                  , r = s.lng >= e.lng && n.lng <= i.lng;
                return a && r
            },
            toBBoxString: function() {
                return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",")
            },
            equals: function(t) {
                return t ? (t = o.latLngBounds(t),
                this._southWest.equals(t.getSouthWest()) && this._northEast.equals(t.getNorthEast())) : !1
            },
            isValid: function() {
                return !(!this._southWest || !this._northEast)
            }
        },
        o.latLngBounds = function(t, e) {
            return !t || t instanceof o.LatLngBounds ? t : new o.LatLngBounds(t,e)
        }
        ,
        o.Projection = {},
        o.Projection.SphericalMercator = {
            MAX_LATITUDE: 85.0511287798,
            project: function(t) {
                var e = o.LatLng.DEG_TO_RAD
                  , i = this.MAX_LATITUDE
                  , n = Math.max(Math.min(i, t.lat), -i)
                  , s = t.lng * e
                  , a = n * e;
                return a = Math.log(Math.tan(Math.PI / 4 + a / 2)),
                new o.Point(s,a)
            },
            unproject: function(t) {
                var e = o.LatLng.RAD_TO_DEG
                  , i = t.x * e
                  , n = (2 * Math.atan(Math.exp(t.y)) - Math.PI / 2) * e;
                return new o.LatLng(n,i)
            }
        },
        o.Projection.LonLat = {
            project: function(t) {
                return new o.Point(t.lng,t.lat)
            },
            unproject: function(t) {
                return new o.LatLng(t.y,t.x)
            }
        },
        o.CRS = {
            latLngToPoint: function(t, e) {
                var i = this.projection.project(t)
                  , n = this.scale(e);
                return this.transformation._transform(i, n)
            },
            pointToLatLng: function(t, e) {
                var i = this.scale(e)
                  , n = this.transformation.untransform(t, i);
                return this.projection.unproject(n)
            },
            project: function(t) {
                return this.projection.project(t)
            },
            scale: function(t) {
                return 256 * Math.pow(2, t)
            }
        },
        o.CRS.Simple = o.extend({}, o.CRS, {
            projection: o.Projection.LonLat,
            transformation: new o.Transformation(1,0,-1,0),
            scale: function(t) {
                return Math.pow(2, t)
            }
        }),
        o.CRS.EPSG3857 = o.extend({}, o.CRS, {
            code: "EPSG:3857",
            projection: o.Projection.SphericalMercator,
            transformation: new o.Transformation(.5 / Math.PI,.5,-.5 / Math.PI,.5),
            project: function(t) {
                var e = this.projection.project(t)
                  , i = 6378137;
                return e.multiplyBy(i)
            }
        }),
        o.CRS.EPSG900913 = o.extend({}, o.CRS.EPSG3857, {
            code: "EPSG:900913"
        }),
        o.CRS.EPSG4326 = o.extend({}, o.CRS, {
            code: "EPSG:4326",
            projection: o.Projection.LonLat,
            transformation: new o.Transformation(1 / 360,.5,-1 / 360,.5)
        }),
        o.Map = o.Class.extend({
            includes: o.Mixin.Events,
            options: {
                crs: o.CRS.EPSG3857,
                fadeAnimation: o.DomUtil.TRANSITION && !o.Browser.android23,
                trackResize: !0,
                markerZoomAnimation: o.DomUtil.TRANSITION && o.Browser.any3d
            },
            initialize: function(t, e) {
                e = o.setOptions(this, e),
                this._initContainer(t),
                this._initLayout(),
                this._initEvents(),
                e.maxBounds && this.setMaxBounds(e.maxBounds),
                e.center && e.zoom !== i && this.setView(o.latLng(e.center), e.zoom, {
                    reset: !0
                }),
                this._handlers = [],
                this._layers = {},
                this._zoomBoundLayers = {},
                this._tileLayersNum = 0,
                this.callInitHooks(),
                this._addLayers(e.layers)
            },
            setView: function(t, e) {
                return this._resetView(o.latLng(t), this._limitZoom(e)),
                this
            },
            setZoom: function(t, e) {
                return this.setView(this.getCenter(), t, {
                    zoom: e
                })
            },
            zoomIn: function(t, e) {
                return this.setZoom(this._zoom + (t || 1), e)
            },
            zoomOut: function(t, e) {
                return this.setZoom(this._zoom - (t || 1), e)
            },
            setZoomAround: function(t, e, i) {
                var n = this.getZoomScale(e)
                  , s = this.getSize().divideBy(2)
                  , a = t instanceof o.Point ? t : this.latLngToContainerPoint(t)
                  , r = a.subtract(s).multiplyBy(1 - 1 / n)
                  , h = this.containerPointToLatLng(s.add(r));
                return this.setView(h, e, {
                    zoom: i
                })
            },
            fitBounds: function(t, e) {
                e = e || {},
                t = t.getBounds ? t.getBounds() : o.latLngBounds(t);
                var i = o.point(e.paddingTopLeft || e.padding || [0, 0])
                  , n = o.point(e.paddingBottomRight || e.padding || [0, 0])
                  , s = this.getBoundsZoom(t, !1, i.add(n))
                  , a = n.subtract(i).divideBy(2)
                  , r = this.project(t.getSouthWest(), s)
                  , h = this.project(t.getNorthEast(), s)
                  , l = this.unproject(r.add(h).divideBy(2).add(a), s);
                return this.setView(l, s, e)
            },
            fitWorld: function(t) {
                return this.fitBounds([[-90, -180], [90, 180]], t)
            },
            panTo: function(t, e) {
                return this.setView(t, this._zoom, {
                    pan: e
                })
            },
            panBy: function(t) {
                return this.fire("movestart"),
                this._rawPanBy(o.point(t)),
                this.fire("move"),
                this.fire("moveend")
            },
            setMaxBounds: function(t, e) {
                if (t = o.latLngBounds(t),
                this.options.maxBounds = t,
                !t)
                    return this._boundsMinZoom = null,
                    this.off("moveend", this._panInsideMaxBounds, this),
                    this;
                var i = this.getBoundsZoom(t, !0);
                return this._boundsMinZoom = i,
                this._loaded && (this._zoom < i ? this.setView(t.getCenter(), i, e) : this.panInsideBounds(t)),
                this.on("moveend", this._panInsideMaxBounds, this),
                this
            },
            panInsideBounds: function(t) {
                t = o.latLngBounds(t);
                var e = this.getPixelBounds()
                  , i = e.getBottomLeft()
                  , n = e.getTopRight()
                  , s = this.project(t.getSouthWest())
                  , a = this.project(t.getNorthEast())
                  , r = 0
                  , h = 0;
                return n.y < a.y && (h = Math.ceil(a.y - n.y)),
                n.x > a.x && (r = Math.floor(a.x - n.x)),
                i.y > s.y && (h = Math.floor(s.y - i.y)),
                i.x < s.x && (r = Math.ceil(s.x - i.x)),
                r || h ? this.panBy([r, h]) : this
            },
            addLayer: function(t) {
                var e = o.stamp(t);
                return this._layers[e] ? this : (this._layers[e] = t,
                !t.options || isNaN(t.options.maxZoom) && isNaN(t.options.minZoom) || (this._zoomBoundLayers[e] = t,
                this._updateZoomLevels()),
                this.options.zoomAnimation && o.TileLayer && t instanceof o.TileLayer && (this._tileLayersNum++,
                this._tileLayersToLoad++,
                t.on("load", this._onTileLayerLoad, this)),
                this._loaded && this._layerAdd(t),
                this)
            },
            removeLayer: function(t) {
                var e = o.stamp(t);
                if (this._layers[e])
                    return this._loaded && t.onRemove(this),
                    delete this._layers[e],
                    this._loaded && this.fire("layerremove", {
                        layer: t
                    }),
                    this._zoomBoundLayers[e] && (delete this._zoomBoundLayers[e],
                    this._updateZoomLevels()),
                    this.options.zoomAnimation && o.TileLayer && t instanceof o.TileLayer && (this._tileLayersNum--,
                    this._tileLayersToLoad--,
                    t.off("load", this._onTileLayerLoad, this)),
                    this
            },
            hasLayer: function(t) {
                return t ? o.stamp(t)in this._layers : !1
            },
            eachLayer: function(t, e) {
                for (var i in this._layers)
                    t.call(e, this._layers[i]);
                return this
            },
            invalidateSize: function(t) {
                t = o.extend({
                    animate: !1,
                    pan: !0
                }, t === !0 ? {
                    animate: !0
                } : t);
                var e = this.getSize();
                if (this._sizeChanged = !0,
                this.options.maxBounds && this.setMaxBounds(this.options.maxBounds),
                !this._loaded)
                    return this;
                var i = this.getSize()
                  , n = e.subtract(i).divideBy(2).round();
                return n.x || n.y ? (t.animate && t.pan ? this.panBy(n) : (t.pan && this._rawPanBy(n),
                this.fire("move"),
                clearTimeout(this._sizeTimer),
                this._sizeTimer = setTimeout(o.bind(this.fire, this, "moveend"), 200)),
                this.fire("resize", {
                    oldSize: e,
                    newSize: i
                })) : this
            },
            addHandler: function(t, e) {
                if (e) {
                    var i = this[t] = new e(this);
                    return this._handlers.push(i),
                    this.options[t] && i.enable(),
                    this
                }
            },
            remove: function() {
                return this._loaded && this.fire("unload"),
                this._initEvents("off"),
                delete this._container._leaflet,
                this._clearPanes(),
                this._clearControlPos && this._clearControlPos(),
                this._clearHandlers(),
                this
            },
            getCenter: function() {
                return this._checkIfLoaded(),
                this._moved() ? this.layerPointToLatLng(this._getCenterLayerPoint()) : this._initialCenter
            },
            getZoom: function() {
                return this._zoom
            },
            getBounds: function() {
                var t = this.getPixelBounds()
                  , e = this.unproject(t.getBottomLeft())
                  , i = this.unproject(t.getTopRight());
                return new o.LatLngBounds(e,i)
            },
            getMinZoom: function() {
                var t = this._layersMinZoom === i ? 0 : this._layersMinZoom
                  , e = this._boundsMinZoom === i ? 0 : this._boundsMinZoom;
                return this.options.minZoom === i ? Math.max(t, e) : this.options.minZoom
            },
            getMaxZoom: function() {
                return this.options.maxZoom === i ? this._layersMaxZoom === i ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom
            },
            getBoundsZoom: function(t, e, i) {
                t = o.latLngBounds(t);
                var n, s = this.getMinZoom() - (e ? 1 : 0), a = this.getMaxZoom(), r = this.getSize(), h = t.getNorthWest(), l = t.getSouthEast(), u = !0;
                i = o.point(i || [0, 0]);
                do
                    s++,
                    n = this.project(l, s).subtract(this.project(h, s)).add(i),
                    u = e ? n.x < r.x || n.y < r.y : r.contains(n);
                while (u && a >= s);
                return u && e ? null : e ? s : s - 1
            },
            getSize: function() {
                return (!this._size || this._sizeChanged) && (this._size = new o.Point(this._container.clientWidth,this._container.clientHeight),
                this._sizeChanged = !1),
                this._size.clone()
            },
            getPixelBounds: function() {
                var t = this._getTopLeftPoint();
                return new o.Bounds(t,t.add(this.getSize()))
            },
            getPixelOrigin: function() {
                return this._checkIfLoaded(),
                this._initialTopLeftPoint
            },
            getPanes: function() {
                return this._panes
            },
            getContainer: function() {
                return this._container
            },
            getZoomScale: function(t) {
                var e = this.options.crs;
                return e.scale(t) / e.scale(this._zoom)
            },
            getScaleZoom: function(t) {
                return this._zoom + Math.log(t) / Math.LN2
            },
            project: function(t, e) {
                return e = e === i ? this._zoom : e,
                this.options.crs.latLngToPoint(o.latLng(t), e)
            },
            unproject: function(t, e) {
                return e = e === i ? this._zoom : e,
                this.options.crs.pointToLatLng(o.point(t), e)
            },
            layerPointToLatLng: function(t) {
                var e = o.point(t).add(this.getPixelOrigin());
                return this.unproject(e)
            },
            latLngToLayerPoint: function(t) {
                var e = this.project(o.latLng(t))._round();
                return e._subtract(this.getPixelOrigin())
            },
            containerPointToLayerPoint: function(t) {
                return o.point(t).subtract(this._getMapPanePos())
            },
            layerPointToContainerPoint: function(t) {
                return o.point(t).add(this._getMapPanePos())
            },
            containerPointToLatLng: function(t) {
                var e = this.containerPointToLayerPoint(o.point(t));
                return this.layerPointToLatLng(e)
            },
            latLngToContainerPoint: function(t) {
                return this.layerPointToContainerPoint(this.latLngToLayerPoint(o.latLng(t)))
            },
            mouseEventToContainerPoint: function(t) {
                return o.DomEvent.getMousePosition(t, this._container)
            },
            mouseEventToLayerPoint: function(t) {
                return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))
            },
            mouseEventToLatLng: function(t) {
                return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))
            },
            _initContainer: function(t) {
                var e = this._container = o.DomUtil.get(t);
                if (!e)
                    throw new Error("Map container not found.");
                if (e._leaflet)
                    throw new Error("Map container is already initialized.");
                e._leaflet = !0
            },
            _initLayout: function() {
                var t = this._container;
                o.DomUtil.addClass(t, "leaflet-container" + (o.Browser.touch ? " leaflet-touch" : "") + (o.Browser.retina ? " leaflet-retina" : "") + (this.options.fadeAnimation ? " leaflet-fade-anim" : ""));
                var e = o.DomUtil.getStyle(t, "position");
                "absolute" !== e && "relative" !== e && "fixed" !== e && (t.style.position = "relative"),
                this._initPanes(),
                this._initControlPos && this._initControlPos()
            },
            _initPanes: function() {
                var t = this._panes = {};
                this._mapPane = t.mapPane = this._createPane("leaflet-map-pane", this._container),
                this._tilePane = t.tilePane = this._createPane("leaflet-tile-pane", this._mapPane),
                t.objectsPane = this._createPane("leaflet-objects-pane", this._mapPane),
                t.shadowPane = this._createPane("leaflet-shadow-pane"),
                t.overlayPane = this._createPane("leaflet-overlay-pane"),
                t.markerPane = this._createPane("leaflet-marker-pane"),
                t.popupPane = this._createPane("leaflet-popup-pane");
                var e = " leaflet-zoom-hide";
                this.options.markerZoomAnimation || (o.DomUtil.addClass(t.markerPane, e),
                o.DomUtil.addClass(t.shadowPane, e),
                o.DomUtil.addClass(t.popupPane, e))
            },
            _createPane: function(t, e) {
                return o.DomUtil.create("div", t, e || this._panes.objectsPane)
            },
            _clearPanes: function() {
                this._container.removeChild(this._mapPane)
            },
            _addLayers: function(t) {
                t = t ? o.Util.isArray(t) ? t : [t] : [];
                for (var e = 0, i = t.length; i > e; e++)
                    this.addLayer(t[e])
            },
            _resetView: function(t, e, i, n) {
                var s = this._zoom !== e;
                n || (this.fire("movestart"),
                s && this.fire("zoomstart")),
                this._zoom = e,
                this._initialCenter = t,
                this._initialTopLeftPoint = this._getNewTopLeftPoint(t),
                i ? this._initialTopLeftPoint._add(this._getMapPanePos()) : o.DomUtil.setPosition(this._mapPane, new o.Point(0,0)),
                this._tileLayersToLoad = this._tileLayersNum;
                var a = !this._loaded;
                this._loaded = !0,
                a && (this.fire("load"),
                this.eachLayer(this._layerAdd, this)),
                this.fire("viewreset", {
                    hard: !i
                }),
                this.fire("move"),
                (s || n) && this.fire("zoomend"),
                this.fire("moveend", {
                    hard: !i
                })
            },
            _rawPanBy: function(t) {
                o.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(t))
            },
            _getZoomSpan: function() {
                return this.getMaxZoom() - this.getMinZoom()
            },
            _updateZoomLevels: function() {
                var t, e = 1 / 0, n = -1 / 0, o = this._getZoomSpan();
                for (t in this._zoomBoundLayers) {
                    var s = this._zoomBoundLayers[t];
                    isNaN(s.options.minZoom) || (e = Math.min(e, s.options.minZoom)),
                    isNaN(s.options.maxZoom) || (n = Math.max(n, s.options.maxZoom))
                }
                t === i ? this._layersMaxZoom = this._layersMinZoom = i : (this._layersMaxZoom = n,
                this._layersMinZoom = e),
                o !== this._getZoomSpan() && this.fire("zoomlevelschange")
            },
            _panInsideMaxBounds: function() {
                this.panInsideBounds(this.options.maxBounds)
            },
            _checkIfLoaded: function() {
                if (!this._loaded)
                    throw new Error("Set map center and zoom first.");
            },
            _initEvents: function(e) {
                if (o.DomEvent) {
                    e = e || "on",
                    o.DomEvent[e](this._container, "click", this._onMouseClick, this);
                    var i, n, s = ["dblclick", "mousedown", "mouseup", "mouseenter", "mouseleave", "mousemove", "contextmenu"];
                    for (i = 0,
                    n = s.length; n > i; i++)
                        o.DomEvent[e](this._container, s[i], this._fireMouseEvent, this);
                    this.options.trackResize && o.DomEvent[e](t, "resize", this._onResize, this)
                }
            },
            _onResize: function() {
                o.Util.cancelAnimFrame(this._resizeRequest),
                this._resizeRequest = o.Util.requestAnimFrame(this.invalidateSize, this, !1, this._container)
            },
            _onMouseClick: function(t) {
                !this._loaded || !t._simulated && this.dragging && this.dragging.moved() || o.DomEvent._skipped(t) || (this.fire("preclick"),
                this._fireMouseEvent(t))
            },
            _fireMouseEvent: function(t) {
                if (this._loaded && !o.DomEvent._skipped(t)) {
                    var e = t.type;
                    if (e = "mouseenter" === e ? "mouseover" : "mouseleave" === e ? "mouseout" : e,
                    this.hasEventListeners(e)) {
                        "contextmenu" === e && o.DomEvent.preventDefault(t);
                        var i = this.mouseEventToContainerPoint(t)
                          , n = this.containerPointToLayerPoint(i)
                          , s = this.layerPointToLatLng(n);
                        this.fire(e, {
                            latlng: s,
                            layerPoint: n,
                            containerPoint: i,
                            originalEvent: t
                        })
                    }
                }
            },
            _onTileLayerLoad: function() {
                this._tileLayersToLoad--,
                this._tileLayersNum && !this._tileLayersToLoad && this.fire("tilelayersload")
            },
            _clearHandlers: function() {
                for (var t = 0, e = this._handlers.length; e > t; t++)
                    this._handlers[t].disable()
            },
            whenReady: function(t, e) {
                return this._loaded ? t.call(e || this, this) : this.on("load", t, e),
                this
            },
            _layerAdd: function(t) {
                t.onAdd(this),
                this.fire("layeradd", {
                    layer: t
                })
            },
            _getMapPanePos: function() {
                return o.DomUtil.getPosition(this._mapPane)
            },
            _moved: function() {
                var t = this._getMapPanePos();
                return t && !t.equals([0, 0])
            },
            _getTopLeftPoint: function() {
                return this.getPixelOrigin().subtract(this._getMapPanePos())
            },
            _getNewTopLeftPoint: function(t, e) {
                var i = this.getSize()._divideBy(2);
                return this.project(t, e)._subtract(i)._round()
            },
            _latLngToNewLayerPoint: function(t, e, i) {
                var n = this._getNewTopLeftPoint(i, e).add(this._getMapPanePos());
                return this.project(t, e)._subtract(n)
            },
            _getCenterLayerPoint: function() {
                return this.containerPointToLayerPoint(this.getSize()._divideBy(2))
            },
            _getCenterOffset: function(t) {
                return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())
            },
            _limitZoom: function(t) {
                var e = this.getMinZoom()
                  , i = this.getMaxZoom();
                return Math.max(e, Math.min(i, t))
            }
        }),
        o.map = function(t, e) {
            return new o.Map(t,e)
        }
        ,
        o.Projection.Mercator = {
            MAX_LATITUDE: 85.0840591556,
            R_MINOR: 6356752.314245179,
            R_MAJOR: 6378137,
            project: function(t) {
                var e = o.LatLng.DEG_TO_RAD
                  , i = this.MAX_LATITUDE
                  , n = Math.max(Math.min(i, t.lat), -i)
                  , s = this.R_MAJOR
                  , a = this.R_MINOR
                  , r = t.lng * e * s
                  , h = n * e
                  , l = a / s
                  , u = Math.sqrt(1 - l * l)
                  , c = u * Math.sin(h);
                c = Math.pow((1 - c) / (1 + c), .5 * u);
                var d = Math.tan(.5 * (.5 * Math.PI - h)) / c;
                return h = -s * Math.log(d),
                new o.Point(r,h)
            },
            unproject: function(t) {
                for (var e, i = o.LatLng.RAD_TO_DEG, n = this.R_MAJOR, s = this.R_MINOR, a = t.x * i / n, r = s / n, h = Math.sqrt(1 - r * r), l = Math.exp(-t.y / n), u = Math.PI / 2 - 2 * Math.atan(l), c = 15, d = 1E-7, p = c, _ = .1; Math.abs(_) > d && --p > 0; )
                    e = h * Math.sin(u),
                    _ = Math.PI / 2 - 2 * Math.atan(l * Math.pow((1 - e) / (1 + e), .5 * h)) - u,
                    u += _;
                return new o.LatLng(u * i,a)
            }
        },
        o.CRS.EPSG3395 = o.extend({}, o.CRS, {
            code: "EPSG:3395",
            projection: o.Projection.Mercator,
            transformation: function() {
                var t = o.Projection.Mercator
                  , e = t.R_MAJOR
                  , i = t.R_MINOR;
                return new o.Transformation(.5 / (Math.PI * e),.5,-.5 / (Math.PI * i),.5)
            }()
        }),
        o.TileLayer = o.Class.extend({
            includes: o.Mixin.Events,
            options: {
                minZoom: 0,
                maxZoom: 18,
                tileSize: 256,
                subdomains: "abc",
                errorTileUrl: "",
                attribution: "",
                zoomOffset: 0,
                opacity: 1,
                unloadInvisibleTiles: o.Browser.mobile,
                updateWhenIdle: o.Browser.mobile
            },
            initialize: function(t, e) {
                e = o.setOptions(this, e),
                e.detectRetina && o.Browser.retina && e.maxZoom > 0 && (e.tileSize = Math.floor(e.tileSize / 2),
                e.zoomOffset++,
                e.minZoom > 0 && e.minZoom--,
                this.options.maxZoom--),
                e.bounds && (e.bounds = o.latLngBounds(e.bounds)),
                this._url = t;
                var i = this.options.subdomains;
                "string" == typeof i && (this.options.subdomains = i.split(""))
            },
            onAdd: function(t) {
                this._map = t,
                this._animated = t._zoomAnimated,
                this._initContainer(),
                this._createTileProto(),
                t.on({
                    viewreset: this._reset,
                    moveend: this._update
                }, this),
                this._animated && t.on({
                    zoomanim: this._animateZoom,
                    zoomend: this._endZoomAnim
                }, this),
                this.options.updateWhenIdle || (this._limitedUpdate = o.Util.limitExecByInterval(this._update, 150, this),
                t.on("move", this._limitedUpdate, this)),
                this._reset(),
                this._update()
            },
            addTo: function(t) {
                return t.addLayer(this),
                this
            },
            onRemove: function(t) {
                this._container.parentNode.removeChild(this._container),
                t.off({
                    viewreset: this._reset,
                    moveend: this._update
                }, this),
                this._animated && t.off({
                    zoomanim: this._animateZoom,
                    zoomend: this._endZoomAnim
                }, this),
                this.options.updateWhenIdle || t.off("move", this._limitedUpdate, this),
                this._container = null,
                this._map = null
            },
            bringToFront: function() {
                var t = this._map._panes.tilePane;
                return this._container && (t.appendChild(this._container),
                this._setAutoZIndex(t, Math.max)),
                this
            },
            bringToBack: function() {
                var t = this._map._panes.tilePane;
                return this._container && (t.insertBefore(this._container, t.firstChild),
                this._setAutoZIndex(t, Math.min)),
                this
            },
            getAttribution: function() {
                return this.options.attribution
            },
            getContainer: function() {
                return this._container
            },
            setOpacity: function(t) {
                return this.options.opacity = t,
                this._map && this._updateOpacity(),
                this
            },
            setZIndex: function(t) {
                return this.options.zIndex = t,
                this._updateZIndex(),
                this
            },
            setUrl: function(t, e) {
                return this._url = t,
                e || this.redraw(),
                this
            },
            redraw: function() {
                return this._map && (this._reset({
                    hard: !0
                }),
                this._update()),
                this
            },
            _updateZIndex: function() {
                this._container && this.options.zIndex !== i && (this._container.style.zIndex = this.options.zIndex)
            },
            _setAutoZIndex: function(t, e) {
                var i, n, o, s = t.children, a = -e(1 / 0, -1 / 0);
                for (n = 0,
                o = s.length; o > n; n++)
                    s[n] !== this._container && (i = parseInt(s[n].style.zIndex, 10),
                    isNaN(i) || (a = e(a, i)));
                this.options.zIndex = this._container.style.zIndex = (isFinite(a) ? a : 0) + e(1, -1)
            },
            _updateOpacity: function() {
                var t, e = this._tiles;
                if (o.Browser.ielt9)
                    for (t in e)
                        o.DomUtil.setOpacity(e[t], this.options.opacity);
                else
                    o.DomUtil.setOpacity(this._container, this.options.opacity)
            },
            _initContainer: function() {
                var t = this._map._panes.tilePane;
                if (!this._container) {
                    if (this._container = o.DomUtil.create("div", "leaflet-layer"),
                    this._updateZIndex(),
                    this._animated) {
                        var e = "leaflet-tile-container leaflet-zoom-animated";
                        this._bgBuffer = o.DomUtil.create("div", e, this._container),
                        this._tileContainer = o.DomUtil.create("div", e, this._container)
                    } else
                        this._tileContainer = this._container;
                    t.appendChild(this._container),
                    this.options.opacity < 1 && this._updateOpacity()
                }
            },
            _reset: function(t) {
                for (var e in this._tiles)
                    this.fire("tileunload", {
                        tile: this._tiles[e]
                    });
                this._tiles = {},
                this._tilesToLoad = 0,
                this.options.reuseTiles && (this._unusedTiles = []),
                this._tileContainer.innerHTML = "",
                this._animated && t && t.hard && this._clearBgBuffer(),
                this._initContainer()
            },
            _update: function() {
                if (this._map) {
                    var t = this._map.getPixelBounds()
                      , e = this._map.getZoom()
                      , i = this.options.tileSize;
                    if (!(e > this.options.maxZoom || e < this.options.minZoom)) {
                        var n = o.bounds(t.min.divideBy(i)._floor(), t.max.divideBy(i)._floor());
                        this._addTilesFromCenterOut(n),
                        (this.options.unloadInvisibleTiles || this.options.reuseTiles) && this._removeOtherTiles(n)
                    }
                }
            },
            _addTilesFromCenterOut: function(t) {
                var i, n, s, a = [], r = t.getCenter();
                for (i = t.min.y; i <= t.max.y; i++)
                    for (n = t.min.x; n <= t.max.x; n++)
                        s = new o.Point(n,i),
                        this._tileShouldBeLoaded(s) && a.push(s);
                var h = a.length;
                if (0 !== h) {
                    a.sort(function(t, e) {
                        return t.distanceTo(r) - e.distanceTo(r)
                    });
                    var l = e.createDocumentFragment();
                    for (this._tilesToLoad || this.fire("loading"),
                    this._tilesToLoad += h,
                    n = 0; h > n; n++)
                        this._addTile(a[n], l);
                    this._tileContainer.appendChild(l)
                }
            },
            _tileShouldBeLoaded: function(t) {
                if (t.x + ":" + t.y in this._tiles)
                    return !1;
                var e = this.options;
                if (!e.continuousWorld) {
                    var i = this._getWrapTileNum();
                    if (e.noWrap && (t.x < 0 || t.x >= i) || t.y < 0 || t.y >= i)
                        return !1
                }
                if (e.bounds) {
                    var n = e.tileSize
                      , o = t.multiplyBy(n)
                      , s = o.add([n, n])
                      , a = this._map.unproject(o)
                      , r = this._map.unproject(s);
                    if (e.continuousWorld || e.noWrap || (a = a.wrap(),
                    r = r.wrap()),
                    !e.bounds.intersects([a, r]))
                        return !1
                }
                return !0
            },
            _removeOtherTiles: function(t) {
                var e, i, n, o;
                for (o in this._tiles)
                    e = o.split(":"),
                    i = parseInt(e[0], 10),
                    n = parseInt(e[1], 10),
                    (i < t.min.x || i > t.max.x || n < t.min.y || n > t.max.y) && this._removeTile(o)
            },
            _removeTile: function(t) {
                var e = this._tiles[t];
                this.fire("tileunload", {
                    tile: e,
                    url: e.src
                }),
                this.options.reuseTiles ? (o.DomUtil.removeClass(e, "leaflet-tile-loaded"),
                this._unusedTiles.push(e)) : e.parentNode === this._tileContainer && this._tileContainer.removeChild(e),
                o.Browser.android || (e.onload = null,
                e.src = o.Util.emptyImageUrl),
                delete this._tiles[t]
            },
            _addTile: function(t, e) {
                var i = this._getTilePos(t)
                  , n = this._getTile();
                o.DomUtil.setPosition(n, i, o.Browser.chrome || o.Browser.android23),
                this._tiles[t.x + ":" + t.y] = n,
                this._loadTile(n, t),
                n.parentNode !== this._tileContainer && e.appendChild(n)
            },
            _getZoomForUrl: function() {
                var t = this.options
                  , e = this._map.getZoom();
                return t.zoomReverse && (e = t.maxZoom - e),
                e + t.zoomOffset
            },
            _getTilePos: function(t) {
                var e = this._map.getPixelOrigin()
                  , i = this.options.tileSize;
                return t.multiplyBy(i).subtract(e)
            },
            getTileUrl: function(t) {
                return o.Util.template(this._url, o.extend({
                    s: this._getSubdomain(t),
                    z: t.z,
                    x: t.x,
                    y: t.y
                }, this.options))
            },
            _getWrapTileNum: function() {
                return Math.pow(2, this._getZoomForUrl())
            },
            _adjustTilePoint: function(t) {
                var e = this._getWrapTileNum();
                this.options.continuousWorld || this.options.noWrap || (t.x = (t.x % e + e) % e),
                this.options.tms && (t.y = e - t.y - 1),
                t.z = this._getZoomForUrl()
            },
            _getSubdomain: function(t) {
                var e = Math.abs(t.x + t.y) % this.options.subdomains.length;
                return this.options.subdomains[e]
            },
            _createTileProto: function() {
                var t = this._tileImg = o.DomUtil.create("img", "leaflet-tile");
                t.style.width = t.style.height = this.options.tileSize + "px",
                t.galleryimg = "no"
            },
            _getTile: function() {
                if (this.options.reuseTiles && this._unusedTiles.length > 0) {
                    var t = this._unusedTiles.pop();
                    return this._resetTile(t),
                    t
                }
                return this._createTile()
            },
            _resetTile: function() {},
            _createTile: function() {
                var t = this._tileImg.cloneNode(!1);
                return t.onselectstart = t.onmousemove = o.Util.falseFn,
                o.Browser.ielt9 && this.options.opacity !== i && o.DomUtil.setOpacity(t, this.options.opacity),
                t
            },
            _loadTile: function(t, e) {
                t._layer = this,
                t.onload = this._tileOnLoad,
                t.onerror = this._tileOnError,
                this._adjustTilePoint(e),
                t.src = this.getTileUrl(e)
            },
            _tileLoaded: function() {
                this._tilesToLoad--,
                this._tilesToLoad || (this.fire("load"),
                this._animated && (clearTimeout(this._clearBgBufferTimer),
                this._clearBgBufferTimer = setTimeout(o.bind(this._clearBgBuffer, this), 500)))
            },
            _tileOnLoad: function() {
                var t = this._layer;
                this.src !== o.Util.emptyImageUrl && (o.DomUtil.addClass(this, "leaflet-tile-loaded"),
                t.fire("tileload", {
                    tile: this,
                    url: this.src
                })),
                t._tileLoaded()
            },
            _tileOnError: function() {
                var t = this._layer;
                t.fire("tileerror", {
                    tile: this,
                    url: this.src
                });
                var e = t.options.errorTileUrl;
                e && (this.src = e),
                t._tileLoaded()
            }
        }),
        o.tileLayer = function(t, e) {
            return new o.TileLayer(t,e)
        }
        ,
        o.TileLayer.WMS = o.TileLayer.extend({
            defaultWmsParams: {
                service: "WMS",
                request: "GetMap",
                version: "1.1.1",
                layers: "",
                styles: "",
                format: "image/jpeg",
                transparent: !1
            },
            initialize: function(t, e) {
                this._url = t;
                var i = o.extend({}, this.defaultWmsParams)
                  , n = e.tileSize || this.options.tileSize;
                i.width = i.height = e.detectRetina && o.Browser.retina ? 2 * n : n;
                for (var s in e)
                    this.options.hasOwnProperty(s) || "crs" === s || (i[s] = e[s]);
                this.wmsParams = i,
                o.setOptions(this, e)
            },
            onAdd: function(t) {
                this._crs = this.options.crs || t.options.crs;
                var e = parseFloat(this.wmsParams.version) >= 1.3 ? "crs" : "srs";
                this.wmsParams[e] = this._crs.code,
                o.TileLayer.prototype.onAdd.call(this, t)
            },
            getTileUrl: function(t, e) {
                var i = this._map
                  , n = this.options.tileSize
                  , s = t.multiplyBy(n)
                  , a = s.add([n, n])
                  , r = this._crs.project(i.unproject(s, e))
                  , h = this._crs.project(i.unproject(a, e))
                  , l = [r.x, h.y, h.x, r.y].join(",")
                  , u = o.Util.template(this._url, {
                    s: this._getSubdomain(t)
                });
                return u + o.Util.getParamString(this.wmsParams, u, !0) + "&BBOX=" + l
            },
            setParams: function(t, e) {
                return o.extend(this.wmsParams, t),
                e || this.redraw(),
                this
            }
        }),
        o.tileLayer.wms = function(t, e) {
            return new o.TileLayer.WMS(t,e)
        }
        ,
        o.TileLayer.Canvas = o.TileLayer.extend({
            options: {
                async: !1
            },
            initialize: function(t) {
                o.setOptions(this, t)
            },
            redraw: function() {
                this._map && (this._reset({
                    hard: !0
                }),
                this._update());
                for (var t in this._tiles)
                    this._redrawTile(this._tiles[t]);
                return this
            },
            _redrawTile: function(t) {
                this.drawTile(t, t._tilePoint, this._map._zoom)
            },
            _createTileProto: function() {
                var t = this._canvasProto = o.DomUtil.create("canvas", "leaflet-tile");
                t.width = t.height = this.options.tileSize
            },
            _createTile: function() {
                var t = this._canvasProto.cloneNode(!1);
                return t.onselectstart = t.onmousemove = o.Util.falseFn,
                t
            },
            _loadTile: function(t, e) {
                t._layer = this,
                t._tilePoint = e,
                this._redrawTile(t),
                this.options.async || this.tileDrawn(t)
            },
            drawTile: function() {},
            tileDrawn: function(t) {
                this._tileOnLoad.call(t)
            }
        }),
        o.tileLayer.canvas = function(t) {
            return new o.TileLayer.Canvas(t)
        }
        ,
        o.ImageOverlay = o.Class.extend({
            includes: o.Mixin.Events,
            options: {
                opacity: 1
            },
            initialize: function(t, e, i) {
                this._url = t,
                this._bounds = o.latLngBounds(e),
                o.setOptions(this, i)
            },
            onAdd: function(t) {
                this._map = t,
                this._image || this._initImage(),
                t._panes.overlayPane.appendChild(this._image),
                t.on("viewreset", this._reset, this),
                t.options.zoomAnimation && o.Browser.any3d && t.on("zoomanim", this._animateZoom, this),
                this._reset()
            },
            onRemove: function(t) {
                t.getPanes().overlayPane.removeChild(this._image),
                t.off("viewreset", this._reset, this),
                t.options.zoomAnimation && t.off("zoomanim", this._animateZoom, this)
            },
            addTo: function(t) {
                return t.addLayer(this),
                this
            },
            setOpacity: function(t) {
                return this.options.opacity = t,
                this._updateOpacity(),
                this
            },
            bringToFront: function() {
                return this._image && this._map._panes.overlayPane.appendChild(this._image),
                this
            },
            bringToBack: function() {
                var t = this._map._panes.overlayPane;
                return this._image && t.insertBefore(this._image, t.firstChild),
                this
            },
            _initImage: function() {
                this._image = o.DomUtil.create("img", "leaflet-image-layer"),
                this._map.options.zoomAnimation && o.Browser.any3d ? o.DomUtil.addClass(this._image, "leaflet-zoom-animated") : o.DomUtil.addClass(this._image, "leaflet-zoom-hide"),
                this._updateOpacity(),
                o.extend(this._image, {
                    galleryimg: "no",
                    onselectstart: o.Util.falseFn,
                    onmousemove: o.Util.falseFn,
                    onload: o.bind(this._onImageLoad, this),
                    src: this._url
                })
            },
            _animateZoom: function(t) {
                var e = this._map
                  , i = this._image
                  , n = e.getZoomScale(t.zoom)
                  , s = this._bounds.getNorthWest()
                  , a = this._bounds.getSouthEast()
                  , r = e._latLngToNewLayerPoint(s, t.zoom, t.center)
                  , h = e._latLngToNewLayerPoint(a, t.zoom, t.center)._subtract(r)
                  , l = r._add(h._multiplyBy(.5 * (1 - 1 / n)));
                i.style[o.DomUtil.TRANSFORM] = o.DomUtil.getTranslateString(l) + " scale(" + n + ") "
            },
            _reset: function() {
                var t = this._image
                  , e = this._map.latLngToLayerPoint(this._bounds.getNorthWest())
                  , i = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(e);
                o.DomUtil.setPosition(t, e),
                t.style.width = i.x + "px",
                t.style.height = i.y + "px"
            },
            _onImageLoad: function() {
                this.fire("load")
            },
            _updateOpacity: function() {
                o.DomUtil.setOpacity(this._image, this.options.opacity)
            }
        }),
        o.imageOverlay = function(t, e, i) {
            return new o.ImageOverlay(t,e,i)
        }
        ,
        o.Icon = o.Class.extend({
            options: {
                className: ""
            },
            initialize: function(t) {
                o.setOptions(this, t)
            },
            createIcon: function(t) {
                return this._createIcon("icon", t)
            },
            createShadow: function(t) {
                return this._createIcon("shadow", t)
            },
            _createIcon: function(t, e) {
                var i = this._getIconUrl(t);
                if (!i) {
                    if ("icon" === t)
                        throw new Error("iconUrl not set in Icon options (see the docs).");
                    return null
                }
                var n;
                return n = e && "IMG" === e.tagName ? this._createImg(i, e) : this._createImg(i),
                this._setIconStyles(n, t),
                n
            },
            _setIconStyles: function(t, e) {
                var i, n = this.options, s = o.point(n[e + "Size"]);
                i = "shadow" === e ? o.point(n.shadowAnchor || n.iconAnchor) : o.point(n.iconAnchor),
                !i && s && (i = s.divideBy(2, !0)),
                t.className = "leaflet-marker-" + e + " " + n.className,
                i && (t.style.marginLeft = -i.x + "px",
                t.style.marginTop = -i.y + "px"),
                s && (t.style.width = s.x + "px",
                t.style.height = s.y + "px")
            },
            _createImg: function(t, i) {
                return o.Browser.ie6 ? (i || (i = e.createElement("div")),
                i.style.filter = 'progid:DXImageTransform.Microsoft.AlphaImageLoader(src="' + t + '")') : (i || (i = e.createElement("img")),
                i.src = t),
                i
            },
            _getIconUrl: function(t) {
                return o.Browser.retina && this.options[t + "RetinaUrl"] ? this.options[t + "RetinaUrl"] : this.options[t + "Url"]
            }
        }),
        o.icon = function(t) {
            return new o.Icon(t)
        }
        ,
        o.Icon.Default = o.Icon.extend({
            options: {
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            },
            _getIconUrl: function(t) {
                var e = t + "Url";
                if (this.options[e])
                    return this.options[e];
                o.Browser.retina && "icon" === t && (t += "-2x");
                var i = o.Icon.Default.imagePath;
                if (!i)
                    throw new Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.");
                return i + "/marker-" + t + ".png"
            }
        }),
        o.Icon.Default.imagePath = function() {
            var t, i, n, o, s, a = e.getElementsByTagName("script"), r = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;
            for (t = 0,
            i = a.length; i > t; t++)
                if (n = a[t].src,
                o = n.match(r))
                    return s = n.split(r)[0],
                    (s ? s + "/" : "") + "images"
        }(),
        o.Marker = o.Class.extend({
            includes: o.Mixin.Events,
            options: {
                icon: new o.Icon.Default,
                title: "",
                clickable: !0,
                draggable: !1,
                keyboard: !0,
                zIndexOffset: 0,
                opacity: 1,
                riseOnHover: !1,
                riseOffset: 250
            },
            initialize: function(t, e) {
                o.setOptions(this, e),
                this._latlng = o.latLng(t)
            },
            onAdd: function(t) {
                this._map = t,
                t.on("viewreset", this.update, this),
                this._initIcon(),
                this.update(),
                t.options.zoomAnimation && t.options.markerZoomAnimation && t.on("zoomanim", this._animateZoom, this)
            },
            addTo: function(t) {
                return t.addLayer(this),
                this
            },
            onRemove: function(t) {
                this.dragging && this.dragging.disable(),
                this._removeIcon(),
                this._removeShadow(),
                this.fire("remove"),
                t.off({
                    viewreset: this.update,
                    zoomanim: this._animateZoom
                }, this),
                this._map = null
            },
            getLatLng: function() {
                return this._latlng
            },
            setLatLng: function(t) {
                return this._latlng = o.latLng(t),
                this.update(),
                this.fire("move", {
                    latlng: this._latlng
                })
            },
            setZIndexOffset: function(t) {
                return this.options.zIndexOffset = t,
                this.update(),
                this
            },
            setIcon: function(t) {
                return this.options.icon = t,
                this._map && (this._initIcon(),
                this.update()),
                this
            },
            update: function() {
                if (this._icon) {
                    var t = this._map.latLngToLayerPoint(this._latlng).round();
                    this._setPos(t)
                }
                return this
            },
            _initIcon: function() {
                var t = this.options
                  , e = this._map
                  , i = e.options.zoomAnimation && e.options.markerZoomAnimation
                  , n = i ? "leaflet-zoom-animated" : "leaflet-zoom-hide"
                  , s = t.icon.createIcon(this._icon)
                  , a = !1;
                s !== this._icon && (this._icon && this._removeIcon(),
                a = !0,
                t.title && (s.title = t.title)),
                o.DomUtil.addClass(s, n),
                t.keyboard && (s.tabIndex = "0"),
                this._icon = s,
                this._initInteraction(),
                t.riseOnHover && o.DomEvent.on(s, "mouseover", this._bringToFront, this).on(s, "mouseout", this._resetZIndex, this);
                var r = t.icon.createShadow(this._shadow)
                  , h = !1;
                r !== this._shadow && (this._removeShadow(),
                h = !0),
                r && o.DomUtil.addClass(r, n),
                this._shadow = r,
                t.opacity < 1 && this._updateOpacity();
                var l = this._map._panes;
                a && l.markerPane.appendChild(this._icon),
                r && h && l.shadowPane.appendChild(this._shadow)
            },
            _removeIcon: function() {
                this.options.riseOnHover && o.DomEvent.off(this._icon, "mouseover", this._bringToFront).off(this._icon, "mouseout", this._resetZIndex),
                this._map._panes.markerPane.removeChild(this._icon),
                this._icon = null
            },
            _removeShadow: function() {
                this._shadow && this._map._panes.shadowPane.removeChild(this._shadow),
                this._shadow = null
            },
            _setPos: function(t) {
                o.DomUtil.setPosition(this._icon, t),
                this._shadow && o.DomUtil.setPosition(this._shadow, t),
                this._zIndex = t.y + this.options.zIndexOffset,
                this._resetZIndex()
            },
            _updateZIndex: function(t) {
                this._icon.style.zIndex = this._zIndex + t
            },
            _animateZoom: function(t) {
                var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center);
                this._setPos(e)
            },
            _initInteraction: function() {
                if (this.options.clickable) {
                    var t = this._icon
                      , e = ["dblclick", "mousedown", "mouseover", "mouseout", "contextmenu"];
                    o.DomUtil.addClass(t, "leaflet-clickable"),
                    o.DomEvent.on(t, "click", this._onMouseClick, this),
                    o.DomEvent.on(t, "keypress", this._onKeyPress, this);
                    for (var i = 0; i < e.length; i++)
                        o.DomEvent.on(t, e[i], this._fireMouseEvent, this);
                    o.Handler.MarkerDrag && (this.dragging = new o.Handler.MarkerDrag(this),
                    this.options.draggable && this.dragging.enable())
                }
            },
            _onMouseClick: function(t) {
                var e = this.dragging && this.dragging.moved();
                (this.hasEventListeners(t.type) || e) && o.DomEvent.stopPropagation(t),
                e || (this.dragging && this.dragging._enabled || !this._map.dragging || !this._map.dragging.moved()) && this.fire(t.type, {
                    originalEvent: t,
                    latlng: this._latlng
                })
            },
            _onKeyPress: function(t) {
                13 === t.keyCode && this.fire("click", {
                    originalEvent: t,
                    latlng: this._latlng
                })
            },
            _fireMouseEvent: function(t) {
                this.fire(t.type, {
                    originalEvent: t,
                    latlng: this._latlng
                }),
                "contextmenu" === t.type && this.hasEventListeners(t.type) && o.DomEvent.preventDefault(t),
                "mousedown" !== t.type ? o.DomEvent.stopPropagation(t) : o.DomEvent.preventDefault(t)
            },
            setOpacity: function(t) {
                return this.options.opacity = t,
                this._map && this._updateOpacity(),
                this
            },
            _updateOpacity: function() {
                o.DomUtil.setOpacity(this._icon, this.options.opacity),
                this._shadow && o.DomUtil.setOpacity(this._shadow, this.options.opacity)
            },
            _bringToFront: function() {
                this._updateZIndex(this.options.riseOffset)
            },
            _resetZIndex: function() {
                this._updateZIndex(0)
            }
        }),
        o.marker = function(t, e) {
            return new o.Marker(t,e)
        }
        ,
        o.DivIcon = o.Icon.extend({
            options: {
                iconSize: [12, 12],
                className: "leaflet-div-icon",
                html: !1
            },
            createIcon: function(t) {
                var i = t && "DIV" === t.tagName ? t : e.createElement("div")
                  , n = this.options;
                return i.innerHTML = n.html !== !1 ? n.html : "",
                n.bgPos && (i.style.backgroundPosition = -n.bgPos.x + "px " + -n.bgPos.y + "px"),
                this._setIconStyles(i, "icon"),
                i
            },
            createShadow: function() {
                return null
            }
        }),
        o.divIcon = function(t) {
            return new o.DivIcon(t)
        }
        ,
        o.Map.mergeOptions({
            closePopupOnClick: !0
        }),
        o.Popup = o.Class.extend({
            includes: o.Mixin.Events,
            options: {
                minWidth: 50,
                maxWidth: 300,
                maxHeight: null,
                autoPan: !0,
                closeButton: !0,
                offset: [0, 7],
                autoPanPadding: [5, 5],
                keepInView: !1,
                className: "",
                zoomAnimation: !0
            },
            initialize: function(t, e) {
                o.setOptions(this, t),
                this._source = e,
                this._animated = o.Browser.any3d && this.options.zoomAnimation,
                this._isOpen = !1
            },
            onAdd: function(t) {
                this._map = t,
                this._container || this._initLayout(),
                this._updateContent();
                var e = t.options.fadeAnimation;
                e && o.DomUtil.setOpacity(this._container, 0),
                t._panes.popupPane.appendChild(this._container),
                t.on(this._getEvents(), this),
                this._update(),
                e && o.DomUtil.setOpacity(this._container, 1),
                this.fire("open"),
                t.fire("popupopen", {
                    popup: this
                }),
                this._source && this._source.fire("popupopen", {
                    popup: this
                })
            },
            addTo: function(t) {
                return t.addLayer(this),
                this
            },
            openOn: function(t) {
                return t.openPopup(this),
                this
            },
            onRemove: function(t) {
                t._panes.popupPane.removeChild(this._container),
                o.Util.falseFn(this._container.offsetWidth),
                t.off(this._getEvents(), this),
                t.options.fadeAnimation && o.DomUtil.setOpacity(this._container, 0),
                this._map = null,
                this.fire("close"),
                t.fire("popupclose", {
                    popup: this
                }),
                this._source && this._source.fire("popupclose", {
                    popup: this
                })
            },
            setLatLng: function(t) {
                return this._latlng = o.latLng(t),
                this._update(),
                this
            },
            setContent: function(t) {
                return this._content = t,
                this._update(),
                this
            },
            _getEvents: function() {
                var t = {
                    viewreset: this._updatePosition
                };
                return this._animated && (t.zoomanim = this._zoomAnimation),
                ("closeOnClick"in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this._close),
                this.options.keepInView && (t.moveend = this._adjustPan),
                t
            },
            _close: function() {
                this._map && this._map.closePopup(this)
            },
            _initLayout: function() {
                var t, e = "leaflet-popup", i = e + " " + this.options.className + " leaflet-zoom-" + (this._animated ? "animated" : "hide"), n = this._container = o.DomUtil.create("div", i);
                this.options.closeButton && (t = this._closeButton = o.DomUtil.create("a", e + "-close-button", n),
                t.href = "#close",
                t.innerHTML = "&#215;",
                o.DomEvent.disableClickPropagation(t),
                o.DomEvent.on(t, "click", this._onCloseButtonClick, this));
                var s = this._wrapper = o.DomUtil.create("div", e + "-content-wrapper", n);
                o.DomEvent.disableClickPropagation(s),
                this._contentNode = o.DomUtil.create("div", e + "-content", s),
                o.DomEvent.on(this._contentNode, "mousewheel", o.DomEvent.stopPropagation),
                o.DomEvent.on(this._contentNode, "MozMousePixelScroll", o.DomEvent.stopPropagation),
                o.DomEvent.on(s, "contextmenu", o.DomEvent.stopPropagation),
                this._tipContainer = o.DomUtil.create("div", e + "-tip-container", n),
                this._tip = o.DomUtil.create("div", e + "-tip", this._tipContainer)
            },
            _update: function() {
                this._map && (this._container.style.visibility = "hidden",
                this._updateContent(),
                this._updateLayout(),
                this._updatePosition(),
                this._container.style.visibility = "",
                this._adjustPan())
            },
            _updateContent: function() {
                if (this._content) {
                    if ("string" == typeof this._content)
                        this._contentNode.innerHTML = this._content;
                    else {
                        for (; this._contentNode.hasChildNodes(); )
                            this._contentNode.removeChild(this._contentNode.firstChild);
                        this._contentNode.appendChild(this._content)
                    }
                    this.fire("contentupdate")
                }
            },
            _updateLayout: function() {
                var t = this._contentNode
                  , e = t.style;
                e.width = "",
                e.whiteSpace = "nowrap";
                var i = t.offsetWidth;
                i = Math.min(i, this.options.maxWidth),
                i = Math.max(i, this.options.minWidth),
                e.width = i + 1 + "px",
                e.whiteSpace = "",
                e.height = "";
                var n = t.offsetHeight
                  , s = this.options.maxHeight
                  , a = "leaflet-popup-scrolled";
                s && n > s ? (e.height = s + "px",
                o.DomUtil.addClass(t, a)) : o.DomUtil.removeClass(t, a),
                this._containerWidth = this._container.offsetWidth
            },
            _updatePosition: function() {
                if (this._map) {
                    var t = this._map.latLngToLayerPoint(this._latlng)
                      , e = this._animated
                      , i = o.point(this.options.offset);
                    e && o.DomUtil.setPosition(this._container, t),
                    this._containerBottom = -i.y - (e ? 0 : t.y),
                    this._containerLeft = -Math.round(this._containerWidth / 2) + i.x + (e ? 0 : t.x),
                    this._container.style.bottom = this._containerBottom + "px",
                    this._container.style.left = this._containerLeft + "px"
                }
            },
            _zoomAnimation: function(t) {
                var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center);
                o.DomUtil.setPosition(this._container, e)
            },
            _adjustPan: function() {
                if (this.options.autoPan) {
                    var t = this._map
                      , e = this._container.offsetHeight
                      , i = this._containerWidth
                      , n = new o.Point(this._containerLeft,-e - this._containerBottom);
                    this._animated && n._add(o.DomUtil.getPosition(this._container));
                    var s = t.layerPointToContainerPoint(n)
                      , a = o.point(this.options.autoPanPadding)
                      , r = t.getSize()
                      , h = 0
                      , l = 0;
                    s.x + i > r.x && (h = s.x + i - r.x + a.x),
                    s.x - h < 0 && (h = s.x - a.x),
                    s.y + e > r.y && (l = s.y + e - r.y + a.y),
                    s.y - l < 0 && (l = s.y - a.y),
                    (h || l) && t.fire("autopanstart").panBy([h, l])
                }
            },
            _onCloseButtonClick: function(t) {
                this._close(),
                o.DomEvent.stop(t)
            }
        }),
        o.popup = function(t, e) {
            return new o.Popup(t,e)
        }
        ,
        o.Map.include({
            openPopup: function(t, e, i) {
                if (this.closePopup(),
                !(t instanceof o.Popup)) {
                    var n = t;
                    t = (new o.Popup(i)).setLatLng(e).setContent(n)
                }
                return t._isOpen = !0,
                this._popup = t,
                this.addLayer(t)
            },
            closePopup: function(t) {
                return t && t !== this._popup || (t = this._popup,
                this._popup = null),
                t && (this.removeLayer(t),
                t._isOpen = !1),
                this
            }
        }),
        o.Marker.include({
            openPopup: function() {
                return this._popup && this._map && !this._map.hasLayer(this._popup) && (this._popup.setLatLng(this._latlng),
                this._map.openPopup(this._popup)),
                this
            },
            closePopup: function() {
                return this._popup && this._popup._close(),
                this
            },
            togglePopup: function() {
                return this._popup && (this._popup._isOpen ? this.closePopup() : this.openPopup()),
                this
            },
            bindPopup: function(t, e) {
                var i = o.point(this.options.icon.options.popupAnchor || [0, 0]);
                return i = i.add(o.Popup.prototype.options.offset),
                e && e.offset && (i = i.add(e.offset)),
                e = o.extend({
                    offset: i
                }, e),
                this._popup || this.on("click", this.togglePopup, this).on("remove", this.closePopup, this).on("move", this._movePopup, this),
                t instanceof o.Popup ? (o.setOptions(t, e),
                this._popup = t) : this._popup = (new o.Popup(e,this)).setContent(t),
                this
            },
            setPopupContent: function(t) {
                return this._popup && this._popup.setContent(t),
                this
            },
            unbindPopup: function() {
                return this._popup && (this._popup = null,
                this.off("click", this.togglePopup).off("remove", this.closePopup).off("move", this._movePopup)),
                this
            },
            _movePopup: function(t) {
                this._popup.setLatLng(t.latlng)
            }
        }),
        o.LayerGroup = o.Class.extend({
            initialize: function(t) {
                this._layers = {};
                var e, i;
                if (t)
                    for (e = 0,
                    i = t.length; i > e; e++)
                        this.addLayer(t[e])
            },
            addLayer: function(t) {
                var e = this.getLayerId(t);
                return this._layers[e] = t,
                this._map && this._map.addLayer(t),
                this
            },
            removeLayer: function(t) {
                var e = t in this._layers ? t : this.getLayerId(t);
                return this._map && this._layers[e] && this._map.removeLayer(this._layers[e]),
                delete this._layers[e],
                this
            },
            hasLayer: function(t) {
                return t ? t in this._layers || this.getLayerId(t)in this._layers : !1
            },
            clearLayers: function() {
                return this.eachLayer(this.removeLayer, this),
                this
            },
            invoke: function(t) {
                var e, i, n = Array.prototype.slice.call(arguments, 1);
                for (e in this._layers)
                    i = this._layers[e],
                    i[t] && i[t].apply(i, n);
                return this
            },
            onAdd: function(t) {
                this._map = t,
                this.eachLayer(t.addLayer, t)
            },
            onRemove: function(t) {
                this.eachLayer(t.removeLayer, t),
                this._map = null
            },
            addTo: function(t) {
                return t.addLayer(this),
                this
            },
            eachLayer: function(t, e) {
                for (var i in this._layers)
                    t.call(e, this._layers[i]);
                return this
            },
            getLayer: function(t) {
                return this._layers[t]
            },
            getLayers: function() {
                var t = [];
                for (var e in this._layers)
                    t.push(this._layers[e]);
                return t
            },
            setZIndex: function(t) {
                return this.invoke("setZIndex", t)
            },
            getLayerId: function(t) {
                return o.stamp(t)
            }
        }),
        o.layerGroup = function(t) {
            return new o.LayerGroup(t)
        }
        ,
        o.FeatureGroup = o.LayerGroup.extend({
            includes: o.Mixin.Events,
            statics: {
                EVENTS: "click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"
            },
            addLayer: function(t) {
                return this.hasLayer(t) ? this : (t.on(o.FeatureGroup.EVENTS, this._propagateEvent, this),
                o.LayerGroup.prototype.addLayer.call(this, t),
                this._popupContent && t.bindPopup && t.bindPopup(this._popupContent, this._popupOptions),
                this.fire("layeradd", {
                    layer: t
                }))
            },
            removeLayer: function(t) {
                return this.hasLayer(t) ? (t in this._layers && (t = this._layers[t]),
                t.off(o.FeatureGroup.EVENTS, this._propagateEvent, this),
                o.LayerGroup.prototype.removeLayer.call(this, t),
                this._popupContent && this.invoke("unbindPopup"),
                this.fire("layerremove", {
                    layer: t
                })) : this
            },
            bindPopup: function(t, e) {
                return this._popupContent = t,
                this._popupOptions = e,
                this.invoke("bindPopup", t, e)
            },
            setStyle: function(t) {
                return this.invoke("setStyle", t)
            },
            bringToFront: function() {
                return this.invoke("bringToFront")
            },
            bringToBack: function() {
                return this.invoke("bringToBack")
            },
            getBounds: function() {
                var t = new o.LatLngBounds;
                return this.eachLayer(function(e) {
                    t.extend(e instanceof o.Marker ? e.getLatLng() : e.getBounds())
                }),
                t
            },
            _propagateEvent: function(t) {
                t.layer || (t.layer = t.target),
                t.target = this,
                this.fire(t.type, t)
            }
        }),
        o.featureGroup = function(t) {
            return new o.FeatureGroup(t)
        }
        ,
        o.Path = o.Class.extend({
            includes: [o.Mixin.Events],
            statics: {
                CLIP_PADDING: function() {
                    var e = o.Browser.mobile ? 1280 : 2E3
                      , i = (e / Math.max(t.outerWidth, t.outerHeight) - 1) / 2;
                    return Math.max(0, Math.min(.5, i))
                }()
            },
            options: {
                stroke: !0,
                color: "#0033ff",
                dashArray: null,
                weight: 5,
                opacity: .5,
                fill: !1,
                fillColor: null,
                fillOpacity: .2,
                clickable: !0
            },
            initialize: function(t) {
                o.setOptions(this, t)
            },
            onAdd: function(t) {
                this._map = t,
                this._container || (this._initElements(),
                this._initEvents()),
                this.projectLatlngs(),
                this._updatePath(),
                this._container && this._map._pathRoot.appendChild(this._container),
                this.fire("add"),
                t.on({
                    viewreset: this.projectLatlngs,
                    moveend: this._updatePath
                }, this)
            },
            addTo: function(t) {
                return t.addLayer(this),
                this
            },
            onRemove: function(t) {
                t._pathRoot.removeChild(this._container),
                this.fire("remove"),
                this._map = null,
                o.Browser.vml && (this._container = null,
                this._stroke = null,
                this._fill = null),
                t.off({
                    viewreset: this.projectLatlngs,
                    moveend: this._updatePath
                }, this)
            },
            projectLatlngs: function() {},
            setStyle: function(t) {
                return o.setOptions(this, t),
                this._container && this._updateStyle(),
                this
            },
            redraw: function() {
                return this._map && (this.projectLatlngs(),
                this._updatePath()),
                this
            }
        }),
        o.Map.include({
            _updatePathViewport: function() {
                var t = o.Path.CLIP_PADDING
                  , e = this.getSize()
                  , i = o.DomUtil.getPosition(this._mapPane)
                  , n = i.multiplyBy(-1)._subtract(e.multiplyBy(t)._round())
                  , s = n.add(e.multiplyBy(1 + 2 * t)._round());
                this._pathViewport = new o.Bounds(n,s)
            }
        }),
        o.Path.SVG_NS = "http://www.w3.org/2000/svg",
        o.Browser.svg = !(!e.createElementNS || !e.createElementNS(o.Path.SVG_NS, "svg").createSVGRect),
        o.Path = o.Path.extend({
            statics: {
                SVG: o.Browser.svg
            },
            bringToFront: function() {
                var t = this._map._pathRoot
                  , e = this._container;
                return e && t.lastChild !== e && t.appendChild(e),
                this
            },
            bringToBack: function() {
                var t = this._map._pathRoot
                  , e = this._container
                  , i = t.firstChild;
                return e && i !== e && t.insertBefore(e, i),
                this
            },
            getPathString: function() {},
            _createElement: function(t) {
                return e.createElementNS(o.Path.SVG_NS, t)
            },
            _initElements: function() {
                this._map._initPathRoot(),
                this._initPath(),
                this._initStyle()
            },
            _initPath: function() {
                this._container = this._createElement("g"),
                this._path = this._createElement("path"),
                this._container.appendChild(this._path)
            },
            _initStyle: function() {
                this.options.stroke && (this._path.setAttribute("stroke-linejoin", "round"),
                this._path.setAttribute("stroke-linecap", "round")),
                this.options.fill && this._path.setAttribute("fill-rule", "evenodd"),
                this.options.pointerEvents && this._path.setAttribute("pointer-events", this.options.pointerEvents),
                this.options.clickable || this.options.pointerEvents || this._path.setAttribute("pointer-events", "none"),
                this._updateStyle()
            },
            _updateStyle: function() {
                this.options.stroke ? (this._path.setAttribute("stroke", this.options.color),
                this._path.setAttribute("stroke-opacity", this.options.opacity),
                this._path.setAttribute("stroke-width", this.options.weight),
                this.options.dashArray ? this._path.setAttribute("stroke-dasharray", this.options.dashArray) : this._path.removeAttribute("stroke-dasharray")) : this._path.setAttribute("stroke", "none"),
                this.options.fill ? (this._path.setAttribute("fill", this.options.fillColor || this.options.color),
                this._path.setAttribute("fill-opacity", this.options.fillOpacity)) : this._path.setAttribute("fill", "none")
            },
            _updatePath: function() {
                var t = this.getPathString();
                t || (t = "M0 0"),
                this._path.setAttribute("d", t)
            },
            _initEvents: function() {
                if (this.options.clickable) {
                    (o.Browser.svg || !o.Browser.vml) && this._path.setAttribute("class", "leaflet-clickable"),
                    o.DomEvent.on(this._container, "click", this._onMouseClick, this);
                    for (var t = ["dblclick", "mousedown", "mouseover", "mouseout", "mousemove", "contextmenu"], e = 0; e < t.length; e++)
                        o.DomEvent.on(this._container, t[e], this._fireMouseEvent, this)
                }
            },
            _onMouseClick: function(t) {
                this._map.dragging && this._map.dragging.moved() || this._fireMouseEvent(t)
            },
            _fireMouseEvent: function(t) {
                if (this.hasEventListeners(t.type)) {
                    var e = this._map
                      , i = e.mouseEventToContainerPoint(t)
                      , n = e.containerPointToLayerPoint(i)
                      , s = e.layerPointToLatLng(n);
                    this.fire(t.type, {
                        latlng: s,
                        layerPoint: n,
                        containerPoint: i,
                        originalEvent: t
                    }),
                    "contextmenu" === t.type && o.DomEvent.preventDefault(t),
                    "mousemove" !== t.type && o.DomEvent.stopPropagation(t)
                }
            }
        }),
        o.Map.include({
            _initPathRoot: function() {
                this._pathRoot || (this._pathRoot = o.Path.prototype._createElement("svg"),
                this._panes.overlayPane.appendChild(this._pathRoot),
                this.options.zoomAnimation && o.Browser.any3d ? (this._pathRoot.setAttribute("class", " leaflet-zoom-animated"),
                this.on({
                    zoomanim: this._animatePathZoom,
                    zoomend: this._endPathZoom
                })) : this._pathRoot.setAttribute("class", " leaflet-zoom-hide"),
                this.on("moveend", this._updateSvgViewport),
                this._updateSvgViewport())
            },
            _animatePathZoom: function(t) {
                var e = this.getZoomScale(t.zoom)
                  , i = this._getCenterOffset(t.center)._multiplyBy(-e)._add(this._pathViewport.min);
                this._pathRoot.style[o.DomUtil.TRANSFORM] = o.DomUtil.getTranslateString(i) + " scale(" + e + ") ",
                this._pathZooming = !0
            },
            _endPathZoom: function() {
                this._pathZooming = !1
            },
            _updateSvgViewport: function() {
                if (!this._pathZooming) {
                    this._updatePathViewport();
                    var t = this._pathViewport
                      , e = t.min
                      , i = t.max
                      , n = i.x - e.x
                      , s = i.y - e.y
                      , a = this._pathRoot
                      , r = this._panes.overlayPane;
                    o.Browser.mobileWebkit && r.removeChild(a),
                    o.DomUtil.setPosition(a, e),
                    a.setAttribute("width", n),
                    a.setAttribute("height", s),
                    a.setAttribute("viewBox", [e.x, e.y, n, s].join(" ")),
                    o.Browser.mobileWebkit && r.appendChild(a)
                }
            }
        }),
        o.Path.include({
            bindPopup: function(t, e) {
                return t instanceof o.Popup ? this._popup = t : ((!this._popup || e) && (this._popup = new o.Popup(e,this)),
                this._popup.setContent(t)),
                this._popupHandlersAdded || (this.on("click", this._openPopup, this).on("remove", this.closePopup, this),
                this._popupHandlersAdded = !0),
                this
            },
            unbindPopup: function() {
                return this._popup && (this._popup = null,
                this.off("click", this._openPopup).off("remove", this.closePopup),
                this._popupHandlersAdded = !1),
                this
            },
            openPopup: function(t) {
                return this._popup && (t = t || this._latlng || this._latlngs[Math.floor(this._latlngs.length / 2)],
                this._openPopup({
                    latlng: t
                })),
                this
            },
            closePopup: function() {
                return this._popup && this._popup._close(),
                this
            },
            _openPopup: function(t) {
                this._popup.setLatLng(t.latlng),
                this._map.openPopup(this._popup)
            }
        }),
        o.Browser.vml = !o.Browser.svg && function() {
            try {
                var t = e.createElement("div");
                t.innerHTML = '<v:shape adj="1"/>';
                var i = t.firstChild;
                return i.style.behavior = "url(#default#VML)",
                i && "object" == typeof i.adj
            } catch (n$31) {
                return !1
            }
        }(),
        o.Path = o.Browser.svg || !o.Browser.vml ? o.Path : o.Path.extend({
            statics: {
                VML: !0,
                CLIP_PADDING: .02
            },
            _createElement: function() {
                try {
                    return e.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"),
                    function(t) {
                        return e.createElement("<lvml:" + t + ' class="lvml">')
                    }
                } catch (t$32) {
                    return function(t) {
                        return e.createElement("<" + t + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')
                    }
                }
            }(),
            _initPath: function() {
                var t = this._container = this._createElement("shape");
                o.DomUtil.addClass(t, "leaflet-vml-shape"),
                this.options.clickable && o.DomUtil.addClass(t, "leaflet-clickable"),
                t.coordsize = "1 1",
                this._path = this._createElement("path"),
                t.appendChild(this._path),
                this._map._pathRoot.appendChild(t)
            },
            _initStyle: function() {
                this._updateStyle()
            },
            _updateStyle: function() {
                var t = this._stroke
                  , e = this._fill
                  , i = this.options
                  , n = this._container;
                n.stroked = i.stroke,
                n.filled = i.fill,
                i.stroke ? (t || (t = this._stroke = this._createElement("stroke"),
                t.endcap = "round",
                n.appendChild(t)),
                t.weight = i.weight + "px",
                t.color = i.color,
                t.opacity = i.opacity,
                t.dashStyle = i.dashArray ? i.dashArray instanceof Array ? i.dashArray.join(" ") : i.dashArray.replace(/( *, *)/g, " ") : "") : t && (n.removeChild(t),
                this._stroke = null),
                i.fill ? (e || (e = this._fill = this._createElement("fill"),
                n.appendChild(e)),
                e.color = i.fillColor || i.color,
                e.opacity = i.fillOpacity) : e && (n.removeChild(e),
                this._fill = null)
            },
            _updatePath: function() {
                var t = this._container.style;
                t.display = "none",
                this._path.v = this.getPathString() + " ",
                t.display = ""
            }
        }),
        o.Map.include(o.Browser.svg || !o.Browser.vml ? {} : {
            _initPathRoot: function() {
                if (!this._pathRoot) {
                    var t = this._pathRoot = e.createElement("div");
                    t.className = "leaflet-vml-container",
                    this._panes.overlayPane.appendChild(t),
                    this.on("moveend", this._updatePathViewport),
                    this._updatePathViewport()
                }
            }
        }),
        o.Browser.canvas = function() {
            return !!e.createElement("canvas").getContext
        }(),
        o.Path = o.Path.SVG && !t.L_PREFER_CANVAS || !o.Browser.canvas ? o.Path : o.Path.extend({
            statics: {
                CANVAS: !0,
                SVG: !1
            },
            redraw: function() {
                return this._map && (this.projectLatlngs(),
                this._requestUpdate()),
                this
            },
            setStyle: function(t) {
                return o.setOptions(this, t),
                this._map && (this._updateStyle(),
                this._requestUpdate()),
                this
            },
            onRemove: function(t) {
                t.off("viewreset", this.projectLatlngs, this).off("moveend", this._updatePath, this),
                this.options.clickable && (this._map.off("click", this._onClick, this),
                this._map.off("mousemove", this._onMouseMove, this)),
                this._requestUpdate(),
                this._map = null
            },
            _requestUpdate: function() {
                this._map && !o.Path._updateRequest && (o.Path._updateRequest = o.Util.requestAnimFrame(this._fireMapMoveEnd, this._map))
            },
            _fireMapMoveEnd: function() {
                o.Path._updateRequest = null,
                this.fire("moveend")
            },
            _initElements: function() {
                this._map._initPathRoot(),
                this._ctx = this._map._canvasCtx
            },
            _updateStyle: function() {
                var t = this.options;
                t.stroke && (this._ctx.lineWidth = t.weight,
                this._ctx.strokeStyle = t.color),
                t.fill && (this._ctx.fillStyle = t.fillColor || t.color)
            },
            _drawPath: function() {
                var t, e, i, n, s, a;
                for (this._ctx.beginPath(),
                t = 0,
                i = this._parts.length; i > t; t++) {
                    for (e = 0,
                    n = this._parts[t].length; n > e; e++)
                        s = this._parts[t][e],
                        a = (0 === e ? "move" : "line") + "To",
                        this._ctx[a](s.x, s.y);
                    this instanceof o.Polygon && this._ctx.closePath()
                }
            },
            _checkIfEmpty: function() {
                return !this._parts.length
            },
            _updatePath: function() {
                if (!this._checkIfEmpty()) {
                    var t = this._ctx
                      , e = this.options;
                    this._drawPath(),
                    t.save(),
                    this._updateStyle(),
                    e.fill && (t.globalAlpha = e.fillOpacity,
                    t.fill()),
                    e.stroke && (t.globalAlpha = e.opacity,
                    t.stroke()),
                    t.restore()
                }
            },
            _initEvents: function() {
                this.options.clickable && (this._map.on("mousemove", this._onMouseMove, this),
                this._map.on("click", this._onClick, this))
            },
            _onClick: function(t) {
                this._containsPoint(t.layerPoint) && this.fire("click", t)
            },
            _onMouseMove: function(t) {
                this._map && !this._map._animatingZoom && (this._containsPoint(t.layerPoint) ? (this._ctx.canvas.style.cursor = "pointer",
                this._mouseInside = !0,
                this.fire("mouseover", t)) : this._mouseInside && (this._ctx.canvas.style.cursor = "",
                this._mouseInside = !1,
                this.fire("mouseout", t)))
            }
        }),
        o.Map.include(o.Path.SVG && !t.L_PREFER_CANVAS || !o.Browser.canvas ? {} : {
            _initPathRoot: function() {
                var t, i = this._pathRoot;
                i || (i = this._pathRoot = e.createElement("canvas"),
                i.style.position = "absolute",
                t = this._canvasCtx = i.getContext("2d"),
                t.lineCap = "round",
                t.lineJoin = "round",
                this._panes.overlayPane.appendChild(i),
                this.options.zoomAnimation && (this._pathRoot.className = "leaflet-zoom-animated",
                this.on("zoomanim", this._animatePathZoom),
                this.on("zoomend", this._endPathZoom)),
                this.on("moveend", this._updateCanvasViewport),
                this._updateCanvasViewport())
            },
            _updateCanvasViewport: function() {
                if (!this._pathZooming) {
                    this._updatePathViewport();
                    var t = this._pathViewport
                      , e = t.min
                      , i = t.max.subtract(e)
                      , n = this._pathRoot;
                    o.DomUtil.setPosition(n, e),
                    n.width = i.x,
                    n.height = i.y,
                    n.getContext("2d").translate(-e.x, -e.y)
                }
            }
        }),
        o.LineUtil = {
            simplify: function(t, e) {
                if (!e || !t.length)
                    return t.slice();
                var i = e * e;
                return t = this._reducePoints(t, i),
                t = this._simplifyDP(t, i)
            },
            pointToSegmentDistance: function(t, e, i) {
                return Math.sqrt(this._sqClosestPointOnSegment(t, e, i, !0))
            },
            closestPointOnSegment: function(t, e, i) {
                return this._sqClosestPointOnSegment(t, e, i)
            },
            _simplifyDP: function(t, e) {
                var n = t.length
                  , o = typeof Uint8Array != i + "" ? Uint8Array : Array
                  , s = new o(n);
                s[0] = s[n - 1] = 1,
                this._simplifyDPStep(t, s, e, 0, n - 1);
                var a, r = [];
                for (a = 0; n > a; a++)
                    s[a] && r.push(t[a]);
                return r
            },
            _simplifyDPStep: function(t, e, i, n, o) {
                var s, a, r, h = 0;
                for (a = n + 1; o - 1 >= a; a++)
                    r = this._sqClosestPointOnSegment(t[a], t[n], t[o], !0),
                    r > h && (s = a,
                    h = r);
                h > i && (e[s] = 1,
                this._simplifyDPStep(t, e, i, n, s),
                this._simplifyDPStep(t, e, i, s, o))
            },
            _reducePoints: function(t, e) {
                for (var i = [t[0]], n = 1, o = 0, s = t.length; s > n; n++)
                    this._sqDist(t[n], t[o]) > e && (i.push(t[n]),
                    o = n);
                return s - 1 > o && i.push(t[s - 1]),
                i
            },
            clipSegment: function(t, e, i, n) {
                var o, s, a, r = n ? this._lastCode : this._getBitCode(t, i), h = this._getBitCode(e, i);
                for (this._lastCode = h; ; ) {
                    if (!(r | h))
                        return [t, e];
                    if (r & h)
                        return !1;
                    o = r || h,
                    s = this._getEdgeIntersection(t, e, o, i),
                    a = this._getBitCode(s, i),
                    o === r ? (t = s,
                    r = a) : (e = s,
                    h = a)
                }
            },
            _getEdgeIntersection: function(t, e, i, n) {
                var s = e.x - t.x
                  , a = e.y - t.y
                  , r = n.min
                  , h = n.max;
                return 8 & i ? new o.Point(t.x + s * (h.y - t.y) / a,h.y) : 4 & i ? new o.Point(t.x + s * (r.y - t.y) / a,r.y) : 2 & i ? new o.Point(h.x,t.y + a * (h.x - t.x) / s) : 1 & i ? new o.Point(r.x,t.y + a * (r.x - t.x) / s) : void 0
            },
            _getBitCode: function(t, e) {
                var i = 0;
                return t.x < e.min.x ? i |= 1 : t.x > e.max.x && (i |= 2),
                t.y < e.min.y ? i |= 4 : t.y > e.max.y && (i |= 8),
                i
            },
            _sqDist: function(t, e) {
                var i = e.x - t.x
                  , n = e.y - t.y;
                return i * i + n * n
            },
            _sqClosestPointOnSegment: function(t, e, i, n) {
                var s, a = e.x, r = e.y, h = i.x - a, l = i.y - r, u = h * h + l * l;
                return u > 0 && (s = ((t.x - a) * h + (t.y - r) * l) / u,
                s > 1 ? (a = i.x,
                r = i.y) : s > 0 && (a += h * s,
                r += l * s)),
                h = t.x - a,
                l = t.y - r,
                n ? h * h + l * l : new o.Point(a,r)
            }
        },
        o.Polyline = o.Path.extend({
            initialize: function(t, e) {
                o.Path.prototype.initialize.call(this, e),
                this._latlngs = this._convertLatLngs(t)
            },
            options: {
                smoothFactor: 1,
                noClip: !1
            },
            projectLatlngs: function() {
                this._originalPoints = [];
                for (var t = 0, e = this._latlngs.length; e > t; t++)
                    this._originalPoints[t] = this._map.latLngToLayerPoint(this._latlngs[t])
            },
            getPathString: function() {
                for (var t = 0, e = this._parts.length, i = ""; e > t; t++)
                    i += this._getPathPartStr(this._parts[t]);
                return i
            },
            getLatLngs: function() {
                return this._latlngs
            },
            setLatLngs: function(t) {
                return this._latlngs = this._convertLatLngs(t),
                this.redraw()
            },
            addLatLng: function(t) {
                return this._latlngs.push(o.latLng(t)),
                this.redraw()
            },
            spliceLatLngs: function() {
                var t = [].splice.apply(this._latlngs, arguments);
                return this._convertLatLngs(this._latlngs, !0),
                this.redraw(),
                t
            },
            closestLayerPoint: function(t) {
                for (var e, i, n = 1 / 0, s = this._parts, a = null, r = 0, h = s.length; h > r; r++)
                    for (var l = s[r], u = 1, c = l.length; c > u; u++) {
                        e = l[u - 1],
                        i = l[u];
                        var d = o.LineUtil._sqClosestPointOnSegment(t, e, i, !0);
                        n > d && (n = d,
                        a = o.LineUtil._sqClosestPointOnSegment(t, e, i))
                    }
                return a && (a.distance = Math.sqrt(n)),
                a
            },
            getBounds: function() {
                return new o.LatLngBounds(this.getLatLngs())
            },
            _convertLatLngs: function(t, e) {
                var i, n, s = e ? t : [];
                for (i = 0,
                n = t.length; n > i; i++) {
                    if (o.Util.isArray(t[i]) && "number" != typeof t[i][0])
                        return;
                    s[i] = o.latLng(t[i])
                }
                return s
            },
            _initEvents: function() {
                o.Path.prototype._initEvents.call(this)
            },
            _getPathPartStr: function(t) {
                for (var e, i = o.Path.VML, n = 0, s = t.length, a = ""; s > n; n++)
                    e = t[n],
                    i && e._round(),
                    a += (n ? "L" : "M") + e.x + " " + e.y;
                return a
            },
            _clipPoints: function() {
                var t, e, i, n = this._originalPoints, s = n.length;
                if (this.options.noClip)
                    return this._parts = [n],
                    void 0;
                this._parts = [];
                var a = this._parts
                  , r = this._map._pathViewport
                  , h = o.LineUtil;
                for (t = 0,
                e = 0; s - 1 > t; t++)
                    i = h.clipSegment(n[t], n[t + 1], r, t),
                    i && (a[e] = a[e] || [],
                    a[e].push(i[0]),
                    (i[1] !== n[t + 1] || t === s - 2) && (a[e].push(i[1]),
                    e++))
            },
            _simplifyPoints: function() {
                for (var t = this._parts, e = o.LineUtil, i = 0, n = t.length; n > i; i++)
                    t[i] = e.simplify(t[i], this.options.smoothFactor)
            },
            _updatePath: function() {
                this._map && (this._clipPoints(),
                this._simplifyPoints(),
                o.Path.prototype._updatePath.call(this))
            }
        }),
        o.polyline = function(t, e) {
            return new o.Polyline(t,e)
        }
        ,
        o.PolyUtil = {},
        o.PolyUtil.clipPolygon = function(t, e) {
            var i, n, s, a, r, h, l, u, c, d = [1, 4, 2, 8], p = o.LineUtil;
            for (n = 0,
            l = t.length; l > n; n++)
                t[n]._code = p._getBitCode(t[n], e);
            for (a = 0; 4 > a; a++) {
                for (u = d[a],
                i = [],
                n = 0,
                l = t.length,
                s = l - 1; l > n; s = n++)
                    r = t[n],
                    h = t[s],
                    r._code & u ? h._code & u || (c = p._getEdgeIntersection(h, r, u, e),
                    c._code = p._getBitCode(c, e),
                    i.push(c)) : (h._code & u && (c = p._getEdgeIntersection(h, r, u, e),
                    c._code = p._getBitCode(c, e),
                    i.push(c)),
                    i.push(r));
                t = i
            }
            return t
        }
        ,
        o.Polygon = o.Polyline.extend({
            options: {
                fill: !0
            },
            initialize: function(t, e) {
                var i, n, s;
                if (o.Polyline.prototype.initialize.call(this, t, e),
                t && o.Util.isArray(t[0]) && "number" != typeof t[0][0])
                    for (this._latlngs = this._convertLatLngs(t[0]),
                    this._holes = t.slice(1),
                    i = 0,
                    n = this._holes.length; n > i; i++)
                        s = this._holes[i] = this._convertLatLngs(this._holes[i]),
                        s[0].equals(s[s.length - 1]) && s.pop();
                t = this._latlngs,
                t.length >= 2 && t[0].equals(t[t.length - 1]) && t.pop()
            },
            projectLatlngs: function() {
                if (o.Polyline.prototype.projectLatlngs.call(this),
                this._holePoints = [],
                this._holes) {
                    var t, e, i, n;
                    for (t = 0,
                    i = this._holes.length; i > t; t++)
                        for (this._holePoints[t] = [],
                        e = 0,
                        n = this._holes[t].length; n > e; e++)
                            this._holePoints[t][e] = this._map.latLngToLayerPoint(this._holes[t][e])
                }
            },
            _clipPoints: function() {
                var t = this._originalPoints
                  , e = [];
                if (this._parts = [t].concat(this._holePoints),
                !this.options.noClip) {
                    for (var i = 0, n = this._parts.length; n > i; i++) {
                        var s = o.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);
                        s.length && e.push(s)
                    }
                    this._parts = e
                }
            },
            _getPathPartStr: function(t) {
                var e = o.Polyline.prototype._getPathPartStr.call(this, t);
                return e + (o.Browser.svg ? "z" : "x")
            }
        }),
        o.polygon = function(t, e) {
            return new o.Polygon(t,e)
        }
        ,
        function() {
            function t(t) {
                return o.FeatureGroup.extend({
                    initialize: function(t, e) {
                        this._layers = {},
                        this._options = e,
                        this.setLatLngs(t)
                    },
                    setLatLngs: function(e) {
                        var i = 0
                          , n = e.length;
                        for (this.eachLayer(function(t) {
                            n > i ? t.setLatLngs(e[i++]) : this.removeLayer(t)
                        }, this); n > i; )
                            this.addLayer(new t(e[i++],this._options));
                        return this
                    },
                    getLatLngs: function() {
                        var t = [];
                        return this.eachLayer(function(e) {
                            t.push(e.getLatLngs())
                        }),
                        t
                    }
                })
            }
            o.MultiPolyline = t(o.Polyline),
            o.MultiPolygon = t(o.Polygon),
            o.multiPolyline = function(t, e) {
                return new o.MultiPolyline(t,e)
            }
            ,
            o.multiPolygon = function(t, e) {
                return new o.MultiPolygon(t,e)
            }
        }(),
        o.Rectangle = o.Polygon.extend({
            initialize: function(t, e) {
                o.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(t), e)
            },
            setBounds: function(t) {
                this.setLatLngs(this._boundsToLatLngs(t))
            },
            _boundsToLatLngs: function(t) {
                return t = o.latLngBounds(t),
                [t.getSouthWest(), t.getNorthWest(), t.getNorthEast(), t.getSouthEast()]
            }
        }),
        o.rectangle = function(t, e) {
            return new o.Rectangle(t,e)
        }
        ,
        o.Circle = o.Path.extend({
            initialize: function(t, e, i) {
                o.Path.prototype.initialize.call(this, i),
                this._latlng = o.latLng(t),
                this._mRadius = e
            },
            options: {
                fill: !0
            },
            setLatLng: function(t) {
                return this._latlng = o.latLng(t),
                this.redraw()
            },
            setRadius: function(t) {
                return this._mRadius = t,
                this.redraw()
            },
            projectLatlngs: function() {
                var t = this._getLngRadius()
                  , e = this._latlng
                  , i = this._map.latLngToLayerPoint([e.lat, e.lng - t]);
                this._point = this._map.latLngToLayerPoint(e),
                this._radius = Math.max(this._point.x - i.x, 1)
            },
            getBounds: function() {
                var t = this._getLngRadius()
                  , e = 360 * (this._mRadius / 40075017)
                  , i = this._latlng;
                return new o.LatLngBounds([i.lat - e, i.lng - t],[i.lat + e, i.lng + t])
            },
            getLatLng: function() {
                return this._latlng
            },
            getPathString: function() {
                var t = this._point
                  , e = this._radius;
                return this._checkIfEmpty() ? "" : o.Browser.svg ? "M" + t.x + "," + (t.y - e) + "A" + e + "," + e + ",0,1,1," + (t.x - .1) + "," + (t.y - e) + " z" : (t._round(),
                e = Math.round(e),
                "AL " + t.x + "," + t.y + " " + e + "," + e + " 0," + 23592600)
            },
            getRadius: function() {
                return this._mRadius
            },
            _getLatRadius: function() {
                return 360 * (this._mRadius / 40075017)
            },
            _getLngRadius: function() {
                return this._getLatRadius() / Math.cos(o.LatLng.DEG_TO_RAD * this._latlng.lat)
            },
            _checkIfEmpty: function() {
                if (!this._map)
                    return !1;
                var t = this._map._pathViewport
                  , e = this._radius
                  , i = this._point;
                return i.x - e > t.max.x || i.y - e > t.max.y || i.x + e < t.min.x || i.y + e < t.min.y
            }
        }),
        o.circle = function(t, e, i) {
            return new o.Circle(t,e,i)
        }
        ,
        o.CircleMarker = o.Circle.extend({
            options: {
                radius: 10,
                weight: 2
            },
            initialize: function(t, e) {
                o.Circle.prototype.initialize.call(this, t, null, e),
                this._radius = this.options.radius
            },
            projectLatlngs: function() {
                this._point = this._map.latLngToLayerPoint(this._latlng)
            },
            _updateStyle: function() {
                o.Circle.prototype._updateStyle.call(this),
                this.setRadius(this.options.radius)
            },
            setRadius: function(t) {
                return this.options.radius = this._radius = t,
                this.redraw()
            }
        }),
        o.circleMarker = function(t, e) {
            return new o.CircleMarker(t,e)
        }
        ,
        o.Polyline.include(o.Path.CANVAS ? {
            _containsPoint: function(t, e) {
                var i, n, s, a, r, h, l, u = this.options.weight / 2;
                for (o.Browser.touch && (u += 10),
                i = 0,
                a = this._parts.length; a > i; i++)
                    for (l = this._parts[i],
                    n = 0,
                    r = l.length,
                    s = r - 1; r > n; s = n++)
                        if ((e || 0 !== n) && (h = o.LineUtil.pointToSegmentDistance(t, l[s], l[n]),
                        u >= h))
                            return !0;
                return !1
            }
        } : {}),
        o.Polygon.include(o.Path.CANVAS ? {
            _containsPoint: function(t) {
                var e, i, n, s, a, r, h, l, u = !1;
                if (o.Polyline.prototype._containsPoint.call(this, t, !0))
                    return !0;
                for (s = 0,
                h = this._parts.length; h > s; s++)
                    for (e = this._parts[s],
                    a = 0,
                    l = e.length,
                    r = l - 1; l > a; r = a++)
                        i = e[a],
                        n = e[r],
                        i.y > t.y != n.y > t.y && t.x < (n.x - i.x) * (t.y - i.y) / (n.y - i.y) + i.x && (u = !u);
                return u
            }
        } : {}),
        o.Circle.include(o.Path.CANVAS ? {
            _drawPath: function() {
                var t = this._point;
                this._ctx.beginPath(),
                this._ctx.arc(t.x, t.y, this._radius, 0, 2 * Math.PI, !1)
            },
            _containsPoint: function(t) {
                var e = this._point
                  , i = this.options.stroke ? this.options.weight / 2 : 0;
                return t.distanceTo(e) <= this._radius + i
            }
        } : {}),
        o.CircleMarker.include(o.Path.CANVAS ? {
            _updateStyle: function() {
                o.Path.prototype._updateStyle.call(this)
            }
        } : {}),
        o.GeoJSON = o.FeatureGroup.extend({
            initialize: function(t, e) {
                o.setOptions(this, e),
                this._layers = {},
                t && this.addData(t)
            },
            addData: function(t) {
                var e, i, n, s = o.Util.isArray(t) ? t : t.features;
                if (s) {
                    for (e = 0,
                    i = s.length; i > e; e++)
                        n = s[e],
                        (n.geometries || n.geometry || n.features || n.coordinates) && this.addData(s[e]);
                    return this
                }
                var a = this.options;
                if (!a.filter || a.filter(t)) {
                    var r = o.GeoJSON.geometryToLayer(t, a.pointToLayer, a.coordsToLatLng);
                    return r.feature = o.GeoJSON.asFeature(t),
                    r.defaultOptions = r.options,
                    this.resetStyle(r),
                    a.onEachFeature && a.onEachFeature(t, r),
                    this.addLayer(r)
                }
            },
            resetStyle: function(t) {
                var e = this.options.style;
                e && (o.Util.extend(t.options, t.defaultOptions),
                this._setLayerStyle(t, e))
            },
            setStyle: function(t) {
                this.eachLayer(function(e) {
                    this._setLayerStyle(e, t)
                }, this)
            },
            _setLayerStyle: function(t, e) {
                "function" == typeof e && (e = e(t.feature)),
                t.setStyle && t.setStyle(e)
            }
        }),
        o.extend(o.GeoJSON, {
            geometryToLayer: function(t, e, i) {
                var n, s, a, r, h, l = "Feature" === t.type ? t.geometry : t, u = l.coordinates, c = [];
                switch (i = i || this.coordsToLatLng,
                l.type) {
                case "Point":
                    return n = i(u),
                    e ? e(t, n) : new o.Marker(n);
                case "MultiPoint":
                    for (a = 0,
                    r = u.length; r > a; a++)
                        n = i(u[a]),
                        h = e ? e(t, n) : new o.Marker(n),
                        c.push(h);
                    return new o.FeatureGroup(c);
                case "LineString":
                    return s = this.coordsToLatLngs(u, 0, i),
                    new o.Polyline(s);
                case "Polygon":
                    return s = this.coordsToLatLngs(u, 1, i),
                    new o.Polygon(s);
                case "MultiLineString":
                    return s = this.coordsToLatLngs(u, 1, i),
                    new o.MultiPolyline(s);
                case "MultiPolygon":
                    return s = this.coordsToLatLngs(u, 2, i),
                    new o.MultiPolygon(s);
                case "GeometryCollection":
                    for (a = 0,
                    r = l.geometries.length; r > a; a++)
                        h = this.geometryToLayer({
                            geometry: l.geometries[a],
                            type: "Feature",
                            properties: t.properties
                        }, e, i),
                        c.push(h);
                    return new o.FeatureGroup(c);
                default:
                    throw new Error("Invalid GeoJSON object.");
                }
            },
            coordsToLatLng: function(t) {
                return new o.LatLng(t[1],t[0])
            },
            coordsToLatLngs: function(t, e, i) {
                var n, o, s, a = [];
                for (o = 0,
                s = t.length; s > o; o++)
                    n = e ? this.coordsToLatLngs(t[o], e - 1, i) : (i || this.coordsToLatLng)(t[o]),
                    a.push(n);
                return a
            },
            latLngToCoords: function(t) {
                return [t.lng, t.lat]
            },
            latLngsToCoords: function(t) {
                for (var e = [], i = 0, n = t.length; n > i; i++)
                    e.push(o.GeoJSON.latLngToCoords(t[i]));
                return e
            },
            getFeature: function(t, e) {
                return t.feature ? o.extend({}, t.feature, {
                    geometry: e
                }) : o.GeoJSON.asFeature(e)
            },
            asFeature: function(t) {
                return "Feature" === t.type ? t : {
                    type: "Feature",
                    properties: {},
                    geometry: t
                }
            }
        });
        var a = {
            toGeoJSON: function() {
                return o.GeoJSON.getFeature(this, {
                    type: "Point",
                    coordinates: o.GeoJSON.latLngToCoords(this.getLatLng())
                })
            }
        };
        o.Marker.include(a),
        o.Circle.include(a),
        o.CircleMarker.include(a),
        o.Polyline.include({
            toGeoJSON: function() {
                return o.GeoJSON.getFeature(this, {
                    type: "LineString",
                    coordinates: o.GeoJSON.latLngsToCoords(this.getLatLngs())
                })
            }
        }),
        o.Polygon.include({
            toGeoJSON: function() {
                var t, e, i, n = [o.GeoJSON.latLngsToCoords(this.getLatLngs())];
                if (n[0].push(n[0][0]),
                this._holes)
                    for (t = 0,
                    e = this._holes.length; e > t; t++)
                        i = o.GeoJSON.latLngsToCoords(this._holes[t]),
                        i.push(i[0]),
                        n.push(i);
                return o.GeoJSON.getFeature(this, {
                    type: "Polygon",
                    coordinates: n
                })
            }
        }),
        function() {
            function t(t, e) {
                t.include({
                    toGeoJSON: function() {
                        var t = [];
                        return this.eachLayer(function(e) {
                            t.push(e.toGeoJSON().geometry.coordinates)
                        }),
                        o.GeoJSON.getFeature(this, {
                            type: e,
                            coordinates: t
                        })
                    }
                })
            }
            t(o.MultiPolyline, "MultiLineString"),
            t(o.MultiPolygon, "MultiPolygon")
        }(),
        o.LayerGroup.include({
            toGeoJSON: function() {
                var t = [];
                return this.eachLayer(function(e) {
                    e.toGeoJSON && t.push(o.GeoJSON.asFeature(e.toGeoJSON()))
                }),
                {
                    type: "FeatureCollection",
                    features: t
                }
            }
        }),
        o.geoJson = function(t, e) {
            return new o.GeoJSON(t,e)
        }
        ,
        o.DomEvent = {
            addListener: function(t, e, i, n) {
                var s, a, r, h = o.stamp(i), l = "_leaflet_" + e + h;
                return t[l] ? this : (s = function(e) {
                    return i.call(n || t, e || o.DomEvent._getEvent())
                }
                ,
                o.Browser.msTouch && 0 === e.indexOf("touch") ? this.addMsTouchListener(t, e, s, h) : (o.Browser.touch && "dblclick" === e && this.addDoubleTapListener && this.addDoubleTapListener(t, s, h),
                "addEventListener"in t ? "mousewheel" === e ? (t.addEventListener("DOMMouseScroll", s, !1),
                t.addEventListener(e, s, !1)) : "mouseenter" === e || "mouseleave" === e ? (a = s,
                r = "mouseenter" === e ? "mouseover" : "mouseout",
                s = function(e) {
                    return o.DomEvent._checkMouse(t, e) ? a(e) : void 0
                }
                ,
                t.addEventListener(r, s, !1)) : "click" === e && o.Browser.android ? (a = s,
                s = function(t) {
                    return o.DomEvent._filterClick(t, a)
                }
                ,
                t.addEventListener(e, s, !1)) : t.addEventListener(e, s, !1) : "attachEvent"in t && t.attachEvent("on" + e, s),
                t[l] = s,
                this))
            },
            removeListener: function(t, e, i) {
                var n = o.stamp(i)
                  , s = "_leaflet_" + e + n
                  , a = t[s];
                return a ? (o.Browser.msTouch && 0 === e.indexOf("touch") ? this.removeMsTouchListener(t, e, n) : o.Browser.touch && "dblclick" === e && this.removeDoubleTapListener ? this.removeDoubleTapListener(t, n) : "removeEventListener"in t ? "mousewheel" === e ? (t.removeEventListener("DOMMouseScroll", a, !1),
                t.removeEventListener(e, a, !1)) : "mouseenter" === e || "mouseleave" === e ? t.removeEventListener("mouseenter" === e ? "mouseover" : "mouseout", a, !1) : t.removeEventListener(e, a, !1) : "detachEvent"in t && t.detachEvent("on" + e, a),
                t[s] = null,
                this) : this
            },
            stopPropagation: function(t) {
                return t.stopPropagation ? t.stopPropagation() : t.cancelBubble = !0,
                this
            },
            disableClickPropagation: function(t) {
                for (var e = o.DomEvent.stopPropagation, i = o.Draggable.START.length - 1; i >= 0; i--)
                    o.DomEvent.addListener(t, o.Draggable.START[i], e);
                return o.DomEvent.addListener(t, "click", o.DomEvent._fakeStop).addListener(t, "dblclick", e)
            },
            preventDefault: function(t) {
                return t.preventDefault ? t.preventDefault() : t.returnValue = !1,
                this
            },
            stop: function(t) {
                return o.DomEvent.preventDefault(t).stopPropagation(t)
            },
            getMousePosition: function(t, i) {
                var n = o.Browser.ie7
                  , s = e.body
                  , a = e.documentElement
                  , r = t.pageX ? t.pageX - s.scrollLeft - a.scrollLeft : t.clientX
                  , h = t.pageY ? t.pageY - s.scrollTop - a.scrollTop : t.clientY
                  , l = new o.Point(r,h)
                  , u = i.getBoundingClientRect()
                  , c = u.left - i.clientLeft
                  , d = u.top - i.clientTop;
                return o.DomUtil.documentIsLtr() || !o.Browser.webkit && !n || (c += i.scrollWidth - i.clientWidth,
                n && "hidden" !== o.DomUtil.getStyle(i, "overflow-y") && "hidden" !== o.DomUtil.getStyle(i, "overflow") && (c += 17)),
                l._subtract(new o.Point(c,d))
            },
            getWheelDelta: function(t) {
                var e = 0;
                return t.wheelDelta && (e = t.wheelDelta / 120),
                t.detail && (e = -t.detail / 3),
                e
            },
            _skipEvents: {},
            _fakeStop: function(t) {
                o.DomEvent._skipEvents[t.type] = !0
            },
            _skipped: function(t) {
                var e = this._skipEvents[t.type];
                return this._skipEvents[t.type] = !1,
                e
            },
            _checkMouse: function(t, e) {
                var i = e.relatedTarget;
                if (!i)
                    return !0;
                try {
                    for (; i && i !== t; )
                        i = i.parentNode
                } catch (n$33) {
                    return !1
                }
                return i !== t
            },
            _getEvent: function() {
                var e = t.event;
                if (!e)
                    for (var i = arguments.callee.caller; i && (e = i.arguments[0],
                    !e || t.Event !== e.constructor); )
                        i = i.caller;
                return e
            },
            _filterClick: function(t, e) {
                var i = t.timeStamp || t.originalEvent.timeStamp
                  , n = o.DomEvent._lastClick && i - o.DomEvent._lastClick;
                return n && n > 100 && 1E3 > n || t.target._simulatedClick && !t._simulated ? (o.DomEvent.stop(t),
                void 0) : (o.DomEvent._lastClick = i,
                e(t))
            }
        },
        o.DomEvent.on = o.DomEvent.addListener,
        o.DomEvent.off = o.DomEvent.removeListener,
        o.Draggable = o.Class.extend({
            includes: o.Mixin.Events,
            statics: {
                START: o.Browser.touch ? ["touchstart", "mousedown"] : ["mousedown"],
                END: {
                    mousedown: "mouseup",
                    touchstart: "touchend",
                    MSPointerDown: "touchend"
                },
                MOVE: {
                    mousedown: "mousemove",
                    touchstart: "touchmove",
                    MSPointerDown: "touchmove"
                }
            },
            initialize: function(t, e) {
                this._element = t,
                this._dragStartTarget = e || t
            },
            enable: function() {
                if (!this._enabled) {
                    for (var t = o.Draggable.START.length - 1; t >= 0; t--)
                        o.DomEvent.on(this._dragStartTarget, o.Draggable.START[t], this._onDown, this);
                    this._enabled = !0
                }
            },
            disable: function() {
                if (this._enabled) {
                    for (var t = o.Draggable.START.length - 1; t >= 0; t--)
                        o.DomEvent.off(this._dragStartTarget, o.Draggable.START[t], this._onDown, this);
                    this._enabled = !1,
                    this._moved = !1
                }
            },
            _onDown: function(t) {
                if (!t.shiftKey && (1 === t.which || 1 === t.button || t.touches) && (o.DomEvent.stopPropagation(t),
                !o.Draggable._disabled)) {
                    o.DomUtil.disableImageDrag(),
                    o.DomUtil.disableTextSelection();
                    var i = t.touches ? t.touches[0] : t
                      , n = i.target;
                    o.Browser.touch && "a" === n.tagName.toLowerCase() && o.DomUtil.addClass(n, "leaflet-active"),
                    this._moved = !1,
                    this._moving || (this._startPoint = new o.Point(i.clientX,i.clientY),
                    this._startPos = this._newPos = o.DomUtil.getPosition(this._element),
                    o.DomEvent.on(e, o.Draggable.MOVE[t.type], this._onMove, this).on(e, o.Draggable.END[t.type], this._onUp, this))
                }
            },
            _onMove: function(t) {
                if (!(t.touches && t.touches.length > 1)) {
                    var i = t.touches && 1 === t.touches.length ? t.touches[0] : t
                      , n = new o.Point(i.clientX,i.clientY)
                      , s = n.subtract(this._startPoint);
                    (s.x || s.y) && (o.DomEvent.preventDefault(t),
                    this._moved || (this.fire("dragstart"),
                    this._moved = !0,
                    this._startPos = o.DomUtil.getPosition(this._element).subtract(s),
                    o.Browser.touch || o.DomUtil.addClass(e.body, "leaflet-dragging")),
                    this._newPos = this._startPos.add(s),
                    this._moving = !0,
                    o.Util.cancelAnimFrame(this._animRequest),
                    this._animRequest = o.Util.requestAnimFrame(this._updatePosition, this, !0, this._dragStartTarget))
                }
            },
            _updatePosition: function() {
                this.fire("predrag"),
                o.DomUtil.setPosition(this._element, this._newPos),
                this.fire("drag")
            },
            _onUp: function() {
                o.Browser.touch || o.DomUtil.removeClass(e.body, "leaflet-dragging");
                for (var t in o.Draggable.MOVE)
                    o.DomEvent.off(e, o.Draggable.MOVE[t], this._onMove).off(e, o.Draggable.END[t], this._onUp);
                o.DomUtil.enableImageDrag(),
                o.DomUtil.enableTextSelection(),
                this._moved && (o.Util.cancelAnimFrame(this._animRequest),
                this.fire("dragend")),
                this._moving = !1
            }
        }),
        o.Handler = o.Class.extend({
            initialize: function(t) {
                this._map = t
            },
            enable: function() {
                this._enabled || (this._enabled = !0,
                this.addHooks())
            },
            disable: function() {
                this._enabled && (this._enabled = !1,
                this.removeHooks())
            },
            enabled: function() {
                return !!this._enabled
            }
        }),
        o.Map.mergeOptions({
            dragging: !0,
            inertia: !o.Browser.android23,
            inertiaDeceleration: 3400,
            inertiaMaxSpeed: 1 / 0,
            inertiaThreshold: o.Browser.touch ? 32 : 18,
            easeLinearity: .25,
            worldCopyJump: !1
        }),
        o.Map.Drag = o.Handler.extend({
            addHooks: function() {
                if (!this._draggable) {
                    var t = this._map;
                    this._draggable = new o.Draggable(t._mapPane,t._container),
                    this._draggable.on({
                        dragstart: this._onDragStart,
                        drag: this._onDrag,
                        dragend: this._onDragEnd
                    }, this),
                    t.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDrag, this),
                    t.on("viewreset", this._onViewReset, this),
                    this._onViewReset())
                }
                this._draggable.enable()
            },
            removeHooks: function() {
                this._draggable.disable()
            },
            moved: function() {
                return this._draggable && this._draggable._moved
            },
            _onDragStart: function() {
                var t = this._map;
                t._panAnim && t._panAnim.stop(),
                t.fire("movestart").fire("dragstart"),
                t.options.inertia && (this._positions = [],
                this._times = [])
            },
            _onDrag: function() {
                if (this._map.options.inertia) {
                    var t = this._lastTime = +new Date
                      , e = this._lastPos = this._draggable._newPos;
                    this._positions.push(e),
                    this._times.push(t),
                    t - this._times[0] > 200 && (this._positions.shift(),
                    this._times.shift())
                }
                this._map.fire("move").fire("drag")
            },
            _onViewReset: function() {
                var t = this._map.getSize()._divideBy(2)
                  , e = this._map.latLngToLayerPoint([0, 0]);
                this._initialWorldOffset = e.subtract(t).x,
                this._worldWidth = this._map.project([0, 180]).x
            },
            _onPreDrag: function() {
                var t = this._worldWidth
                  , e = Math.round(t / 2)
                  , i = this._initialWorldOffset
                  , n = this._draggable._newPos.x
                  , o = (n - e + i) % t + e - i
                  , s = (n + e + i) % t - e - i
                  , a = Math.abs(o + i) < Math.abs(s + i) ? o : s;
                this._draggable._newPos.x = a
            },
            _onDragEnd: function() {
                var t = this._map
                  , e = t.options
                  , i = +new Date - this._lastTime
                  , n = !e.inertia || i > e.inertiaThreshold || !this._positions[0];
                if (t.fire("dragend"),
                n)
                    t.fire("moveend");
                else {
                    var s = this._lastPos.subtract(this._positions[0])
                      , a = (this._lastTime + i - this._times[0]) / 1E3
                      , r = e.easeLinearity
                      , h = s.multiplyBy(r / a)
                      , l = h.distanceTo([0, 0])
                      , u = Math.min(e.inertiaMaxSpeed, l)
                      , c = h.multiplyBy(u / l)
                      , d = u / (e.inertiaDeceleration * r)
                      , p = c.multiplyBy(-d / 2).round();
                    p.x && p.y ? o.Util.requestAnimFrame(function() {
                        t.panBy(p, {
                            duration: d,
                            easeLinearity: r,
                            noMoveStart: !0
                        })
                    }) : t.fire("moveend")
                }
            }
        }),
        o.Map.addInitHook("addHandler", "dragging", o.Map.Drag),
        o.Map.mergeOptions({
            doubleClickZoom: !0
        }),
        o.Map.DoubleClickZoom = o.Handler.extend({
            addHooks: function() {
                this._map.on("dblclick", this._onDoubleClick)
            },
            removeHooks: function() {
                this._map.off("dblclick", this._onDoubleClick)
            },
            _onDoubleClick: function(t) {
                this.setZoomAround(t.containerPoint, this._zoom + 1)
            }
        }),
        o.Map.addInitHook("addHandler", "doubleClickZoom", o.Map.DoubleClickZoom),
        o.Map.mergeOptions({
            scrollWheelZoom: !0
        }),
        o.Map.ScrollWheelZoom = o.Handler.extend({
            addHooks: function() {
                o.DomEvent.on(this._map._container, "mousewheel", this._onWheelScroll, this),
                o.DomEvent.on(this._map._container, "MozMousePixelScroll", o.DomEvent.preventDefault),
                this._delta = 0
            },
            removeHooks: function() {
                o.DomEvent.off(this._map._container, "mousewheel", this._onWheelScroll),
                o.DomEvent.off(this._map._container, "MozMousePixelScroll", o.DomEvent.preventDefault)
            },
            _onWheelScroll: function(t) {
                var e = o.DomEvent.getWheelDelta(t);
                this._delta += e,
                this._lastMousePos = this._map.mouseEventToContainerPoint(t),
                this._startTime || (this._startTime = +new Date);
                var i = Math.max(40 - (+new Date - this._startTime), 0);
                clearTimeout(this._timer),
                this._timer = setTimeout(o.bind(this._performZoom, this), i),
                o.DomEvent.preventDefault(t),
                o.DomEvent.stopPropagation(t)
            },
            _performZoom: function() {
                var t = this._map
                  , e = this._delta
                  , i = t.getZoom();
                e = e > 0 ? Math.ceil(e) : Math.floor(e),
                e = Math.max(Math.min(e, 4), -4),
                e = t._limitZoom(i + e) - i,
                this._delta = 0,
                this._startTime = null,
                e && t.setZoomAround(this._lastMousePos, i + e)
            }
        }),
        o.Map.addInitHook("addHandler", "scrollWheelZoom", o.Map.ScrollWheelZoom),
        o.extend(o.DomEvent, {
            _touchstart: o.Browser.msTouch ? "MSPointerDown" : "touchstart",
            _touchend: o.Browser.msTouch ? "MSPointerUp" : "touchend",
            addDoubleTapListener: function(t, i, n) {
                function s(t) {
                    var e;
                    if (o.Browser.msTouch ? (_.push(t.pointerId),
                    e = _.length) : e = t.touches.length,
                    !(e > 1)) {
                        var i = Date.now()
                          , n = i - (r || i);
                        h = t.touches ? t.touches[0] : t,
                        l = n > 0 && u >= n,
                        r = i
                    }
                }
                function a(t) {
                    if (o.Browser.msTouch) {
                        var e = _.indexOf(t.pointerId);
                        if (-1 === e)
                            return;
                        _.splice(e, 1)
                    }
                    if (l) {
                        if (o.Browser.msTouch) {
                            var n, s = {};
                            for (var a in h)
                                n = h[a],
                                s[a] = "function" == typeof n ? n.bind(h) : n;
                            h = s
                        }
                        h.type = "dblclick",
                        i(h),
                        r = null
                    }
                }
                var r, h, l = !1, u = 250, c = "_leaflet_", d = this._touchstart, p = this._touchend, _ = [];
                t[c + d + n] = s,
                t[c + p + n] = a;
                var m = o.Browser.msTouch ? e.documentElement : t;
                return t.addEventListener(d, s, !1),
                m.addEventListener(p, a, !1),
                o.Browser.msTouch && m.addEventListener("MSPointerCancel", a, !1),
                this
            },
            removeDoubleTapListener: function(t, i) {
                var n = "_leaflet_";
                return t.removeEventListener(this._touchstart, t[n + this._touchstart + i], !1),
                (o.Browser.msTouch ? e.documentElement : t).removeEventListener(this._touchend, t[n + this._touchend + i], !1),
                o.Browser.msTouch && e.documentElement.removeEventListener("MSPointerCancel", t[n + this._touchend + i], !1),
                this
            }
        }),
        o.extend(o.DomEvent, {
            _msTouches: [],
            _msDocumentListener: !1,
            addMsTouchListener: function(t, e, i, n) {
                switch (e) {
                case "touchstart":
                    return this.addMsTouchListenerStart(t, e, i, n);
                case "touchend":
                    return this.addMsTouchListenerEnd(t, e, i, n);
                case "touchmove":
                    return this.addMsTouchListenerMove(t, e, i, n);
                default:
                    throw "Unknown touch event type";
                }
            },
            addMsTouchListenerStart: function(t, i, n, o) {
                var s = "_leaflet_"
                  , a = this._msTouches
                  , r = function(t) {
                    for (var e = !1, i = 0; i < a.length; i++)
                        if (a[i].pointerId === t.pointerId) {
                            e = !0;
                            break
                        }
                    e || a.push(t),
                    t.touches = a.slice(),
                    t.changedTouches = [t],
                    n(t)
                };
                if (t[s + "touchstart" + o] = r,
                t.addEventListener("MSPointerDown", r, !1),
                !this._msDocumentListener) {
                    var h = function(t) {
                        for (var e = 0; e < a.length; e++)
                            if (a[e].pointerId === t.pointerId) {
                                a.splice(e, 1);
                                break
                            }
                    };
                    e.documentElement.addEventListener("MSPointerUp", h, !1),
                    e.documentElement.addEventListener("MSPointerCancel", h, !1),
                    this._msDocumentListener = !0
                }
                return this
            },
            addMsTouchListenerMove: function(t, e, i, n) {
                function o(t) {
                    if (t.pointerType !== t.MSPOINTER_TYPE_MOUSE || 0 !== t.buttons) {
                        for (var e = 0; e < a.length; e++)
                            if (a[e].pointerId === t.pointerId) {
                                a[e] = t;
                                break
                            }
                        t.touches = a.slice(),
                        t.changedTouches = [t],
                        i(t)
                    }
                }
                var s = "_leaflet_"
                  , a = this._msTouches;
                return t[s + "touchmove" + n] = o,
                t.addEventListener("MSPointerMove", o, !1),
                this
            },
            addMsTouchListenerEnd: function(t, e, i, n) {
                var o = "_leaflet_"
                  , s = this._msTouches
                  , a = function(t) {
                    for (var e = 0; e < s.length; e++)
                        if (s[e].pointerId === t.pointerId) {
                            s.splice(e, 1);
                            break
                        }
                    t.touches = s.slice(),
                    t.changedTouches = [t],
                    i(t)
                };
                return t[o + "touchend" + n] = a,
                t.addEventListener("MSPointerUp", a, !1),
                t.addEventListener("MSPointerCancel", a, !1),
                this
            },
            removeMsTouchListener: function(t, e, i) {
                var n = "_leaflet_"
                  , o = t[n + e + i];
                switch (e) {
                case "touchstart":
                    t.removeEventListener("MSPointerDown", o, !1);
                    break;
                case "touchmove":
                    t.removeEventListener("MSPointerMove", o, !1);
                    break;
                case "touchend":
                    t.removeEventListener("MSPointerUp", o, !1),
                    t.removeEventListener("MSPointerCancel", o, !1)
                }
                return this
            }
        }),
        o.Map.mergeOptions({
            touchZoom: o.Browser.touch && !o.Browser.android23
        }),
        o.Map.TouchZoom = o.Handler.extend({
            addHooks: function() {
                o.DomEvent.on(this._map._container, "touchstart", this._onTouchStart, this)
            },
            removeHooks: function() {
                o.DomEvent.off(this._map._container, "touchstart", this._onTouchStart, this)
            },
            _onTouchStart: function(t) {
                var i = this._map;
                if (t.touches && 2 === t.touches.length && !i._animatingZoom && !this._zooming) {
                    var n = i.mouseEventToLayerPoint(t.touches[0])
                      , s = i.mouseEventToLayerPoint(t.touches[1])
                      , a = i._getCenterLayerPoint();
                    this._startCenter = n.add(s)._divideBy(2),
                    this._startDist = n.distanceTo(s),
                    this._moved = !1,
                    this._zooming = !0,
                    this._centerOffset = a.subtract(this._startCenter),
                    i._panAnim && i._panAnim.stop(),
                    o.DomEvent.on(e, "touchmove", this._onTouchMove, this).on(e, "touchend", this._onTouchEnd, this),
                    o.DomEvent.preventDefault(t)
                }
            },
            _onTouchMove: function(t) {
                var e = this._map;
                if (t.touches && 2 === t.touches.length && this._zooming) {
                    var i = e.mouseEventToLayerPoint(t.touches[0])
                      , n = e.mouseEventToLayerPoint(t.touches[1]);
                    this._scale = i.distanceTo(n) / this._startDist,
                    this._delta = i._add(n)._divideBy(2)._subtract(this._startCenter),
                    1 !== this._scale && (this._moved || (o.DomUtil.addClass(e._mapPane, "leaflet-touching"),
                    e.fire("movestart").fire("zoomstart"),
                    this._moved = !0),
                    o.Util.cancelAnimFrame(this._animRequest),
                    this._animRequest = o.Util.requestAnimFrame(this._updateOnMove, this, !0, this._map._container),
                    o.DomEvent.preventDefault(t))
                }
            },
            _updateOnMove: function() {
                var t = this._map
                  , e = this._getScaleOrigin()
                  , i = t.layerPointToLatLng(e)
                  , n = t.getScaleZoom(this._scale);
                t._animateZoom(i, n, this._startCenter, this._scale, this._delta)
            },
            _onTouchEnd: function() {
                if (!this._moved || !this._zooming)
                    return this._zooming = !1,
                    void 0;
                var t = this._map;
                this._zooming = !1,
                o.DomUtil.removeClass(t._mapPane, "leaflet-touching"),
                o.Util.cancelAnimFrame(this._animRequest),
                o.DomEvent.off(e, "touchmove", this._onTouchMove).off(e, "touchend", this._onTouchEnd);
                var i = this._getScaleOrigin()
                  , n = t.layerPointToLatLng(i)
                  , s = t.getZoom()
                  , a = t.getScaleZoom(this._scale) - s
                  , r = a > 0 ? Math.ceil(a) : Math.floor(a)
                  , h = t._limitZoom(s + r)
                  , l = t.getZoomScale(h) / this._scale;
                t._animateZoom(n, h, i, l)
            },
            _getScaleOrigin: function() {
                var t = this._centerOffset.subtract(this._delta).divideBy(this._scale);
                return this._startCenter.add(t)
            }
        }),
        o.Map.addInitHook("addHandler", "touchZoom", o.Map.TouchZoom),
        o.Map.mergeOptions({
            tap: !0,
            tapTolerance: 15
        }),
        o.Map.Tap = o.Handler.extend({
            addHooks: function() {
                o.DomEvent.on(this._map._container, "touchstart", this._onDown, this)
            },
            removeHooks: function() {
                o.DomEvent.off(this._map._container, "touchstart", this._onDown, this)
            },
            _onDown: function(t) {
                if (t.touches) {
                    if (o.DomEvent.preventDefault(t),
                    this._fireClick = !0,
                    t.touches.length > 1)
                        return this._fireClick = !1,
                        clearTimeout(this._holdTimeout),
                        void 0;
                    var i = t.touches[0]
                      , n = i.target;
                    this._startPos = this._newPos = new o.Point(i.clientX,i.clientY),
                    "a" === n.tagName.toLowerCase() && o.DomUtil.addClass(n, "leaflet-active"),
                    this._holdTimeout = setTimeout(o.bind(function() {
                        this._isTapValid() && (this._fireClick = !1,
                        this._onUp(),
                        this._simulateEvent("contextmenu", i))
                    }, this), 1E3),
                    o.DomEvent.on(e, "touchmove", this._onMove, this).on(e, "touchend", this._onUp, this)
                }
            },
            _onUp: function(t) {
                if (clearTimeout(this._holdTimeout),
                o.DomEvent.off(e, "touchmove", this._onMove, this).off(e, "touchend", this._onUp, this),
                this._fireClick && t && t.changedTouches) {
                    var i = t.changedTouches[0]
                      , n = i.target;
                    "a" === n.tagName.toLowerCase() && o.DomUtil.removeClass(n, "leaflet-active"),
                    this._isTapValid() && this._simulateEvent("click", i)
                }
            },
            _isTapValid: function() {
                return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance
            },
            _onMove: function(t) {
                var e = t.touches[0];
                this._newPos = new o.Point(e.clientX,e.clientY)
            },
            _simulateEvent: function(i, n) {
                var o = e.createEvent("MouseEvents");
                o._simulated = !0,
                n.target._simulatedClick = !0,
                o.initMouseEvent(i, !0, !0, t, 1, n.screenX, n.screenY, n.clientX, n.clientY, !1, !1, !1, !1, 0, null),
                n.target.dispatchEvent(o)
            }
        }),
        o.Browser.touch && !o.Browser.msTouch && o.Map.addInitHook("addHandler", "tap", o.Map.Tap),
        o.Map.mergeOptions({
            boxZoom: !0
        }),
        o.Map.BoxZoom = o.Handler.extend({
            initialize: function(t) {
                this._map = t,
                this._container = t._container,
                this._pane = t._panes.overlayPane
            },
            addHooks: function() {
                o.DomEvent.on(this._container, "mousedown", this._onMouseDown, this)
            },
            removeHooks: function() {
                o.DomEvent.off(this._container, "mousedown", this._onMouseDown)
            },
            _onMouseDown: function(t) {
                return !t.shiftKey || 1 !== t.which && 1 !== t.button ? !1 : (o.DomUtil.disableTextSelection(),
                o.DomUtil.disableImageDrag(),
                this._startLayerPoint = this._map.mouseEventToLayerPoint(t),
                this._box = o.DomUtil.create("div", "leaflet-zoom-box", this._pane),
                o.DomUtil.setPosition(this._box, this._startLayerPoint),
                this._container.style.cursor = "crosshair",
                o.DomEvent.on(e, "mousemove", this._onMouseMove, this).on(e, "mouseup", this._onMouseUp, this).on(e, "keydown", this._onKeyDown, this),
                this._map.fire("boxzoomstart"),
                void 0)
            },
            _onMouseMove: function(t) {
                var e = this._startLayerPoint
                  , i = this._box
                  , n = this._map.mouseEventToLayerPoint(t)
                  , s = n.subtract(e)
                  , a = new o.Point(Math.min(n.x, e.x),Math.min(n.y, e.y));
                o.DomUtil.setPosition(i, a),
                i.style.width = Math.max(0, Math.abs(s.x) - 4) + "px",
                i.style.height = Math.max(0, Math.abs(s.y) - 4) + "px"
            },
            _finish: function() {
                this._pane.removeChild(this._box),
                this._container.style.cursor = "",
                o.DomUtil.enableTextSelection(),
                o.DomUtil.enableImageDrag(),
                o.DomEvent.off(e, "mousemove", this._onMouseMove).off(e, "mouseup", this._onMouseUp).off(e, "keydown", this._onKeyDown)
            },
            _onMouseUp: function(t) {
                this._finish();
                var e = this._map
                  , i = e.mouseEventToLayerPoint(t);
                if (!this._startLayerPoint.equals(i)) {
                    var n = new o.LatLngBounds(e.layerPointToLatLng(this._startLayerPoint),e.layerPointToLatLng(i));
                    e.fitBounds(n),
                    e.fire("boxzoomend", {
                        boxZoomBounds: n
                    })
                }
            },
            _onKeyDown: function(t) {
                27 === t.keyCode && this._finish()
            }
        }),
        o.Map.addInitHook("addHandler", "boxZoom", o.Map.BoxZoom),
        o.Map.mergeOptions({
            keyboard: !0,
            keyboardPanOffset: 80,
            keyboardZoomOffset: 1
        }),
        o.Map.Keyboard = o.Handler.extend({
            keyCodes: {
                left: [37],
                right: [39],
                down: [40],
                up: [38],
                zoomIn: [187, 107, 61],
                zoomOut: [189, 109, 173]
            },
            initialize: function(t) {
                this._map = t,
                this._setPanOffset(t.options.keyboardPanOffset),
                this._setZoomOffset(t.options.keyboardZoomOffset)
            },
            addHooks: function() {
                var t = this._map._container;
                -1 === t.tabIndex && (t.tabIndex = "0"),
                o.DomEvent.on(t, "focus", this._onFocus, this).on(t, "blur", this._onBlur, this).on(t, "mousedown", this._onMouseDown, this),
                this._map.on("focus", this._addHooks, this).on("blur", this._removeHooks, this)
            },
            removeHooks: function() {
                this._removeHooks();
                var t = this._map._container;
                o.DomEvent.off(t, "focus", this._onFocus, this).off(t, "blur", this._onBlur, this).off(t, "mousedown", this._onMouseDown, this),
                this._map.off("focus", this._addHooks, this).off("blur", this._removeHooks, this)
            },
            _onMouseDown: function() {
                if (!this._focused) {
                    var i = e.body
                      , n = e.documentElement
                      , o = i.scrollTop || n.scrollTop
                      , s = i.scrollLeft || n.scrollLeft;
                    this._map._container.focus(),
                    t.scrollTo(s, o)
                }
            },
            _onFocus: function() {
                this._focused = !0,
                this._map.fire("focus")
            },
            _onBlur: function() {
                this._focused = !1,
                this._map.fire("blur")
            },
            _setPanOffset: function(t) {
                var e, i, n = this._panKeys = {}, o = this.keyCodes;
                for (e = 0,
                i = o.left.length; i > e; e++)
                    n[o.left[e]] = [-1 * t, 0];
                for (e = 0,
                i = o.right.length; i > e; e++)
                    n[o.right[e]] = [t, 0];
                for (e = 0,
                i = o.down.length; i > e; e++)
                    n[o.down[e]] = [0, t];
                for (e = 0,
                i = o.up.length; i > e; e++)
                    n[o.up[e]] = [0, -1 * t]
            },
            _setZoomOffset: function(t) {
                var e, i, n = this._zoomKeys = {}, o = this.keyCodes;
                for (e = 0,
                i = o.zoomIn.length; i > e; e++)
                    n[o.zoomIn[e]] = t;
                for (e = 0,
                i = o.zoomOut.length; i > e; e++)
                    n[o.zoomOut[e]] = -t
            },
            _addHooks: function() {
                o.DomEvent.on(e, "keydown", this._onKeyDown, this)
            },
            _removeHooks: function() {
                o.DomEvent.off(e, "keydown", this._onKeyDown, this)
            },
            _onKeyDown: function(t) {
                var e = t.keyCode
                  , i = this._map;
                if (e in this._panKeys) {
                    if (i._panAnim && i._panAnim._inProgress)
                        return;
                    i.panBy(this._panKeys[e]),
                    i.options.maxBounds && i.panInsideBounds(i.options.maxBounds)
                } else {
                    if (!(e in this._zoomKeys))
                        return;
                    i.setZoom(i.getZoom() + this._zoomKeys[e])
                }
                o.DomEvent.stop(t)
            }
        }),
        o.Map.addInitHook("addHandler", "keyboard", o.Map.Keyboard),
        o.Handler.MarkerDrag = o.Handler.extend({
            initialize: function(t) {
                this._marker = t
            },
            addHooks: function() {
                var t = this._marker._icon;
                this._draggable || (this._draggable = new o.Draggable(t,t)),
                this._draggable.on("dragstart", this._onDragStart, this).on("drag", this._onDrag, this).on("dragend", this._onDragEnd, this),
                this._draggable.enable()
            },
            removeHooks: function() {
                this._draggable.off("dragstart", this._onDragStart, this).off("drag", this._onDrag, this).off("dragend", this._onDragEnd, this),
                this._draggable.disable()
            },
            moved: function() {
                return this._draggable && this._draggable._moved
            },
            _onDragStart: function() {
                this._marker.closePopup().fire("movestart").fire("dragstart")
            },
            _onDrag: function() {
                var t = this._marker
                  , e = t._shadow
                  , i = o.DomUtil.getPosition(t._icon)
                  , n = t._map.layerPointToLatLng(i);
                e && o.DomUtil.setPosition(e, i),
                t._latlng = n,
                t.fire("move", {
                    latlng: n
                }).fire("drag")
            },
            _onDragEnd: function() {
                this._marker.fire("moveend").fire("dragend")
            }
        }),
        o.Control = o.Class.extend({
            options: {
                position: "topright"
            },
            initialize: function(t) {
                o.setOptions(this, t)
            },
            getPosition: function() {
                return this.options.position
            },
            setPosition: function(t) {
                var e = this._map;
                return e && e.removeControl(this),
                this.options.position = t,
                e && e.addControl(this),
                this
            },
            getContainer: function() {
                return this._container
            },
            addTo: function(t) {
                this._map = t;
                var e = this._container = this.onAdd(t)
                  , i = this.getPosition()
                  , n = t._controlCorners[i];
                return o.DomUtil.addClass(e, "leaflet-control"),
                -1 !== i.indexOf("bottom") ? n.insertBefore(e, n.firstChild) : n.appendChild(e),
                this
            },
            removeFrom: function(t) {
                var e = this.getPosition()
                  , i = t._controlCorners[e];
                return i.removeChild(this._container),
                this._map = null,
                this.onRemove && this.onRemove(t),
                this
            }
        }),
        o.control = function(t) {
            return new o.Control(t)
        }
        ,
        o.Map.include({
            addControl: function(t) {
                return t.addTo(this),
                this
            },
            removeControl: function(t) {
                return t.removeFrom(this),
                this
            },
            _initControlPos: function() {
                function t(t, s) {
                    var a = i + t + " " + i + s;
                    e[t + s] = o.DomUtil.create("div", a, n)
                }
                var e = this._controlCorners = {}
                  , i = "leaflet-"
                  , n = this._controlContainer = o.DomUtil.create("div", i + "control-container", this._container);
                t("top", "left"),
                t("top", "right"),
                t("bottom", "left"),
                t("bottom", "right")
            },
            _clearControlPos: function() {
                this._container.removeChild(this._controlContainer)
            }
        }),
        o.Control.Zoom = o.Control.extend({
            options: {
                position: "topleft"
            },
            onAdd: function(t) {
                var e = "leaflet-control-zoom"
                  , i = o.DomUtil.create("div", e + " leaflet-bar");
                return this._map = t,
                this._zoomInButton = this._createButton("+", "Zoom in", e + "-in", i, this._zoomIn, this),
                this._zoomOutButton = this._createButton("-", "Zoom out", e + "-out", i, this._zoomOut, this),
                t.on("zoomend zoomlevelschange", this._updateDisabled, this),
                i
            },
            onRemove: function(t) {
                t.off("zoomend zoomlevelschange", this._updateDisabled, this)
            },
            _zoomIn: function(t) {
                this._map.zoomIn(t.shiftKey ? 3 : 1)
            },
            _zoomOut: function(t) {
                this._map.zoomOut(t.shiftKey ? 3 : 1)
            },
            _createButton: function(t, e, i, n, s, a) {
                var r = o.DomUtil.create("a", i, n);
                r.innerHTML = t,
                r.href = "#",
                r.title = e;
                var h = o.DomEvent.stopPropagation;
                return o.DomEvent.on(r, "click", h).on(r, "mousedown", h).on(r, "dblclick", h).on(r, "click", o.DomEvent.preventDefault).on(r, "click", s, a),
                r
            },
            _updateDisabled: function() {
                var t = this._map
                  , e = "leaflet-disabled";
                o.DomUtil.removeClass(this._zoomInButton, e),
                o.DomUtil.removeClass(this._zoomOutButton, e),
                t._zoom === t.getMinZoom() && o.DomUtil.addClass(this._zoomOutButton, e),
                t._zoom === t.getMaxZoom() && o.DomUtil.addClass(this._zoomInButton, e)
            }
        }),
        o.Map.mergeOptions({
            zoomControl: !0
        }),
        o.Map.addInitHook(function() {
            this.options.zoomControl && (this.zoomControl = new o.Control.Zoom,
            this.addControl(this.zoomControl))
        }),
        o.control.zoom = function(t) {
            return new o.Control.Zoom(t)
        }
        ,
        o.Control.Attribution = o.Control.extend({
            options: {
                position: "bottomright",
                prefix: '<a href="https://leafletjs.com" target="_blank" title="A JS library for interactive maps">Leaflet</a>'
            },
            initialize: function(t) {
                o.setOptions(this, t),
                this._attributions = {}
            },
            onAdd: function(t) {
                return this._container = o.DomUtil.create("div", "leaflet-control-attribution"),
                o.DomEvent.disableClickPropagation(this._container),
                t.on("layeradd", this._onLayerAdd, this).on("layerremove", this._onLayerRemove, this),
                this._update(),
                this._container
            },
            onRemove: function(t) {
                t.off("layeradd", this._onLayerAdd).off("layerremove", this._onLayerRemove)
            },
            setPrefix: function(t) {
                return this.options.prefix = t,
                this._update(),
                this
            },
            addAttribution: function(t) {
                return t ? (this._attributions[t] || (this._attributions[t] = 0),
                this._attributions[t]++,
                this._update(),
                this) : void 0
            },
            removeAttribution: function(t) {
                return t ? (this._attributions[t] && (this._attributions[t]--,
                this._update()),
                this) : void 0
            },
            _update: function() {
                if (this._map) {
                    var t = [];
                    for (var e in this._attributions)
                        this._attributions[e] && t.push(e);
                    var i = [];
                    this.options.prefix && i.push(this.options.prefix),
                    t.length && i.push(t.join(", ")),
                    this._container.innerHTML = i.join(" | ")
                }
            },
            _onLayerAdd: function(t) {
                t.layer.getAttribution && this.addAttribution(t.layer.getAttribution())
            },
            _onLayerRemove: function(t) {
                t.layer.getAttribution && this.removeAttribution(t.layer.getAttribution())
            }
        }),
        o.Map.mergeOptions({
            attributionControl: !0
        }),
        o.Map.addInitHook(function() {
            this.options.attributionControl && (this.attributionControl = (new o.Control.Attribution).addTo(this))
        }),
        o.control.attribution = function(t) {
            return new o.Control.Attribution(t)
        }
        ,
        o.Control.Scale = o.Control.extend({
            options: {
                position: "bottomleft",
                maxWidth: 100,
                metric: !0,
                imperial: !0,
                updateWhenIdle: !1
            },
            onAdd: function(t) {
                this._map = t;
                var e = "leaflet-control-scale"
                  , i = o.DomUtil.create("div", e)
                  , n = this.options;
                return this._addScales(n, e, i),
                t.on(n.updateWhenIdle ? "moveend" : "move", this._update, this),
                t.whenReady(this._update, this),
                i
            },
            onRemove: function(t) {
                t.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this)
            },
            _addScales: function(t, e, i) {
                t.metric && (this._mScale = o.DomUtil.create("div", e + "-line", i)),
                t.imperial && (this._iScale = o.DomUtil.create("div", e + "-line", i))
            },
            _update: function() {
                var t = this._map.getBounds()
                  , e = t.getCenter().lat
                  , i = 6378137 * Math.PI * Math.cos(e * Math.PI / 180)
                  , n = i * (t.getNorthEast().lng - t.getSouthWest().lng) / 180
                  , o = this._map.getSize()
                  , s = this.options
                  , a = 0;
                o.x > 0 && (a = n * (s.maxWidth / o.x)),
                this._updateScales(s, a)
            },
            _updateScales: function(t, e) {
                t.metric && e && this._updateMetric(e),
                t.imperial && e && this._updateImperial(e)
            },
            _updateMetric: function(t) {
                var e = this._getRoundNum(t);
                this._mScale.style.width = this._getScaleWidth(e / t) + "px",
                this._mScale.innerHTML = 1E3 > e ? e + " m" : e / 1E3 + " km"
            },
            _updateImperial: function(t) {
                var e, i, n, o = 3.2808399 * t, s = this._iScale;
                o > 5280 ? (e = o / 5280,
                i = this._getRoundNum(e),
                s.style.width = this._getScaleWidth(i / e) + "px",
                s.innerHTML = i + " mi") : (n = this._getRoundNum(o),
                s.style.width = this._getScaleWidth(n / o) + "px",
                s.innerHTML = n + " ft")
            },
            _getScaleWidth: function(t) {
                return Math.round(this.options.maxWidth * t) - 10
            },
            _getRoundNum: function(t) {
                var e = Math.pow(10, (Math.floor(t) + "").length - 1)
                  , i = t / e;
                return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : 1,
                e * i
            }
        }),
        o.control.scale = function(t) {
            return new o.Control.Scale(t)
        }
        ,
        o.Control.Layers = o.Control.extend({
            options: {
                collapsed: !0,
                position: "topright",
                autoZIndex: !0
            },
            initialize: function(t, e, i) {
                o.setOptions(this, i),
                this._layers = {},
                this._lastZIndex = 0,
                this._handlingClick = !1;
                for (var n in t)
                    this._addLayer(t[n], n);
                for (n in e)
                    this._addLayer(e[n], n, !0)
            },
            onAdd: function(t) {
                return this._initLayout(),
                this._update(),
                t.on("layeradd", this._onLayerChange, this).on("layerremove", this._onLayerChange, this),
                this._container
            },
            onRemove: function(t) {
                t.off("layeradd", this._onLayerChange).off("layerremove", this._onLayerChange)
            },
            addBaseLayer: function(t, e) {
                return this._addLayer(t, e),
                this._update(),
                this
            },
            addOverlay: function(t, e) {
                return this._addLayer(t, e, !0),
                this._update(),
                this
            },
            removeLayer: function(t) {
                var e = o.stamp(t);
                return delete this._layers[e],
                this._update(),
                this
            },
            _initLayout: function() {
                var t = "leaflet-control-layers"
                  , e = this._container = o.DomUtil.create("div", t);
                e.setAttribute("aria-haspopup", !0),
                o.Browser.touch ? o.DomEvent.on(e, "click", o.DomEvent.stopPropagation) : (o.DomEvent.disableClickPropagation(e),
                o.DomEvent.on(e, "mousewheel", o.DomEvent.stopPropagation));
                var i = this._form = o.DomUtil.create("form", t + "-list");
                if (this.options.collapsed) {
                    o.Browser.android || o.DomEvent.on(e, "mouseover", this._expand, this).on(e, "mouseout", this._collapse, this);
                    var n = this._layersLink = o.DomUtil.create("a", t + "-toggle", e);
                    n.href = "#",
                    n.title = "Layers",
                    o.Browser.touch ? o.DomEvent.on(n, "click", o.DomEvent.stop).on(n, "click", this._expand, this) : o.DomEvent.on(n, "focus", this._expand, this),
                    this._map.on("click", this._collapse, this)
                } else
                    this._expand();
                this._baseLayersList = o.DomUtil.create("div", t + "-base", i),
                this._separator = o.DomUtil.create("div", t + "-separator", i),
                this._overlaysList = o.DomUtil.create("div", t + "-overlays", i),
                e.appendChild(i)
            },
            _addLayer: function(t, e, i) {
                var n = o.stamp(t);
                this._layers[n] = {
                    layer: t,
                    name: e,
                    overlay: i
                },
                this.options.autoZIndex && t.setZIndex && (this._lastZIndex++,
                t.setZIndex(this._lastZIndex))
            },
            _update: function() {
                if (this._container) {
                    this._baseLayersList.innerHTML = "",
                    this._overlaysList.innerHTML = "";
                    var t, e, i = !1, n = !1;
                    for (t in this._layers)
                        e = this._layers[t],
                        this._addItem(e),
                        n = n || e.overlay,
                        i = i || !e.overlay;
                    this._separator.style.display = n && i ? "" : "none"
                }
            },
            _onLayerChange: function(t) {
                var e = this._layers[o.stamp(t.layer)];
                if (e) {
                    this._handlingClick || this._update();
                    var i = e.overlay ? "layeradd" === t.type ? "overlayadd" : "overlayremove" : "layeradd" === t.type ? "baselayerchange" : null;
                    i && this._map.fire(i, e)
                }
            },
            _createRadioElement: function(t, i) {
                var n = '<input type="radio" class="leaflet-control-layers-selector" name="' + t + '"';
                i && (n += ' checked="checked"'),
                n += "/>";
                var o = e.createElement("div");
                return o.innerHTML = n,
                o.firstChild
            },
            _addItem: function(t) {
                var i, n = e.createElement("label"), s = this._map.hasLayer(t.layer);
                t.overlay ? (i = e.createElement("input"),
                i.type = "checkbox",
                i.className = "leaflet-control-layers-selector",
                i.defaultChecked = s) : i = this._createRadioElement("leaflet-base-layers", s),
                i.layerId = o.stamp(t.layer),
                o.DomEvent.on(i, "click", this._onInputClick, this);
                var a = e.createElement("span");
                a.innerHTML = " " + t.name,
                n.appendChild(i),
                n.appendChild(a);
                var r = t.overlay ? this._overlaysList : this._baseLayersList;
                return r.appendChild(n),
                n
            },
            _onInputClick: function() {
                var t, e, i, n = this._form.getElementsByTagName("input"), o = n.length;
                for (this._handlingClick = !0,
                t = 0; o > t; t++)
                    e = n[t],
                    i = this._layers[e.layerId],
                    e.checked && !this._map.hasLayer(i.layer) ? this._map.addLayer(i.layer) : !e.checked && this._map.hasLayer(i.layer) && this._map.removeLayer(i.layer);
                this._handlingClick = !1
            },
            _expand: function() {
                o.DomUtil.addClass(this._container, "leaflet-control-layers-expanded")
            },
            _collapse: function() {
                this._container.className = this._container.className.replace(" leaflet-control-layers-expanded", "")
            }
        }),
        o.control.layers = function(t, e, i) {
            return new o.Control.Layers(t,e,i)
        }
        ,
        o.PosAnimation = o.Class.extend({
            includes: o.Mixin.Events,
            run: function(t, e, i, n) {
                this.stop(),
                this._el = t,
                this._inProgress = !0,
                this._newPos = e,
                this.fire("start"),
                t.style[o.DomUtil.TRANSITION] = "all " + (i || .25) + "s cubic-bezier(0,0," + (n || .5) + ",1)",
                o.DomEvent.on(t, o.DomUtil.TRANSITION_END, this._onTransitionEnd, this),
                o.DomUtil.setPosition(t, e),
                o.Util.falseFn(t.offsetWidth),
                this._stepTimer = setInterval(o.bind(this._onStep, this), 50)
            },
            stop: function() {
                this._inProgress && (o.DomUtil.setPosition(this._el, this._getPos()),
                this._onTransitionEnd(),
                o.Util.falseFn(this._el.offsetWidth))
            },
            _onStep: function() {
                var t = this._getPos();
                return t ? (this._el._leaflet_pos = t,
                this.fire("step"),
                void 0) : (this._onTransitionEnd(),
                void 0)
            },
            _transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,
            _getPos: function() {
                var e, i, n, s = this._el, a = t.getComputedStyle(s);
                if (o.Browser.any3d) {
                    if (n = a[o.DomUtil.TRANSFORM].match(this._transformRe),
                    !n)
                        return;
                    e = parseFloat(n[1]),
                    i = parseFloat(n[2])
                } else
                    e = parseFloat(a.left),
                    i = parseFloat(a.top);
                return new o.Point(e,i,!0)
            },
            _onTransitionEnd: function() {
                o.DomEvent.off(this._el, o.DomUtil.TRANSITION_END, this._onTransitionEnd, this),
                this._inProgress && (this._inProgress = !1,
                this._el.style[o.DomUtil.TRANSITION] = "",
                this._el._leaflet_pos = this._newPos,
                clearInterval(this._stepTimer),
                this.fire("step").fire("end"))
            }
        }),
        o.Map.include({
            setView: function(t, e, n) {
                if (e = this._limitZoom(e),
                t = o.latLng(t),
                n = n || {},
                this._panAnim && this._panAnim.stop(),
                this._loaded && !n.reset && n !== !0) {
                    n.animate !== i && (n.zoom = o.extend({
                        animate: n.animate
                    }, n.zoom),
                    n.pan = o.extend({
                        animate: n.animate
                    }, n.pan));
                    var s = this._zoom !== e ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, e, n.zoom) : this._tryAnimatedPan(t, n.pan);
                    if (s)
                        return clearTimeout(this._sizeTimer),
                        this
                }
                return this._resetView(t, e),
                this
            },
            panBy: function(t, e) {
                if (t = o.point(t).round(),
                e = e || {},
                !t.x && !t.y)
                    return this;
                if (this._panAnim || (this._panAnim = new o.PosAnimation,
                this._panAnim.on({
                    step: this._onPanTransitionStep,
                    end: this._onPanTransitionEnd
                }, this)),
                e.noMoveStart || this.fire("movestart"),
                e.animate !== !1) {
                    o.DomUtil.addClass(this._mapPane, "leaflet-pan-anim");
                    var i = this._getMapPanePos().subtract(t);
                    this._panAnim.run(this._mapPane, i, e.duration || .25, e.easeLinearity)
                } else
                    this._rawPanBy(t),
                    this.fire("move").fire("moveend");
                return this
            },
            _onPanTransitionStep: function() {
                this.fire("move")
            },
            _onPanTransitionEnd: function() {
                o.DomUtil.removeClass(this._mapPane, "leaflet-pan-anim"),
                this.fire("moveend")
            },
            _tryAnimatedPan: function(t, e) {
                var i = this._getCenterOffset(t)._floor();
                return (e && e.animate) === !0 || this.getSize().contains(i) ? (this.panBy(i, e),
                !0) : !1
            }
        }),
        o.PosAnimation = o.DomUtil.TRANSITION ? o.PosAnimation : o.PosAnimation.extend({
            run: function(t, e, i, n) {
                this.stop(),
                this._el = t,
                this._inProgress = !0,
                this._duration = i || .25,
                this._easeOutPower = 1 / Math.max(n || .5, .2),
                this._startPos = o.DomUtil.getPosition(t),
                this._offset = e.subtract(this._startPos),
                this._startTime = +new Date,
                this.fire("start"),
                this._animate()
            },
            stop: function() {
                this._inProgress && (this._step(),
                this._complete())
            },
            _animate: function() {
                this._animId = o.Util.requestAnimFrame(this._animate, this),
                this._step()
            },
            _step: function() {
                var t = +new Date - this._startTime
                  , e = 1E3 * this._duration;
                e > t ? this._runFrame(this._easeOut(t / e)) : (this._runFrame(1),
                this._complete())
            },
            _runFrame: function(t) {
                var e = this._startPos.add(this._offset.multiplyBy(t));
                o.DomUtil.setPosition(this._el, e),
                this.fire("step")
            },
            _complete: function() {
                o.Util.cancelAnimFrame(this._animId),
                this._inProgress = !1,
                this.fire("end")
            },
            _easeOut: function(t) {
                return 1 - Math.pow(1 - t, this._easeOutPower)
            }
        }),
        o.Map.mergeOptions({
            zoomAnimation: !0,
            zoomAnimationThreshold: 4
        }),
        o.DomUtil.TRANSITION && o.Map.addInitHook(function() {
            this._zoomAnimated = this.options.zoomAnimation && o.DomUtil.TRANSITION && o.Browser.any3d && !o.Browser.android23 && !o.Browser.mobileOpera,
            this._zoomAnimated && o.DomEvent.on(this._mapPane, o.DomUtil.TRANSITION_END, this._catchTransitionEnd, this)
        }),
        o.Map.include(o.DomUtil.TRANSITION ? {
            _catchTransitionEnd: function() {
                this._animatingZoom && this._onZoomTransitionEnd()
            },
            _nothingToAnimate: function() {
                return !this._container.getElementsByClassName("leaflet-zoom-animated").length
            },
            _tryAnimatedZoom: function(t, e, i) {
                if (this._animatingZoom)
                    return !0;
                if (i = i || {},
                !this._zoomAnimated || i.animate === !1 || this._nothingToAnimate() || Math.abs(e - this._zoom) > this.options.zoomAnimationThreshold)
                    return !1;
                var n = this.getZoomScale(e)
                  , o = this._getCenterOffset(t)._divideBy(1 - 1 / n)
                  , s = this._getCenterLayerPoint()._add(o);
                return i.animate === !0 || this.getSize().contains(o) ? (this.fire("movestart").fire("zoomstart"),
                this._animateZoom(t, e, s, n, null, !0),
                !0) : !1
            },
            _animateZoom: function(t, e, i, n, s, a) {
                this._animatingZoom = !0,
                o.DomUtil.addClass(this._mapPane, "leaflet-zoom-anim"),
                this._animateToCenter = t,
                this._animateToZoom = e,
                o.Draggable && (o.Draggable._disabled = !0),
                this.fire("zoomanim", {
                    center: t,
                    zoom: e,
                    origin: i,
                    scale: n,
                    delta: s,
                    backwards: a
                })
            },
            _onZoomTransitionEnd: function() {
                this._animatingZoom = !1,
                o.DomUtil.removeClass(this._mapPane, "leaflet-zoom-anim"),
                this._resetView(this._animateToCenter, this._animateToZoom, !0, !0),
                o.Draggable && (o.Draggable._disabled = !1)
            }
        } : {}),
        o.TileLayer.include({
            _animateZoom: function(t) {
                this._animating || (this._animating = !0,
                this._prepareBgBuffer());
                var e = this._bgBuffer
                  , i = o.DomUtil.TRANSFORM
                  , n = t.delta ? o.DomUtil.getTranslateString(t.delta) : e.style[i]
                  , s = o.DomUtil.getScaleString(t.scale, t.origin);
                e.style[i] = t.backwards ? s + " " + n : n + " " + s
            },
            _endZoomAnim: function() {
                var t = this._tileContainer
                  , e = this._bgBuffer;
                t.style.visibility = "",
                t.parentNode.appendChild(t),
                o.Util.falseFn(e.offsetWidth),
                this._animating = !1
            },
            _clearBgBuffer: function() {
                var t = this._map;
                !t || t._animatingZoom || t.touchZoom._zooming || (this._bgBuffer.innerHTML = "",
                this._bgBuffer.style[o.DomUtil.TRANSFORM] = "")
            },
            _prepareBgBuffer: function() {
                var t = this._tileContainer
                  , e = this._bgBuffer
                  , i = this._getLoadedTilesPercentage(e)
                  , n = this._getLoadedTilesPercentage(t);
                return e && i > .5 && .5 > n ? (t.style.visibility = "hidden",
                this._stopLoadingImages(t),
                void 0) : (e.style.visibility = "hidden",
                e.style[o.DomUtil.TRANSFORM] = "",
                this._tileContainer = e,
                e = this._bgBuffer = t,
                this._stopLoadingImages(e),
                clearTimeout(this._clearBgBufferTimer),
                void 0)
            },
            _getLoadedTilesPercentage: function(t) {
                var e, i, n = t.getElementsByTagName("img"), o = 0;
                for (e = 0,
                i = n.length; i > e; e++)
                    n[e].complete && o++;
                return o / i
            },
            _stopLoadingImages: function(t) {
                var e, i, n, s = Array.prototype.slice.call(t.getElementsByTagName("img"));
                for (e = 0,
                i = s.length; i > e; e++)
                    n = s[e],
                    n.complete || (n.onload = o.Util.falseFn,
                    n.onerror = o.Util.falseFn,
                    n.src = o.Util.emptyImageUrl,
                    n.parentNode.removeChild(n))
            }
        }),
        o.Map.include({
            _defaultLocateOptions: {
                watch: !1,
                setView: !1,
                maxZoom: 1 / 0,
                timeout: 1E4,
                maximumAge: 0,
                enableHighAccuracy: !1
            },
            locate: function(t) {
                if (t = this._locateOptions = o.extend(this._defaultLocateOptions, t),
                !navigator.geolocation)
                    return this._handleGeolocationError({
                        code: 0,
                        message: "Geolocation not supported."
                    }),
                    this;
                var e = o.bind(this._handleGeolocationResponse, this)
                  , i = o.bind(this._handleGeolocationError, this);
                return t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(e, i, t) : navigator.geolocation.getCurrentPosition(e, i, t),
                this
            },
            stopLocate: function() {
                return navigator.geolocation && navigator.geolocation.clearWatch(this._locationWatchId),
                this._locateOptions && (this._locateOptions.setView = !1),
                this
            },
            _handleGeolocationError: function(t) {
                var e = t.code
                  , i = t.message || (1 === e ? "permission denied" : 2 === e ? "position unavailable" : "timeout");
                this._locateOptions.setView && !this._loaded && this.fitWorld(),
                this.fire("locationerror", {
                    code: e,
                    message: "Geolocation error: " + i + "."
                })
            },
            _handleGeolocationResponse: function(t) {
                var e = t.coords.latitude
                  , i = t.coords.longitude
                  , n = new o.LatLng(e,i)
                  , s = 180 * t.coords.accuracy / 40075017
                  , a = s / Math.cos(o.LatLng.DEG_TO_RAD * e)
                  , r = o.latLngBounds([e - s, i - a], [e + s, i + a])
                  , h = this._locateOptions;
                if (h.setView) {
                    var l = Math.min(this.getBoundsZoom(r), h.maxZoom);
                    this.setView(n, l)
                }
                var u = {
                    latlng: n,
                    bounds: r
                };
                for (var c in t.coords)
                    "number" == typeof t.coords[c] && (u[c] = t.coords[c]);
                this.fire("locationfound", u)
            }
        })
    }(window, document);
(function() {
    tdgchart.prototype.cacheLeafletBubbleMarkerSize = cacheLeafletBubbleMarkerSize;
    tdgchart.prototype.isLeaflet = function() {
        return this.chartType === "map" && this.mapProperties.engine === "leaflet"
    }
    ;
    var tdg = tdgchart.util;
    tdgchart.prototype.drawLeafletMap = function(chartPanel, chartLayout) {
        var chart = this;
        var root = document.getElementById(chart.documentRoot);
        var svg = root.getElementsByTagName("svg")[0];
        chart._internalMapCache = {
            map: undefined,
            layerControl: undefined,
            zoomLayerInfo: [],
            groupLayers: {},
            toolTipDiv: undefined
        };
        var relContainer = document.createElement("div");
        relContainer.style.position = "relative";
        relContainer.appendChild(svg);
        var container = document.createElement("div");
        container.setAttribute("class", "leafletContainer");
        container.style.position = "absolute";
        container.style.left = chartPanel.computedSize.x + "px";
        container.style.top = chartPanel.computedSize.y + "px";
        container.style.zIndex = 10;
        var scale = chart.get("transform.scale", 1);
        container.style.width = chartPanel.computedSize.width * scale + "px";
        container.style.height = chartPanel.computedSize.height * scale + "px";
        root.appendChild(relContainer);
        relContainer.appendChild(container);
        drawLeafletInternal(chart, container, chartPanel);
        chart.processEvents();
        chart.doMouseHover();
        chart.processSelection(chartLayout);
        if (chart.htmlToolTip.enabled) {
            var toolTipDiv = chart._internalMapCache.toolTipDiv = chart.createHTMLToolTip(tdgchart.d3.select(root));
            toolTipDiv.style.zIndex = 20
        }
    }
    ;
    function addTouchToLeaflet() {
        L.Map.mergeOptions({
            touchExtend: true
        });
        L.Map.TouchExtend = L.Handler.extend({
            initialize: function(map) {
                this._map = map;
                this._container = map._container;
                this._pane = map._panes.overlayPane
            },
            addHooks: function() {
                L.DomEvent.on(this._container, "touchstart", this._onTouchStart, this);
                L.DomEvent.on(this._container, "touchend", this._onTouchEnd, this);
                L.DomEvent.on(this._container, "touchmove", this._onTouchMove, this)
            },
            removeHooks: function() {
                L.DomEvent.off(this._container, "touchstart", this._onTouchStart);
                L.DomEvent.off(this._container, "touchend", this._onTouchEnd);
                L.DomEvent.off(this._container, "touchmove", this._onTouchMove)
            },
            _onTouchEvent: function(e, type) {
                var containerPoint, latlng, layerPoint, touch;
                if (!this._map._loaded)
                    return;
                touch = e.touches[0];
                containerPoint = L.point(touch.clientX, touch.clientY);
                layerPoint = this._map.containerPointToLayerPoint(containerPoint);
                latlng = this._map.layerPointToLatLng(layerPoint);
                return this._map.fire(type, {
                    latlng: latlng,
                    layerPoint: layerPoint,
                    containerPoint: containerPoint,
                    originalEvent: e
                })
            },
            _onTouchStart: function(e) {
                return this._onTouchEvent(e, "touchstart")
            },
            _onTouchEnd: function(e) {
                if (!this._map._loaded)
                    return;
                return this._map.fire("touchend", {
                    originalEvent: e
                })
            },
            _onTouchMove: function(e) {
                return this._onTouchEvent(e, "touchmove")
            }
        });
        L.Map.addInitHook("addHandler", "touchExtend", L.Map.TouchExtend)
    }
    if (typeof window !== "undefined")
        addTouchToLeaflet();
    function loadLeafletCSS() {
        // テスト用に変更
        // var leafletCSSID = "leafletCSSID";
        // var leafletDrawCSSID = "leafletDrawCSSID";
        // if (!document.getElementById(leafletCSSID))
        //     tdg.loadCSSFile(leafletCSSID, tdgchart.getScriptPath() + "leaflet/leaflet.css");
        // if (!document.getElementById(leafletDrawCSSID))
        //     tdg.loadCSSFile(leafletDrawCSSID, tdgchart.getScriptPath() + "leaflet/leaflet.draw.css")
    }
    if (typeof window !== "undefined")
        loadLeafletCSS();
    var buttonMode = "Pan";
    function addSelectionButton(chart) {
        function setButtonMode(button, mode) {
            if (mode === "Pan") {
                button._map.dragging.enable();
                button._map._mapPane.style.cursor = "";
                chart._disableSelection = true;
                tdgchart.d3.select(".leafletContainer").select("svg").attr("cursor", "grab")
            } else {
                button._map.dragging.disable();
                chart._disableSelection = false;
                tdgchart.d3.select(".leafletContainer").select("svg").attr("cursor", "crosshair")
            }
            button.innerHTML = mode
        }
        function selectionButtonEvent() {
            buttonMode = buttonMode === "Pan" ? "Selection" : "Pan";
            setButtonMode(this, buttonMode)
        }
        return new (L.Control.extend({
            onAdd: function(map) {
                var button = L.DomUtil.create("button", "data-selection-button");
                button.style.cursor = "pointer";
                L.DomEvent.addListener(button, "click", selectionButtonEvent);
                button._map = map;
                setButtonMode(button, buttonMode);
                return button
            }
        }))
    }
    function drawLeafletInternal(chart, where, chartPanel) {
        if (!chart._internalData)
            chart._internalData = chart.data;
        var a = Array.isArray
          , d = chart._internalData;
        if (a(d) && a(d[0]) && (!a(d[0][0]) && typeof d[0][0] !== "object"))
            chart._internalData = [chart._internalData];
        var map = chart._internalMapCache.map = L.map(where, chart.mapProperties.leaflet.mapOptions);
        var layerControl;
        var i, bounds = null;
        if (chart.dataSelection.enabled)
            map.addControl(addSelectionButton(chart));
        if (chart.mapProperties.leaflet.controls)
            for (i = 0; i < chart.mapProperties.leaflet.controls.length; ++i) {
                var c = chart.mapProperties.leaflet.controls[i];
                if (c.control) {
                    var control = null;
                    if (typeof c.control === "function")
                        control = c.control(map, c.options);
                    else if (typeof c.control === "string")
                        if (c.control === "L.Control.Layers") {
                            control = new L.Control.Layers({},{},c.options);
                            layerControl = chart._internalMapCache.layerControl = control;
                            control = null
                        } else
                            try {
                                var cc = c.control.split(".").reduce(function(b, p) {
                                    return b[p]
                                }, window);
                                control = new cc(map,c.options)
                            } catch (e$34) {}
                    if (control)
                        control.addTo(map)
                }
            }
        var lastLayer;
        var firstLayer;
        var count = 0;
        chart.mapProperties.leaflet.baselayers = chart.mapProperties.leaflet.baselayers || [];
        chart.mapProperties.leaflet.baselayers.forEach(function(d) {
            if (d.layerInfo.minZoom < 0)
                d.layerInfo.minZoom = 0;
            if (d.layerInfo.maxZoom < 0)
                d.layerInfo.maxZoom = 1024;
            if (d.layerInfo.attribution && typeof d.layerInfo.attribution === "function")
                d.layerInfo.attribution = d.layerInfo.attribution();
            if (d.url && typeof d.url === "function")
                d.url = d.url();
            lastLayer = L.tileLayer(d.url, d.layerInfo);
            if (layerControl)
                layerControl.addBaseLayer(lastLayer, d.title);
            if (count === 0)
                firstLayer = lastLayer;
            count += 1;
            lastLayer.on("load", function() {
                window.setTimeout(function() {
                    chart.processRenderComplete()
                }, 250)
            })
        });
        if (firstLayer)
            firstLayer.addTo(map);
        chart.mapProperties.leaflet.overlayLayers = chart.mapProperties.leaflet.overlayLayers || [];
        for (i = 0; i < chart.mapProperties.leaflet.overlayLayers.length; ++i) {
            var overlay = chart.mapProperties.leaflet.overlayLayers[i];
            var overlayURLContent = loadOverlayURL(chart, overlay);
            var leafletData = null;
            leafletData = getLeafletData(chart, overlay, overlayURLContent);
            if (leafletData) {
                if (bounds) {
                    if (leafletData.bounds && leafletData.leafletData.dataLookup)
                        bounds.extend(leafletData.bounds.min).extend(leafletData.bounds.max)
                } else
                    bounds = leafletData.bounds;
                leafletData = leafletData.leafletData
            }
            var newLayer = null;
            if (leafletData)
                newLayer = setLeafletLayer(chart, leafletData);
            if (newLayer)
                addOverlayToMap(chart, overlay, newLayer)
        }
        if (layerControl)
            layerControl.addTo(map);
        var applyBounds = false;
        if (chart.mapProperties.leaflet.initPos && chart.mapProperties.leaflet.initPos.center[0] === tdgchart.defaultProperties.mapProperties.leaflet.initPos.center[0] && chart.mapProperties.leaflet.initPos.center[1] === tdgchart.defaultProperties.mapProperties.leaflet.initPos.center[1] && chart.mapProperties.leaflet.initPos.level === tdgchart.defaultProperties.mapProperties.leaflet.initPos.level)
            applyBounds = true;
        if (!applyBounds)
            map.setView(chart.mapProperties.leaflet.initPos.center, chart.mapProperties.leaflet.initPos.level);
        else if (bounds) {
            var southWest = new L.LatLng(bounds.min.y,bounds.min.x)
              , northEast = new L.LatLng(bounds.max.y,bounds.max.x)
              , _LatLngBounds = new L.LatLngBounds(southWest,northEast);
            map.fitBounds(_LatLngBounds)
        } else
            map.setView([0, 0], 0);
        map.on("zoomend", tdg.bind(changeMapZoom, chart));
        map.on("zoomlevelschange", tdg.bind(changeMapZoom, chart));
        map.on("movestart", tdg.bind(changeMapMoveStart, chart));
        changeMapZoom.call(chart);
        chart._internalMapCache.tooltipState = {
            visibleDelayTimer: undefined,
            hideDelayTimer: undefined,
            triggerMousePos: undefined,
            last_x: Infinity,
            last_y: Infinity,
            root: tdgchart.d3.select("#" + chart.documentRoot)
        };
        map.on("touchstart", tdg.partial(handleToolTip, [chart, chartPanel, null]));
        map.on("mousemove", tdg.partial(handleToolTip, [chart, chartPanel, null]))
    }
    function handleToolTip(chart, chartPanel, e) {
        function showToolTipTimerCallback(mp) {
            return function() {
                if (!toolTipDiv.innerHTML)
                    return;
                var tooltipPos = chart.tooltipPosition(toolTipDiv, mp);
                toolTipDiv.style.left = tooltipPos.x;
                toolTipDiv.style.top = tooltipPos.y;
                if (chart.htmlToolTip.enabled)
                    toolTipDiv.style.visibility = "visible";
                toolTipDiv.isBelow = tooltipPos.isBelow;
                chart._internalMapCache.tooltipState.triggerMousePos = mp;
                chart._internalMapCache.tooltipState.hideDelayTimer = window.setTimeout(tdg.bind(chart.hideToolTip, chart), 2E3)
            }
        }
        function mouseNearTooltip(e) {
            var triggerMousePos = chart._internalMapCache.tooltipState.triggerMousePos;
            if (triggerMousePos && toolTipDiv && toolTipDiv.style.visibility === "visible") {
                var mousePos = chart.mousePosition(chart._internalMapCache.tooltipState.root, e);
                var ttr = triggerMousePos.x + toolTipDiv.clientWidth;
                if (toolTipDiv.isBelow) {
                    var ttb = triggerMousePos.y + toolTipDiv.clientHeight;
                    if (mousePos.x > triggerMousePos.x - 8 && mousePos.x < ttr + 8 && mousePos.y > triggerMousePos.y - 9 && mousePos.y < ttb + 9)
                        return true
                } else {
                    var ttt = triggerMousePos.y - toolTipDiv.clientHeight;
                    if (mousePos.x > triggerMousePos.x - 8 && mousePos.x < ttr + 8 && mousePos.y > ttt - 9 && mousePos.y < triggerMousePos.y + 9)
                        return true
                }
            }
            return false
        }
        function hideStickyToolTip() {
            if (chart._internalMapCache.tooltipState.visibleDelayTimer) {
                window.clearTimeout(chart._internalMapCache.tooltipState.visibleDelayTimer);
                chart._internalMapCache.tooltipState.visibleDelayTimer = null
            }
            if (toolTipDiv) {
                if (toolTipDiv.newTarget) {
                    chart.setToolTipContent(toolTipDiv, toolTipDiv.newTarget.getAttribute("tdgtitle"), toolTipDiv.newTarget);
                    toolTipDiv.newTarget = undefined
                }
                toolTipDiv.style.visibility = "hidden"
            }
        }
        if (chart._disableToolTips)
            return;
        e = e.originalEvent;
        var target = e.target;
        if (!chart.htmlToolTip.sticky || chart.htmlToolTip.snap)
            if (target && target.nodeName === "svg") {
                chart.hideToolTip();
                return
            }
        if (!target.hasAttribute("tdgtitle"))
            return;
        if (e != null && e.type != null && (e.type === "touchstart" || e.type === "touchmove")) {
            e = e.touches[0];
            e.type = "touch";
            chart.htmlToolTip.sticky = false;
            chart.htmlToolTip.snap = true
        }
        var toolTipDiv = chart._internalMapCache.toolTipDiv;
        var tooltipState = chart._internalMapCache.tooltipState;
        if (!toolTipDiv || e.clientX === tooltipState.last_x && e.clientY === tooltipState.last_y)
            return;
        tooltipState.last_x = e.clientX;
        tooltipState.last_y = e.clientY;
        var mousePos = chart.mousePosition(tooltipState.root, e);
        var map = chart._internalMapCache.map;
        var tooltipContent = target.getAttribute("tdgtitle") || target.parentNode.getAttribute("tdgtitle");
        if (tooltipContent == null)
            tooltipContent = "";
        if (chart.htmlToolTip.sticky && !chart.htmlToolTip.snap) {
            if (tooltipState.visibleDelayTimer) {
                window.clearTimeout(tooltipState.visibleDelayTimer);
                tooltipState.visibleDelayTimer = null
            }
            if (tooltipState.hideDelayTimer) {
                window.clearTimeout(tooltipState.hideDelayTimer);
                tooltipState.hideDelayTimer = null
            }
            if (toolTipDiv.style.visibility === "visible" && tooltipState.triggerMousePos) {
                if (!mouseNearTooltip(e))
                    hideStickyToolTip()
            } else
                tooltipState.visibleDelayTimer = window.setTimeout(showToolTipTimerCallback(mousePos), 270);
            if (mouseNearTooltip(e))
                toolTipDiv.newTarget = target;
            else
                chart.setToolTipContent(toolTipDiv, tooltipContent, target);
            return
        }
        chart.setToolTipContent(toolTipDiv, tooltipContent, target);
        if (chart.htmlToolTip.snap) {
            var offSet = map.layerPointToContainerPoint([0, 0]);
            offSet.x += chartPanel.computedSize.x;
            offSet.y += chartPanel.computedSize.y;
            chart.snapToolTip(chart.chartType, target, toolTipDiv, offSet)
        } else {
            var tooltipPos = chart.tooltipPosition(toolTipDiv, mousePos);
            toolTipDiv.style.left = tooltipPos.x;
            toolTipDiv.style.top = tooltipPos.y
        }
        if (chart.htmlToolTip.enabled)
            toolTipDiv.style.visibility = "visible"
    }
    function loadOverlayURL(chart, overlay) {
        var url = overlay.url, fileContent;
        if (typeof url === "function")
            url = overlay.url({
                overlay: overlay,
                chart: chart
            });
        if (typeof url === "string")
            if (overlay.type === "geojson")
                fileContent = tdg.ajax(url, {
                    asJSON: true
                });
            else if (overlay.type === "csv")
                fileContent = tdg.ajax(url);
            else {
                if (overlay.type === "tdg")
                    if (tdgchart._internalMaps && tdgchart._internalMaps[overlay.url])
                        fileContent = tdgchart._internalMaps[overlay.url];
                    else
                        fileContent = tdg.ajax(url, {
                            asJSON: true
                        })
            }
        else if (typeof url === "object")
            fileContent = url;
        return fileContent
    }
    function cacheLeafletBubbleMarkerSize() {
        var chart = this;
        var data = chart._internalData;
        var overlays = chart.mapProperties.leaflet.overlayLayers;
        var markerType = overlays && overlays[0] && overlays[0].markerType ? overlays[0].markerType : chart.mapProperties.markerType;
        if (markerType === "bubble") {
            if (overlays && overlays[0] && overlays[0].seriesID != null)
                data = [chart._internalData[overlays[0].seriesID]] || [[]];
            var tmp = chart._internalData;
            chart._internalData = data;
            chart.dataDrivenMarkerSize("value");
            chart._internalData = tmp
        }
    }
    function buildDatum(chart, datum, odata, value, color, border, seriesID, groupID, groupID_int, lat, lng, bubbleSize, markerType) {
        var newDatum = {
            value: value,
            color: color,
            seriesID: seriesID,
            groupID: groupID,
            border: {
                color: border.color,
                width: border.width,
                dash: border.dash
            },
            lat: lat,
            lng: lng
        };
        if (odata && typeof odata === "object")
            datum.data = tdg.mergeObjects(odata, newDatum);
        else if (datum && datum.properties && datum.properties.item)
            datum.data = tdg.mergeObjects(datum.properties.item, newDatum);
        else
            datum.data = newDatum;
        var fakeMark = {
            index: groupID_int,
            parent: {
                index: seriesID
            },
            value: newDatum.value,
            color: markerType === "choropleth" ? newDatum.value : newDatum.color,
            data: function() {
                return this
            }
        };
        if (markerType === "bubble") {
            var mark_border = chart.getSeriesAndGroupProperty(seriesID, null, "marker.border");
            datum.data.border.color = chart.markerStrokeStyle().call(fakeMark, datum.data) || "black";
            datum.data.border.width = !mark_border || mark_border.width == null ? datum.data.border.width : mark_border.width;
            datum.data.border.dash = !mark_border || !mark_border.dash ? datum.data.border.dash : mark_border.dash;
            datum.data.radius = bubbleSize
        }
        datum.data.fillColor = chart.markerFillStyle().call(fakeMark, datum.data);
        return datum
    }
    function getLeafletData(chart, overlay, overlayURLContent) {
        var seriesID = overlay.seriesID;
        var i, j, data, directData = [], dataNames = [], minMax = {
            min: -1,
            max: 1
        };
        if (seriesID == null)
            data = chart._internalData;
        else {
            data = chart._internalData[seriesID] || [[]];
            data = [data]
        }
        var leafletData = overlayURLContent;
        if (overlay.type === "csv")
            leafletData = L.geoCsv(leafletData, overlay.layerInfo).toGeoJSON();
        else if (overlay.type === "tdg")
            leafletData = L.geoTdg(leafletData, overlay.layerInfo).toGeoJSON();
        else if (overlay.type === "latlng")
            leafletData = latLngDataToGeoJSON(data, seriesID);
        if (!leafletData)
            return null;
        if (overlay.type === "tdg" && overlay.dataLookup == null && overlayURLContent && overlayURLContent.layers)
            overlayURLContent.layers.forEach(function(el) {
                if (el.type === overlayURLContent.primary_layer && el.primary_name_field)
                    overlay.dataLookup = "properties." + el.primary_name_field
            });
        if (typeof overlay.dataLookup === "string") {
            if (overlay.dataLookup.trim().length !== 0)
                leafletData.dataLookup = function(f) {
                    if (overlay.dataLookup.indexOf(".") >= 0)
                        return overlay.dataLookup.split(".").reduce(function(b, p) {
                            return b[p]
                        }, f);
                    return f[overlay.dataLookup]
                }
        } else
            leafletData.dataLookup = overlay.dataLookup;
        if (!leafletData.dataLookup && overlay.type !== "latlng")
            return null;
        var markerType = overlay.markerType || chart.mapProperties.markerType;
        addCentroids(leafletData);
        if (markerType === "bubble" && (overlay.type === "geojson" || overlay.type === "tdg"))
            convertPolygonLayerToMarker(leafletData);
        var stateKeys, stateKeyNames = {};
        if (leafletData.dataLookup)
            stateKeys = leafletData.features.map(function(el) {
                return chart.mapNormalizeName(leafletData.dataLookup(el))
            });
        var missing = [];
        if (stateKeys && data[0][0].name != null) {
            for (i = 0; i < stateKeys.length; ++i)
                stateKeyNames[stateKeys[i]] = i + 1;
            for (i = 0; i < data.length; i++)
                for (j = 0; j < data[i].length; j++) {
                    var d = data[i][j];
                    var key = stateKeyNames[chart.mapNormalizeName(d.name)];
                    key = key && key >= 0 ? key - 1 : -1;
                    if (key >= 0) {
                        d.seriesID = seriesID == null ? i : seriesID;
                        d.groupID = j;
                        dataNames[key] = d.name;
                        directData[key] = directData[key] || [];
                        directData[key].push(d)
                    } else if (d.name)
                        missing.push(d.name)
                }
        } else if (data[0][0].lat != null || data[0][0].lng != null)
            directData = data[0].map(function(el) {
                return [el]
            });
        minMax = chart.getScaleMinMax(chart.yaxis, data);
        var bubbleSize, border, color;
        if (markerType === "choropleth") {
            border = chart.getSeriesAndGroupProperty(seriesID, null, "border") || {
                width: 1
            };
            color = tdg.color(chart.getSeriesAndGroupProperty(seriesID, null, "color"))
        } else {
            var tmp = chart._internalData;
            chart._internalData = data;
            bubbleSize = chart.dataDrivenMarkerSize("value");
            chart._internalData = tmp;
            border = chart.getSeriesAndGroupProperty(seriesID, null, "marker.border") || {
                width: 1
            }
        }
        var bounds = addBounds(leafletData);
        var withColors = [];
        for (i = 0; i < leafletData.features.length; i++) {
            var n = leafletData.features[i];
            if (n.properties && n.properties.seriesID != null)
                seriesID = n.properties.seriesID;
            var datum, value, lat, lng, odata, groupID, groupID_int = i;
            if (leafletData.dataLookup) {
                groupID = leafletData.dataLookup(n);
                var k = stateKeyNames[chart.mapNormalizeName(groupID)];
                k = k && k >= 0 ? k - 1 : -1;
                if (directData[k] != null)
                    for (j = 0; j < directData[k].length; j++) {
                        odata = directData[k][j];
                        value = odata.value;
                        if (odata.seriesID != null)
                            seriesID = odata.seriesID;
                        if (odata.groupID != null)
                            groupID_int = odata.groupID;
                        if (dataNames[k])
                            groupID = dataNames[k];
                        n = tdg.cloneObject(n);
                        datum = buildDatum(chart, n, odata, value, color, border, seriesID, groupID, groupID_int, lat, lng, bubbleSize, markerType);
                        withColors.push(datum)
                    }
            } else if (n.properties.value != null) {
                groupID = n.properties.groupID == null ? i : n.properties.groupID;
                value = odata = n.properties.value;
                color = n.properties.color || undefined;
                if (n.properties.item) {
                    lat = n.properties.item.lat;
                    lng = n.properties.item.lng
                }
                if (odata == null)
                    continue;
                datum = buildDatum(chart, n, odata, value, color, border, seriesID, groupID, groupID_int, lat, lng, bubbleSize, markerType);
                withColors.push(datum)
            }
        }
        leafletData.features = withColors;
        var prevData = chart.cache.get_or_set("leaflet_full_dataset", []);
        chart.cache.set("leaflet_full_dataset", prevData.concat(withColors));
        if (missing.length > 0) {
            var div = document.getElementById(chart.documentRoot);
            div = div.getElementsByClassName("leaflet-bottom leaflet-left")[0];
            if (div) {
                var newDiv = document.createElement("div");
                newDiv.setAttribute("class", "leaflet-bar leaflet-control leaflet-control-unmatched-data");
                newDiv.appendChild(document.createTextNode(missing.length + " " + chart.mapProperties.leaflet.unmatchedLabel));
                newDiv.setAttribute("title", missing.join("\n"));
                div.appendChild(newDiv)
            }
        }
        if (leafletData.features.length > 0)
            bounds = addBounds(leafletData);
        return {
            leafletData: leafletData,
            bounds: bounds,
            missing: missing
        }
    }
    function changeMapMoveStart() {
        var chart = this;
        if (!chart._internalMapCache.map || chart._internalMapCache.map._zoom == null)
            return;
        var toolTipDiv = chart._internalMapCache.toolTipDiv;
        if (toolTipDiv)
            toolTipDiv.style.visibility = "hidden";
        var current_root = document.getElementById(chart.documentRoot);
        var hov = current_root.getElementsByClassName("hoverFill")[0];
        if (hov)
            hov.setAttribute("display", "none")
    }
    function changeMapZoom() {
        var chart = this;
        if (!chart._internalMapCache.map || chart._internalMapCache.map._zoom == null)
            return;
        var map = chart._internalMapCache.map;
        var layerControl = chart._internalMapCache.layerControl;
        var zoomLayerInfo = chart._internalMapCache.zoomLayerInfo;
        var toolTipDiv = chart._internalMapCache.toolTipDiv;
        if (toolTipDiv)
            toolTipDiv.style.visibility = "hidden";
        zoomLayerInfo.forEach(function(o) {
            if (layerControl)
                layerControl.removeLayer(o.layer);
            map.removeLayer(o.layer)
        });
        zoomLayerInfo.forEach(function(o) {
            var hide = false;
            if (o.minZoom >= 0 && o.minZoom > map._zoom)
                hide = true;
            if (o.maxZoom >= 0 && map._zoom > o.maxZoom)
                hide = true;
            if (!hide) {
                if (layerControl)
                    layerControl.addOverlay(o.layer, o.title);
                map.addLayer(o.layer)
            }
        });
        var current_root = document.getElementById(chart.documentRoot);
        var hov = current_root.getElementsByClassName("hoverFill")[0];
        if (hov) {
            hov.setAttribute("display", "none");
            if (hov._relatedHoverTarget) {
                var e = document.createEvent("MouseEvents");
                e.initMouseEvent("mouseover", false, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
                hov._relatedHoverTarget.dispatchEvent(e)
            }
            hov.parentNode.appendChild(hov)
        }
    }
    function addOverlayToMap(chart, overlayProperties, newOverlay) {
        if (!newOverlay)
            return;
        var op = overlayProperties;
        if (op.group) {
            var group = chart._internalMapCache.groupLayers[op.group];
            if (!group) {
                group = new L.LayerGroup([]);
                chart._internalMapCache.groupLayers[op.group] = group;
                group.addLayer(newOverlay);
                newOverlay = group
            } else {
                group.addLayer(newOverlay);
                newOverlay = null
            }
        }
        if (newOverlay) {
            chart._internalMapCache.map.addLayer(newOverlay);
            if (chart._internalMapCache.layerControl)
                chart._internalMapCache.layerControl.addOverlay(newOverlay, op.title);
            var minZoom = op.layerInfo && op.layerInfo.minZoom ? op.layerInfo.minZoom : -1;
            var maxZoom = op.layerInfo && op.layerInfo.maxZoom ? op.layerInfo.maxZoom : -1;
            chart._internalMapCache.zoomLayerInfo.push({
                layer: newOverlay,
                minZoom: minZoom,
                maxZoom: maxZoom,
                title: op.title
            })
        }
    }
    function setLeafletLayer(chart, leafletData) {
        return L.geoJson(leafletData, {
            style: function(feature) {
                var c, d = feature.data;
                var style = {
                    radius: 10,
                    stroke: false,
                    color: "red",
                    opacity: 0,
                    weight: 0,
                    dashArray: null,
                    fill: true,
                    fillColor: "red",
                    fillOpacity: .7
                };
                if (d && d.radius)
                    style.radius = d.radius([d.value]) * chart.get("transform.scale", 1);
                var fill = true;
                var stroke = true;
                var layerOpacity = chart.mapProperties.mapOpacity;
                layerOpacity = typeof layerOpacity === "number" ? layerOpacity : .82;
                if (feature.geometry.type === "LineString" || feature.geometry.type === "MultiLineString")
                    fill = false;
                if (feature.geometry.type === "Polygon" || feature.geometry.type === "MultiPolygon")
                    stroke = d && d.border.color ? true : false;
                if (d && d.border) {
                    c = tdg.color(d.border.color);
                    style.stroke = stroke;
                    if (feature.geometry.type === "LineString" || feature.geometry.type === "MultiLineString")
                        style.color = d.fillColor || style.color;
                    else
                        style.color = d.border.color || style.color;
                    style.opacity = layerOpacity;
                    style.weight = d.border.width || style.weight;
                    style.dashArray = d.border.dash || style.dashArray
                }
                if (d && d.fillColor) {
                    c = tdg.color(d.fillColor);
                    if (c.type && c.type !== "solid") {
                        var defNode = document.getElementById(chart.documentRoot).getElementsByTagName("defs")[0];
                        pv.SvgScene.addFillStyleDefinitionDirect(chart.documentRoot, defNode, c)
                    }
                    style.fill = fill;
                    style.fillColor = c.color;
                    style.fillOpacity = layerOpacity
                }
                style.lineCap = "butt";
                style.lineJoin = "bevel";
                return style
            },
            pointToLayer: function(feature, latlng) {
                return latlng == null ? null : L.circleMarker(latlng, {})
            },
            onEachFeature: function(feature, layer) {
                if (!feature.data)
                    return;
                var tooltipLookup = chart.seriesToolTipLookup();
                var labelTextLookup = chart.dataTextMarkLookup();
                function add(feature, e) {
                    var path = e.target._path;
                    var className = chart.buildClassName("riser", feature.data.seriesID, feature.data.groupID, "state");
                    var c = path.getAttribute("class");
                    if (c.indexOf("clickable") >= 0)
                        e.target._path.style.cursor = "pointer";
                    path.setAttribute("class", className);
                    var fakeMark = {
                        className: function() {
                            return className
                        },
                        index: 0,
                        parent: {
                            index: feature.data.seriesID
                        },
                        data: function() {
                            return feature.data
                        }
                    };
                    var tooltip = tooltipLookup.call(fakeMark, feature.data, feature);
                    if (tooltip) {
                        path.setAttribute("tdgtitle", "placeholder");
                        path.tdgtitle_dom = tooltip
                    }
                    if (chart.areDataLabelsVisible()) {
                        var lbl = document.createElementNS(tdg.ns.svg, "text");
                        setDataLabelText(chart, lbl, feature.data, labelTextLookup, fakeMark);
                        feature._dataLabel = lbl;
                        path.parentNode.appendChild(lbl);
                        setDataLabelPosition(chart, this, lbl)
                    }
                }
                function remove(feature) {
                    if (feature._dataLabel)
                        feature._dataLabel.parentNode.removeChild(feature._dataLabel)
                }
                var addFeature = tdg.partial(add, [feature, null]);
                var removeFeature = tdg.partial(remove, [feature, null]);
                if (feature.geometry.type === "MultiPolygon")
                    for (var l in layer._layers) {
                        if (layer._layers.hasOwnProperty(l))
                            layer._layers[l].on({
                                add: addFeature
                            })
                    }
                else
                    layer.on({
                        add: addFeature,
                        remove: removeFeature
                    });
                if (chart.htmlToolTip.enabled && (!chart.htmlToolTip.sticky || chart.htmlToolTip.snap))
                    layer.on({
                        mouseout: function(e) {
                            var c, toolTipDiv = chart._internalMapCache.toolTipDiv;
                            e = e.originalEvent;
                            if (e && e.relatedTarget) {
                                c = e.relatedTarget.getAttribute("class");
                                if (!toolTipDiv.contains(e.relatedTarget) && (!c || c.indexOf("tooltipCallout") < 0))
                                    toolTipDiv.style.visibility = "hidden"
                            } else
                                toolTipDiv.style.visibility = "hidden"
                        }
                    })
            }
        })
    }
    function setDataLabelPosition(chart, mark, label) {
        var centroid = {
            lng: mark.feature.geometry.centroid[0],
            lat: mark.feature.geometry.centroid[1]
        };
        var initPos = mark._map.latLngToLayerPoint(centroid);
        var x = initPos.x
          , y = initPos.y;
        var data = mark.feature.data;
        var r = data.radius ? data.radius([data.value]) * chart.get("transform.scale", 1) : 0;
        var position = chart.getSeriesAndGroupProperty(data.seriesID, null, "dataLabels.position");
        if (r === 0)
            position = "center";
        switch (position) {
        case "top":
            x = x - label.clientWidth / 2;
            y = y - r - 4;
            break;
        case "bottom":
            x = x - label.clientWidth / 2;
            y = y + label.clientHeight + r;
            break;
        case "right":
            label.setAttribute("dy", "-0.3em");
            x = x + r + 4;
            y = y + label.clientHeight / 2;
            break;
        case "left":
            label.setAttribute("dy", "-0.3em");
            x = x - r - label.clientWidth - 4;
            y = y + label.clientHeight / 2;
            break;
        case "center":
            label.setAttribute("dy", "-0.3em");
            x = x - label.clientWidth / 2;
            y = y + label.clientHeight / 2;
            break
        }
        label.setAttribute("transform", "translate(" + x + "," + y + ")")
    }
    function setDataLabelText(chart, label, data, labelTextLookup, fakeMark) {
        var dataCopy = {};
        for (var k in data)
            if (data.hasOwnProperty(k) && data[k] != null)
                dataCopy[k] = data[k];
        var text = labelTextLookup.call(fakeMark, dataCopy);
        label.appendChild(document.createTextNode(text));
        label.style.font = chart.getSeriesAndGroupProperty(data.seriesID, null, "dataLabels.font");
        label.style.fill = chart.getSeriesAndGroupProperty(data.seriesID, null, "dataLabels.color");
        var className = chart.buildClassName("dataLabels", data.seriesID, data.groupID, "dataLabels");
        label.setAttribute("class", className)
    }
    function findArea2(pts) {
        var area = 0;
        var nPts = pts.length;
        var j = nPts - 1;
        var p1;
        var p2;
        for (var i = 0; i < nPts; j = i++) {
            p1 = pts[i];
            p2 = pts[j];
            area += p1[0] * p2[1];
            area -= p1[1] * p2[0]
        }
        area /= 2;
        return area
    }
    function centroid2(pts) {
        var nPts = pts.length;
        var lng = 0;
        var lat = 0;
        var f;
        var j = nPts - 1;
        var p1;
        var p2;
        if (nPts === 1)
            return pts[0];
        if (nPts === 2)
            return [(pts[0][0] + pts[1][0]) / 2, (pts[0][1] + pts[1][1]) / 2];
        for (var i = 0; i < nPts; j = i++) {
            p1 = pts[i];
            p2 = pts[j];
            f = p1[0] * p2[1] - p2[0] * p1[1];
            lng += (p1[0] + p2[0]) * f;
            lat += (p1[1] + p2[1]) * f
        }
        f = findArea2(pts) * 6;
        lng = lng / f;
        lat = lat / f;
        if (isNaN(lng) || isNaN(lat))
            return pts[0];
        return [lng, lat]
    }
    function addCentroids(leafletData) {
        leafletData.features.forEach(function(feature) {
            if (feature.geometry.centroid)
                return;
            var data, area, tempArea, i, j, k, a, b, c;
            if (feature.geometry.type === "Polygon") {
                data = feature.geometry.coordinates;
                area = -1;
                for (j = 0; j < data.length; ++j) {
                    tempArea = Math.abs(findArea2(data[j]));
                    if (area < tempArea) {
                        area = tempArea;
                        feature.geometry.centroid = centroid2(data[j])
                    }
                }
            } else if (feature.geometry.type === "MultiPolygon") {
                data = feature.geometry.coordinates;
                area = -1;
                for (i = 0; i < data.length; ++i)
                    for (j = 0; j < data[i].length; ++j) {
                        tempArea = Math.abs(findArea2(data[i][j]));
                        if (area < tempArea) {
                            area = tempArea;
                            feature.geometry.centroid = centroid2(data[i][j])
                        }
                    }
            } else if (feature.geometry.type === "Point")
                feature.geometry.centroid = feature.geometry.coordinates;
            else if (feature.geometry.type === "LineString" || feature.geometry.type === "MultiLineString") {
                a = [feature.geometry.coordinates];
                if (feature.geometry.type === "LineString")
                    a = [a];
                var count = 0;
                var x = 0;
                var y = 0;
                for (i = 0; i < a.length; ++i) {
                    b = a[i];
                    for (j = 0; j < b.length; ++j) {
                        c = b[j];
                        for (k = 0; k < c.length; ++k) {
                            x = x + c[k][0];
                            y = y + c[k][1];
                            ++count
                        }
                    }
                }
                x = x / count;
                y = y / count;
                feature.geometry.centroid = null;
                var dist = Number.MAX_VALUE;
                for (i = 0; i < a.length; ++i) {
                    b = a[i];
                    for (j = 0; j < b.length; ++j) {
                        c = b[j];
                        for (k = 0; k < c.length; ++k) {
                            var xx = x - c[k][0];
                            var yy = y - c[k][1];
                            var ll = xx * xx + yy * yy;
                            if (ll < dist) {
                                dist = ll;
                                feature.geometry.centroid = c[k]
                            }
                        }
                    }
                }
            } else
                throw Error("feature.geometry.type = " + feature.geometry.type);
        })
    }
    function addBounds(leafletData) {
        var rtn = null;
        leafletData.features.forEach(function(feature) {
            var a = null;
            if (feature.geometry.type === "Polygon")
                a = [feature.geometry.coordinates];
            else if (feature.geometry.type === "MultiPolygon")
                a = feature.geometry.coordinates;
            else if (feature.geometry.type === "Point")
                a = [[[feature.geometry.coordinates]]];
            else if (feature.geometry.type === "LineString")
                a = [[feature.geometry.coordinates]];
            else if (feature.geometry.type === "MultiLineString")
                a = [feature.geometry.coordinates];
            else
                throw Error("feature.geometry.type = " + feature.geometry.type);
            if (!a) {
                feature.geometry.extent = null;
                return false
            }
            var bounds = null;
            for (var i = 0; i < a.length; ++i) {
                var b = a[i];
                for (var j = 0; j < b.length; ++j) {
                    var c = b[j];
                    for (var k = 0; k < c.length; ++k)
                        if (!bounds) {
                            var p1 = new L.Point(c[k][0],c[k][1]);
                            bounds = new L.Bounds(p1,p1)
                        } else if (!bounds.contains(c[k]))
                            bounds.extend(c[k])
                }
            }
            if (!rtn)
                rtn = new L.Bounds(bounds.min,bounds.max);
            else
                rtn.extend(bounds.min).extend(bounds.max);
            feature.geometry.extent = bounds
        });
        return rtn
    }
    function convertPolygonLayerToMarker(leafletData) {
        for (var i = 0; i < leafletData.features.length; i++) {
            var g = leafletData.features[i].geometry;
            if (g.type !== "Point" && g.centroid) {
                g.coordinates = g.centroid;
                g.type = "Point"
            }
        }
    }
    function latLngDataToGeoJSON(data, seriesID) {
        var json = {
            type: "FeatureCollection",
            features: []
        };
        for (var i = 0; i < data.length; i++)
            for (var j = 0; j < data[i].length; j++) {
                var d = data[i][j];
                if (d && d.lng != null && d.lat != null)
                    json.features.push({
                        type: "Feature",
                        properties: {
                            seriesID: seriesID == null ? i : seriesID,
                            groupID: j,
                            value: d.value,
                            color: d.color,
                            item: d
                        },
                        geometry: {
                            type: "Point",
                            coordinates: [d.lng, d.lat]
                        }
                    })
            }
        return json.features.length ? json : undefined
    }
}
)();
if (typeof window !== "undefined")
    (function(t, e) {
        L.drawVersion = "0.2.1-dev",
        L.drawLocal = {
            draw: {
                toolbar: {
                    actions: {
                        title: "Cancel drawing",
                        text: "Cancel"
                    },
                    buttons: {
                        polyline: "Draw a polyline",
                        polygon: "Draw a polygon",
                        rectangle: "Draw a rectangle",
                        circle: "Draw a circle",
                        marker: "Draw a marker"
                    }
                },
                handlers: {
                    circle: {
                        tooltip: {
                            start: "Click and drag to draw circle."
                        }
                    },
                    marker: {
                        tooltip: {
                            start: "Click map to place marker."
                        }
                    },
                    polygon: {
                        tooltip: {
                            start: "Click to start drawing shape.",
                            cont: "Click to continue drawing shape.",
                            end: "Click first point to close this shape."
                        }
                    },
                    polyline: {
                        error: "<strong>Error:</strong> shape edges cannot cross!",
                        tooltip: {
                            start: "Click to start drawing line.",
                            cont: "Click to continue drawing line.",
                            end: "Click last point to finish line."
                        }
                    },
                    rectangle: {
                        tooltip: {
                            start: "Click and drag to draw rectangle."
                        }
                    },
                    simpleshape: {
                        tooltip: {
                            end: "Release mouse to finish drawing."
                        }
                    }
                }
            },
            edit: {
                toolbar: {
                    actions: {
                        save: {
                            title: "Save changes.",
                            text: "Save"
                        },
                        cancel: {
                            title: "Cancel editing, discards all changes.",
                            text: "Cancel"
                        }
                    },
                    buttons: {
                        edit: "Edit layers",
                        remove: "Delete layers"
                    }
                },
                handlers: {
                    edit: {
                        tooltip: {
                            text: "Drag handles, or marker to edit feature.",
                            subtext: "Click cancel to undo changes."
                        }
                    },
                    remove: {
                        tooltip: {
                            text: "Click on a feature to remove"
                        }
                    }
                }
            }
        },
        L.Draw = {},
        L.Draw.Feature = L.Handler.extend({
            includes: L.Mixin.Events,
            initialize: function(t, e) {
                this._map = t,
                this._container = t._container,
                this._overlayPane = t._panes.overlayPane,
                this._popupPane = t._panes.popupPane,
                e && e.shapeOptions && (e.shapeOptions = L.Util.extend({}, this.options.shapeOptions, e.shapeOptions)),
                L.Util.extend(this.options, e)
            },
            enable: function() {
                this._enabled || (L.Handler.prototype.enable.call(this),
                this.fire("enabled", {
                    handler: this.type
                }),
                this._map.fire("draw:drawstart", {
                    layerType: this.type
                }))
            },
            disable: function() {
                this._enabled && (L.Handler.prototype.disable.call(this),
                this.fire("disabled", {
                    handler: this.type
                }),
                this._map.fire("draw:drawstop", {
                    layerType: this.type
                }))
            },
            addHooks: function() {
                this._map && (L.DomUtil.disableTextSelection(),
                this._tooltip = new L.Tooltip(this._map),
                L.DomEvent.addListener(this._container, "keyup", this._cancelDrawing, this))
            },
            removeHooks: function() {
                this._map && (L.DomUtil.enableTextSelection(),
                this._tooltip.dispose(),
                this._tooltip = null,
                L.DomEvent.removeListener(this._container, "keyup", this._cancelDrawing))
            },
            setOptions: function(t) {
                L.setOptions(this, t)
            },
            _fireCreatedEvent: function(t) {
                this._map.fire("draw:created", {
                    layer: t,
                    layerType: this.type
                })
            },
            _cancelDrawing: function(t) {
                27 === t.keyCode && this.disable()
            }
        }),
        L.Draw.Polyline = L.Draw.Feature.extend({
            statics: {
                TYPE: "polyline"
            },
            Poly: L.Polyline,
            options: {
                allowIntersection: !0,
                repeatMode: !1,
                drawError: {
                    color: "#b00b00",
                    message: L.drawLocal.draw.handlers.polyline.error,
                    timeout: 2500
                },
                icon: new L.DivIcon({
                    iconSize: new L.Point(8,8),
                    className: "leaflet-div-icon leaflet-editing-icon"
                }),
                guidelineDistance: 20,
                shapeOptions: {
                    stroke: !0,
                    color: "#f06eaa",
                    weight: 4,
                    opacity: .5,
                    fill: !1,
                    clickable: !0
                },
                metric: !0,
                zIndexOffset: 2E3
            },
            initialize: function(t, e) {
                e && e.drawError && (e.drawError = L.Util.extend({}, this.options.drawError, e.drawError)),
                this.type = L.Draw.Polyline.TYPE,
                L.Draw.Feature.prototype.initialize.call(this, t, e)
            },
            addHooks: function() {
                L.Draw.Feature.prototype.addHooks.call(this),
                this._map && (this._markers = [],
                this._markerGroup = new L.LayerGroup,
                this._map.addLayer(this._markerGroup),
                this._poly = new L.Polyline([],this.options.shapeOptions),
                this._tooltip.updateContent(this._getTooltipText()),
                this._mouseMarker || (this._mouseMarker = L.marker(this._map.getCenter(), {
                    icon: L.divIcon({
                        className: "leaflet-mouse-marker",
                        iconAnchor: [20, 20],
                        iconSize: [40, 40]
                    }),
                    opacity: 0,
                    zIndexOffset: this.options.zIndexOffset
                })),
                this._mouseMarker.on("click", this._onClick, this).addTo(this._map),
                this._map.on("mousemove", this._onMouseMove, this).on("zoomend", this._onZoomEnd, this))
            },
            removeHooks: function() {
                L.Draw.Feature.prototype.removeHooks.call(this),
                this._clearHideErrorTimeout(),
                this._cleanUpShape(),
                this._map.removeLayer(this._markerGroup),
                delete this._markerGroup,
                delete this._markers,
                this._map.removeLayer(this._poly),
                delete this._poly,
                this._mouseMarker.off("click", this._onClick, this),
                this._map.removeLayer(this._mouseMarker),
                delete this._mouseMarker,
                this._clearGuides(),
                this._map.off("mousemove", this._onMouseMove, this).off("zoomend", this._onZoomEnd, this)
            },
            _finishShape: function() {
                var t = this._poly.newLatLngIntersects(this._poly.getLatLngs()[0], !0);
                return !this.options.allowIntersection && t || !this._shapeIsValid() ? (this._showErrorTooltip(),
                undefined) : (this._fireCreatedEvent(),
                this.disable(),
                this.options.repeatMode && this.enable(),
                undefined)
            },
            _shapeIsValid: function() {
                return !0
            },
            _onZoomEnd: function() {
                this._updateGuide()
            },
            _onMouseMove: function(t) {
                var e = t.layerPoint
                  , i = t.latlng;
                this._currentLatLng = i,
                this._updateTooltip(i),
                this._updateGuide(e),
                this._mouseMarker.setLatLng(i),
                L.DomEvent.preventDefault(t.originalEvent)
            },
            _onClick: function(t) {
                var e = t.target.getLatLng()
                  , i = this._markers.length;
                return i > 0 && !this.options.allowIntersection && this._poly.newLatLngIntersects(e) ? (this._showErrorTooltip(),
                undefined) : (this._errorShown && this._hideErrorTooltip(),
                this._markers.push(this._createMarker(e)),
                this._poly.addLatLng(e),
                2 === this._poly.getLatLngs().length && this._map.addLayer(this._poly),
                this._updateFinishHandler(),
                this._vertexAdded(e),
                this._clearGuides(),
                this._updateTooltip(),
                undefined)
            },
            _updateFinishHandler: function() {
                var t = this._markers.length;
                t > 1 && this._markers[t - 1].on("click", this._finishShape, this),
                t > 2 && this._markers[t - 2].off("click", this._finishShape, this)
            },
            _createMarker: function(t) {
                var e = new L.Marker(t,{
                    icon: this.options.icon,
                    zIndexOffset: 2 * this.options.zIndexOffset
                });
                return this._markerGroup.addLayer(e),
                e
            },
            _updateGuide: function(t) {
                t = t || this._map.latLngToLayerPoint(this._currentLatLng);
                var e = this._markers.length;
                e > 0 && (this._clearGuides(),
                this._drawGuide(this._map.latLngToLayerPoint(this._markers[e - 1].getLatLng()), t))
            },
            _updateTooltip: function(t) {
                var e = this._getTooltipText();
                t && this._tooltip.updatePosition(t),
                this._errorShown || this._tooltip.updateContent(e)
            },
            _drawGuide: function(t, e) {
                var i, o, a, s, r = Math.floor(Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)));
                for (this._guidesContainer || (this._guidesContainer = L.DomUtil.create("div", "leaflet-draw-guides", this._overlayPane)),
                i = this.options.guidelineDistance; r > i; i += this.options.guidelineDistance)
                    o = i / r,
                    a = {
                        x: Math.floor(t.x * (1 - o) + o * e.x),
                        y: Math.floor(t.y * (1 - o) + o * e.y)
                    },
                    s = L.DomUtil.create("div", "leaflet-draw-guide-dash", this._guidesContainer),
                    s.style.backgroundColor = this._errorShown ? this.options.drawError.color : this.options.shapeOptions.color,
                    L.DomUtil.setPosition(s, a)
            },
            _updateGuideColor: function(t) {
                if (this._guidesContainer)
                    for (var e = 0, i = this._guidesContainer.childNodes.length; i > e; e++)
                        this._guidesContainer.childNodes[e].style.backgroundColor = t
            },
            _clearGuides: function() {
                if (this._guidesContainer)
                    for (; this._guidesContainer.firstChild; )
                        this._guidesContainer.removeChild(this._guidesContainer.firstChild)
            },
            _getTooltipText: function() {
                var t, e;
                return 0 === this._markers.length ? t = {
                    text: L.drawLocal.draw.handlers.polyline.tooltip.start
                } : (e = this._getMeasurementString(),
                t = 1 === this._markers.length ? {
                    text: L.drawLocal.draw.handlers.polyline.tooltip.cont,
                    subtext: e
                } : {
                    text: L.drawLocal.draw.handlers.polyline.tooltip.end,
                    subtext: e
                }),
                t
            },
            _getMeasurementString: function() {
                var t, e, i = this._currentLatLng, o = this._markers[this._markers.length - 1].getLatLng();
                return t = this._measurementRunningTotal + i.distanceTo(o),
                this.options.metric ? e = t > 1E3 ? (t / 1E3).toFixed(2) + " km" : Math.ceil(t) + " m" : (t *= 1.09361,
                e = t > 1760 ? (t / 1760).toFixed(2) + " miles" : Math.ceil(t) + " yd"),
                e
            },
            _showErrorTooltip: function() {
                this._errorShown = !0,
                this._tooltip.showAsError().updateContent({
                    text: this.options.drawError.message
                }),
                this._updateGuideColor(this.options.drawError.color),
                this._poly.setStyle({
                    color: this.options.drawError.color
                }),
                this._clearHideErrorTimeout(),
                this._hideErrorTimeout = setTimeout(L.Util.bind(this._hideErrorTooltip, this), this.options.drawError.timeout)
            },
            _hideErrorTooltip: function() {
                this._errorShown = !1,
                this._clearHideErrorTimeout(),
                this._tooltip.removeError().updateContent(this._getTooltipText()),
                this._updateGuideColor(this.options.shapeOptions.color),
                this._poly.setStyle({
                    color: this.options.shapeOptions.color
                })
            },
            _clearHideErrorTimeout: function() {
                this._hideErrorTimeout && (clearTimeout(this._hideErrorTimeout),
                this._hideErrorTimeout = null)
            },
            _vertexAdded: function(t) {
                1 === this._markers.length ? this._measurementRunningTotal = 0 : this._measurementRunningTotal += t.distanceTo(this._markers[this._markers.length - 2].getLatLng())
            },
            _cleanUpShape: function() {
                this._markers.length > 1 && this._markers[this._markers.length - 1].off("click", this._finishShape, this)
            },
            _fireCreatedEvent: function() {
                var t = new this.Poly(this._poly.getLatLngs(),this.options.shapeOptions);
                L.Draw.Feature.prototype._fireCreatedEvent.call(this, t)
            }
        }),
        L.Draw.Polygon = L.Draw.Polyline.extend({
            statics: {
                TYPE: "polygon"
            },
            Poly: L.Polygon,
            options: {
                showArea: !1,
                shapeOptions: {
                    stroke: !0,
                    color: "#f06eaa",
                    weight: 4,
                    opacity: .5,
                    fill: !0,
                    fillColor: null,
                    fillOpacity: .2,
                    clickable: !0
                }
            },
            initialize: function(t, e) {
                L.Draw.Polyline.prototype.initialize.call(this, t, e),
                this.type = L.Draw.Polygon.TYPE
            },
            _updateFinishHandler: function() {
                var t = this._markers.length;
                1 === t && this._markers[0].on("click", this._finishShape, this),
                t > 2 && (this._markers[t - 1].on("dblclick", this._finishShape, this),
                t > 3 && this._markers[t - 2].off("dblclick", this._finishShape, this))
            },
            _getTooltipText: function() {
                var t, e;
                return 0 === this._markers.length ? t = L.drawLocal.draw.handlers.polygon.tooltip.start : 3 > this._markers.length ? t = L.drawLocal.draw.handlers.polygon.tooltip.cont : (t = L.drawLocal.draw.handlers.polygon.tooltip.end,
                e = this._getMeasurementString()),
                {
                    text: t,
                    subtext: e
                }
            },
            _getMeasurementString: function() {
                var t, e = this._area;
                return e ? (this.options.metric ? t = e >= 1E4 ? (1E-4 * e).toFixed(2) + " ha" : e.toFixed(2) + " m&sup2;" : (e *= .836127,
                t = e >= 3097600 ? (e / 3097600).toFixed(2) + " mi&sup2;" : e >= 4840 ? (e / 4840).toFixed(2) + " acres" : Math.ceil(e) + " yd&sup2;"),
                t) : null
            },
            _shapeIsValid: function() {
                return this._markers.length >= 3
            },
            _vertexAdded: function() {
                if (!this.options.allowIntersection && this.options.showArea) {
                    var t = this._poly.getLatLngs();
                    this._area = L.PolygonUtil.geodesicArea(t)
                }
            },
            _cleanUpShape: function() {
                var t = this._markers.length;
                t > 0 && (this._markers[0].off("click", this._finishShape, this),
                t > 2 && this._markers[t - 1].off("dblclick", this._finishShape, this))
            }
        }),
        L.SimpleShape = {},
        L.Draw.SimpleShape = L.Draw.Feature.extend({
            options: {
                repeatMode: !0
            },
            initialize: function(t, e) {
                L.Draw.Feature.prototype.initialize.call(this, t, e)
            },
            addHooks: function() {
                L.Draw.Feature.prototype.addHooks.call(this),
                this._map && (this._map.dragging.disable(),
                this._container.style.cursor = "crosshair",
                this._tooltip.updateContent({
                    text: this._initialLabelText
                }),
                this._map.on("mousedown", this._onMouseDown, this).on("mousemove", this._onMouseMove, this))
            },
            removeHooks: function() {
                L.Draw.Feature.prototype.removeHooks.call(this),
                this._map && (this._map.dragging.enable(),
                this._container.style.cursor = "",
                this._map.off("mousedown", this._onMouseDown, this).off("mousemove", this._onMouseMove, this),
                L.DomEvent.off(e, "mouseup", this._onMouseUp),
                this._shape && (this._map.removeLayer(this._shape),
                delete this._shape)),
                this._isDrawing = !1
            },
            _onMouseDown: function(t) {
                this._isDrawing = !0,
                this._startLatLng = t.latlng,
                L.DomEvent.on(e, "mouseup", this._onMouseUp, this).preventDefault(t.originalEvent)
            },
            _onMouseMove: function(t) {
                var e = t.latlng;
                this._tooltip.updatePosition(e),
                this._isDrawing && (this._tooltip.updateContent({
                    text: L.drawLocal.draw.handlers.simpleshape.tooltip.end
                }),
                this._drawShape(e))
            },
            _onMouseUp: function() {
                this._shape && this._fireCreatedEvent(),
                this.disable(),
                this.options.repeatMode && this.enable()
            }
        }),
        L.Draw.Rectangle = L.Draw.SimpleShape.extend({
            statics: {
                TYPE: "rectangle"
            },
            options: {
                shapeOptions: {
                    stroke: !0,
                    color: "#f06eaa",
                    weight: 4,
                    opacity: .5,
                    fill: !0,
                    fillColor: null,
                    fillOpacity: .2,
                    clickable: !0
                }
            },
            initialize: function(t, e) {
                this.type = L.Draw.Rectangle.TYPE,
                L.Draw.SimpleShape.prototype.initialize.call(this, t, e)
            },
            _initialLabelText: L.drawLocal.draw.handlers.rectangle.tooltip.start,
            _drawShape: function(t) {
                this._shape ? this._shape.setBounds(new L.LatLngBounds(this._startLatLng,t)) : (this._shape = new L.Rectangle(new L.LatLngBounds(this._startLatLng,t),this.options.shapeOptions),
                this._map.addLayer(this._shape))
            },
            _fireCreatedEvent: function() {
                var t = new L.Rectangle(this._shape.getBounds(),this.options.shapeOptions);
                L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, t)
            }
        }),
        L.Draw.Circle = L.Draw.SimpleShape.extend({
            statics: {
                TYPE: "circle"
            },
            options: {
                shapeOptions: {
                    stroke: !0,
                    color: "#f06eaa",
                    weight: 4,
                    opacity: .5,
                    fill: !0,
                    fillColor: null,
                    fillOpacity: .2,
                    clickable: !0
                }
            },
            initialize: function(t, e) {
                this.type = L.Draw.Circle.TYPE,
                L.Draw.SimpleShape.prototype.initialize.call(this, t, e)
            },
            _initialLabelText: L.drawLocal.draw.handlers.circle.tooltip.start,
            _drawShape: function(t) {
                this._shape ? this._shape.setRadius(this._startLatLng.distanceTo(t)) : (this._shape = new L.Circle(this._startLatLng,this._startLatLng.distanceTo(t),this.options.shapeOptions),
                this._map.addLayer(this._shape))
            },
            _fireCreatedEvent: function() {
                var t = new L.Circle(this._startLatLng,this._shape.getRadius(),this.options.shapeOptions);
                L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, t)
            },
            _onMouseMove: function(t) {
                var e, i = t.latlng;
                this._tooltip.updatePosition(i),
                this._isDrawing && (this._drawShape(i),
                e = this._shape.getRadius().toFixed(1),
                this._tooltip.updateContent({
                    text: "Release mouse to finish drawing.",
                    subtext: "Radius: " + e + " m"
                }))
            }
        }),
        L.Draw.Marker = L.Draw.Feature.extend({
            statics: {
                TYPE: "marker"
            },
            options: {
                icon: new L.Icon.Default,
                repeatMode: !1,
                zIndexOffset: 2E3
            },
            initialize: function(t, e) {
                this.type = L.Draw.Marker.TYPE,
                L.Draw.Feature.prototype.initialize.call(this, t, e)
            },
            addHooks: function() {
                L.Draw.Feature.prototype.addHooks.call(this),
                this._map && (this._tooltip.updateContent({
                    text: L.drawLocal.draw.handlers.marker.tooltip.start
                }),
                this._mouseMarker || (this._mouseMarker = L.marker(this._map.getCenter(), {
                    icon: L.divIcon({
                        className: "leaflet-mouse-marker",
                        iconAnchor: [20, 20],
                        iconSize: [40, 40]
                    }),
                    opacity: 0,
                    zIndexOffset: this.options.zIndexOffset
                })),
                this._mouseMarker.on("click", this._onClick, this).addTo(this._map),
                this._map.on("mousemove", this._onMouseMove, this))
            },
            removeHooks: function() {
                L.Draw.Feature.prototype.removeHooks.call(this),
                this._map && (this._marker && (this._marker.off("click", this._onClick, this),
                this._map.off("click", this._onClick, this).removeLayer(this._marker),
                delete this._marker),
                this._mouseMarker.off("click", this._onClick, this),
                this._map.removeLayer(this._mouseMarker),
                delete this._mouseMarker,
                this._map.off("mousemove", this._onMouseMove, this))
            },
            _onMouseMove: function(t) {
                var e = t.latlng;
                this._tooltip.updatePosition(e),
                this._mouseMarker.setLatLng(e),
                this._marker ? this._marker.setLatLng(e) : (this._marker = new L.Marker(e,{
                    icon: this.options.icon,
                    zIndexOffset: this.options.zIndexOffset
                }),
                this._marker.on("click", this._onClick, this),
                this._map.on("click", this._onClick, this).addLayer(this._marker))
            },
            _onClick: function() {
                this._fireCreatedEvent(),
                this.disable(),
                this.options.repeatMode && this.enable()
            },
            _fireCreatedEvent: function() {
                var t = new L.Marker(this._marker.getLatLng(),{
                    icon: this.options.icon
                });
                L.Draw.Feature.prototype._fireCreatedEvent.call(this, t)
            }
        }),
        L.Edit = L.Edit || {},
        L.Edit.Poly = L.Handler.extend({
            options: {
                icon: new L.DivIcon({
                    iconSize: new L.Point(8,8),
                    className: "leaflet-div-icon leaflet-editing-icon"
                })
            },
            initialize: function(t, e) {
                this._poly = t,
                L.setOptions(this, e)
            },
            addHooks: function() {
                this._poly._map && (this._markerGroup || this._initMarkers(),
                this._poly._map.addLayer(this._markerGroup))
            },
            removeHooks: function() {
                this._poly._map && (this._poly._map.removeLayer(this._markerGroup),
                delete this._markerGroup,
                delete this._markers)
            },
            updateMarkers: function() {
                this._markerGroup.clearLayers(),
                this._initMarkers()
            },
            _initMarkers: function() {
                this._markerGroup || (this._markerGroup = new L.LayerGroup),
                this._markers = [];
                var t, e, i, o, a = this._poly._latlngs;
                for (t = 0,
                i = a.length; i > t; t++)
                    o = this._createMarker(a[t], t),
                    o.on("click", this._onMarkerClick, this),
                    this._markers.push(o);
                var s, r;
                for (t = 0,
                e = i - 1; i > t; e = t++)
                    (0 !== t || L.Polygon && this._poly instanceof L.Polygon) && (s = this._markers[e],
                    r = this._markers[t],
                    this._createMiddleMarker(s, r),
                    this._updatePrevNext(s, r))
            },
            _createMarker: function(t, e) {
                var i = new L.Marker(t,{
                    draggable: !0,
                    icon: this.options.icon
                });
                return i._origLatLng = t,
                i._index = e,
                i.on("drag", this._onMarkerDrag, this),
                i.on("dragend", this._fireEdit, this),
                this._markerGroup.addLayer(i),
                i
            },
            _removeMarker: function(t) {
                var e = t._index;
                this._markerGroup.removeLayer(t),
                this._markers.splice(e, 1),
                this._poly.spliceLatLngs(e, 1),
                this._updateIndexes(e, -1),
                t.off("drag", this._onMarkerDrag, this).off("dragend", this._fireEdit, this).off("click", this._onMarkerClick, this)
            },
            _fireEdit: function() {
                this._poly.edited = !0,
                this._poly.fire("edit")
            },
            _onMarkerDrag: function(t) {
                var e = t.target;
                L.extend(e._origLatLng, e._latlng),
                e._middleLeft && e._middleLeft.setLatLng(this._getMiddleLatLng(e._prev, e)),
                e._middleRight && e._middleRight.setLatLng(this._getMiddleLatLng(e, e._next)),
                this._poly.redraw()
            },
            _onMarkerClick: function(t) {
                if (!(3 > this._poly._latlngs.length)) {
                    var e = t.target;
                    this._removeMarker(e),
                    this._updatePrevNext(e._prev, e._next),
                    e._middleLeft && this._markerGroup.removeLayer(e._middleLeft),
                    e._middleRight && this._markerGroup.removeLayer(e._middleRight),
                    e._prev && e._next ? this._createMiddleMarker(e._prev, e._next) : e._prev ? e._next || (e._prev._middleRight = null) : e._next._middleLeft = null,
                    this._fireEdit()
                }
            },
            _updateIndexes: function(t, e) {
                this._markerGroup.eachLayer(function(i) {
                    i._index > t && (i._index += e)
                })
            },
            _createMiddleMarker: function(t, e) {
                var i, o, a, s = this._getMiddleLatLng(t, e), r = this._createMarker(s);
                r.setOpacity(.6),
                t._middleRight = e._middleLeft = r,
                o = function() {
                    var o = e._index;
                    r._index = o,
                    r.off("click", i, this).on("click", this._onMarkerClick, this),
                    s.lat = r.getLatLng().lat,
                    s.lng = r.getLatLng().lng,
                    this._poly.spliceLatLngs(o, 0, s),
                    this._markers.splice(o, 0, r),
                    r.setOpacity(1),
                    this._updateIndexes(o, 1),
                    e._index++,
                    this._updatePrevNext(t, r),
                    this._updatePrevNext(r, e)
                }
                ,
                a = function() {
                    r.off("dragstart", o, this),
                    r.off("dragend", a, this),
                    this._createMiddleMarker(t, r),
                    this._createMiddleMarker(r, e)
                }
                ,
                i = function() {
                    o.call(this),
                    a.call(this),
                    this._fireEdit()
                }
                ,
                r.on("click", i, this).on("dragstart", o, this).on("dragend", a, this),
                this._markerGroup.addLayer(r)
            },
            _updatePrevNext: function(t, e) {
                t && (t._next = e),
                e && (e._prev = t)
            },
            _getMiddleLatLng: function(t, e) {
                var i = this._poly._map
                  , o = i.latLngToLayerPoint(t.getLatLng())
                  , a = i.latLngToLayerPoint(e.getLatLng());
                return i.layerPointToLatLng(o._add(a)._divideBy(2))
            }
        }),
        L.Polyline.addInitHook(function() {
            this.editing || (L.Edit.Poly && (this.editing = new L.Edit.Poly(this),
            this.options.editable && this.editing.enable()),
            this.on("add", function() {
                this.editing && this.editing.enabled() && this.editing.addHooks()
            }),
            this.on("remove", function() {
                this.editing && this.editing.enabled() && this.editing.removeHooks()
            }))
        }),
        L.Edit = L.Edit || {},
        L.Edit.SimpleShape = L.Handler.extend({
            options: {
                moveIcon: new L.DivIcon({
                    iconSize: new L.Point(8,8),
                    className: "leaflet-div-icon leaflet-editing-icon leaflet-edit-move"
                }),
                resizeIcon: new L.DivIcon({
                    iconSize: new L.Point(8,8),
                    className: "leaflet-div-icon leaflet-editing-icon leaflet-edit-resize"
                })
            },
            initialize: function(t, e) {
                this._shape = t,
                L.Util.setOptions(this, e)
            },
            addHooks: function() {
                this._shape._map && (this._map = this._shape._map,
                this._markerGroup || this._initMarkers(),
                this._map.addLayer(this._markerGroup))
            },
            removeHooks: function() {
                if (this._shape._map) {
                    this._unbindMarker(this._moveMarker);
                    for (var t = 0, e = this._resizeMarkers.length; e > t; t++)
                        this._unbindMarker(this._resizeMarkers[t]);
                    this._resizeMarkers = null,
                    this._map.removeLayer(this._markerGroup),
                    delete this._markerGroup
                }
                this._map = null
            },
            updateMarkers: function() {
                this._markerGroup.clearLayers(),
                this._initMarkers()
            },
            _initMarkers: function() {
                this._markerGroup || (this._markerGroup = new L.LayerGroup),
                this._createMoveMarker(),
                this._createResizeMarker()
            },
            _createMoveMarker: function() {},
            _createResizeMarker: function() {},
            _createMarker: function(t, e) {
                var i = new L.Marker(t,{
                    draggable: !0,
                    icon: e,
                    zIndexOffset: 10
                });
                return this._bindMarker(i),
                this._markerGroup.addLayer(i),
                i
            },
            _bindMarker: function(t) {
                t.on("dragstart", this._onMarkerDragStart, this).on("drag", this._onMarkerDrag, this).on("dragend", this._onMarkerDragEnd, this)
            },
            _unbindMarker: function(t) {
                t.off("dragstart", this._onMarkerDragStart, this).off("drag", this._onMarkerDrag, this).off("dragend", this._onMarkerDragEnd, this)
            },
            _onMarkerDragStart: function(t) {
                var e = t.target;
                e.setOpacity(0)
            },
            _fireEdit: function() {
                this._shape.edited = !0,
                this._shape.fire("edit")
            },
            _onMarkerDrag: function(t) {
                var e = t.target
                  , i = e.getLatLng();
                e === this._moveMarker ? this._move(i) : this._resize(i),
                this._shape.redraw()
            },
            _onMarkerDragEnd: function(t) {
                var e = t.target;
                e.setOpacity(1),
                this._shape.fire("edit"),
                this._fireEdit()
            },
            _move: function() {},
            _resize: function() {}
        }),
        L.Edit = L.Edit || {},
        L.Edit.Rectangle = L.Edit.SimpleShape.extend({
            _createMoveMarker: function() {
                var t = this._shape.getBounds()
                  , e = t.getCenter();
                this._moveMarker = this._createMarker(e, this.options.moveIcon)
            },
            _createResizeMarker: function() {
                var t = this._getCorners();
                this._resizeMarkers = [];
                for (var e = 0, i = t.length; i > e; e++)
                    this._resizeMarkers.push(this._createMarker(t[e], this.options.resizeIcon)),
                    this._resizeMarkers[e]._cornerIndex = e
            },
            _onMarkerDragStart: function(t) {
                L.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, t);
                var e = this._getCorners()
                  , i = t.target
                  , o = i._cornerIndex;
                this._oppositeCorner = e[(o + 2) % 4],
                this._toggleCornerMarkers(0, o)
            },
            _onMarkerDragEnd: function(t) {
                var e, i, o = t.target;
                o === this._moveMarker && (e = this._shape.getBounds(),
                i = e.getCenter(),
                o.setLatLng(i)),
                this._toggleCornerMarkers(1),
                this._repositionCornerMarkers(),
                L.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this, t)
            },
            _move: function(t) {
                for (var e, i = this._shape.getLatLngs(), o = this._shape.getBounds(), a = o.getCenter(), s = [], r = 0, n = i.length; n > r; r++)
                    e = [i[r].lat - a.lat, i[r].lng - a.lng],
                    s.push([t.lat + e[0], t.lng + e[1]]);
                this._shape.setLatLngs(s),
                this._repositionCornerMarkers()
            },
            _resize: function(t) {
                var e;
                this._shape.setBounds(L.latLngBounds(t, this._oppositeCorner)),
                e = this._shape.getBounds(),
                this._moveMarker.setLatLng(e.getCenter())
            },
            _getCorners: function() {
                var t = this._shape.getBounds()
                  , e = t.getNorthWest()
                  , i = t.getNorthEast()
                  , o = t.getSouthEast()
                  , a = t.getSouthWest();
                return [e, i, o, a]
            },
            _toggleCornerMarkers: function(t) {
                for (var e = 0, i = this._resizeMarkers.length; i > e; e++)
                    this._resizeMarkers[e].setOpacity(t)
            },
            _repositionCornerMarkers: function() {
                for (var t = this._getCorners(), e = 0, i = this._resizeMarkers.length; i > e; e++)
                    this._resizeMarkers[e].setLatLng(t[e])
            }
        }),
        L.Rectangle.addInitHook(function() {
            L.Edit.Rectangle && (this.editing = new L.Edit.Rectangle(this),
            this.options.editable && this.editing.enable())
        }),
        L.Edit = L.Edit || {},
        L.Edit.Circle = L.Edit.SimpleShape.extend({
            _createMoveMarker: function() {
                var t = this._shape.getLatLng();
                this._moveMarker = this._createMarker(t, this.options.moveIcon)
            },
            _createResizeMarker: function() {
                var t = this._shape.getLatLng()
                  , e = this._getResizeMarkerPoint(t);
                this._resizeMarkers = [],
                this._resizeMarkers.push(this._createMarker(e, this.options.resizeIcon))
            },
            _getResizeMarkerPoint: function(t) {
                var e = this._shape._radius * Math.cos(Math.PI / 4)
                  , i = this._map.project(t);
                return this._map.unproject([i.x + e, i.y - e])
            },
            _move: function(t) {
                var e = this._getResizeMarkerPoint(t);
                this._resizeMarkers[0].setLatLng(e),
                this._shape.setLatLng(t)
            },
            _resize: function(t) {
                var e = this._moveMarker.getLatLng()
                  , i = e.distanceTo(t);
                this._shape.setRadius(i)
            }
        }),
        L.Circle.addInitHook(function() {
            L.Edit.Circle && (this.editing = new L.Edit.Circle(this),
            this.options.editable && this.editing.enable()),
            this.on("add", function() {
                this.editing && this.editing.enabled() && this.editing.addHooks()
            }),
            this.on("remove", function() {
                this.editing && this.editing.enabled() && this.editing.removeHooks()
            })
        }),
        L.LatLngUtil = {
            cloneLatLngs: function(t) {
                for (var e = [], i = 0, o = t.length; o > i; i++)
                    e.push(this.cloneLatLng(t[i]));
                return e
            },
            cloneLatLng: function(t) {
                return L.latLng(t.lat, t.lng)
            }
        },
        L.PolygonUtil = {
            geodesicArea: function(t) {
                var e, i, o = t.length, a = 0, s = L.LatLng.DEG_TO_RAD;
                if (o > 2) {
                    for (var r = 0; o > r; r++)
                        e = t[r],
                        i = t[(r + 1) % o],
                        a += (i.lng - e.lng) * s * (2 + Math.sin(e.lat * s) + Math.sin(i.lat * s));
                    a = 6378137 * 6378137 * a / 2
                }
                return Math.abs(a)
            }
        },
        L.Util.extend(L.LineUtil, {
            segmentsIntersect: function(t, e, i, o) {
                return this._checkCounterclockwise(t, i, o) !== this._checkCounterclockwise(e, i, o) && this._checkCounterclockwise(t, e, i) !== this._checkCounterclockwise(t, e, o)
            },
            _checkCounterclockwise: function(t, e, i) {
                return (i.y - t.y) * (e.x - t.x) > (e.y - t.y) * (i.x - t.x)
            }
        }),
        L.Polyline.include({
            intersects: function() {
                var t, e, i, o = this._originalPoints, a = o ? o.length : 0;
                if (this._tooFewPointsForIntersection())
                    return !1;
                for (t = a - 1; t >= 3; t--)
                    if (e = o[t - 1],
                    i = o[t],
                    this._lineSegmentsIntersectsRange(e, i, t - 2))
                        return !0;
                return !1
            },
            newLatLngIntersects: function(t, e) {
                return this._map ? this.newPointIntersects(this._map.latLngToLayerPoint(t), e) : !1
            },
            newPointIntersects: function(t, e) {
                var i = this._originalPoints
                  , o = i ? i.length : 0
                  , a = i ? i[o - 1] : null
                  , s = o - 2;
                return this._tooFewPointsForIntersection(1) ? !1 : this._lineSegmentsIntersectsRange(a, t, s, e ? 1 : 0)
            },
            _tooFewPointsForIntersection: function(t) {
                var e = this._originalPoints
                  , i = e ? e.length : 0;
                return i += t || 0,
                !this._originalPoints || 3 >= i
            },
            _lineSegmentsIntersectsRange: function(t, e, i, o) {
                var a, s, r = this._originalPoints;
                o = o || 0;
                for (var n = i; n > o; n--)
                    if (a = r[n - 1],
                    s = r[n],
                    L.LineUtil.segmentsIntersect(t, e, a, s))
                        return !0;
                return !1
            }
        }),
        L.Polygon.include({
            intersects: function() {
                var t, e, i, o, a, s = this._originalPoints;
                return this._tooFewPointsForIntersection() ? !1 : (t = L.Polyline.prototype.intersects.call(this)) ? !0 : (e = s.length,
                i = s[0],
                o = s[e - 1],
                a = e - 2,
                this._lineSegmentsIntersectsRange(o, i, a, 1))
            }
        }),
        L.Control.Draw = L.Control.extend({
            options: {
                position: "topleft",
                draw: {},
                edit: !1
            },
            initialize: function(t) {
                if ("0.5.1" >= L.version)
                    throw Error("Leaflet.draw 0.2.0+ requires Leaflet 0.6.0+. Download latest from https://github.com/Leaflet/Leaflet/");
                L.Control.prototype.initialize.call(this, t);
                var e, i;
                this._toolbars = {},
                L.DrawToolbar && this.options.draw && (i = new L.DrawToolbar(this.options.draw),
                e = L.stamp(i),
                this._toolbars[e] = i,
                this._toolbars[e].on("enable", this._toolbarEnabled, this)),
                L.EditToolbar && this.options.edit && (i = new L.EditToolbar(this.options.edit),
                e = L.stamp(i),
                this._toolbars[e] = i,
                this._toolbars[e].on("enable", this._toolbarEnabled, this))
            },
            onAdd: function(t) {
                var e, i = L.DomUtil.create("div", "leaflet-draw"), o = !1, a = "leaflet-draw-toolbar-top";
                for (var s in this._toolbars)
                    this._toolbars.hasOwnProperty(s) && (e = this._toolbars[s].addToolbar(t),
                    o || (L.DomUtil.hasClass(e, a) || L.DomUtil.addClass(e.childNodes[0], a),
                    o = !0),
                    i.appendChild(e));
                return i
            },
            onRemove: function() {
                for (var t in this._toolbars)
                    this._toolbars.hasOwnProperty(t) && this._toolbars[t].removeToolbar()
            },
            setDrawingOptions: function(t) {
                for (var e in this._toolbars)
                    this._toolbars[e]instanceof L.DrawToolbar && this._toolbars[e].setOptions(t)
            },
            _toolbarEnabled: function(t) {
                var e = "" + L.stamp(t.target);
                for (var i in this._toolbars)
                    this._toolbars.hasOwnProperty(i) && i !== e && this._toolbars[i].disable()
            }
        }),
        L.Map.mergeOptions({
            drawControl: !1
        }),
        L.Map.addInitHook(function() {
            this.options.drawControl && (this.drawControl = new L.Control.Draw,
            this.addControl(this.drawControl))
        }),
        L.Toolbar = L.Class.extend({
            includes: [L.Mixin.Events],
            initialize: function(t) {
                L.setOptions(this, t),
                this._modes = {},
                this._actionButtons = [],
                this._activeMode = null
            },
            enabled: function() {
                return null !== this._activeMode
            },
            disable: function() {
                this.enabled() && this._activeMode.handler.disable()
            },
            removeToolbar: function() {
                for (var t in this._modes)
                    this._modes.hasOwnProperty(t) && (this._disposeButton(this._modes[t].button, this._modes[t].handler.enable),
                    this._modes[t].handler.disable(),
                    this._modes[t].handler.off("enabled", this._handlerActivated, this).off("disabled", this._handlerDeactivated, this));
                this._modes = {};
                for (var e = 0, i = this._actionButtons.length; i > e; e++)
                    this._disposeButton(this._actionButtons[e].button, this._actionButtons[e].callback);
                this._actionButtons = [],
                this._actionsContainer = null
            },
            _initModeHandler: function(t, e, i, o, a) {
                var s = t.type;
                this._modes[s] = {},
                this._modes[s].handler = t,
                this._modes[s].button = this._createButton({
                    title: a,
                    className: o + "-" + s,
                    container: e,
                    callback: this._modes[s].handler.enable,
                    context: this._modes[s].handler
                }),
                this._modes[s].buttonIndex = i,
                this._modes[s].handler.on("enabled", this._handlerActivated, this).on("disabled", this._handlerDeactivated, this)
            },
            _createButton: function(t) {
                var e = L.DomUtil.create("a", t.className || "", t.container);
                return e.href = "#",
                t.text && (e.innerHTML = t.text),
                t.title && (e.title = t.title),
                L.DomEvent.on(e, "click", L.DomEvent.stopPropagation).on(e, "mousedown", L.DomEvent.stopPropagation).on(e, "dblclick", L.DomEvent.stopPropagation).on(e, "click", L.DomEvent.preventDefault).on(e, "click", t.callback, t.context),
                e
            },
            _disposeButton: function(t, e) {
                L.DomEvent.off(t, "click", L.DomEvent.stopPropagation).off(t, "mousedown", L.DomEvent.stopPropagation).off(t, "dblclick", L.DomEvent.stopPropagation).off(t, "click", L.DomEvent.preventDefault).off(t, "click", e)
            },
            _handlerActivated: function(t) {
                this._activeMode && this._activeMode.handler.enabled() && this._activeMode.handler.disable(),
                this._activeMode = this._modes[t.handler],
                L.DomUtil.addClass(this._activeMode.button, "leaflet-draw-toolbar-button-enabled"),
                this._showActionsToolbar(),
                this.fire("enable")
            },
            _handlerDeactivated: function() {
                this._hideActionsToolbar(),
                L.DomUtil.removeClass(this._activeMode.button, "leaflet-draw-toolbar-button-enabled"),
                this._activeMode = null,
                this.fire("disable")
            },
            _createActions: function(t) {
                for (var e, i, o = L.DomUtil.create("ul", "leaflet-draw-actions"), a = 50, s = t.length, r = s * a + (s - 1), n = 0; s > n; n++)
                    e = L.DomUtil.create("li", "", o),
                    i = this._createButton({
                        title: t[n].title,
                        text: t[n].text,
                        container: e,
                        callback: t[n].callback,
                        context: t[n].context
                    }),
                    this._actionButtons.push({
                        button: i,
                        callback: t[n].callback
                    });
                return o.style.width = r + "px",
                o
            },
            _showActionsToolbar: function() {
                var t = this._activeMode.buttonIndex
                  , e = this._lastButtonIndex
                  , i = 26
                  , o = 1
                  , a = t * i + t * o - 1;
                this._actionsContainer.style.top = a + "px",
                0 === t && (L.DomUtil.addClass(this._toolbarContainer, "leaflet-draw-toolbar-notop"),
                L.DomUtil.addClass(this._actionsContainer, "leaflet-draw-actions-top")),
                t === e && (L.DomUtil.addClass(this._toolbarContainer, "leaflet-draw-toolbar-nobottom"),
                L.DomUtil.addClass(this._actionsContainer, "leaflet-draw-actions-bottom")),
                this._actionsContainer.style.display = "block"
            },
            _hideActionsToolbar: function() {
                this._actionsContainer.style.display = "none",
                L.DomUtil.removeClass(this._toolbarContainer, "leaflet-draw-toolbar-notop"),
                L.DomUtil.removeClass(this._toolbarContainer, "leaflet-draw-toolbar-nobottom"),
                L.DomUtil.removeClass(this._actionsContainer, "leaflet-draw-actions-top"),
                L.DomUtil.removeClass(this._actionsContainer, "leaflet-draw-actions-bottom")
            }
        }),
        L.Tooltip = L.Class.extend({
            initialize: function(t) {
                this._map = t,
                this._popupPane = t._panes.popupPane,
                this._container = L.DomUtil.create("div", "leaflet-draw-tooltip", this._popupPane),
                this._singleLineLabel = !1
            },
            dispose: function() {
                this._popupPane.removeChild(this._container),
                this._container = null
            },
            updateContent: function(t) {
                return t.subtext = t.subtext || "",
                0 !== t.subtext.length || this._singleLineLabel ? t.subtext.length > 0 && this._singleLineLabel && (L.DomUtil.removeClass(this._container, "leaflet-draw-tooltip-single"),
                this._singleLineLabel = !1) : (L.DomUtil.addClass(this._container, "leaflet-draw-tooltip-single"),
                this._singleLineLabel = !0),
                this._container.innerHTML = (t.subtext.length > 0 ? '<span class="leaflet-draw-tooltip-subtext">' + t.subtext + "</span>" + "<br />" : "") + "<span>" + t.text + "</span>",
                this
            },
            updatePosition: function(t) {
                var e = this._map.latLngToLayerPoint(t);
                return L.DomUtil.setPosition(this._container, e),
                this
            },
            showAsError: function() {
                return L.DomUtil.addClass(this._container, "leaflet-error-draw-tooltip"),
                this
            },
            removeError: function() {
                return L.DomUtil.removeClass(this._container, "leaflet-error-draw-tooltip"),
                this
            }
        }),
        L.DrawToolbar = L.Toolbar.extend({
            options: {
                polyline: {},
                polygon: {},
                rectangle: {},
                circle: {},
                marker: {}
            },
            initialize: function(t) {
                for (var e in this.options)
                    this.options.hasOwnProperty(e) && t[e] && (t[e] = L.extend({}, this.options[e], t[e]));
                L.Toolbar.prototype.initialize.call(this, t)
            },
            addToolbar: function(t) {
                var e = L.DomUtil.create("div", "leaflet-draw-section")
                  , i = 0
                  , o = "leaflet-draw-draw";
                return this._toolbarContainer = L.DomUtil.create("div", "leaflet-draw-toolbar leaflet-bar"),
                this.options.polyline && this._initModeHandler(new L.Draw.Polyline(t,this.options.polyline), this._toolbarContainer, i++, o, L.drawLocal.draw.toolbar.buttons.polyline),
                this.options.polygon && this._initModeHandler(new L.Draw.Polygon(t,this.options.polygon), this._toolbarContainer, i++, o, L.drawLocal.draw.toolbar.buttons.polygon),
                this.options.rectangle && this._initModeHandler(new L.Draw.Rectangle(t,this.options.rectangle), this._toolbarContainer, i++, o, L.drawLocal.draw.toolbar.buttons.rectangle),
                this.options.circle && this._initModeHandler(new L.Draw.Circle(t,this.options.circle), this._toolbarContainer, i++, o, L.drawLocal.draw.toolbar.buttons.circle),
                this.options.marker && this._initModeHandler(new L.Draw.Marker(t,this.options.marker), this._toolbarContainer, i++, o, L.drawLocal.draw.toolbar.buttons.marker),
                this._lastButtonIndex = --i,
                this._actionsContainer = this._createActions([{
                    title: L.drawLocal.draw.toolbar.actions.title,
                    text: L.drawLocal.draw.toolbar.actions.text,
                    callback: this.disable,
                    context: this
                }]),
                e.appendChild(this._toolbarContainer),
                e.appendChild(this._actionsContainer),
                e
            },
            setOptions: function(t) {
                L.setOptions(this, t);
                for (var e in this._modes)
                    this._modes.hasOwnProperty(e) && t.hasOwnProperty(e) && this._modes[e].handler.setOptions(t[e])
            }
        }),
        L.EditToolbar = L.Toolbar.extend({
            options: {
                edit: {
                    selectedPathOptions: {
                        color: "#fe57a1",
                        opacity: .6,
                        dashArray: "10, 10",
                        fill: !0,
                        fillColor: "#fe57a1",
                        fillOpacity: .1
                    }
                },
                remove: {},
                featureGroup: null
            },
            initialize: function(t) {
                t.edit && (t.edit.selectedPathOptions === undefined && (t.edit.selectedPathOptions = this.options.edit.selectedPathOptions),
                t.edit = L.extend({}, this.options.edit, t.edit)),
                t.remove && (t.remove = L.extend({}, this.options.remove, t.remove)),
                L.Toolbar.prototype.initialize.call(this, t),
                this._selectedFeatureCount = 0
            },
            addToolbar: function(t) {
                var e = L.DomUtil.create("div", "leaflet-draw-section")
                  , i = 0
                  , o = "leaflet-draw-edit";
                return this._toolbarContainer = L.DomUtil.create("div", "leaflet-draw-toolbar leaflet-bar"),
                this._map = t,
                this.options.edit && this._initModeHandler(new L.EditToolbar.Edit(t,{
                    featureGroup: this.options.featureGroup,
                    selectedPathOptions: this.options.edit.selectedPathOptions
                }), this._toolbarContainer, i++, o, L.drawLocal.edit.toolbar.buttons.edit),
                this.options.remove && this._initModeHandler(new L.EditToolbar.Delete(t,{
                    featureGroup: this.options.featureGroup
                }), this._toolbarContainer, i++, o, L.drawLocal.edit.toolbar.buttons.remove),
                this._lastButtonIndex = --i,
                this._actionsContainer = this._createActions([{
                    title: L.drawLocal.edit.toolbar.actions.save.title,
                    text: L.drawLocal.edit.toolbar.actions.save.text,
                    callback: this._save,
                    context: this
                }, {
                    title: L.drawLocal.edit.toolbar.actions.cancel.title,
                    text: L.drawLocal.edit.toolbar.actions.cancel.text,
                    callback: this.disable,
                    context: this
                }]),
                e.appendChild(this._toolbarContainer),
                e.appendChild(this._actionsContainer),
                e
            },
            disable: function() {
                this.enabled() && (this._activeMode.handler.revertLayers(),
                L.Toolbar.prototype.disable.call(this))
            },
            _save: function() {
                this._activeMode.handler.save(),
                this._activeMode.handler.disable()
            }
        }),
        L.EditToolbar.Edit = L.Handler.extend({
            statics: {
                TYPE: "edit"
            },
            includes: L.Mixin.Events,
            initialize: function(t, e) {
                if (L.Handler.prototype.initialize.call(this, t),
                this._selectedPathOptions = e.selectedPathOptions,
                this._featureGroup = e.featureGroup,
                !(this._featureGroup instanceof L.FeatureGroup))
                    throw Error("options.featureGroup must be a L.FeatureGroup");
                this._uneditedLayerProps = {},
                this.type = L.EditToolbar.Edit.TYPE
            },
            enable: function() {
                this._enabled || (L.Handler.prototype.enable.call(this),
                this._featureGroup.on("layeradd", this._enableLayerEdit, this).on("layerremove", this._disableLayerEdit, this),
                this.fire("enabled", {
                    handler: this.type
                }),
                this._map.fire("draw:editstart", {
                    handler: this.type
                }))
            },
            disable: function() {
                this._enabled && (this.fire("disabled", {
                    handler: this.type
                }),
                this._map.fire("draw:editstop", {
                    handler: this.type
                }),
                this._featureGroup.off("layeradd", this._enableLayerEdit, this).off("layerremove", this._disableLayerEdit, this),
                L.Handler.prototype.disable.call(this))
            },
            addHooks: function() {
                this._map && (this._featureGroup.eachLayer(this._enableLayerEdit, this),
                this._tooltip = new L.Tooltip(this._map),
                this._tooltip.updateContent({
                    text: L.drawLocal.edit.handlers.edit.tooltip.text,
                    subtext: L.drawLocal.edit.handlers.edit.tooltip.subtext
                }),
                this._map.on("mousemove", this._onMouseMove, this))
            },
            removeHooks: function() {
                this._map && (this._featureGroup.eachLayer(this._disableLayerEdit, this),
                this._uneditedLayerProps = {},
                this._tooltip.dispose(),
                this._tooltip = null,
                this._map.off("mousemove", this._onMouseMove, this))
            },
            revertLayers: function() {
                this._featureGroup.eachLayer(function(t) {
                    this._revertLayer(t)
                }, this)
            },
            save: function() {
                var t = new L.LayerGroup;
                this._featureGroup.eachLayer(function(e) {
                    e.edited && (t.addLayer(e),
                    e.edited = !1)
                }),
                this._map.fire("draw:edited", {
                    layers: t
                })
            },
            _backupLayer: function(t) {
                var e = L.Util.stamp(t);
                this._uneditedLayerProps[e] || (this._uneditedLayerProps[e] = t instanceof L.Polyline || t instanceof L.Polygon || t instanceof L.Rectangle ? {
                    latlngs: L.LatLngUtil.cloneLatLngs(t.getLatLngs())
                } : t instanceof L.Circle ? {
                    latlng: L.LatLngUtil.cloneLatLng(t.getLatLng()),
                    radius: t.getRadius()
                } : {
                    latlng: L.LatLngUtil.cloneLatLng(t.getLatLng())
                })
            },
            _revertLayer: function(t) {
                var e = L.Util.stamp(t);
                t.edited = !1,
                this._uneditedLayerProps.hasOwnProperty(e) && (t instanceof L.Polyline || t instanceof L.Polygon || t instanceof L.Rectangle ? t.setLatLngs(this._uneditedLayerProps[e].latlngs) : t instanceof L.Circle ? (t.setLatLng(this._uneditedLayerProps[e].latlng),
                t.setRadius(this._uneditedLayerProps[e].radius)) : t.setLatLng(this._uneditedLayerProps[e].latlng))
            },
            _toggleMarkerHighlight: function(t) {
                var e = t._icon;
                e.style.display = "none",
                L.DomUtil.hasClass(e, "leaflet-edit-marker-selected") ? (L.DomUtil.removeClass(e, "leaflet-edit-marker-selected"),
                this._offsetMarker(e, -4)) : (L.DomUtil.addClass(e, "leaflet-edit-marker-selected"),
                this._offsetMarker(e, 4)),
                e.style.display = ""
            },
            _offsetMarker: function(t, e) {
                var i = parseInt(t.style.marginTop, 10) - e
                  , o = parseInt(t.style.marginLeft, 10) - e;
                t.style.marginTop = i + "px",
                t.style.marginLeft = o + "px"
            },
            _enableLayerEdit: function(t) {
                var e, i = t.layer || t.target || t, o = i instanceof L.Marker;
                (!o || i._icon) && (this._backupLayer(i),
                this._selectedPathOptions && (e = L.Util.extend({}, this._selectedPathOptions),
                o ? this._toggleMarkerHighlight(i) : (i.options.previousOptions = i.options,
                i instanceof L.Circle || i instanceof L.Polygon || i instanceof L.Rectangle || (e.fill = !1),
                i.setStyle(e))),
                o ? (i.dragging.enable(),
                i.on("dragend", this._onMarkerDragEnd)) : i.editing.enable())
            },
            _disableLayerEdit: function(t) {
                var e = t.layer || t.target || t;
                e.edited = !1,
                this._selectedPathOptions && (e instanceof L.Marker ? this._toggleMarkerHighlight(e) : (e.setStyle(e.options.previousOptions),
                delete e.options.previousOptions)),
                e instanceof L.Marker ? (e.dragging.disable(),
                e.off("dragend", this._onMarkerDragEnd, this)) : e.editing.disable()
            },
            _onMarkerDragEnd: function(t) {
                var e = t.target;
                e.edited = !0
            },
            _onMouseMove: function(t) {
                this._tooltip.updatePosition(t.latlng)
            }
        }),
        L.EditToolbar.Delete = L.Handler.extend({
            statics: {
                TYPE: "remove"
            },
            includes: L.Mixin.Events,
            initialize: function(t, e) {
                if (L.Handler.prototype.initialize.call(this, t),
                L.Util.setOptions(this, e),
                this._deletableLayers = this.options.featureGroup,
                !(this._deletableLayers instanceof L.FeatureGroup))
                    throw Error("options.featureGroup must be a L.FeatureGroup");
                this.type = L.EditToolbar.Delete.TYPE
            },
            enable: function() {
                this._enabled || (L.Handler.prototype.enable.call(this),
                this._deletableLayers.on("layeradd", this._enableLayerDelete, this).on("layerremove", this._disableLayerDelete, this),
                this.fire("enabled", {
                    handler: this.type
                }),
                this._map.fire("draw:editstart", {
                    handler: this.type
                }))
            },
            disable: function() {
                this._enabled && (L.Handler.prototype.disable.call(this),
                this._deletableLayers.off("layeradd", this._enableLayerDelete, this).off("layerremove", this._disableLayerDelete, this),
                this.fire("disabled", {
                    handler: this.type
                }),
                this._map.fire("draw:editstop", {
                    handler: this.type
                }))
            },
            addHooks: function() {
                this._map && (this._deletableLayers.eachLayer(this._enableLayerDelete, this),
                this._deletedLayers = new L.layerGroup,
                this._tooltip = new L.Tooltip(this._map),
                this._tooltip.updateContent({
                    text: L.drawLocal.edit.handlers.remove.tooltip.text
                }),
                this._map.on("mousemove", this._onMouseMove, this))
            },
            removeHooks: function() {
                this._map && (this._deletableLayers.eachLayer(this._disableLayerDelete, this),
                this._deletedLayers = null,
                this._tooltip.dispose(),
                this._tooltip = null,
                this._map.off("mousemove", this._onMouseMove, this))
            },
            revertLayers: function() {
                this._deletedLayers.eachLayer(function(t) {
                    this._deletableLayers.addLayer(t)
                }, this)
            },
            save: function() {
                this._map.fire("draw:deleted", {
                    layers: this._deletedLayers
                })
            },
            _enableLayerDelete: function(t) {
                var e = t.layer || t.target || t;
                e.on("click", this._removeLayer, this)
            },
            _disableLayerDelete: function(t) {
                var e = t.layer || t.target || t;
                e.off("click", this._removeLayer, this),
                this._deletedLayers.removeLayer(e)
            },
            _removeLayer: function(t) {
                var e = t.layer || t.target || t;
                this._deletableLayers.removeLayer(e),
                this._deletedLayers.addLayer(e)
            },
            _onMouseMove: function(t) {
                this._tooltip.updatePosition(t.latlng)
            }
        })
    }
    )(this, document);
if (typeof window !== "undefined")
    (function(e) {
        if ("function" == typeof bootstrap)
            bootstrap("leafletpip", e);
        else if ("undefined" != typeof ses) {
            if (!ses.ok())
                return;
            ses.makeLeafletPip = e
        } else
            "undefined" != typeof window ? window.leafletPip = e() : global.leafletPip = e()
    }
    )(function() {
        return function(e, t, n) {
            function r(n, i) {
                if (!t[n]) {
                    if (!e[n]) {
                        var s = "function" == typeof require && require;
                        if (!i && s)
                            return s(n, !0);
                        throw Error("Cannot find module '" + n + "'");
                    }
                    var o = t[n] = {
                        exports: {}
                    };
                    e[n][0](function(t) {
                        var i = e[n][1][t];
                        return r(i ? i : t)
                    }, o, o.exports)
                }
                return t[n].exports
            }
            for (var i = 0; n.length > i; i++)
                r(n[i]);
            return r
        }({
            1: [function(require, module) {
                function getLls(l) {
                    for (var lls = l.getLatLngs(), o = [], i = 0; lls.length > i; i++)
                        o[i] = [lls[i].lng, lls[i].lat];
                    return o
                }
                var pip = require("point-in-polygon")
                  , leafletPip = {
                    bassackwards: !1,
                    pointInLayer: function(p, layer, first) {
                        if (!(layer instanceof L.GeoJSON))
                            throw Error("must be L.GeoJSON");
                        p instanceof L.LatLng && (p = [p.lng, p.lat]),
                        leafletPip.bassackwards && p.reverse();
                        var results = [];
                        return layer.eachLayer(function(l) {
                            if (!first || !results.length) {
                                var lls = [];
                                l instanceof L.MultiPolygon ? l.eachLayer(function(sub) {
                                    lls.push(getLls(sub))
                                }) : l instanceof L.Polygon && lls.push(getLls(l));
                                for (var i = 0; lls.length > i; i++)
                                    pip(p, lls[i]) && results.push(l)
                            }
                        }),
                        results
                    }
                };
                module.exports = leafletPip
            }
            , {
                "point-in-polygon": 2
            }],
            2: [function(require, module) {
                module.exports = function(point, vs) {
                    for (var x = point[0], y = point[1], inside = !1, i = 0, j = vs.length - 1; vs.length > i; j = i++) {
                        var xi = vs[i][0]
                          , yi = vs[i][1]
                          , xj = vs[j][0]
                          , yj = vs[j][1]
                          , intersect = yi > y != yj > y && (xj - xi) * (y - yi) / (yj - yi) + xi > x;
                        intersect && (inside = !inside)
                    }
                    return inside
                }
            }
            , {}]
        }, {}, [1])(1)
    });
if (typeof window !== "undefined") {
    L.GeoCSV = L.GeoJSON.extend({
        options: {
            fieldNames: ["region", "lng", "lat"],
            fieldSep: ",",
            lineSep: "\n",
            firstRowIsTitles: false,
            removeSurroundingQuotes: true
        },
        initialize: function(data, options) {
            L.Util.setOptions(this, options);
            L.GeoJSON.prototype.initialize.call(this, data, options)
        },
        addData: function(data) {
            if (typeof data === "string") {
                var options = this.options;
                var features = [];
                if (options.firstRowIsTitles) {
                    options.fieldNames = data.slice(0, data.indexOf(options.lineSep)).split(options.fieldSep).map(function(el) {
                        return (el || "").trim()
                    });
                    data = data.slice(data.indexOf(options.lineSep) + 1)
                }
                var cleanData;
                if (!this.options.removeSurroundingQuotes)
                    cleanData = function(txt) {
                        return txt.trim()
                    }
                    ;
                else
                    cleanData = function(txt) {
                        return txt.trim().replace(/^"/, "").replace(/"$/, "")
                    }
                    ;
                data.split(options.lineSep).forEach(function(el) {
                    var items = el.split(options.fieldSep);
                    if (items.length < 2)
                        return;
                    var f = {
                        type: "Feature",
                        properties: {},
                        geometry: {
                            type: "Point",
                            coordinates: [parseFloat(cleanData(items[options.fieldNames.indexOf("lng")])), parseFloat(cleanData(items[options.fieldNames.indexOf("lat")]))]
                        }
                    };
                    options.fieldNames.forEach(function(el, idx) {
                        if (el !== "lat" && el !== "lng")
                            f.properties[el] = cleanData(items[idx])
                    });
                    features.push(f);
                    return
                });
                data = {
                    "type": "FeatureCollection",
                    "features": features
                }
            }
            L.GeoJSON.prototype.addData.call(this, data)
        }
    });
    L.geoCsv = function(csv, options) {
        return new L.GeoCSV(csv,options)
    }
}
;if (typeof window !== "undefined") {
    L.GeoTDG = L.GeoJSON.extend({
        options: {
            type: null,
            useDestRects: false
        },
        _areaMaps: [],
        initialize: function(tdg, options) {
            L.Util.setOptions(this, options);
            L.GeoJSON.prototype.initialize.call(this, tdg, options)
        },
        addData: function(data) {
            data = this._tdg2json(data);
            L.GeoJSON.prototype.addData.call(this, data)
        },
        _tdg2json: function(tdgmap) {
            if (typeof tdgmap === "string")
                tdgmap = eval("( " + tdgmap + ")");
            if (tdgmap.type === "FeatureCollection" && tdgmap.features)
                return tdgmap;
            if (tdgmap.type === "Feature")
                return tdgmap;
            if (tdgmap.fileformat == 2)
                return this._tdg2jsonV2(tdgmap);
            return this._tdg2jsonV1(tdgmap)
        },
        _tdg2jsonV1: function(tdgmap) {
            var ibitdgmap = {
                "type": "FeatureCollection",
                "features": []
            };
            var idCounter = 0;
            for (var i = 0; i < tdgmap.regions.length; ++i) {
                var tdg = tdgmap.regions[i];
                var feature = {
                    "type": "Feature",
                    "id": "" + idCounter++,
                    "properties": {},
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": tdg.borders
                    }
                };
                for (var key in tdg) {
                    if (key === "borders")
                        continue;
                    if (key === "destRect")
                        continue;
                    if (tdg.hasOwnProperty(key))
                        feature.properties[key] = tdg[key]
                }
                ibitdgmap.features.push(feature)
            }
            return ibitdgmap
        },
        _tdg2jsonV2: function(tdgmap) {
            var ibitdgmap = {
                "type": "FeatureCollection",
                "features": []
            };
            var layer = null;
            var whichLayerType = this.options.type;
            if (!whichLayerType)
                whichLayerType = tdgmap.primary_layer;
            if (!whichLayerType)
                whichLayerType = "regions";
            tdgmap.layers.forEach(function(l) {
                if (whichLayerType == l.type)
                    layer = l
            });
            var geoType = null;
            var geoSource = null;
            switch (layer.geometry_type) {
            case "polygon":
                geoType = "Polygon";
                geoSource = "borders";
                break;
            case "point":
                geoType = "Point";
                geoSource = "position";
                break
            }
            var features = layer.features;
            var idCounter = 0;
            features.forEach(function(f) {
                var feature = {
                    "type": "Feature",
                    "id": "" + idCounter++,
                    "properties": {},
                    "geometry": {
                        "type": geoType,
                        "coordinates": f[geoSource]
                    }
                };
                for (var key in f) {
                    if (key == geoSource)
                        continue;
                    if (f.hasOwnProperty(key))
                        feature.properties[key] = f[key]
                }
                if (feature.geometry.type === "Polygon") {
                    var repaired = false;
                    var newArray = [];
                    var a = [feature.geometry.coordinates];
                    for (var i = 0; i < a.length; ++i) {
                        var b = a[i];
                        newArray.push(b);
                        for (var j = 0; j < b.length; ++j) {
                            var c = b[j];
                            if (c.length == 1) {
                                c.push(c[0]);
                                c.push(c[0]);
                                repaired = true
                            }
                        }
                    }
                    if (repaired) {
                        feature.geometry.coordinates = newArray;
                        feature.geometry.type = "MultiPolygon"
                    }
                }
                ibitdgmap.features.push(feature)
            });
            return ibitdgmap
        }
    });
    L.geoTdg = function(tdg, options) {
        return new L.GeoTDG(tdg,options)
    }
}
;(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.doHichertProperties = function() {
        var chart = this;
        if (!chart.hichertProperties)
            return;
        if (chart.hichertProperties.dataTypeColoring) {
            var hichertColor = function(color) {
                return function(d) {
                    return d.hicherttype && color[d.hicherttype] || color["default"] || color
                }
            };
            chart.series.forEach(function(series, i) {
                if (series.color && typeof series.color === "object")
                    chart.cache.setProperty("series[" + i + "].color", hichertColor(series.color))
            })
        }
        if (chart.hichertProperties.dataLabelsSkip && chart.areDataLabelsVisible() && typeof chart.hichertProperties.dataLabelsSkip.count === "number") {
            var eachNthInFirstSeries = function(skip, defaultVisible) {
                var start = (skip.start || 0) % skip.count;
                var series = skip.series || [0];
                return function(d, s, g, data) {
                    if (!series.includes(s))
                        return defaultVisible;
                    if (chart.hichertProperties.dataLabelsDrawLast && Array.isArray(data)) {
                        var lastNonNullDatum;
                        for (var i = 0; i < data.length; i++)
                            if (!data[i] || data[i].value == null) {
                                lastNonNullDatum = i - 1;
                                break
                            }
                        if (lastNonNullDatum === g)
                            return true
                    }
                    return g % skip.count === start
                }
            };
            var s = chart.getSeries(0);
            if (!s || !s.dataLabels)
                s = chart.getSeries("all");
            chart.cache.setProperty("series[" + chart.series.indexOf(s) + "].dataLabels.visible", eachNthInFirstSeries(chart.hichertProperties.dataLabelsSkip, s.dataLabels.visible))
        }
    }
    ;
    tdgchart.hichert = {};
    var hichert = tdgchart.hichert;
    hichert.scenarios = ["vj", "ist", "bgt", "erw", "strat", "plan"];
    var swisspost_palette = ["", "#D8D8D8", "#BFBFBF", "#A5A5A5", "#7F7F7F", "#75A800", "#CE000A", "#98BAE9", "#6598DE", "#1A437C"];
    var swisspost_palette_other_colors = ["#A6A6A6", "#FFEB99", "#FFCC00", "#99BBE9", "#6699DF"];
    hichert.colors = {
        scenario: {
            ist: swisspost_palette[7],
            plan: swisspost_palette[2],
            erw: swisspost_palette[4]
        },
        deviation: {
            positive: swisspost_palette[5],
            negative: swisspost_palette[6]
        }
    };
    hichert.defaults = {
        swisspost_palette: swisspost_palette,
        swisspost_colors: {
            "default": swisspost_palette[7],
            ist: swisspost_palette[7],
            bgt: swisspost_palette[1],
            plan: swisspost_palette[2],
            erw: swisspost_palette[4],
            strat: swisspost_palette[8]
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    var sliderHeight = 42;
    var sliderBarHeight = 12;
    var sliderHandleHeight = 24;
    var sliderHandleWidth = 12;
    tdgchart.prototype.isPageSliderEnabled = function() {
        var chart = this;
        return chart.dataPageSlider && chart.dataPageSlider.enabled && tdg.nestedArrayDepth(chart.data) > 2
    }
    ;
    tdgchart.prototype.layoutSlider = function(slider) {
        if (!slider || !slider.enabled)
            return {
                size: 0
            };
        return {
            size: sliderHeight
        }
    }
    ;
    tdgchart.prototype.drawDataPageSlider = function(slider, panel, layout) {
        if (!slider || !slider.enabled)
            return;
        var chart = this;
        var mekkoData = chart.cache.get("mekkoData");
        chart.cache.remove("mekkoData");
        var labels = slider.labels || [];
        if (tdg.isEmpty(labels))
            labels = tdg.repeat("Page ", chart.data.length).map(function(el, idx) {
                return el + (idx + 1)
            });
        var animateButton = slider.animateButton || {
            enabled: false,
            delay: 0
        };
        var needAnimateButton = animateButton.enabled && labels.length > 1;
        var left = chart.measureLabel(labels[0], "7.5pt Sans-Serif").width / 2 + 10;
        var right = chart.measureLabel(labels[labels.length - 1], "7.5pt Sans-Serif").width / 2 + 10;
        var ordGroupSize = (panel.computedSize.width - left - right) / (labels.length - 1);
        left = Math.min(ordGroupSize, left);
        right = Math.min(ordGroupSize, right);
        right = Math.max(right, needAnimateButton ? 40 : 0);
        var sliderBarWidth = panel.computedSize.width - left - right;
        var scene = chart.cache.get("tdgscene");
        slider.currentPage = slider.currentPage || 0;
        var sliderGroup = scene.group(panel, "sliderContainer", left, layout.slider.y);
        var sliderBarStyle = {
            className: "sliderBody",
            color: "rgb(240, 240, 240)",
            lineStyle: {
                width: 1,
                color: "rgb(180, 180, 180)"
            },
            antialias: false,
            interaction: {
                events: {
                    click: sliderBarClick,
                    touchend: sliderBarClick
                }
            }
        };
        sliderGroup.rect(0, (sliderHandleHeight - sliderBarHeight) / 2, sliderBarWidth, sliderBarHeight, sliderBarStyle);
        function sliderBarClick(d, data, e) {
            var x = tdg.getMousePosition(e).x;
            var dx = this.ownerSVGElement.getScreenCTM().e + left;
            var snap = nearestX(x - dx);
            var currentPage = slider.currentPage;
            slider.currentPage = snap.idx;
            if (slider.isAnimating)
                slider.isAnimating = false;
            else {
                handle.moveTo(snap.x, 0);
                if (currentPage !== slider.currentPage)
                    chart.redraw()
            }
        }
        function playClick() {
            if (slider.isAnimating)
                slider.isAnimating = false;
            else if (slider.currentPage === chart.data.length - 1) {
                slider.currentPage = -1;
                chart.redraw();
                window.setTimeout(step, 200)
            } else if (slider.currentPage < chart.data.length - 1)
                step()
        }
        function step() {
            slider.isAnimating = true;
            slider.currentPage++;
            chart.morphAnimation.duration = animateButton.delay - 100;
            chart.morph()
        }
        if (needAnimateButton) {
            var buttonSize = sliderBarHeight + 7;
            var halfButtonSize = buttonSize / 2;
            var buttonPad = 10;
            var buttonGroup = sliderGroup.group("button", sliderBarWidth + buttonPad, 2.5);
            var animateButtonStyle = {
                className: "animateButton",
                cornerRadius: 3,
                cursor: "pointer",
                lineStyle: {
                    width: 1,
                    color: "darkgrey"
                },
                color: "rgb(230, 230, 230)",
                interaction: {
                    events: {
                        click: playClick,
                        touchend: playClick
                    }
                }
            };
            buttonGroup.rect(0, 0, buttonSize, buttonSize, animateButtonStyle);
            var animateIconStyle = {
                className: "animateButtonIcon",
                cursor: "pointer",
                color: "darkgrey",
                rotation: -90,
                "pointer-events": "none"
            };
            buttonGroup.dot(halfButtonSize, halfButtonSize, buttonSize - buttonPad, slider.isAnimating ? "square" : "triangle", animateIconStyle)
        }
        var axisGroup = sliderGroup.group("xaxis", 0, (sliderHandleHeight + sliderBarHeight) / 2);
        axisGroup.computedSize = {
            width: sliderBarWidth,
            height: sliderBarHeight
        };
        var sliderX = chart.getOrdinalScale(axisGroup.computedSize, 1, "horizontal", false, false, labels.length - 1, labels);
        ordGroupSize = sliderX.range().band;
        sliderX.side = "bottom";
        labels = labels.map(function(el) {
            return chart.truncateLabel(el, "7.5pt Sans-Serif", ordGroupSize)
        });
        var sliderAxisProps = {
            name: "slider",
            side: "bottom",
            labels: labels,
            properties: {
                majorGrid: {
                    visible: false,
                    ticks: {
                        visible: true,
                        length: 5,
                        style: "outer",
                        lineStyle: {
                            width: 1,
                            color: "rgb(180, 180, 180)"
                        }
                    }
                },
                labels: {
                    visible: true,
                    font: "7.5pt Sans-Serif",
                    color: "black"
                },
                title: {},
                bodyLineStyle: {},
                centerGroupLabels: false
            }
        };
        var axisPanels = {
            axis: [],
            xAxis: {
                fg: axisGroup,
                bg: axisGroup,
                axis: axisGroup,
                title: axisGroup
            },
            chartSize: axisGroup.computedSize
        };
        chart.drawOrdinalAxis(axisPanels, sliderX, sliderAxisProps, {}, false);
        sliderX.range().push(sliderBarWidth);
        var handleDX;
        function mouseDown() {
            handleDX = this.ownerSVGElement.getScreenCTM().e + left
        }
        function mouseMove(d, data, e) {
            if (handleDX == null)
                return;
            var currentPage = slider.currentPage;
            var x = tdg.getMousePosition(e).x;
            if (slider.discrete) {
                var snap = nearestX(x - handleDX);
                x = snap.x;
                slider.currentPage = snap.idx
            }
            handle.moveTo(x, 0);
            if (currentPage !== slider.currentPage)
                chart.redraw()
        }
        function mouseUp() {
            handleDX = null
        }
        chart.globalMouseMoveAdd(tdg.partial(mouseMove, [0, 0, null]), "drawDataPageSlider");
        chart.globalMouseUpAdd(mouseUp, "drawDataPageSlider");
        chart._postProcessCallbacks.push(function() {
            var handleNode = tdgchart.d3.select(handle._instance);
            chart.registerShortDrag(handleNode, mouseDown, mouseMove, mouseUp)
        });
        var handleLeft = sliderX(slider.currentPage) - sliderHandleWidth / 2;
        var handleStyle = {
            className: "sliderHandle",
            lineStyle: {
                width: 1,
                color: "darkgrey"
            },
            color: "rgb(211, 211, 211)",
            cornerRadius: 3,
            cursor: "ew-resize",
            translate: {
                x: handleLeft,
                y: 0
            },
            interaction: {
                events: {
                    mousedown: mouseDown
                }
            }
        };
        var handle = sliderGroup.rect(0, 0, sliderHandleWidth, sliderHandleHeight, handleStyle);
        function nearestX(x) {
            var r = sliderX.range();
            var dx = Infinity;
            var curX = 0;
            for (var i = 0; i < r.length; i++) {
                var dxx = Math.abs(r[i] - x);
                if (dxx < dx) {
                    dx = dxx;
                    curX = i
                }
            }
            return {
                idx: curX,
                x: r[curX] - sliderHandleWidth / 2
            }
        }
        chart.cache.set("mekkoData", mekkoData)
    }
    ;
    tdgchart.prototype.stepDataPageSlider = function() {
        var chart = this;
        var slider = chart.dataPageSlider || {};
        if (slider.currentPage < chart.data.length - 1)
            if (slider.isAnimating) {
                slider.currentPage++;
                chart.morphAnimation.duration = slider.animateButton.delay - 100;
                chart.morph()
            } else
                chart.redraw();
        else {
            slider.isAnimating = false;
            chart.redraw()
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.addScrollPanel = function(chartPanel, panelinfo) {
        var hackMargin = 1E3;
        var clippanel = chartPanel;
        if (panelinfo.clip === false && panelinfo.w === panelinfo.virt_w && panelinfo.h === panelinfo.virt_h)
            clippanel = chartPanel.add(pv.Panel).height(panelinfo.h).top(panelinfo.y).className(panelinfo.className + "-clip").width(panelinfo.w).left(panelinfo.x);
        else if (panelinfo.clip === false && panelinfo.w === panelinfo.virt_w)
            clippanel = chartPanel.add(pv.Panel).left(-hackMargin).right(-hackMargin).height(panelinfo.h).top(panelinfo.y).overflow("hidden").className(panelinfo.className + "-clip").add(pv.Panel).width(panelinfo.w).left(panelinfo.x + hackMargin);
        else if (panelinfo.clip === false && panelinfo.h === panelinfo.virt_h)
            clippanel = chartPanel.add(pv.Panel).top(-hackMargin).bottom(-hackMargin).width(panelinfo.w).left(panelinfo.x).overflow("hidden").className(panelinfo.className + "-clip").add(pv.Panel).height(panelinfo.h).left(panelinfo.start_x || 0).top(panelinfo.y + hackMargin);
        else
            clippanel = chartPanel.add(pv.Panel).width(panelinfo.w).height(panelinfo.h).top(panelinfo.y).left(panelinfo.x).overflow("hidden").className(panelinfo.className + "-clip");
        addScrolling(panelinfo.name, panelinfo);
        var panel = clippanel.add(pv.Panel).overflow("visible").width(panelinfo.virt_w).height(panelinfo.virt_h).className(panelinfo.className);
        panel.computedSize = {
            width: panelinfo.virt_w,
            height: panelinfo.virt_h
        };
        return panel
    }
    ;
    tdgchart.prototype.addScrollGroup = function(parentGroup, panelinfo) {
        var clipG = parentGroup;
        if (panelinfo.clip === false && panelinfo.w === panelinfo.virt_w && panelinfo.h === panelinfo.virt_h)
            clipG = parentGroup;
        else
            clipG = parentGroup.group(panelinfo.className + "-clip", panelinfo.x, panelinfo.y, panelinfo.clip_w || panelinfo.w, panelinfo.clip_h || panelinfo.h, true);
        addScrolling(panelinfo.name, panelinfo);
        var group = clipG.group(panelinfo.className, 0, 0, panelinfo.virt_w, panelinfo.virt_h);
        group.rect(0, 0, panelinfo.virt_w, panelinfo.virt_h, {
            color: "transparent",
            className: "touchScrollCatcher"
        });
        return group
    }
    ;
    function addScrolling(id, panelInfo) {
        if (panelInfo.scroll_h)
            panelInfo.hdir = addScrollingDirection(id + "-h", true, panelInfo.x, panelInfo.w, panelInfo.virt_w, panelInfo);
        if (panelInfo.scroll_v)
            panelInfo.vdir = addScrollingDirection(id + "-v", false, panelInfo.y, panelInfo.h, panelInfo.virt_h, panelInfo)
    }
    function addScrollingDirection(id, isHorizontal, origin, size, virtual_size, panelInfo) {
        var scrollArea = {};
        scrollArea.id = id;
        scrollArea.isHorizontal = isHorizontal;
        scrollArea.bounds = [origin, origin + size - 1];
        scrollArea.offset = 0;
        scrollArea.virtual_size = virtual_size;
        scrollArea.panelInfo = panelInfo;
        if (!scrollArea.panelInfo.dx)
            scrollArea.panelInfo.dx = 0;
        if (!scrollArea.panelInfo.dy)
            scrollArea.panelInfo.dy = 0;
        return scrollArea
    }
    tdgchart.prototype.addScrollBar = function(panel, id, origin, size, ortsize, primaryPanel, attrs) {
        var chart = this;
        var isHorizontal = id !== "vertical" && id.indexOf("-v") === -1;
        var handleSize = size * (isHorizontal ? primaryPanel.w / primaryPanel.virt_w : primaryPanel.h / primaryPanel.virt_h);
        if (handleSize < ortsize) {
            primaryPanel[isHorizontal ? "hdir" : "vdir"].virtual_size *= (size - handleSize) / (size - ortsize);
            handleSize = ortsize
        }
        var start = isHorizontal ? origin.x : origin.y;
        if (!chart.cache.hasKey("scroll_js_scrollbars"))
            chart.cache.set("scroll_js_scrollbars", {});
        var handleOffset = 0;
        if (chart.cache.get("scroll_js_scrollbars")[id]) {
            handleOffset = chart.cache.get("scroll_js_scrollbars")[id].from || (chart.cache.get("scroll_js_scrollbars")[id].fromPercent || 0) * size;
            handleOffset = tdg.bound(handleOffset, 0, size - handleSize)
        }
        var bar = {
            id: id,
            isHorizontal: isHorizontal,
            bounds: [start, start + size - 1],
            handle: [handleOffset, handleOffset + handleSize - 1],
            scrollDirections: []
        };
        var isTDGScene = tdgchart.tdgscene.isTDGSceneGroup(panel);
        if (!isTDGScene)
            bar.root = tdgchart.d3.select("#" + chart.documentRoot);
        chart.cache.get("scroll_js_scrollbars")[id] = bar;
        var dim = {
            x: origin.x,
            y: origin.y,
            length: size,
            thick: ortsize
        };
        bar.boundScrollBar = chart.drawScroll(panel, id, dim, {
            from: 0,
            to: size - 1,
            virt_length: primaryPanel[isHorizontal ? "hdir" : "vdir"].virtual_size
        }, {
            from: bar.handle[0],
            to: bar.handle[1]
        }, scroll_callback, resize_callback, attrs);
        bindScrollPanel(bar, primaryPanel);
        return bar
    }
    ;
    function initPanelTransform(panelInfo, root) {
        root = root.node();
        var e = root.querySelector("g[class=" + panelInfo.className + "]");
        panelInfo.scale = e.transform.baseVal.appendItem(e.ownerSVGElement.createSVGTransform());
        panelInfo.transform = e.transform.baseVal.appendItem(e.ownerSVGElement.createSVGTransform());
        panelInfo.labelScales = [];
        var labels = root.querySelectorAll("g[class=" + panelInfo.className + "] text");
        for (var i = 0; i < labels.length; i++) {
            var lbl = labels[i];
            panelInfo.labelScales[i] = lbl.transform.baseVal.appendItem(lbl.ownerSVGElement.createSVGTransform())
        }
    }
    function scrollAreaTo(panelInfo, root, x, y, isHorizontal) {
        if (panelInfo.g)
            panelInfo.g.moveTo(-x, -y);
        else if (panelInfo.scroll_h_panels || panelInfo.scroll_v_panels)
            if (panelInfo.scroll_h_panels && isHorizontal)
                panelInfo.scroll_h_panels.forEach(function(el) {
                    el.moveBy(panelInfo.dx - x, 0)
                });
            else {
                if (panelInfo.scroll_v_panels && !isHorizontal)
                    panelInfo.scroll_v_panels.forEach(function(el) {
                        el.moveBy(0, panelInfo.dy - y)
                    })
            }
        else {
            if (!panelInfo.transform)
                initPanelTransform(panelInfo, root);
            panelInfo.transform.setTranslate(-x, -y)
        }
        panelInfo.dx = x;
        panelInfo.dy = y
    }
    function resize_callback(id, from, width, isDone) {
        var chart = this;
        scroll_callback.call(this, id, from, isDone);
        var b, panelInfo, root, i;
        var sb = chart.cache.get("scroll_js_scrollbars")[id];
        if (!sb)
            return;
        for (var a = 0; a < sb.scrollDirections.length; a++) {
            var scrollDir = sb.scrollDirections[a];
            if (isDone) {
                sb.from = from;
                sb.width = width;
                chart.cache.preserve("scroll_js_scrollbars");
                chart.redraw();
                continue
            }
            if (scrollDir.isHorizontal) {
                b = sb.bounds[1] - sb.bounds[0] + 1;
                var virt_w = b * b / width;
                panelInfo = scrollDir.scrollInfo.panelInfo;
                panelInfo.p.width(virt_w);
                panelInfo.p.computedSize.width = virt_w;
                if (!panelInfo.transform) {
                    root = tdgchart.d3.select("#" + chart.documentRoot);
                    initPanelTransform(panelInfo, root)
                }
                for (i = 0; i < panelInfo.labelScales.length; i++)
                    panelInfo.labelScales[i].setScale(panelInfo.virt_w / virt_w, 1);
                panelInfo.scale.setScale(virt_w / panelInfo.virt_w, 1)
            } else {
                b = sb.bounds[1] - sb.bounds[0] + 1;
                var virt_h = b * b / width;
                panelInfo = scrollDir.scrollInfo.panelInfo;
                panelInfo.p.height(virt_h);
                panelInfo.p.computedSize.height = virt_h;
                if (!panelInfo.transform) {
                    root = tdgchart.d3.select("#" + chart.documentRoot);
                    initPanelTransform(panelInfo, root)
                }
                for (i = 0; i < panelInfo.labelScales.length; i++)
                    panelInfo.labelScales[i].setScale(1, panelInfo.virt_h / virt_h);
                panelInfo.scale.setScale(1, virt_h / panelInfo.virt_h)
            }
        }
    }
    function scroll_callback(id, pos, doNotScale) {
        var chart = this;
        var sb = chart.cache.get("scroll_js_scrollbars")[id];
        if (!sb)
            return;
        for (var a = 0; a < sb.scrollDirections.length; a++) {
            var scrollDir = sb.scrollDirections[a];
            sb.from = pos;
            sb.width = sb.handle[1] - sb.handle[0] + 1;
            pos = doNotScale ? pos : scrollDir.scale(pos);
            if (scrollDir.isHorizontal)
                scrollAreaTo(scrollDir.scrollInfo.panelInfo, sb.root, pos, scrollDir.scrollInfo.panelInfo.dy, scrollDir.isHorizontal);
            else
                scrollAreaTo(scrollDir.scrollInfo.panelInfo, sb.root, scrollDir.scrollInfo.panelInfo.dx, pos, scrollDir.isHorizontal)
        }
    }
    function bindScrollPanel(bar, panelInfo, isHorizontal) {
        var isHorizontalDirection = isHorizontal != null ? isHorizontal : bar.isHorizontal;
        var scrollDir = isHorizontalDirection ? panelInfo.hdir : panelInfo.vdir;
        if (!bar || !scrollDir)
            return;
        bar.scrollDirections.push({
            scrollInfo: scrollDir,
            isHorizontal: isHorizontalDirection,
            scale: pv.Scale.linear(0, bar.bounds[1] - bar.bounds[0] + 1).range(0, scrollDir.virtual_size)
        })
    }
    tdgchart.prototype.resizeScrollPanel = function(bar, dx) {
        if (bar.isHorizontal && !tdg.eq(dx, 0)) {
            var newVirtSize;
            bar.scrollDirections.forEach(function(el) {
                if (el.isHorizontal) {
                    newVirtSize = el.scrollInfo.virtual_size + dx;
                    el.scale.range(0, newVirtSize);
                    el.scrollInfo.virtual_size = el.scrollInfo.panelInfo.virt_w = newVirtSize
                }
            });
            if (dx < 0 && bar.handle[1] >= newVirtSize)
                return;
            else if (dx > 0 && bar.bounds[1] >= newVirtSize)
                return;
            var handleSize = (bar.bounds[1] + 1) * ((bar.bounds[1] + 1) / newVirtSize) - 1;
            if (bar.from > 0 && dx < 0) {
                var newFrom = bar.from - handleSize + bar.handle[1];
                bar.from = newFrom;
                bar.boundScrollBar.innerBar.start = newFrom;
                bar.boundScrollBar.bar._instance.transform.baseVal.getItem(0).setTranslate(newFrom, 0)
            }
            bar.handle[1] = handleSize;
            bar.boundScrollBar.bar.w = handleSize;
            bar.boundScrollBar.innerBar.width = handleSize;
            bar.boundScrollBar.bar._instance.firstChild.setAttribute("width", handleSize)
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    var _scrollBarColor = {
        border: "rgb(80,80, 80)",
        space: "rgb(240, 240, 240)",
        bar: "rgba(180, 180, 180, 0.5)",
        hoverBar: "rgba(140, 140, 140, 0.5)",
        barborder: "rgb(140, 140, 140)",
        barborderwidth: 0
    };
    function drawMiniChart(chart, panel) {
        var miniChart = new tdgchart;
        var scene = chart.cache.get("tdgscene");
        miniChart.cache.set("tdgscene", scene);
        miniChart.set(chart);
        if (chart.axisList.x1.scroll.miniChartProperties)
            miniChart.set(chart.axisList.x1.scroll.miniChartProperties);
        miniChart.dataSubset = {
            start: null,
            stop: null
        };
        miniChart._isChartSlider = true;
        miniChart.cache.set("axisModes", chart.cache.get("axisModes"));
        miniChart.axisList.y1.labels.visible = false;
        miniChart.axisList.y1.majorGrid.visible = false;
        miniChart.axisList.y1.majorGrid.ticks.visible = false;
        miniChart.axisList.y1.minorGrid.visible = false;
        miniChart.axisList.y1.minorGrid.ticks.visible = false;
        miniChart.axisList.y1.baseLineStyle.color = "transparent";
        miniChart.axisList.y1.bodyLineStyle.color = "transparent";
        miniChart.axisList.x1.majorGrid.visible = false;
        miniChart.axisList.x1.majorGrid.ticks.visible = false;
        miniChart.axisList.x1.minorGrid.visible = false;
        miniChart.axisList.x1.minorGrid.ticks.visible = false;
        miniChart.axisList.x1.labels.visible = false;
        miniChart.axisList.x1.title.visible = false;
        miniChart.setSeriesProperty("dataLabels.visible", false);
        miniChart.enableBehavior("all", false);
        var res = miniChart.trimInvisibleSeries(miniChart.data);
        miniChart._internalData = res.data;
        miniChart._internalData.seriesMap = res.seriesMap;
        miniChart.trendline.enabled = false;
        miniChart.setSeriesProperty("trendline.enabled", false);
        var miniChartSize = panel.computedSize;
        var chartLayout = miniChart.layoutBLAChart(miniChartSize);
        miniChart.drawBLAChart(panel, chartLayout)
    }
    function getBLAscrollRatio(chart, panelSize, barid) {
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        var extendToFrameEdge = chart.blaProperties.extendToFrameEdge && !chart.isBar();
        var length = isHorizontal ? panelSize.height : panelSize.width;
        var padding = chart.getAxisPadding(chart.axisList.x1.inset, length);
        var obligatoryPaddingTotal = padding ? padding[0] + padding[1] : 0;
        var cachedScrollbar = chart.cache.get_or_set("scroll_js_scrollbars", {});
        if (barid && cachedScrollbar && cachedScrollbar[barid]) {
            var width = cachedScrollbar[barid].width;
            if (width != null)
                return length / (width || 1)
        }
        var gc = chart.groupCount() || 1;
        var ratio, forceRatio;
        if (chart.axisList.x1.scroll.initialPosition != undefined) {
            var start = Array.isArray(chart.axisList.x1.scroll.initialPosition) ? chart.axisList.x1.scroll.initialPosition[0] : chart.axisList.x1.scroll.initialPosition;
            var end = Array.isArray(chart.axisList.x1.scroll.initialPosition) ? chart.axisList.x1.scroll.initialPosition[1] : undefined;
            if (start != undefined) {
                var startPercent = tdg.bound(tdg.isPercentString(start) ? tdg.parsePercent(start) : start / gc, 0, 1);
                cachedScrollbar[barid] = cachedScrollbar[barid] || {};
                cachedScrollbar[barid].fromPercent = startPercent;
                if (end != undefined) {
                    var endPercent = tdg.bound(tdg.isPercentString(end) ? tdg.parsePercent(end) : (end + 1) / gc, 0, 1);
                    if (endPercent - startPercent > 0)
                        forceRatio = 1 / (endPercent - startPercent)
                }
            }
        }
        if (extendToFrameEdge)
            gc--;
        var groupWidth = (length - obligatoryPaddingTotal) / gc;
        var groupFit = chart.axisList.x1.groupFit || {};
        if (ratio == undefined && groupFit.rule === "auto" && chart.axisList.x1.scroll.enabled !== false) {
            var ordLabelSize = 0;
            if (chart.axisList.x1.labels.rotation === 0) {
                var labels = chart.getOriginalGroupLabels();
                for (var i = 0; i < labels.length; i++)
                    ordLabelSize += chart.measureLabel(labels[i], chart.axisList.x1.labels.font).width;
                ordLabelSize = ordLabelSize / labels.length
            } else
                ordLabelSize = tdg.measureFont(chart.axisList.x1.labels.font).height;
            var virtLength = (ordLabelSize + 5) * gc;
            if (virtLength + obligatoryPaddingTotal > length)
                ratio = (virtLength + obligatoryPaddingTotal) / length
        }
        var groupSizeRequired;
        if (ratio == undefined)
            if (groupFit.rule === "labelHeight") {
                groupSizeRequired = tdg.measureFont(chart.get("axisList.x1.labels.font")).height;
                groupSizeRequired += groupFit.value ? tdg.applyNumOrPercent(groupFit.value, groupSizeRequired) : 3;
                ratio = Math.max(1, (groupSizeRequired * gc + obligatoryPaddingTotal) / length)
            } else {
                groupSizeRequired = tdg.applyNumOrPercent(groupFit.value, length);
                if ((groupFit.rule === "minSize" || groupFit.rule === "exactSize") && groupWidth < groupSizeRequired)
                    ratio = (groupSizeRequired * gc + obligatoryPaddingTotal) / length;
                else if (groupFit.rule === "maxCount" && gc > groupFit.value)
                    ratio = gc / (groupFit.value - (extendToFrameEdge ? 1 : 0))
            }
        if (ratio == undefined && chart.axisList.x1.scroll.enabled === true)
            ratio = gc < 2 ? 2 : gc / (gc - 1);
        if (!ratio)
            return 1;
        else
            return forceRatio || ratio
    }
    tdgchart.prototype.getScrollParams = function(chart, panelSize, axisInset) {
        var scrollPossible = ["pareto", "waterfall", "boxplot", "heatmap", "histogram"];
        if (!(chart.isBLA() || scrollPossible.indexOf(chart.chartType) >= 0) || chart._isChartSlider)
            return {
                enabled: false
            };
        if (chart.chartFrame.aspectRatio)
            return {
                enabled: false
            };
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        var scrollParams = {
            enabled: true,
            buttonsSize: 0
        };
        var isMiniScroll = chart.isScrollMiniChart(chart.axisList.x1);
        var barid = isMiniScroll ? "slider-h" : isHorizontal ? "rp-v" : "rp-h";
        scrollParams.ratio = getBLAscrollRatio(chart, panelSize, barid);
        if (scrollParams.ratio === 1 && !isMiniScroll)
            return {
                enabled: false
            };
        if (!chart.axisList.x1.scroll.enabled)
            scrollParams.noScrollBar = true;
        scrollParams.view = {
            width: panelSize.width,
            height: panelSize.height
        };
        if (isHorizontal)
            scrollParams.virt = {
                width: panelSize.width,
                height: panelSize.height * scrollParams.ratio
            };
        else
            scrollParams.virt = {
                width: panelSize.width * scrollParams.ratio,
                height: panelSize.height
            };
        if (!isMiniScroll)
            scrollParams.size = 15;
        else {
            if (chart.axisList.x1.scroll.miniChartProperties && chart.axisList.x1.scroll.miniChartProperties.height) {
                var height = chart.axisList.x1.scroll.miniChartProperties.height;
                height = tdg.applyNumOrPercent(height, panelSize.height);
                scrollParams.size = Math.min(height, panelSize.height / 2)
            } else
                scrollParams.size = panelSize.height / 5;
            if (chart.axisList.x1.scroll.intervalButtons) {
                var buttons = getAxisScrollButtons(chart);
                scrollParams.buttonsSize += buttons.maxSize.height
            }
        }
        if (scrollParams.noScrollBar)
            scrollParams.size = 0;
        else if (axisInset) {
            scrollParams.position = {
                x: 0,
                y: 0
            };
            if (chart.isScrollMiniChart(chart.axisList.x1))
                scrollParams.position.y = scrollParams.view.height + axisInset.bottom - scrollParams.size;
            else if (isHorizontal)
                scrollParams.position.x = scrollParams.view.width + axisInset.right - scrollParams.size - 5;
            else {
                var axisSize = axisInset.bottom || 15;
                scrollParams.position.y = panelSize.height + axisSize + chart.getPadding("label", "aveVert") - scrollParams.size - 5
            }
        }
        return scrollParams
    }
    ;
    tdgchart.prototype.drawScroll = function(panel, id, dim, range, handlepos, callback, resize_callback, attrs) {
        var chart = this;
        chart.cache.set("haveScrollBars", true);
        var isSlider = id.indexOf("slider") === 0;
        var isHoriz = id !== "vertical" && id.indexOf("-v") === -1;
        var x = dim.x
          , y = dim.y
          , length = dim.length
          , thick = dim.thick;
        var w = isHoriz ? length : thick;
        var h = isHoriz ? thick : length;
        var isTDGScene = tdgchart.tdgscene.isTDGSceneGroup(panel);
        var scrollFrame;
        attrs = attrs || {};
        if (isTDGScene)
            panel.rect(x, y, w, h, {
                lineWidth: 0,
                border: attrs.cborder || _scrollBarColor.cborder
            });
        else
            scrollFrame = panel.add(pv.Panel).left(x).top(y).width(w).height(h).lineWidth(0).strokeStyle(attrs.cborder || _scrollBarColor.cborder).antialias(false);
        var _margin_off_scroll = 0
          , _margin_sides = 0;
        var wpad = isHoriz ? _margin_off_scroll : _margin_sides;
        var hpad = isHoriz ? _margin_sides : _margin_off_scroll;
        var scrollBarSpace, scrollBarSpaceRect;
        if (isTDGScene) {
            scrollBarSpace = panel.group("scrollBarSpace", x + wpad, y + hpad, w - 2 * wpad, h - 2 * hpad);
            scrollBarSpaceRect = scrollBarSpace.rect(0, 0, scrollBarSpace.w, scrollBarSpace.h, {
                color: attrs.space || _scrollBarColor.space
            })
        } else {
            scrollBarSpace = scrollFrame.add(pv.Panel).left(wpad).right(wpad).top(hpad).bottom(hpad).className("scrollBarSpace").events("all").antialias(false);
            if (isSlider) {
                scrollBarSpace.computedSize = {
                    width: w - 2 * (isHoriz ? _margin_off_scroll : _margin_sides),
                    height: h - 2 * (isHoriz ? _margin_sides : _margin_off_scroll),
                    x: 0,
                    y: 0
                };
                drawMiniChart(chart, scrollBarSpace)
            } else
                scrollBarSpace.fillStyle(attrs.space || _scrollBarColor.space)
        }
        var scrollSize = length - 2 * _margin_off_scroll;
        var scrollBar = {};
        if (isTDGScene) {
            var x1 = isHoriz ? handlepos.from : 0;
            var y1 = isHoriz ? 0 : handlepos.from;
            var x2 = isHoriz ? handlepos.to : w - 2 * wpad;
            var y2 = isHoriz ? h - 2 * hpad : handlepos.to;
            scrollBar.bar = scrollBarSpace.group("scroll-" + id, 0, 0, x2 - x1, y2 - y1);
            var props = {
                color: attrs.bar || _scrollBarColor.bar,
                lineWidth: attrs.barborderwidth || _scrollBarColor.barborderwidth,
                border: attrs.barborder || _scrollBarColor.barborder,
                cursor: "pointer"
            };
            scrollBar.bar.rect(0, 0, scrollBar.bar.w, scrollBar.bar.h, props)
        } else {
            scrollBar.bar = scrollBarSpace.add(pv.Panel).left(isHoriz ? 0 : null).width(isHoriz ? handlepos.to - handlepos.from : null).top(!isHoriz ? handlepos.from : null).bottom(!isHoriz ? scrollSize - handlepos.to : null).className("scroll-" + id).fillStyle(isSlider ? "rgba(128,128,128,0.5)" : "grey").lineWidth(attrs.barborderwidth || _scrollBarColor.barborderwidth).strokeStyle(attrs.barborder || _scrollBarColor.barborder).cursor("pointer").antialias(false);
            if (isSlider) {
                scrollBar.edgeR = scrollBarSpace.add(pv.Panel).left(isHoriz ? handlepos.to - handlepos.from - 3 : null).width(isHoriz ? 3 : null).top(!isHoriz ? handlepos.from : null).bottom(!isHoriz ? scrollSize - handlepos.to : null).className("scroll-r-" + id).cursor(isHoriz ? "ew-resize" : "ns-resize");
                scrollBar.edgeL = scrollBarSpace.add(pv.Panel).left(isHoriz ? 0 : null).width(isHoriz ? 3 : null).top(!isHoriz ? handlepos.from : null).bottom(!isHoriz ? scrollSize - handlepos.to : null).className("scroll-l-" + id).cursor(isHoriz ? "ew-resize" : "ns-resize")
            }
        }
        if (isTDGScene)
            addScrollInteractionTDGScene(chart, isHoriz, scrollBarSpaceRect, scrollBar, id, range, handlepos, callback, resize_callback, attrs);
        else
            addScrollInteraction(panel, chart, isHoriz, scrollBarSpace, scrollBar, id, range, handlepos, callback, resize_callback, attrs);
        return scrollBar
    }
    ;
    var scrolling_now, highlighting_now, bar_resizing_now;
    tdgchart.prototype.isScrolling = function() {
        return scrolling_now != null || highlighting_now != null
    }
    ;
    tdgchart.prototype.isScrollBar = function(target) {
        if (target) {
            if (target.parentNode.className === "scrollBarSpace" || target.parentNode.className.baseVal === "scrollBarSpace")
                return true;
            if (target.parentNode.parentNode.className === "scrollBarSpace" || target.parentNode.parentNode.className.baseVal === "scrollBarSpace")
                return true
        }
        return false
    }
    ;
    var time_presets = [{
        name: "second",
        interval: "seconds",
        seconds: 1
    }, {
        name: "minute",
        interval: "minutes",
        seconds: 60
    }, {
        name: "hour",
        interval: "hours",
        seconds: 3600
    }, {
        name: "day",
        interval: "days",
        seconds: 24 * 3600
    }, {
        name: "week",
        interval: "weeks",
        seconds: 7 * 24 * 3600
    }, {
        name: "30 days",
        interval: "months",
        seconds: 30 * 24 * 3600
    }, {
        name: "year",
        interval: "years",
        seconds: 365.25 * 24 * 3600
    }, {
        name: "3 years",
        interval: null,
        seconds: 3 * 365.25 * 24 * 3600
    }, {
        name: "5 years",
        interval: null,
        seconds: 5 * 365.25 * 24 * 3600
    }, {
        name: "10 years",
        interval: null,
        seconds: 10 * 365.25 * 24 * 3600
    }, {
        name: "25 years",
        interval: null,
        seconds: 25 * 365.25 * 24 * 3600
    }, {
        name: "50 years",
        interval: null,
        seconds: 50 * 365.25 * 24 * 3600
    }, {
        name: "100 years",
        interval: null,
        seconds: 100 * 365.25 * 24 * 3600
    }];
    function getAxisScrollButtons(chart) {
        var i, buttons = {
            list: [],
            maxSize: {
                width: 0,
                height: 0
            }
        };
        if (!chart.axisList.x1.scroll.intervalButtons)
            return buttons;
        if (chart.axisList.x1.scroll.intervalButtons === "auto")
            buttons.list = addAutoTimeButtons(chart);
        else
            for (i = 0; i < chart.axisList.x1.scroll.intervalButtons.length; i++) {
                var b = chart.axisList.x1.scroll.intervalButtons[i];
                var label = b.label || {
                    text: "Button"
                };
                buttons.list.push({
                    name: label.text,
                    groups: b.groupCount,
                    bgcolor: b.fill,
                    textcolor: label.color,
                    font: label.font
                })
            }
        var list = buttons.list.length ? buttons.list : time_presets;
        for (i = 0; i < list.length; i++) {
            var s = chart.measureLabel(list[i].name, list[i].font);
            buttons.maxSize.width = Math.max(buttons.maxSize.width, s.width);
            buttons.maxSize.height = Math.max(buttons.maxSize.height, s.height)
        }
        return buttons
    }
    function addAxisScrollButtons(panel, chart, range, scroll_id, cb) {
        var buttons = getAxisScrollButtons(chart);
        if (buttons.list.length) {
            var renderCompleteFunctions = chart.cache.get("scroll_onRenderComplete");
            renderCompleteFunctions.buttons = addButtons
        }
        var useSeries = false;
        var gc = useSeries ? chart.seriesCount() : chart.groupCount();
        var group_width = (range.to - range.from) / gc;
        var max_width = group_width * gc;
        function addButtons() {
            var root = chart.cache.get_or_set("root", tdgchart.d3.select("#" + chart.documentRoot));
            var chartPanel = root.select("g[class=chartPanel]").node();
            var button_h = buttons.maxSize.height;
            var button_w = buttons.maxSize.width + 10;
            var menu_w = (button_w + 2) * buttons.list.length + 4;
            var menu_h = button_h + 4;
            var menu = createSVG("g", {
                id: "menu",
                transform: "translate(" + (panel.parent.computedSize.width - menu_w - 1) + "," + (panel.parent.computedSize.height - menu_h - 1) + ")"
            });
            var bg = createSVG("rect", {
                rx: 5,
                width: menu_w,
                height: menu_h
            });
            menu.appendChild(bg);
            chartPanel.appendChild(menu);
            for (var i = 0; i < buttons.list.length; i++) {
                var btn = buttons.list[i];
                var b = createButton(2 + i * (button_w + 2), 2, button_w, button_h, btn.name, cb, Math.min((btn.groups || gc) * group_width, max_width), btn.bgcolor, btn.textcolor, btn.font);
                menu.appendChild(b)
            }
        }
    }
    function addAutoTimeButtons(chart) {
        var ta = chart.axisList.x1.timeAxis;
        var interval = chart.axisList.x1.timeAxis.interval || chart.cache.get("xaxis_time_interval");
        var useSeries = false;
        var gc = useSeries ? chart.seriesCount() : chart.groupCount();
        var presets = [];
        if (!interval)
            return presets;
        var start = Date.parse(ta.startTime);
        var stop = Date.parse(ta.stopTime);
        var span = (stop.getTime() - start.getTime()) / 1E3;
        var interval_time;
        for (var i = 0, on = false; i < time_presets.length && span > time_presets[i].seconds; i++) {
            if (interval === time_presets[i].interval) {
                interval_time = time_presets[i].seconds;
                span = interval_time * gc
            }
            if (time_presets[i].seconds >= interval_time * 3)
                on = true;
            if (on) {
                time_presets[i].groups = time_presets[i].seconds / interval_time;
                presets.push(time_presets[i])
            }
        }
        return presets
    }
    function createButton(x, y, w, h, name, cb, value, bgcolor, textcolor, font) {
        bgcolor = bgcolor || "#bbb";
        textcolor = textcolor || "#000";
        font = "font: " + font || "";
        var g = createSVG("g", {
            transform: "translate(" + x + "," + y + ")"
        });
        var button = createSVG("rect", {
            rx: 5,
            fill: bgcolor,
            width: w,
            height: h
        });
        var text = createSVG("text", {
            x: w / 2,
            y: h / 2 + 1,
            fill: textcolor,
            style: "text-anchor: middle; alignment-baseline: middle;" + font
        }, name);
        text.setAttribute("pointer-events", "none");
        g.appendChild(button);
        g.appendChild(text);
        var dg = tdgchart.d3.select(button);
        dg.on("mouseover", function() {
            this.setAttribute("fill", "#999")
        });
        dg.on("mouseout", function() {
            this.setAttribute("fill", bgcolor)
        });
        dg.on("click", function() {
            cb(value)
        });
        g.setAttribute("pointer-events", "all");
        return g
    }
    function addScrollInteraction(panel, chart, isHoriz, scrollBarSpace, scrollBar, scroll_id, range, handlepos, callback, resize_callback, attrs) {
        var svg = chart.cache.get_or_set("svg", document.createElementNS("http://www.w3.org/2000/svg", "svg"));
        var root = chart.cache.get_or_set("root", tdgchart.d3.select("#" + chart.documentRoot));
        var bar = {
            start: 0,
            width: handlepos.to - handlepos.from
        };
        var currentValue;
        var oldwidth = bar.width
          , oldoldwidth = bar.width;
        var singleGroupWidth = (range.to - range.from) / chart.groupCount();
        var renderCompleteFunctions = chart.cache.get("scroll_onRenderComplete");
        if (!renderCompleteFunctions) {
            renderCompleteFunctions = chart.cache.set("scroll_onRenderComplete", {});
            var onRenderComplete = function() {
                for (var f in renderCompleteFunctions)
                    if (renderCompleteFunctions.hasOwnProperty(f) && typeof renderCompleteFunctions[f] === "function")
                        renderCompleteFunctions[f]();
                var chart = this;
                if (chart && !tdg.isEmpty(chart._callbackList)) {
                    var idx = chart._callbackList.map(function(el) {
                        return el.callback
                    }).indexOf(onRenderComplete);
                    if (idx >= 0)
                        chart._callbackList.splice(idx, 1)
                }
            };
            chart.registerEvent(onRenderComplete, "renderComplete")
        }
        if (chart.axisList.x1.scroll.miniChartProperties && chart.axisList.x1.scroll.miniChartProperties.dataSelection && chart.axisList.x1.scroll.miniChartProperties.dataSelection.selectionRect) {
            _scrollBarColor.bar = chart.axisList.x1.scroll.miniChartProperties.dataSelection.selectionRect.fill;
            _scrollBarColor.hoverBar = chart.axisList.x1.scroll.miniChartProperties.dataSelection.selectionRect.fill
        }
        renderCompleteFunctions["init." + scroll_id] = function() {
            initScroll(scroll_id)
        }
        ;
        function initScroll(scroll_id) {
            if (!scrollBar.bar.t) {
                scrollBar.bar.t = root.select("g[class=scroll-" + scroll_id + "]")[0][0].transform.baseVal.appendItem(svg.createSVGTransform());
                if (scrollBar.edgeR)
                    scrollBar.edgeR.t = root.select("g[class=scroll-r-" + scroll_id + "]")[0][0].transform.baseVal.appendItem(svg.createSVGTransform());
                if (scrollBar.edgeL)
                    scrollBar.edgeL.t = root.select("g[class=scroll-l-" + scroll_id + "]")[0][0].transform.baseVal.appendItem(svg.createSVGTransform())
            }
        }
        if (handlepos.from)
            renderCompleteFunctions["barstart_" + scroll_id] = function() {
                bar.start = handlepos.from;
                moveBar(bar.start);
                updateMaster(bar.start);
                renderCompleteFunctions["barstart_" + scroll_id] = null
            }
            ;
        else
            renderCompleteFunctions["barstart_" + scroll_id] = null;
        chart.globalMouseUpAdd(onMouseUp, "addScrollInteraction");
        chart.globalMouseMoveAdd(onMouseMove, "addScrollInteraction");
        if (chart.axisList.x1.scroll.intervalButtons && chart.isScrollMiniChart(chart.axisList.x1))
            addAxisScrollButtons(panel, chart, range, scroll_id, buttonResize_handler);
        function get_mouse(isHoriz, event) {
            if (event)
                return isHoriz ? event.x : event.y;
            else if (pv.event)
                if (isHoriz)
                    return pv.event.x != null ? pv.event.x : pv.event.clientX;
                else
                    return pv.event.y != null ? pv.event.y : pv.event.clientY;
            return 0
        }
        function moveBar(to) {
            if (isHoriz) {
                scrollBar.bar.t.setTranslate(to, 0);
                if (scrollBar.edgeR)
                    scrollBar.edgeR.t.setTranslate(to, 0);
                if (scrollBar.edgeL)
                    scrollBar.edgeL.t.setTranslate(to, 0)
            } else {
                scrollBar.bar.t.setTranslate(0, to);
                if (scrollBar.edgeR)
                    scrollBar.edgeR.t.setTranslate(0, to);
                if (scrollBar.edgeL)
                    scrollBar.edgeL.t.setTranslate(0, to)
            }
        }
        function scrollHandler() {
            var start = bar.start + get_mouse(isHoriz) - scrolling_now.mouse_offset;
            scrolling_now.start = Math.max(Math.min(start, range.to - bar.width), range.from);
            moveBar(scrolling_now.start);
            updateMaster(scrolling_now.start)
        }
        scrollBar.bar.touchScroll = function(dt, start_offset) {
            var start = bar.start + dt - start_offset;
            start = tdg.bound(start, range.from, (range.to - bar.width) * (range.virt_length / range.to));
            moveBar(start / (range.virt_length / range.to));
            updateMaster(start, true);
            return start
        }
        ;
        function scrollEndHandler(start) {
            start = start == null ? scrolling_now.start : start;
            updateMaster(start, false);
            if (start != null)
                bar.start = start;
            chart._disableHover = chart._disableToolTips = false;
            chart.__refreshMarkerList = true
        }
        scrollBar.bar.touchScrollEnd = scrollEndHandler;
        function updateMaster(start, doNotScale) {
            var value = start != null ? start : bar.start;
            if (value !== currentValue) {
                callback.call(chart, scroll_id, value, doNotScale);
                currentValue = value
            }
        }
        function updateMasterResize(start, width, isDone) {
            if (isDone)
                if (width !== oldoldwidth) {
                    resize_callback.call(chart, scroll_id, start, width, isDone);
                    oldoldwidth = oldwidth = width
                } else if (width !== oldwidth) {
                    resize_callback.call(chart, scroll_id, start, width);
                    oldwidth = width
                } else
                    updateMaster(start);
            else if (width !== oldwidth) {
                resize_callback.call(chart, scroll_id, start, width);
                oldwidth = width
            }
        }
        var now = {
            scrollBar: scrollBar,
            onEnd: scrollEndHandler
        };
        var _highlightVal = 0;
        function highlight(e, on) {
            if (on) {
                _highlightVal++;
                if (_highlightVal === 1) {
                    scrollBar.bar.fillStyle(attrs.hoverBar || _scrollBarColor.hoverBar);
                    highlighting_now = now
                }
            } else {
                _highlightVal--;
                if (_highlightVal === 0) {
                    scrollBar.bar.fillStyle(attrs.bar || _scrollBarColor.bar);
                    highlighting_now = null
                }
            }
            scrollBar.bar.render()
        }
        now.highlight = highlight;
        scrollBar.bar.def("fillStyle", attrs.bar || _scrollBarColor.bar).event("mouseover", function() {
            highlight(this, true)
        }).event("mouseout", function() {
            highlight(this, false)
        }).event("mousedown", function(event) {
            if (chart._disableScroll)
                return;
            highlight(this, true);
            chart._disableHover = chart._disableToolTips = true;
            now.mouse_offset = get_mouse(isHoriz, event);
            scrolling_now = now;
            pv.Behavior.pan().call(this)
        }).event("touchstart", pv.Behavior.pan()).event("pan", scrollHandler);
        if (isHoriz) {
            if (scrollBar.edgeR)
                scrollBar.edgeR.def("fillStyle", "rgba(0,255,0,0.01)").event("mouseover", function() {
                    highlight(this, true)
                }).event("mouseout", function() {
                    highlight(this, false)
                }).event("mousedown", function() {
                    if (chart._disableScroll)
                        return;
                    var t = scrollBar.bar.transform();
                    var offset = isHoriz ? pv.event.x - scrollBar.bar.mouse().x - t.x : pv.event.y - scrollBar.bar.mouse().y - t.y;
                    selection_start("to", bar.start, bar.start + bar.width, offset)
                });
            if (scrollBar.edgeL)
                scrollBar.edgeL.def("fillStyle", "rgba(255,0,0,0.01)").event("mouseover", function() {
                    highlight(this, true)
                }).event("mouseout", function() {
                    highlight(this, false)
                }).event("mousedown", function() {
                    if (chart._disableScroll)
                        return;
                    var t = scrollBar.bar.transform();
                    var offset = isHoriz ? pv.event.x - scrollBar.bar.mouse().x - t.x : pv.event.y - scrollBar.bar.mouse().y - t.y;
                    selection_start("from", bar.start, bar.start + bar.width, offset)
                })
        }
        function scroll_one_page() {
            var click_pos = isHoriz ? this.mouse().x : this.mouse().y;
            var w = handlepos.to - handlepos.from;
            var start = bar.start;
            if (click_pos < bar.start)
                start -= w;
            else if (click_pos > bar.start + w)
                start += w;
            start = Math.max(Math.min(start, range.to - bar.width), range.from);
            moveBar(start);
            updateMaster(start);
            scrollEndHandler(start)
        }
        var isResizing = false;
        function selection_start_new_selection() {
            if (chart._disableScroll)
                return;
            var click_pos = isHoriz ? this.mouse().x : this.mouse().y;
            selection_start("to", click_pos, click_pos, (isHoriz ? pv.event.x : pv.event.y) - click_pos)
        }
        function selection_start(resize_side, from, to, mouseoffset) {
            if (chart._disableScroll)
                return;
            isResizing = true;
            bar_resizing_now = {
                scrollSpace: scrollBar,
                onResize: selection_resize_handler,
                onEnd: selection_end,
                side: resize_side,
                mouse_offset: mouseoffset,
                from: from,
                to: to,
                highlight: highlight
            };
            highlight(scrollBar.bar, true);
            chart._disableHover = chart._disableToolTips = true
        }
        function buttonResize_handler(width) {
            barResize(null, width, true)
        }
        function barResize(from, width, isDone) {
            if (width < 2)
                width = oldwidth;
            if (isDone && width < singleGroupWidth * 2)
                width = Math.min(singleGroupWidth * 2, range.to - range.from);
            if (from == null)
                from = bar.start;
            from = Math.min(range.to - width, from);
            moveBar(from);
            if (isHoriz) {
                scrollBar.bar.width(width);
                if (scrollBar.edgeR)
                    scrollBar.edgeR.left(width - 3)
            } else {
                scrollBar.bar.height(width);
                if (scrollBar.edgeR)
                    scrollBar.edgeR.height(width - 3)
            }
            scrollBar.bar.render();
            if (scrollBar.edgeR)
                scrollBar.edgeR.render();
            updateMasterResize(from, width, isDone);
            bar.start = from;
            bar.width = width
        }
        function selection_resize_handler(event) {
            if (!isResizing)
                return;
            if (!event)
                event = pv.event;
            var click_pos = (isHoriz ? event.x : event.y) - bar_resizing_now.mouse_offset;
            bar_resizing_now[bar_resizing_now.side] = Math.max(range.from, Math.min(range.to, click_pos));
            var w = Math.abs(bar_resizing_now.from - bar_resizing_now.to);
            var f = Math.min(bar_resizing_now.from, bar_resizing_now.to);
            barResize(f, w)
        }
        function selection_end() {
            if (!isResizing)
                return;
            isResizing = false;
            var f = Math.min(bar_resizing_now.from, bar_resizing_now.to);
            highlight(this, false);
            barResize(f, bar.width, true);
            chart._disableHover = chart._disableToolTips = false;
            chart.__refreshMarkerList = true
        }
        var i = chart.interaction;
        if (chart.chartType !== "matrix" && (i.touchDrag === "pan" || i.longTouchDrag === "pan")) {
            panel.events("all");
            chart._postProcessCallbacks.push(function() {
                var root = tdgchart.d3.select("#" + chart.documentRoot);
                var svgNode = root.select("svg").node();
                var downPt, lastScroll;
                function touchStart() {
                    chart.hideHoverNode();
                    chart.hideToolTip();
                    downPt = tdg.getMouseInViewPort(svgNode, tdgchart.d3.event)
                }
                function touchMove() {
                    tdgchart.d3.event.preventDefault();
                    if (downPt == null)
                        return;
                    var upPt = tdg.getMouseInViewPort(svgNode, tdgchart.d3.event);
                    if (isHoriz)
                        lastScroll = scrollBar.bar.touchScroll(downPt.x, upPt.x);
                    else
                        lastScroll = scrollBar.bar.touchScroll(downPt.y, upPt.y)
                }
                function touchEnd() {
                    downPt = null;
                    scrollBar.bar.touchScrollEnd(lastScroll)
                }
                if (i.touchDrag === "pan" || i.touchDrag === "select" && !chart.previewSelection.enabled && !chart.dataSelection.enabled)
                    chart.registerShortDrag(root.select(".chartPanel"), touchStart, touchMove, touchEnd, chart.documentRoot + "_" + scroll_id);
                if (i.longTouchDrag === "pan")
                    chart.registerLongDrag(root.select(".chartPanel"), touchStart, touchMove, touchEnd, chart.documentRoot + "_" + scroll_id)
            })
        }
        if (scroll_id && scroll_id.includes("slider"))
            scrollBarSpace.event("mousedown", selection_start_new_selection);
        else
            scrollBarSpace.event("click", scroll_one_page)
    }
    function addScrollInteractionTDGScene(chart, isHoriz, scrollBarSpace, scrollBar, scroll_id, range, handlepos, callback, resize_callback, attrs) {
        var bar = {
            start: 0,
            width: handlepos.to - handlepos.from
        };
        var now = {
            scrollBar: scrollBar,
            onMove: scrollHandler,
            onEnd: scrollEndHandler
        };
        var currentValue;
        scrollBar.innerBar = bar;
        var renderCompleteFunctions = chart.cache.get("scroll_onRenderComplete");
        if (!renderCompleteFunctions) {
            renderCompleteFunctions = chart.cache.set("scroll_onRenderComplete", {});
            var onRenderComplete = function() {
                for (var f in renderCompleteFunctions)
                    if (renderCompleteFunctions.hasOwnProperty(f) && typeof renderCompleteFunctions[f] === "function")
                        renderCompleteFunctions[f]();
                var chart = this;
                if (chart && !tdg.isEmpty(chart._callbackList)) {
                    var idx = chart._callbackList.map(function(el) {
                        return el.callback
                    }).indexOf(onRenderComplete);
                    if (idx >= 0)
                        chart._callbackList.splice(idx, 1)
                }
            };
            chart.registerEvent(onRenderComplete, "renderComplete")
        }
        if (chart.axisList.x1.scroll.miniChartProperties.dataSelection && chart.axisList.x1.scroll.miniChartProperties.dataSelection.selectionRect) {
            _scrollBarColor.bar = chart.axisList.x1.scroll.miniChartProperties.dataSelection.selectionRect.fill;
            _scrollBarColor.hoverBar = chart.axisList.x1.scroll.miniChartProperties.dataSelection.selectionRect.fill
        }
        if (handlepos.from)
            renderCompleteFunctions["barstart_" + scroll_id] = function() {
                bar.start = handlepos.from;
                moveBar(bar.start);
                updateMaster(bar.start);
                renderCompleteFunctions["barstart_" + scroll_id] = null
            }
            ;
        else
            renderCompleteFunctions["barstart_" + scroll_id] = null;
        renderCompleteFunctions["addTouch_" + scroll_id] = function(bar, now) {
            var scrolling_now;
            return function() {
                var root = document.getElementById(chart.documentRoot);
                var touchGroups = root.getElementsByClassName("touchScrollCatcher")[0].parentNode;
                touchGroups = tdgchart.d3.select(touchGroups);
                function touchStart(d, data, e) {
                    e = tdg.getMousePosition(e);
                    chart._disableHover = chart._disableToolTips = true;
                    now.mouse_offset = isHoriz ? e.x : e.y;
                    now.start = bar.start;
                    scrolling_now = now
                }
                function touchMove(d, data, e) {
                    e.preventDefault();
                    e = tdg.getMousePosition(e);
                    var start = bar.start - (isHoriz ? e.x : e.y) + scrolling_now.mouse_offset;
                    if (start < range.from) {
                        scrolling_now.mouse_offset -= start;
                        return
                    } else if (start > range.virt_length - range.to) {
                        scrolling_now.mouse_offset -= start - range.virt_length + range.to;
                        return
                    }
                    start = Math.max(range.from, Math.min(start, range.virt_length - range.to));
                    scrolling_now.start = start;
                    moveBar(start * range.to / range.virt_length);
                    callback.call(chart, scroll_id, start, true)
                }
                function touchEnd() {
                    bar.start = scrolling_now.start;
                    callback.call(chart, scroll_id, scrolling_now.start, true);
                    chart._disableHover = chart._disableToolTips = false
                }
                chart.registerShortDrag(touchGroups, touchStart, touchMove, touchEnd, scroll_id)
            }
        }(bar, now);
        chart.globalMouseUpAdd(onMouseUp, "addScrollInteraction");
        chart.globalMouseMoveAdd(onMouseMove, "addScrollInteraction");
        function moveBar(to) {
            if (isHoriz)
                scrollBar.bar.moveTo(to, 0);
            else
                scrollBar.bar.moveTo(0, to)
        }
        function scrollHandler(e) {
            e = tdg.getMousePosition(e);
            var start = bar.start + (isHoriz ? e.x : e.y) - scrolling_now.mouse_offset;
            scrolling_now.start = Math.max(range.from, Math.min(start, range.to - bar.width));
            moveBar(scrolling_now.start);
            updateMaster(scrolling_now.start);
            tdgchart.d3.event.preventDefault()
        }
        function scrollEndHandler() {
            scrollEnd(scrolling_now.start)
        }
        function scrollEnd(barstart) {
            updateMaster(barstart);
            if (barstart != null)
                bar.start = barstart;
            chart._disableHover = chart._disableToolTips = false
        }
        function updateMaster(start) {
            var value = start != null ? start : bar.start;
            if (value !== currentValue) {
                callback.call(chart, scroll_id, value, false);
                currentValue = value
            }
        }
        var _highlightVal = 0;
        function highlight(e, on) {
            if (on) {
                _highlightVal++;
                if (_highlightVal === 1) {
                    scrollBar.bar.color(attrs.hoverBar || _scrollBarColor.hoverBar);
                    highlighting_now = now
                }
            } else {
                _highlightVal--;
                if (_highlightVal === 0) {
                    scrollBar.bar.color(attrs.bar || _scrollBarColor.bar);
                    highlighting_now = null
                }
            }
        }
        now.highlight = highlight;
        scrollBar.bar.interaction.events.mouseover = function() {
            highlight(this, true)
        }
        ;
        scrollBar.bar.interaction.events.mouseout = function() {
            highlight(this, false)
        }
        ;
        scrollBar.bar.interaction.events.mousedown = function mouseDown(element, pointer) {
            highlight(this, true);
            chart._disableHover = chart._disableToolTips = true;
            now.mouse_offset = isHoriz ? pointer.x : pointer.y;
            now.start = bar.start;
            scrolling_now = now
        }
        ;
        scrollBarSpace.interaction.events.click = function(element, pointer) {
            var click_pos = isHoriz ? pointer.relX : pointer.relY;
            var w = handlepos.to - handlepos.from;
            var shift = 0;
            if (click_pos < bar.start)
                shift = -w;
            else if (click_pos > bar.start + w)
                shift = w;
            if (shift) {
                bar.start = Math.max(Math.min(bar.start + shift, range.to - bar.width), range.from);
                moveBar(bar.start);
                scrollEnd(bar.start)
            }
        }
    }
    function onMouseUp(event) {
        if (scrolling_now) {
            scrolling_now.highlight(scrolling_now.scrollBar, false);
            scrolling_now.onEnd()
        } else if (bar_resizing_now) {
            bar_resizing_now.onResize(event);
            bar_resizing_now.onEnd(event)
        } else if (highlighting_now)
            highlighting_now.highlight(highlighting_now.scrollBar, false);
        scrolling_now = null;
        bar_resizing_now = null
    }
    function onMouseMove(event) {
        if (scrolling_now && scrolling_now.onMove)
            scrolling_now.onMove(event);
        else if (bar_resizing_now)
            bar_resizing_now.onResize(event)
    }
    function createSVG(tag, attrs, text) {
        var node = document.createElementNS(tdg.ns.svg, tag);
        for (var attr in attrs)
            if (attrs.hasOwnProperty(attr))
                node.setAttribute(attr, attrs[attr]);
        if (text != null) {
            var textNode = document.createTextNode(text);
            node.appendChild(textNode)
        }
        return node
    }
    tdgchart.prototype.isScrollMiniChart = function(axis) {
        return axis.scroll && axis.scroll.enabled && axis.scroll.style === "miniChart" && this.blaProperties.orientation === "vertical"
    }
}
)();
(function() {
    var re = "";
    var chart;
    function setRiserColor(s, g, color) {
        if (chart.getColorMode() === "byGroup") {
            var tmp = s;
            s = g;
            g = tmp
        }
        var sg = chart.getSeriesAndGroup(s, g);
        if (sg)
            sg.color = color;
        else
            chart.series.push({
                series: s,
                group: g,
                color: color
            })
    }
    function clearRiserColor(s, g) {
        if (chart.getColorMode() === "byGroup") {
            var tmp = s;
            s = g;
            g = tmp
        }
        var sg = chart.getSeriesAndGroup(s, g);
        if (sg)
            chart.series.splice(chart.series.indexOf(sg), 1)
    }
    function update(clear) {
        var i, j;
        if (chart.filter.mode === "series") {
            var groupCount = chart.groupCount();
            var seriesLabels = chart.getSeriesLabels(groupCount);
            if (chart.chartType === "pie" && chart.swapData)
                groupCount = chart.data[0].length;
            for (i = 0; i < seriesLabels.length; i++)
                for (j = 0; j < groupCount; j++)
                    if (seriesLabels[i].match(re) && !clear)
                        setRiserColor(i, j, chart.mouseOverIndicator.color || "blue");
                    else
                        clearRiserColor(i, j)
        } else {
            var groupLabels = chart.getGroupLabels();
            var seriesCount = chart.seriesCount();
            for (i = 0; i < groupLabels.length; i++)
                for (j = 0; j < seriesCount; j++)
                    if (groupLabels[i].match(re) && !clear)
                        setRiserColor(j, i, chart.mouseOverIndicator.color || "blue");
                    else
                        clearRiserColor(j, i)
        }
        chart.redraw()
    }
    tdgchart.prototype.doFilter = function(text) {
        if (this.filter.text === text)
            return;
        var clear = true;
        this.filter.text = text;
        if (text && text !== re) {
            var query = document.getElementById("query");
            if (query.value !== text) {
                query.value = text;
                query.focus()
            }
            try {
                re = new RegExp(text,"i");
                clear = false
            } catch (e$35) {}
        }
        update(clear)
    }
    ;
    tdgchart.prototype.addFilter = function() {
        chart = this;
        if (typeof chart.filter === "undefined" || !chart.filter.enabled)
            return;
        chart.filter.processed = true;
        var div = document.getElementById(chart.documentRoot);
        var lbl = document.createElement("label");
        var mode = chart.filter.mode === "series" ? tdgchart.translations.SERIES : tdgchart.translations.GROUP;
        var txt = document.createTextNode("Select " + mode + ": ");
        lbl.appendChild(txt);
        lbl.setAttribute("for", "query");
        div.appendChild(lbl);
        var txtBox = document.createElement("input");
        txtBox.id = "query";
        txtBox.type = "text";
        txtBox.onkeyup = function() {
            return function() {
                chart.doFilter(this.value)
            }
        }();
        txtBox.onfocus = function() {
            this.value = this.value
        }
        ;
        div.appendChild(txtBox);
        txtBox.value = chart.filter.text;
        txtBox.focus();
        if (txtBox.setSelectionRange) {
            var len = txtBox.value.length * 2;
            txtBox.setSelectionRange(len, len)
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.isNarrativeTextEnabled = function() {
        var chart = this;
        var supportedChartTypes = ["bar", "line", "area", "pie", "matrix"];
        return chart.narrativeText && chart.narrativeText.enabled && supportedChartTypes.includes(chart.chartType)
    }
    ;
    tdgchart.prototype.isNarrativeTextChartHidden = function() {
        var chart = this;
        return chart.narrativeText && chart.narrativeText.hideChart && chart.isNarrativeTextEnabled()
    }
    ;
    tdgchart.prototype.layoutNarrativeText = function(titleHeight, subtitleHeight, footnoteHeight, dataPageSliderSize, legendLayout) {
        var chart = this;
        var props = chart.narrativeText, cacheContent;
        var res = {
            position: "top",
            topDisplacement: 0,
            rightDisplacement: 0,
            bottomDisplacement: 0,
            leftDisplacement: 0,
            content: null,
            neededHeight: 0,
            containerLayout: {}
        };
        if (!props || !chart.isNarrativeTextEnabled())
            return res;
        if (chart.chartType === "matrix")
            res.content = tdgchart.translations.NarrativeMatrixUnsupported;
        else if (props.content)
            res.content = props.content;
        else if (chart.cache.hasKey("narrative_text_result")) {
            cacheContent = chart.cache.get("narrative_text_result", {});
            if (cacheContent.content == null) {
                if (cacheContent.responseRequest)
                    cacheContent.responseRequest.onreadystatechange = function() {}
            } else {
                res.content = cacheContent.content;
                chart.cache.remove("narrative_text_result")
            }
        }
        if (!res.content)
            if (props.url) {
                cacheContent = {
                    content: null
                };
                chart.cache.set("narrative_text_result", cacheContent);
                chart.cache.preserve("narrative_text_result");
                var asyncRes = getAsyncNarrativeTextContent(chart);
                if (asyncRes && asyncRes.success)
                    res.content = tdgchart.translations.NarrativeRetrieving;
                else if (asyncRes && asyncRes.error)
                    res.content = asyncRes.error;
                else
                    res.content = tdgchart.translations.NarrativeToMuchData2Dim
            } else
                res.content = tdgchart.translations.NarrativeNoURL + "; " + tdgchart.translations.NarrativeErrorRetrieve;
        if (typeof res.content === "string") {
            var div = document.createElement("div");
            div.innerHTML = res.content;
            var container = document.createElement("div");
            container.appendChild(div);
            res.content = container
        }
        res.position = (props.position + "").toLowerCase();
        if (props.hideChart)
            res.position = "top";
        var pad = 5
          , contentBiggerThanMax = false;
        var topTitlesHeight = pad + chart.padWithMargin(titleHeight, pad) + chart.padWithMargin(subtitleHeight, pad);
        var legendTop = legendLayout ? legendLayout.topDisplacement : 0;
        var legendHeight = legendLayout ? legendLayout.topDisplacement + legendLayout.bottomDisplacement : 0;
        footnoteHeight = chart.padWithMargin(footnoteHeight, pad);
        var borderWidth2 = tdg.get("border.width", props, 0)
          , borderWidth = borderWidth2 / 2;
        var availableHeight = chart.height - topTitlesHeight - footnoteHeight - dataPageSliderSize - legendHeight - borderWidth2 - pad;
        var availableWidth = chart.width - borderWidth2;
        var isAboveOrBelow = res.position === "top" || res.position === "bottom";
        var boxSize = 80;
        if (props.maxSize != null)
            boxSize = tdg.applyNumOrPercent(props.maxSize, isAboveOrBelow ? availableHeight : availableWidth);
        if (isAboveOrBelow) {
            res.neededHeight = chart.measureLabel(res.content.outerHTML, props.label.font, availableWidth - borderWidth2 - pad - pad).height;
            res.neededHeight += borderWidth2 + pad + 5 + pad;
            if (res.neededHeight < boxSize + 10)
                boxSize = res.neededHeight;
            else {
                contentBiggerThanMax = res.neededHeight > boxSize;
                boxSize = Math.min(res.neededHeight, boxSize)
            }
        } else {
            res.neededHeight = chart.measureLabel(res.content.outerHTML, props.label.font, boxSize - borderWidth2 - 10).height;
            if (res.neededHeight >= availableHeight) {
                res.neededHeight = chart.measureLabel(res.content.outerHTML, props.label.font, boxSize - borderWidth2 - 25).height;
                contentBiggerThanMax = res.neededHeight >= availableHeight
            }
        }
        if (props.hideChart)
            boxSize = isAboveOrBelow ? availableHeight : availableWidth;
        switch (res.position) {
        case "right":
            res.rightDisplacement = boxSize + borderWidth2 + pad;
            res.containerLayout = {
                x: chart.width - boxSize - borderWidth - pad,
                y: topTitlesHeight + dataPageSliderSize + legendTop + borderWidth,
                width: boxSize,
                height: availableHeight
            };
            break;
        case "bottom":
            res.bottomDisplacement = boxSize + borderWidth2 + pad;
            res.containerLayout = {
                x: pad + borderWidth,
                y: chart.height - footnoteHeight - boxSize - borderWidth - pad,
                width: availableWidth - pad - pad,
                height: boxSize
            };
            break;
        case "left":
            res.leftDisplacement = boxSize + borderWidth2 + pad;
            res.containerLayout = {
                x: pad + borderWidth,
                y: topTitlesHeight + dataPageSliderSize + legendTop + borderWidth,
                width: boxSize,
                height: availableHeight
            };
            break;
        default:
            res.topDisplacement = boxSize + borderWidth2 + pad;
            res.containerLayout = {
                x: pad + borderWidth,
                y: topTitlesHeight + borderWidth,
                width: availableWidth - pad - pad,
                height: boxSize
            }
        }
        res.containerLayout.contentBiggerThanMax = contentBiggerThanMax;
        return res
    }
    ;
    function buildYSEOPRequest(chart) {
        var chartType = "BAR_CHART";
        if (chart.chartType === "line" || chart.chartType === "area")
            chartType = "LINE_CHART";
        else if (chart.chartType === "pie" || chart.chartType === "funnel" || chart.chartType === "gauge")
            chartType = "PIE_CHART";
        var i, j, data;
        var dimensionLabels = []
          , measureLabels = [];
        var seriesCount = chart.seriesCount();
        var seriesLabels = (chart.getSeriesLabels() || []).map(function(el) {
            return el + ""
        });
        var groupCount = chart.groupCount();
        var groupLabels = groupCount > 1 ? chart.getGroupLabels() : [];
        if (groupCount < 2 && seriesCount < 2 || chartType === "PIE_CHART" && seriesCount < 2 || chartType !== "PIE_CHART" && groupCount < 2)
            return tdgchart.translations.NarrativeInsufficientData;
        var haveMeasuresAsSeries = chart.get("legend.title.visible") === false && (chart.get("legend.title.text") === "Legend Title" || chart.get("legend.title.text") === "") && chart.get("yaxis.title.text") === "";
        if (!haveMeasuresAsSeries && chartType !== "PIE_CHART" && seriesCount > 1 && chart.get("splitNumericAxis.splitY.enabled"))
            haveMeasuresAsSeries = chart.getAxisAssignment().some(function(el) {
                return el !== 1
            });
        if (chartType !== "PIE_CHART" && haveMeasuresAsSeries && seriesCount === 1 && seriesLabels.length === 1 && seriesLabels[0] === " ")
            return tdgchart.translations.NarrativeInsufficientData;
        var res = {
            extensionVersion: "2",
            charts: [{
                inputChart: {
                    type: chartType,
                    multiSeriesType: "UNRELATED",
                    mainDimensionIndex: 0,
                    mainDimensionOrdered: chartType !== "PIE_CHART",
                    disableInterpolation: true
                },
                outputText: {
                    levelOfDetail: 7,
                    persona: "MANAGER",
                    lang: "en",
                    useBulletPoints: false
                },
                dimensions: [],
                measures: [],
                facts: []
            }]
        };
        if (chartType === "PIE_CHART") {
            dimensionLabels = [seriesLabels];
            res.charts[0].dimensions.push({
                label: chart.get("legend.title.text") || "First Dimension",
                cardinal: 1,
                othersLabel: "Others",
                technicalLabel: false,
                ordered: false
            });
            if (groupCount > 1) {
                measureLabels = groupLabels.slice(0, 2);
                data = tdg.transpose(chart.data.slice(0, 2));
                data = data.map(function(el) {
                    return el.map(function(d, idx) {
                        return {
                            index: idx,
                            value: (d || {}).value + ""
                        }
                    })
                })
            } else {
                measureLabels = [chart.getGroupLabel(0)];
                data = chart.data[0].map(function(d) {
                    return [{
                        index: 0,
                        value: (d || {}).value + ""
                    }]
                })
            }
        } else {
            if (seriesCount > 1 && !haveMeasuresAsSeries) {
                dimensionLabels.push(seriesLabels);
                res.charts[0].dimensions.push({
                    label: chart.get("legend.title.text") || "First Dimension",
                    cardinal: seriesCount,
                    othersLabel: "Others",
                    technicalLabel: false,
                    ordered: true
                })
            }
            if (groupCount > 1) {
                dimensionLabels.push(groupLabels);
                res.charts[0].dimensions.push({
                    label: chart.get("axisList.x1.title.text") || "Second Dimension",
                    cardinal: groupCount,
                    othersLabel: "Others",
                    technicalLabel: false,
                    ordered: true
                })
            }
            if (res.charts[0].dimensions.length == 2)
                res.charts[0].inputChart.mainDimensionIndex = 1;
            if (haveMeasuresAsSeries)
                measureLabels = seriesLabels.slice(0, 2);
            else
                measureLabels = [chart.get("axisList.y1.title.text") || chart.get("yaxis.title.text") || "First Measure"];
            if (seriesCount > 1 && groupCount > 1 && !haveMeasuresAsSeries)
                data = chart.data;
            else if (seriesCount > 1 && groupCount > 1 && haveMeasuresAsSeries) {
                data = tdg.transpose(chart.data.slice(0, 2));
                data = data.map(function(el) {
                    return el.map(function(d, idx) {
                        return {
                            index: idx,
                            value: (d || {}).value + ""
                        }
                    })
                })
            } else
                data = chart.data[0].map(function(d) {
                    return [{
                        index: 0,
                        value: (d || {}).value + ""
                    }]
                })
        }
        data = data || [];
        dimensionLabels = dimensionLabels || [[]];
        measureLabels = measureLabels || [];
        measureLabels.forEach(function(el) {
            res.charts[0].measures.push({
                label: el || "",
                technicalLabel: false,
                defaultValue: "0",
                meaningOfUp: "GOOD",
                unit: ""
            })
        });
        if (res.charts[0].dimensions.length === 2)
            for (i = 0; i < data.length; i++)
                for (j = 0; j < data[i].length; j++) {
                    if (data[i] && data[i][j] && data[i][j].value != null)
                        res.charts[0].facts.push({
                            dimensions: [{
                                index: 0,
                                label: dimensionLabels[0][i] + "" || "",
                                position: i
                            }, {
                                index: 1,
                                label: dimensionLabels[1][j] + "" || "",
                                position: j
                            }],
                            measures: [{
                                index: 0,
                                value: data[i][j].value + ""
                            }]
                        })
                }
        else
            for (i = 0; i < data.length; i++)
                res.charts[0].facts.push({
                    dimensions: [{
                        index: 0,
                        label: dimensionLabels[0][i] + "" || "",
                        position: i
                    }],
                    measures: data[i]
                });
        tdg.additiveMerge(chart.get("narrativeText.textGenerationAPI", {}), res.charts[0]);
        return res
    }
    function cleanupYSEOPResponse(doc) {
        var div = document.createElement("div");
        if (typeof doc === "string") {
            div.innerHTML = doc;
            return div
        } else if (!doc || !(doc instanceof Document)) {
            div.innerHTML = tdgchart.translations.NarrativeErrorParse;
            return div
        }
        var content = doc.getElementsByClassName("text-result")[0];
        if (!content)
            content = doc.getElementsByClassName("errors-and-warnings")[0];
        if (!content || !content.childNodes || !content.childNodes.length) {
            div.innerHTML = tdgchart.translations.NarrativeErrorParse;
            return div
        }
        var nodeList = [[]];
        function clean(el) {
            var text;
            if (el instanceof Text)
                text = el.textContent || "";
            else if (el instanceof HTMLSpanElement || el instanceof HTMLDivElement) {
                tdg.map(el.childNodes, clean);
                return
            } else if (el instanceof HTMLParagraphElement || el instanceof HTMLBRElement)
                nodeList.push([]);
            else if (el instanceof HTMLElement && el.tagName === "B")
                nodeList.push([el]);
            if (text) {
                text = text.replace(/\n/g, " ");
                text = text.replace(/[\s]{2,}/g, " ");
                nodeList[nodeList.length - 1].push(text)
            }
            return text
        }
        tdg.map(content.childNodes, clean);
        nodeList.forEach(function(el) {
            if (el && el.length) {
                div.appendChild(document.createElement("p"));
                el.forEach(function(text) {
                    if (typeof text === "string")
                        div.lastChild.appendChild(document.createTextNode(text));
                    else
                        div.lastChild.appendChild(text)
                })
            }
        });
        div.firstChild.style["margin-top"] = "0px";
        div.lastChild.style["margin-bottom"] = "0px";
        var container = document.createElement("div");
        container.appendChild(div);
        return container
    }
    function getAsyncNarrativeTextContent(chart) {
        var yseopRequestSerialized, yseopRequest = buildYSEOPRequest(chart);
        if (yseopRequest && typeof yseopRequest === "string")
            return {
                error: yseopRequest
            };
        else if (yseopRequest && typeof yseopRequest === "object")
            yseopRequestSerialized = JSON.stringify(yseopRequest);
        else
            return {
                error: tdgchart.translations.NarrativeErrorRequest
            };
        function processYseopContent(content) {
            var cacheContent = chart.cache.get("narrative_text_result");
            cacheContent.content = content;
            if (cacheContent && cacheContent.doMorph)
                chart.morph();
            else
                chart.redraw()
        }
        function getYseopRequestChangeFn(xhttp, url, keyList) {
            var par = function(t) {
                return "<p>" + t + "</p>"
            };
            return function() {
                var content = "";
                if (xhttp && xhttp.readyState === 4) {
                    if (xhttp.status === 200) {
                        content = (new DOMParser).parseFromString(xhttp.responseText, "text/html");
                        content = cleanupYSEOPResponse(content)
                    } else if (xhttp.status === 400)
                        try {
                            var res = JSON.parse(xhttp.responseText);
                            if (res) {
                                res = res[0] || {};
                                content = par(tdgchart.translations.NarrativeInvalidRequest + ":");
                                content += par(tdgchart.translations.NarrativeProperty + ": " + (res.schema || {}).pointer);
                                content += par(tdgchart.translations.NarrativeError + ": " + res.message)
                            }
                        } catch (e$36) {
                            content = par(tdgchart.translations.NarrativeInvalidRequest + ":");
                            content += par(tdgchart.translations.NarrativeErrorParse);
                            content += par(e$36.toString())
                        }
                    else if (xhttp.status === 401)
                        if (keyList.length) {
                            createYseopRequest(url, keyList);
                            return
                        } else
                            content = par(tdgchart.translations.NarrativeAuthFailed);
                    else if (xhttp.status === 500)
                        if (xhttp.responseText)
                            if (xhttp.responseText.includes("Constant GARBAGEABLE_NUMBERS_STACK too small"))
                                content = par(tdgchart.translations.NarrativeToMuchData);
                            else {
                                if (xhttp.responseText.includes("engineErrors")) {
                                    content = (new DOMParser).parseFromString(xhttp.responseText, "text/html");
                                    content = par(tdgchart.translations.NarrativeInvalidRequest) + content.getElementById("engineErrors").innerHTML
                                }
                            }
                        else
                            content = par(tdgchart.translations.NarrativeInvalidRequest + "; " + tdgchart.translations.NarrativeErrorRetrieve);
                    if (!content)
                        content = tdgchart.translations.NarrativeErrorConnect + ": " + tdg.formatString('<a href="{0}">{0}</a>', chart.narrativeText.url || "");
                    processYseopContent(content)
                }
            }
        }
        function createYseopRequest(url, keyList) {
            var xhttp = cacheContent.responseRequest = new XMLHttpRequest;
            var key = keyList.shift();
            xhttp.open("POST", url, true);
            if (key != undefined) {
                xhttp.withCredentials = true;
                xhttp.setRequestHeader("Authorization", "Basic " + key)
            }
            xhttp.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            xhttp.setRequestHeader("Content-type", "application/json;charset=UTF-8");
            xhttp.onreadystatechange = getYseopRequestChangeFn(xhttp, url, keyList);
            xhttp.send(yseopRequestSerialized);
            return {
                success: true
            }
        }
        var cacheContent = chart.cache.get("narrative_text_result");
        if (!chart.narrativeText)
            return {
                error: tdgchart.translations.NarrativeDisabled
            };
        else if (!chart.narrativeText.url || !cacheContent)
            return {
                error: tdgchart.translations.NarrativeNoURL
            };
        if (chart.narrativeText.user || chart.narrativeText.password) {
            var key = (chart.narrativeText.user || "") + ":" + (chart.narrativeText.password || "");
            return createYseopRequest(chart.narrativeText.url, [window.btoa(key)])
        } else if (chart.narrativeText.requestKey) {
            var keyHasColon = chart.narrativeText.requestKey.indexOf(":") != -1;
            var key = chart.narrativeText.requestKey + (keyHasColon ? "" : ":");
            return createYseopRequest(chart.narrativeText.url, [window.btoa(key)])
        } else
            return createYseopRequest(chart.narrativeText.url, [undefined, window.btoa(":")])
    }
    tdgchart.prototype.drawNarrativeText = function(panel, overallLayout) {
        var chart = this;
        var props = chart.narrativeText;
        var content = overallLayout.narrativeTextLayout.content;
        if (!props || !props.enabled || !content)
            return;
        props.dockButton = props.dockButton || {};
        props.voiceTextButton = props.voiceTextButton || {};
        var layout = overallLayout.narrativeTextLayout.containerLayout;
        var haveButton = layout.contentBiggerThanMax && props.dockButton && props.dockButton.enabled && !props.hideChart;
        var haveScrollBar = layout.height < overallLayout.narrativeTextLayout.neededHeight;
        var pad = 5
          , scrollBarSize = haveScrollBar ? 15 : 0;
        var borderWidth = tdg.get("border.width", props, 0);
        var borderPad = pad + borderWidth / 2;
        var isAboveOrBelow = props.position === "top" || props.position === "bottom";
        var buttonSize = 0
          , buttonWidth = 0
          , buttonHeight = 0;
        if (haveButton) {
            buttonSize = props.dockButton.size == null ? tdg.bound(layout.width * .02, 10, 25) : props.dockButton.size;
            buttonHeight = isAboveOrBelow ? buttonSize + 20 : buttonSize + 10;
            buttonWidth = isAboveOrBelow ? buttonSize + 10 : layout.width - scrollBarSize - pad
        }
        var scene = chart.cache.get("tdgscene");
        var group;
        if (tdgchart.tdgscene.isTDGSceneGroup(panel))
            group = panel.group();
        else
            group = scene.group(panel, "narrativeText");
        var containerStyle = {
            antialias: false,
            lineStyle: props.border,
            color: props.backgroundColor || chart.fill.color,
            className: "narrativeText-background"
        };
        group.rect(layout.x, layout.y, layout.width, layout.height, containerStyle);
        var align = tdg.get("label.align", props, "left").toLowerCase();
        align = align === "middle" ? "center" : align;
        var css = "width: {0}px; height: {1}px; overflow-y: auto; overflow-x: hidden; white-space: normal; text-align: {2}; padding: 0px {3}px {4}px 0px; box-sizing: content-box;";
        var rightPad = haveScrollBar ? pad : 0;
        layout.innerWidth = haveScrollBar ? layout.width - pad - borderWidth - rightPad : layout.width - pad - borderWidth - pad;
        layout.innerHeight = layout.height - pad - borderWidth - pad - buttonHeight;
        css = tdg.formatString(css, layout.innerWidth, layout.innerHeight, align, rightPad, buttonHeight);
        content.setAttribute("style", css);
        content.setAttribute("class", "narrativeText-label");
        if (isAboveOrBelow && content.firstChild && content.firstChild instanceof HTMLDivElement)
            content.firstChild.setAttribute("style", "width: " + (layout.innerWidth - buttonWidth - scrollBarSize) + "px");
        if (!content)
            return;
        if ("speechSynthesis"in window && props.voiceTextButton.enabled) {
            var btn = document.createElement("button");
            btn.textContent = "Read Text";
            btn.setAttribute("style", "float: right;");
            tdgchart.__voiceClick = function(content, voiceConfig) {
                var isSpeaking = false, voiceList;
                return function(btn) {
                    if (!btn)
                        return;
                    if (isSpeaking) {
                        window.speechSynthesis.cancel();
                        btn.innerText = tdgchart.translations.ReadText
                    } else {
                        if (content && content.lastChild && content.lastChild.textContent) {
                            var msg = new SpeechSynthesisUtterance(content.lastChild.textContent);
                            if (voiceConfig.voice != null)
                                if (voiceList == null)
                                    window.speechSynthesis.onvoiceschanged = function() {
                                        return function() {
                                            voiceList = window.speechSynthesis.getVoices();
                                            msg.voice = voiceList[voiceConfig.voice];
                                            window.speechSynthesis.speak(msg)
                                        }
                                    }(msg);
                                else {
                                    msg.voice = voiceList[voiceConfig.voice];
                                    window.speechSynthesis.speak(msg)
                                }
                            else {
                                for (var key in voiceConfig)
                                    if (voiceConfig.hasOwnProperty(key))
                                        msg[key] = voiceConfig[key];
                                window.speechSynthesis.speak(msg)
                            }
                        }
                        btn.innerText = tdgchart.translations.StopReadText
                    }
                    isSpeaking = !isSpeaking
                }
            }(content, props.voiceTextButton.voiceTextProperties || {});
            btn.setAttribute("onclick", "tdgchart.__voiceClick(this);");
            content.insertBefore(btn, content.firstChild)
        }
        var lblStyle = {
            className: "narrativeText-container",
            font: tdg.get("label.font", props, "8pt Sans-Serif"),
            color: tdg.get("label.color", props, "black")
        };
        group.label(layout.x + borderPad, layout.y + borderPad, content.outerHTML, lblStyle);
        if (haveButton) {
            var strokeColor = props.dockButton.color || "rgb(50, 50, 50)";
            var hoverColor = props.dockButton.hoverColor || "black";
            var delay = props.dockButton.animationDelay || 0;
            var isExpanded = false;
            var positionalInfo = getPositionalInfo(chart, props.position, overallLayout, buttonSize, buttonWidth, buttonHeight, scrollBarSize, pad);
            var g = group.group("narrativeText-button", positionalInfo.x, positionalInfo.y);
            g.rect(0, 0, buttonWidth, buttonHeight, {
                color: containerStyle.color
            });
            var iconStyle = {
                lineStyle: {
                    color: strokeColor,
                    width: buttonSize * .25
                }
            };
            var unexpandedIcon = g.dot(positionalInfo.bx, positionalInfo.by, buttonSize, positionalInfo.unexpandedIcon, iconStyle);
            var expandedIcon = g.dot(positionalInfo.bx, positionalInfo.by, buttonSize, positionalInfo.expandedIcon, tdg.merge(iconStyle, {
                style: "display: none;"
            }));
            g.interaction.events.touchend = g.interaction.events.click = function(t, p, e) {
                function slide(transform) {
                    return function(el) {
                        if (el.cb)
                            transform[el.type](el.value, function() {
                                return el.cb.call(this, isExpanded)
                            });
                        else
                            transform[el.type](el.value, isExpanded ? el.expanded : el.unexpanded)
                    }
                }
                e.preventDefault();
                unexpandedIcon.visible(isExpanded);
                expandedIcon.visible(!isExpanded);
                isExpanded = !isExpanded;
                var root = chart.cache.get_or_set("root", tdgchart.d3.select("#" + chart.documentRoot));
                for (var target in positionalInfo.slideTransform)
                    if (positionalInfo.slideTransform.hasOwnProperty(target)) {
                        var transform = root.select("." + target).transition().duration(delay);
                        positionalInfo.slideTransform[target].forEach(slide(transform))
                    }
            }
            ;
            g.interaction.events.mouseover = g.interaction.events.mouseout = function(target, props, e) {
                var c = e && typeof e.type === "string" && e.type.toLowerCase() === "mouseover" ? hoverColor : strokeColor;
                tdg.map(this.childNodes, function(el) {
                    if (el && typeof el.nodeName === "string" && el.nodeName.toLowerCase() === "path")
                        el.setAttribute("stroke", c)
                })
            }
            ;
            if (!document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Extensibility", "1.1"))
                chart.registerEvent(function() {
                    var root = document.getElementById(chart.documentRoot);
                    var button = (root.getElementsByClassName("narrativeText-button") || [])[0];
                    var container = (root.getElementsByClassName("htmlLabelHolder") || [])[0];
                    if (!button || !container)
                        return;
                    var newSVG = document.createElementNS(tdg.ns.svg, "svg");
                    newSVG.setAttribute("xmlns", tdg.ns.svg);
                    newSVG.setAttribute("width", layout.width - 10);
                    newSVG.setAttribute("height", chart.height);
                    newSVG.setAttribute("fill", "none");
                    newSVG.setAttribute("style", "display: inline-block; position: absolute; left: 0px; top: 0px; z-index: 20;");
                    newSVG.appendChild(button);
                    container.appendChild(newSVG)
                }, "renderComplete")
        }
    }
    ;
    function getPositionalInfo(chart, pos, overallLayout, buttonSize, buttonWidth, buttonHeight, scrollBarSize, pad) {
        var layout = overallLayout.narrativeTextLayout.containerLayout;
        var borderWidth = chart.get("narrativeTextProperties.border.width", 0);
        var maxWidth = chart.width - pad - pad;
        if (pos === "right")
            return {
                x: layout.x + pad,
                y: layout.y + layout.height - buttonHeight - 2,
                bx: 5,
                by: buttonHeight - buttonSize / 2 - 5,
                unexpandedIcon: "chevron-l",
                expandedIcon: "chevron-r",
                slideTransform: {
                    "narrativeText-background": [{
                        type: "attr",
                        value: "width",
                        expanded: maxWidth,
                        unexpanded: layout.width
                    }, {
                        type: "attr",
                        value: "x",
                        expanded: pad,
                        unexpanded: layout.x
                    }],
                    "narrativeText-container": [{
                        type: "attr",
                        value: "x",
                        expanded: pad + pad,
                        unexpanded: layout.x + pad + .5
                    }, {
                        type: "attr",
                        value: "width",
                        expanded: maxWidth,
                        unexpanded: layout.width
                    }],
                    "narrativeText-label": [{
                        type: "style",
                        value: "width",
                        expanded: maxWidth - pad - borderWidth - pad + "px",
                        unexpanded: layout.innerWidth + "px"
                    }],
                    "narrativeText-button": [{
                        type: "attr",
                        value: "transform",
                        cb: function(isExpanded) {
                            var expanded = pad + 2;
                            var unexpanded = layout.x + pad;
                            return tdg.transform.setXY(this, isExpanded ? expanded : unexpanded, null)
                        }
                    }]
                }
            };
        else if (pos === "bottom")
            return {
                x: layout.x + layout.width - buttonWidth - pad - scrollBarSize,
                y: layout.y + 5,
                bx: buttonSize / 2,
                by: 10,
                unexpandedIcon: "chevron-u",
                expandedIcon: "chevron-d",
                slideTransform: {
                    "narrativeText-background": [{
                        type: "attr",
                        value: "height",
                        expanded: chart.height - pad - pad,
                        unexpanded: layout.height
                    }, {
                        type: "attr",
                        value: "y",
                        expanded: pad,
                        unexpanded: layout.y
                    }],
                    "narrativeText-container": [{
                        type: "attr",
                        value: "y",
                        expanded: pad + pad + .5,
                        unexpanded: layout.y + pad + .5
                    }, {
                        type: "attr",
                        value: "height",
                        expanded: chart.height - pad - pad,
                        unexpanded: layout.height
                    }],
                    "narrativeText-label": [{
                        type: "style",
                        value: "height",
                        expanded: chart.height - pad - pad - borderWidth - pad - pad - buttonHeight + "px",
                        unexpanded: layout.innerHeight + "px"
                    }],
                    "narrativeText-button": [{
                        type: "attr",
                        value: "transform",
                        cb: function(isExpanded) {
                            var expanded = pad + 2;
                            var unexpanded = layout.y + 2;
                            return tdg.transform.setXY(this, null, isExpanded ? expanded : unexpanded)
                        }
                    }]
                }
            };
        else if (pos === "left")
            return {
                x: layout.x + layout.width - buttonWidth - pad - scrollBarSize,
                y: layout.y + layout.height - buttonHeight - 5,
                bx: layout.width - scrollBarSize - buttonSize - 5,
                by: buttonHeight - buttonSize / 2 - 5,
                unexpandedIcon: "chevron-r",
                expandedIcon: "chevron-l",
                slideTransform: {
                    "narrativeText-background": [{
                        type: "attr",
                        value: "width",
                        expanded: maxWidth,
                        unexpanded: layout.width
                    }],
                    "narrativeText-container": [{
                        type: "attr",
                        value: "width",
                        expanded: maxWidth,
                        unexpanded: layout.width
                    }],
                    "narrativeText-label": [{
                        type: "style",
                        value: "width",
                        expanded: maxWidth - pad - borderWidth - pad - 1 + "px",
                        unexpanded: layout.innerWidth + "px"
                    }],
                    "narrativeText-button": [{
                        type: "attr",
                        value: "transform",
                        cb: function(isExpanded) {
                            var expanded = layout.x + maxWidth - buttonWidth - pad - scrollBarSize;
                            var unexpanded = layout.x + layout.width - buttonWidth - pad - scrollBarSize;
                            return tdg.transform.setXY(this, isExpanded ? expanded : unexpanded, null)
                        }
                    }]
                }
            };
        var maxHeight = chart.height - layout.y - pad;
        maxHeight = Math.min(maxHeight, overallLayout.narrativeTextLayout.neededHeight + 30);
        return {
            x: layout.x + layout.width - buttonWidth - scrollBarSize - 2,
            y: layout.y + layout.height - buttonHeight - 5,
            bx: buttonSize / 2,
            by: buttonHeight - buttonSize / 2 - 5,
            unexpandedIcon: "chevron-d",
            expandedIcon: "chevron-u",
            slideTransform: {
                "narrativeText-background": [{
                    type: "attr",
                    value: "height",
                    expanded: maxHeight,
                    unexpanded: layout.height
                }],
                "narrativeText-container": [{
                    type: "attr",
                    value: "height",
                    expanded: maxHeight,
                    unexpanded: layout.height
                }],
                "narrativeText-label": [{
                    type: "style",
                    value: "height",
                    expanded: maxHeight - pad - borderWidth - pad - buttonHeight + "px",
                    unexpanded: layout.innerHeight + "px"
                }],
                "narrativeText-button": [{
                    type: "attr",
                    value: "transform",
                    cb: function(isExpanded) {
                        var expanded = layout.y + maxHeight - buttonHeight - 5;
                        var unexpanded = layout.y + layout.height - buttonHeight - 5;
                        return tdg.transform.setXY(this, null, isExpanded ? expanded : unexpanded)
                    }
                }]
            }
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    var MATRIX_HEADER_MAX_LEN = .25;
    var MATRIX_HEADER_MAX_LEN_NESTED = .8;
    var WITH_AXES = true;
    var JUST_CHART = false;
    var IGNORE_PADDING = true;
    tdgchart.prototype.innerChartType = function() {
        var chart = this;
        return chart.chartType === "matrix" ? chart.matrixProperties.chartType : chart.chartType
    }
    ;
    function facetRearrange(chart, data) {
        var maxCols = chart.cache.get("matrixFacetCols");
        var newData = [];
        if (data.length > 1 || data[0].length <= maxCols)
            return data;
        var row, i;
        for (i = 0; i < data[0].length; i++) {
            if (i % maxCols == 0) {
                row = [];
                newData.push(row)
            }
            row.push(data[0][i])
        }
        while (i % maxCols) {
            row.push();
            i++
        }
        return newData
    }
    tdgchart.prototype.initFacetChart = function(data) {
        var chart = this;
        if (data.length != 1)
            return;
        var count = chart.matrixProperties.colWrapCount || 0;
        if (count === "auto")
            count = Math.ceil(Math.sqrt(data[0].length));
        if (count > 0)
            chart.cache.set("matrixFacetCols", count)
    }
    ;
    tdgchart.prototype.layoutMatrixChart = function(overallChartSize, data) {
        var chart = this;
        var chartLayout = chart.layoutDefaultChart(overallChartSize);
        chartLayout.matrixLayout = {};
        chartLayout.matrixLayout.masterChartSize = chartLayout.chartSize;
        data = data || chart._internalData;
        if (chart.cache.get("matrixFacetCols")) {
            data = facetRearrange(chart, data || chart._internalData);
            chart._internalData = data
        }
        var gridSize = getGridSize(data || chart._internalData);
        var minMaxData = chartLayout.matrixLayout.minMaxData = perRowMinMax(chart, gridSize);
        var sizeFunction;
        var padding;
        switch (chart.matrixProperties.chartType) {
        case "bar":
        case "line":
        case "area":
            padding = sizeMatrixBLAPadding(chart, minMaxData.splitYInfo.globalMinMax || minMaxData, minMaxData.splitYInfo.isMinExcluded);
            chartLayout.matrixLayout.validCells = validateCellsData(gridSize, chart._internalData, isValidDataArray);
            sizeFunction = function(chart, chartLayout, dim) {
                var localMinMax = minMaxData;
                if (minMaxData.splitYInfo && !minMaxData.rowMinMax && Array.isArray(minMaxData.splitYInfo.lineAxisConfig) && minMaxData.splitYInfo.lineAxisConfig[0]) {
                    localMinMax = [];
                    minMaxData.splitYInfo.lineAxisConfig.forEach(function(el) {
                        localMinMax = localMinMax.concat(el)
                    })
                }
                sizeMatrixBLAAxes(chart, chartLayout, dim, localMinMax)
            }
            ;
            break;
        case "bubble":
        case "scatter":
            chartLayout.matrixLayout.validCells = validateCellsData(gridSize, chart._internalData, Array.isArray);
            sizeFunction = function(chart, chartLayout, dim) {
                sizeMatrixScatterAxes(chart, chartLayout, dim)
            }
            ;
            break;
        case "histogram":
            padding = sizeMatrixHistogramPadding(chart, chartLayout, minMaxData.histInfo.minMax);
            chartLayout.matrixLayout.validCells = validateCellsData(gridSize, minMaxData.histInfo.dataCollection, Array.isArray);
            sizeFunction = function(chart, chartLayout, dim) {
                sizeMatrixBLAAxes(chart, chartLayout, dim, minMaxData.histInfo.minMax)
            }
            ;
            break;
        case "heatmap":
            sizeFunction = function(chart, chartLayout, dim) {
                sizeMatrixHeatMapAxes(chart, chartLayout, dim)
            }
            ;
            break;
        case "bullet":
            sizeFunction = function(chart, chartLayout, dim) {
                sizeMatrixBullet(chart, chartLayout, dim)
            }
            ;
            break;
        case "pie":
        case "gauge":
        case "marker":
        case "sparkline":
            sizeFunction = function(chart, chartLayout, dim) {
                sizeMatrixNoAxes(dim, chartLayout)
            }
            ;
            break;
        case "polar":
        case "radar":
            sizeFunction = function(chart, chartLayout, dim) {
                sizeMatrixRadar(chart, chartLayout, dim)
            }
            ;
            break
        }
        chartLayout.matrixLayout.dim = chart.dimMatrixChart(chartLayout, gridSize, sizeFunction, padding);
        perColumnCompressedGroupsScales(chart, chartLayout);
        getPerRowAxisLayouts(chart, chartLayout, minMaxData.splitYInfo, minMaxData.dualYInfo);
        chartLayout.chartSize = chart.updateSizeAxisLayout(chartLayout.chartSize, chartLayout.axisLayout.spacing);
        return chartLayout
    }
    ;
    tdgchart.prototype.drawMatrixChart = function(rootChartPanel, chartLayout) {
        var chart = this;
        var dim = chartLayout.matrixLayout.dim;
        var minMaxData = chartLayout.matrixLayout.minMaxData;
        var panels = getMatrixRootPanelsConfig(chart, dim);
        createMatrixRootPanels(chart, rootChartPanel, panels);
        chart.cache.set("matrixScrollPanels", panels);
        var matrixChartPanels = createMatrixChartPanels(chart, panels, dim, chartLayout);
        updateScroll(chart, panels, dim);
        var fill = chart.chartFrame.fill.color;
        if (fill && fill !== "transparent" && panels.panel && panels.panel.p)
            panels.panel.p.fillStyle(fill);
        switch (chart.matrixProperties.chartType) {
        case "bar":
        case "line":
        case "area":
            drawMatrixBLAChart(chart, chartLayout, matrixChartPanels, dim, minMaxData);
            break;
        case "bubble":
        case "scatter":
            drawMatrixXYChart(chart, chartLayout, matrixChartPanels, dim);
            break;
        case "histogram":
            drawMatrixHistogramChart(chart, chartLayout, matrixChartPanels, dim, minMaxData.histInfo);
            break;
        case "heatmap":
            drawMatrixHeatMapChart(chart, chartLayout, matrixChartPanels, dim);
            break;
        case "pie":
            drawMatrixPieChart(chart, chartLayout, matrixChartPanels, dim);
            break;
        case "polar":
        case "radar":
            drawMatrixPolarRadarChart(chart, chartLayout, matrixChartPanels, dim);
            break;
        case "gauge":
            drawGaugeChart(chart, chartLayout, matrixChartPanels, dim);
            break;
        case "marker":
        case "bullet":
        case "sparkline":
            drawMicroChart(chart, chartLayout, matrixChartPanels, dim);
            break;
        default:
            return
        }
        if (chart.cache.get("matrixFacetCols"))
            drawCellColHeaders(chart, chartLayout, matrixChartPanels, dim);
        drawMatrixHeaders(chart, panels, dim);
        drawMatrixGrid(chart, rootChartPanel, panels, dim);
        addScroll(chart, rootChartPanel, panels, dim);
        addInteraction(chart, rootChartPanel, panels)
    }
    ;
    tdgchart.prototype.dimMatrixChart = function(chartLayout, gridSize, sizeFunction, padding) {
        var chart = this;
        var dim = tdg.cloneObject(gridSize);
        var cellsWidth = chartLayout.matrixLayout.masterChartSize.width;
        var cellsHeight = chartLayout.matrixLayout.masterChartSize.height;
        var need_h_scroll = false
          , need_v_scroll = false;
        var scrollbar_size = chart.getMatrixChartScrollSize();
        dim.chart = {
            width: chartLayout.matrixLayout.masterChartSize.width,
            height: chartLayout.matrixLayout.masterChartSize.height
        };
        dim.scroll_space = {
            bottom: 0,
            right: 0
        };
        dim.padding = padding;
        dim.hHeaderSide = chart.matrixProperties.rowLabels.swapChartSide ? 1 : 0;
        dim.vHeaderSide = chart.matrixProperties.colLabels.swapChartSide ? 1 : 0;
        dim.hHeaderSpace = [0, 0];
        dim.vHeaderSpace = [0, 0];
        if (chart.cache.get("matrixFacetCols")) {
            sizeVHeader(chart, dim);
            if (!dim.padding)
                dim.padding = {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0
                };
            dim.padding.top += dim.vHeaderLabelsHeight + 8
        }
        var pass = 0
          , passLimit = 2;
        while (pass < passLimit) {
            dim.cellsInfo = cell_dimensions(chart, dim, cellsWidth, cellsHeight);
            if (!need_h_scroll && dim.cellsInfo.totalWidth > cellsWidth + .999) {
                cellsHeight -= scrollbar_size.h;
                dim.scroll_space.bottom = scrollbar_size.h;
                dim.chart.height -= dim.scroll_space.bottom;
                need_h_scroll = true;
                continue
            }
            if (!need_v_scroll && dim.cellsInfo.totalHeight > cellsHeight + .999) {
                cellsWidth -= scrollbar_size.w;
                dim.scroll_space.right = scrollbar_size.w;
                dim.chart.width -= dim.scroll_space.right;
                need_v_scroll = true;
                continue
            }
            sizeFunction(chart, chartLayout, dim);
            dim.cell = sizeMiniChart(dim, JUST_CHART, IGNORE_PADDING);
            var prevHeaderSpace = dim.vHeaderSpace[0] + dim.vHeaderSpace[1];
            sizeMatrixHeaders(chart, dim, pass === passLimit - 1 ? true : false);
            if (prevHeaderSpace != dim.vHeaderSpace[0] + dim.vHeaderSpace[1] && passLimit == 2)
                passLimit++;
            cellsWidth = dim.chart.width - dim.hHeaderSpace[0] - dim.hHeaderSpace[1];
            cellsHeight = dim.chart.height - dim.vHeaderSpace[0] - dim.vHeaderSpace[1];
            pass++
        }
        return dim
    }
    ;
    function getMatrixRootPanelsConfig(chart, dim) {
        var panels = {
            panel: {
                name: "panel",
                x: dim.hHeaderSpace[0],
                y: dim.vHeaderSpace[0],
                w: dim.chart.width - dim.hHeaderSpace[0] - dim.hHeaderSpace[1],
                h: dim.chart.height - dim.vHeaderSpace[0] - dim.vHeaderSpace[1],
                virt_w: dim.cellsInfo.totalWidth,
                virt_h: dim.cellsInfo.totalHeight,
                scroll_h: 1,
                scroll_v: 1,
                className: "scrollCharts",
                debugColor: "rgba(0,255,0, 0.3)"
            },
            rowTitlePanelL: {
                name: "rowTitlePanelL",
                x: 0,
                y: dim.topHorizTitle ? 0 : dim.vHeaderSpace[0],
                w: !dim.hHeaderSide ? dim.topHorizTitle ? dim.hHeaderSpace[0] : dim.hHeaderTitleWidth : 0,
                h: dim.topHorizTitle ? dim.vHeaderSpace[0] : dim.chart.height - dim.vHeaderSpace[0] - dim.vHeaderSpace[1],
                scroll_h: 0,
                scroll_v: 0,
                className: "scrollRowTitleL",
                debugColor: "rgba(255,0,0, 0.3)"
            },
            rowLabelsPanelL: {
                name: "rowLabelsPanelL",
                x: dim.hHeaderTitleWidth,
                y: dim.vHeaderSpace[0],
                w: !dim.hHeaderSide ? dim.hHeaderLabelsWidth : 0,
                h: dim.chart.height - dim.vHeaderSpace[0] - dim.vHeaderSpace[1],
                virt_h: dim.cellsInfo.totalHeight,
                scroll_h: 0,
                scroll_v: 1,
                className: "scrollRowLblL",
                debugColor: "rgba(255,127,127, 0.3)"
            },
            rowAxisPanelL: {
                name: "rowAxisPanelL",
                x: dim.hHeaderSpace[0] - dim.hAxisSpace[0],
                y: dim.vHeaderSpace[0],
                w: dim.hAxisSpace[0],
                h: dim.chart.height - dim.vHeaderSpace[0] - dim.vHeaderSpace[1],
                virt_h: dim.cellsInfo.totalHeight,
                scroll_h: 0,
                scroll_v: 1,
                clip: false,
                className: "scrollRowAxisL",
                debugColor: "rgba(255,255,0, 0.3)"
            },
            rowAxisPanelR: {
                name: "rowAxisPanelR",
                x: dim.chart.width - dim.hHeaderSpace[1],
                y: dim.vHeaderSpace[0],
                w: dim.hAxisSpace[1],
                h: dim.chart.height - dim.vHeaderSpace[0] - dim.vHeaderSpace[1],
                virt_h: dim.cellsInfo.totalHeight,
                scroll_h: 0,
                scroll_v: 1,
                clip: false,
                className: "scrollRowAxisR",
                debugColor: "rgba(255,255,0, 0.3)"
            },
            rowLabelsPanelR: {
                name: "rowLabelsPanelR",
                x: dim.chart.width - dim.hHeaderSpace[1] + dim.hAxisSpace[1],
                y: dim.vHeaderSpace[0],
                w: !dim.hHeaderSide ? 0 : dim.hHeaderLabelsWidth,
                h: dim.chart.height - dim.vHeaderSpace[0] - dim.vHeaderSpace[1],
                virt_h: dim.cellsInfo.totalHeight,
                scroll_h: 0,
                scroll_v: 1,
                className: "scrollRowLblR",
                debugColor: "rgba(255,127,127, 0.3)"
            },
            rowTitlePanelR: {
                name: "rowTitlePanelR",
                x: dim.topHorizTitle ? dim.chart.width - dim.hHeaderSpace[1] : dim.chart.width - dim.hHeaderTitleWidth,
                y: dim.topHorizTitle ? 0 : dim.vHeaderSpace[0],
                w: !dim.hHeaderSide ? 0 : dim.topHorizTitle ? dim.hHeaderSpace[1] : dim.hHeaderTitleWidth,
                h: dim.topHorizTitle ? dim.vHeaderSpace[0] : dim.chart.height - dim.vHeaderSpace[0] - dim.vHeaderSpace[1],
                scroll_h: 0,
                scroll_v: 0,
                className: "scrollRowTitleR",
                debugColor: "rgba(255,0,0, 0.3)"
            },
            colTitlePanelT: {
                name: "colTitlePanelT",
                x: dim.hHeaderSpace[0],
                y: 0,
                w: dim.chart.width - dim.hHeaderSpace[0] - dim.hHeaderSpace[1],
                h: !dim.vHeaderSide ? dim.vHeaderTitleHeight : 0,
                virt_w: dim.cellsInfo.totalWidth,
                scroll_h: 0,
                scroll_v: 0,
                className: "scrollColTitle",
                debugColor: "rgba(0,0,255, 0.3)"
            },
            colLabelsPanelT: {
                name: "colLabelsPanelT",
                x: dim.hHeaderSpace[0],
                y: dim.vHeaderTitleHeight,
                w: dim.chart.width - dim.hHeaderSpace[0] - dim.hHeaderSpace[1],
                h: !dim.vHeaderSide ? dim.vHeaderLabelsHeight : 0,
                virt_w: dim.cellsInfo.totalWidth,
                scroll_h: 1,
                scroll_v: 0,
                className: "scrollColLbl",
                debugColor: "rgba(255,0,255, 0.3)"
            },
            colAxisPanelT: {
                name: "colAxisPanelT",
                x: dim.hHeaderSpace[0],
                y: dim.vHeaderSpace[0] - dim.vAxisSpace[0],
                w: dim.chart.width - dim.hHeaderSpace[0] - dim.hHeaderSpace[1],
                h: dim.vAxisSpace[0],
                virt_w: dim.cellsInfo.totalWidth,
                scroll_h: 1,
                scroll_v: 0,
                clip: false,
                className: "scrollColAxisT",
                debugColor: "rgba(0,0,255, 0.3)"
            },
            colAxisPanelB: {
                name: "colAxisPanelB",
                x: dim.hHeaderSpace[0],
                y: dim.chart.height - dim.vHeaderSpace[1],
                w: dim.chart.width - dim.hHeaderSpace[0] - dim.hHeaderSpace[1],
                h: dim.vAxisSpace[1],
                virt_w: dim.cellsInfo.totalWidth,
                scroll_h: 1,
                scroll_v: 0,
                clip: false,
                className: "scrollColAxis",
                debugColor: "rgba(0,0,255, 0.3)"
            },
            colLabelsPanelB: {
                name: "colLabelsPanelB",
                x: dim.hHeaderSpace[0],
                y: dim.chart.height - dim.vHeaderSpace[1] + dim.vAxisSpace[1],
                w: dim.chart.width - dim.hHeaderSpace[0] - dim.hHeaderSpace[1],
                h: !dim.vHeaderSide ? 0 : dim.vHeaderLabelsHeight,
                virt_w: dim.cellsInfo.totalWidth,
                scroll_h: 1,
                scroll_v: 0,
                className: "scrollColLbl",
                debugColor: "rgba(255,0,255, 0.3)"
            },
            colTitlePanelB: {
                name: "colTitlePanelB",
                x: dim.hHeaderSpace[0],
                y: dim.chart.height - dim.vHeaderTitleHeight,
                w: dim.chart.width - dim.hHeaderSpace[0] - dim.hHeaderSpace[1],
                h: !dim.vHeaderSide ? 0 : dim.vHeaderTitleHeight,
                virt_w: dim.cellsInfo.totalWidth,
                scroll_h: 0,
                scroll_v: 0,
                className: "scrollColTitle",
                debugColor: "rgba(0,0,255, 0.3)"
            }
        };
        for (var p in panels)
            if (panels.hasOwnProperty(p)) {
                if (panels[p].virt_w == null)
                    panels[p].virt_w = panels[p].w;
                if (panels[p].virt_h == null)
                    panels[p].virt_h = panels[p].h;
                if (panels[p].w <= 0 || panels[p].h <= 0)
                    panels[p].ignore = true
            }
        return panels
    }
    function createMatrixRootPanels(chart, chartPanel, panels) {
        for (var p in panels)
            if (panels.hasOwnProperty(p))
                if (!panels[p].ignore)
                    panels[p].p = chart.addScrollPanel(chartPanel, panels[p])
    }
    function updateScroll(chart, panels, dim) {
        var scroll = chart.cache.get("matrixScroll");
        if (!scroll) {
            scroll = {
                cellsInfo: dim.cellsInfo,
                render: {
                    row: [0, dim.rows - 1],
                    col: [0, dim.cols - 1]
                },
                datarange: {
                    row: [0, dim.rows - 1],
                    col: [0, dim.cols - 1]
                },
                pos: {
                    x: 0,
                    y: 0
                },
                transform: {},
                view: {
                    width: panels.panel.w,
                    height: panels.panel.h
                }
            };
            chart.cache.set("matrixScroll", scroll)
        }
        if (scroll && panels && panels.panel && panels.panel.p)
            scroll.canvas = {
                width: panels.panel.p.computedSize.width,
                height: panels.panel.p.computedSize.height
            }
    }
    tdgchart.prototype.getMatrixChartScrollSize = function() {
        return {
            w: 15,
            h: 15
        }
    }
    ;
    function cell_dimensions(chart, dim, cellsWidth, cellsHeight) {
        var s, g, groupCount, labelHeight;
        var rows = dim.rows;
        var cols = dim.cols;
        var matrixType = chart.matrixProperties.chartType;
        var cellsInfo = {
            totalWidth: 100 * cols,
            totalHeight: 100 * rows,
            ww: [],
            wo: [],
            hh: [],
            ho: []
        };
        var compInfo = chart.cache.get("matrixCompressedGroups");
        var isVertical = chart.blaProperties.orientation !== "horizontal";
        if (chart.matrixProperties.minCellSize === "auto")
            if (matrixType === "bar" || matrixType === "line" || matrixType === "area") {
                labelHeight = tdg.measureFont(chart.axisList.x1.labels.font).height + 1;
                if (compInfo)
                    if (isVertical)
                        cellsInfo.totalWidth = compInfo.allGroupCount * labelHeight;
                    else
                        cellsInfo.totalHeight = compInfo.allGroupCount * labelHeight;
                else {
                    groupCount = chart.groupCount();
                    if (isVertical)
                        cellsInfo.totalWidth = groupCount * labelHeight * cols;
                    else
                        cellsInfo.totalHeight = groupCount * labelHeight * rows
                }
            } else if (matrixType === "scatter" || matrixType === "bubble") {
                var axisModes = chart.cache.get("axisModes", {});
                if (axisModes.x1 === "ordinal") {
                    groupCount = chart.getXYOrdAxisLabels("x").length;
                    labelHeight = tdg.measureFont(chart.axisList.x1.labels.font).height + 1;
                    cellsInfo.totalWidth = groupCount * labelHeight * cols
                }
                if (axisModes.y1 === "ordinal") {
                    groupCount = chart.getXYOrdAxisLabels("y").length;
                    labelHeight = tdg.measureFont(chart.axisList.y1.labels.font).height + 1;
                    cellsInfo.totalHeight = groupCount * labelHeight * rows
                }
            } else {
                if (matrixType === "marker") {
                    var userPad = chart.get("matrixProperties.layout.cellPadding", {});
                    labelHeight = tdg.measureFont(chart.matrixProperties.rowHeader.font).height + 1;
                    labelHeight += (userPad.top == null ? 5 : userPad.top) + (userPad.bottom == null ? 5 : userPad.bottom);
                    cellsInfo.totalWidth = Math.max(cellsWidth, cols * 10);
                    cellsInfo.totalHeight = Math.max(cellsHeight, rows * labelHeight)
                }
            }
        else {
            if (chart.matrixProperties.minCellSize.width > 0)
                cellsInfo.totalWidth = chart.matrixProperties.minCellSize.width * cols;
            else
                cellsInfo.totalWidth = cellsWidth;
            if (chart.matrixProperties.minCellSize.height > 0)
                cellsInfo.totalHeight = chart.matrixProperties.minCellSize.height * rows;
            else
                cellsInfo.totalHeight = cellsHeight
        }
        if (cellsInfo.totalWidth < cellsWidth)
            cellsInfo.totalWidth = cellsWidth;
        if (cellsInfo.totalHeight < cellsHeight)
            cellsInfo.totalHeight = cellsHeight;
        var uncompressedCellWidth = cellsInfo.totalWidth / cols;
        var uncompressedCellHeight = cellsInfo.totalHeight / rows;
        if (isVertical) {
            for (g = 0; g < cols; g++) {
                cellsInfo.ww[g] = compInfo ? cellsInfo.totalWidth * compInfo.proportion[g] : uncompressedCellWidth;
                cellsInfo.wo[g] = g === 0 ? 0 : cellsInfo.ww[g - 1] + cellsInfo.wo[g - 1]
            }
            for (s = 0; s < rows; s++) {
                cellsInfo.hh[s] = uncompressedCellHeight;
                cellsInfo.ho[s] = s === 0 ? 0 : cellsInfo.hh[s - 1] + cellsInfo.ho[s - 1]
            }
        } else {
            for (g = 0; g < cols; g++) {
                cellsInfo.ww[g] = uncompressedCellWidth;
                cellsInfo.wo[g] = g === 0 ? 0 : cellsInfo.ww[g - 1] + cellsInfo.wo[g - 1]
            }
            for (s = 0; s < rows; s++) {
                cellsInfo.hh[s] = compInfo ? cellsInfo.totalHeight * compInfo.proportion[s] : uncompressedCellHeight;
                cellsInfo.ho[s] = s === 0 ? 0 : cellsInfo.hh[s - 1] + cellsInfo.ho[s - 1]
            }
        }
        return cellsInfo
    }
    function hasBarSizeScaleData(data) {
        if (!data || !data.length)
            return false;
        for (var i = 0; i < data.length; i++) {
            var d = data[i];
            if (Array.isArray(d))
                return hasBarSizeScaleData(d);
            else if (typeof d === "object" && d.size != null)
                return true
        }
        return false
    }
    function perRowMinMax(chart, dim) {
        var i, localMinMax, minMaxData = {};
        var matrixType = chart.matrixProperties.chartType;
        var isVertical = chart.blaProperties.orientation !== "horizontal";
        var originalMin, originalMax;
        function getMinMax(rowconfig, data) {
            var minMaxData = [];
            if (["bar", "line", "area"].includes(matrixType)) {
                originalMin = chart.axisList.y1.min;
                originalMax = chart.axisList.y1.max;
                if (rowconfig) {
                    chart.axisList.y1.min = rowconfig.min;
                    chart.axisList.y1.max = rowconfig.max
                }
                minMaxData = chart.getScaleMinMax(chart.axisList.y1, "y1", data);
                minMaxData.splitYInfo = getSplitYAxesData(chart, dim);
                minMaxData.dualYInfo = getDualYAxesData(chart, dim);
                if (matrixType === "bar")
                    if (chart.dataArrayMap && chart.dataArrayMap.includes("size")) {
                        if (hasBarSizeScaleData(data))
                            minMaxData.barSizeMinMax = chart.getDataSetMinMax({}, "", data, "absolute", "size")
                    } else if (chart.getRiserSeriesLayout("bar") === "sidebyside")
                        if (minMaxData.dualYInfo.dataObjByCell) {
                            minMaxData.sideBySideBarCount = undefined;
                            tdg.max(tdg.map(minMaxData.dualYInfo.dataObjByCell, function(el) {
                                return tdg.max(el, function(ele) {
                                    return ele.odata.bar.length
                                })
                            }))
                        } else
                            minMaxData.sideBySideBarCount = tdg.max(tdg.map(data, function(el) {
                                return tdg.max(el, "length")
                            }));
                chart.axisList.y1.min = originalMin;
                chart.axisList.y1.max = originalMax
            } else if (matrixType === "histogram") {
                var histInfo = getHistogramInfo(chart, dim);
                minMaxData = tdg.clone(histInfo.minMax);
                minMaxData.histInfo = histInfo
            } else if (matrixType === "bubble" || matrixType === "scatter") {
                originalMin = chart.axisList.y1.min;
                originalMax = chart.axisList.y1.max;
                if (rowconfig) {
                    chart.axisList.y1.min = rowconfig.min;
                    chart.axisList.y1.max = rowconfig.max
                }
                var yMinMax = chart.getScaleMinMax(chart.axisList.y1, "x1", data);
                chart.axisList.y1.min = originalMin;
                chart.axisList.y1.max = originalMax;
                originalMin = chart.axisList.x1.min;
                originalMax = chart.axisList.x1.max;
                if (rowconfig) {
                    chart.axisList.x1.min = rowconfig.min;
                    chart.axisList.x1.max = rowconfig.max
                }
                var xMinMax = chart.getScaleMinMax(chart.axisList.x1, "x1", data);
                chart.axisList.x1.min = originalMin;
                chart.axisList.x1.max = originalMax;
                minMaxData = {
                    splitYInfo: getXYMatrixDataObj(chart, dim),
                    x: xMinMax,
                    y: yMinMax
                }
            }
            return minMaxData
        }
        minMaxData = getMinMax(null, chart._internalData);
        var xMin = chart.axisList.x1.min
          , xMax = chart.axisList.x1.max;
        var yMin = chart.axisList.y1.min
          , yMax = chart.axisList.y1.max;
        var needYMinMax = Array.isArray(yMin) || Array.isArray(yMax) || yMin === "autoPerRow" || yMax === "autoPerRow";
        var needXMinMax = !chart.isBLA() && (Array.isArray(xMin) || Array.isArray(xMax) || xMin === "autoPerRow" || xMax === "autoPerRow");
        if (chart.splitNumericAxis.splitX.enabled || chart.splitNumericAxis.splitY.enabled)
            needYMinMax = needXMinMax = false;
        var columnsOfData;
        if (needXMinMax || needYMinMax)
            if (chart.isBLA()) {
                minMaxData.rowMinMax = [];
                if (isVertical)
                    for (i = 0; i < chart._internalData.length; i++) {
                        localMinMax = {
                            min: Array.isArray(yMin) ? yMin[i] || null : null,
                            max: Array.isArray(yMax) ? yMax[i] || null : null
                        };
                        minMaxData.rowMinMax[i] = getMinMax(localMinMax, [chart._internalData[i]])
                    }
                else {
                    columnsOfData = chart._internalData = tdg.transpose(chart._internalData);
                    for (i = 0; i < columnsOfData.length; i++) {
                        localMinMax = {
                            min: Array.isArray(yMin) ? yMin[i] || null : null,
                            max: Array.isArray(yMax) ? yMax[i] || null : null
                        };
                        minMaxData.rowMinMax[i] = getMinMax(localMinMax, [columnsOfData[i]])
                    }
                    chart._internalData = tdg.transpose(chart._internalData)
                }
                if (yMin === "autoPerRow") {
                    chart.cache.setProperty("yaxis.min", null);
                    chart.cache.setProperty("axisList.y1.min", null)
                }
                if (yMax === "autoPerRow") {
                    chart.cache.setProperty("yaxis.max", null);
                    chart.cache.setProperty("axisList.y1.max", null)
                }
            } else if (matrixType === "bubble" || matrixType === "scatter") {
                columnsOfData = chart._internalData = tdg.transpose(chart._internalData);
                var originalDim = tdg.clone(dim);
                dim = {
                    rows: originalDim.cols,
                    cols: originalDim.rows
                };
                minMaxData.colMinMax = [];
                for (i = 0; i < columnsOfData.length; i++) {
                    localMinMax = {
                        min: Array.isArray(xMin) ? xMin[i] || null : null,
                        max: Array.isArray(xMax) ? xMax[i] || null : null
                    };
                    minMaxData.colMinMax[i] = getMinMax(localMinMax, [columnsOfData[i]])
                }
                if (xMin === "autoPerRow")
                    chart.cache.setProperty("axisList.x1.min", null);
                if (xMax === "autoPerRow")
                    chart.cache.setProperty("axisList.x1.max", null);
                chart._internalData = tdg.transpose(chart._internalData);
                dim = originalDim;
                minMaxData.rowMinMax = [];
                for (i = 0; i < chart._internalData.length; i++) {
                    localMinMax = {
                        min: Array.isArray(yMin) ? yMin[i] || null : null,
                        max: Array.isArray(yMax) ? yMax[i] || null : null
                    };
                    minMaxData.rowMinMax[i] = getMinMax(localMinMax, [chart._internalData[i]])
                }
                if (yMin === "autoPerRow") {
                    chart.cache.setProperty("yaxis.min", null);
                    chart.cache.setProperty("axisList.y1.min", null)
                }
                if (yMax === "autoPerRow") {
                    chart.cache.setProperty("yaxis.max", null);
                    chart.cache.setProperty("axisList.y1.max", null)
                }
            }
        return minMaxData
    }
    function validateCellsData(dim, data, f) {
        var valid = [];
        for (var r = 0; r < dim.rows; r++) {
            valid.push([]);
            for (var c = 0; c < dim.cols; c++)
                valid[r].push(f((data[r] || [])[c]))
        }
        return valid
    }
    function getGridSize(data) {
        return {
            rows: Math.max(data.length, 1),
            cols: Math.max(tdg.max(data, "length"), 1)
        }
    }
    function addScroll(chart, chartPanel, panels, dim) {
        var scroll = chart.cache.get("matrixScroll");
        if (!scroll.canvas)
            return;
        var scroll_dim, v_scrollbar, h_scrollbar;
        var matrixScrollSize = chart.getMatrixChartScrollSize();
        if (dim.scroll_space.bottom > 0 || dim.scroll_space.right > 0)
            chart._postProcessCallbacks.push(matrix_scroll_onRedraw);
        if (dim.scroll_space.bottom > 0 && scroll.view.width > 0) {
            scroll.hscale = dim.cellsInfo.totalWidth / scroll.view.width;
            var handleWidth = (scroll.pos.x + scroll.view.width) / scroll.hscale;
            if (handleWidth < matrixScrollSize.h) {
                scroll.hscale *= (scroll.view.width - handleWidth) / (scroll.view.width - matrixScrollSize.h);
                handleWidth = matrixScrollSize.h
            }
            scroll_dim = {
                x: panels.panel.x,
                y: dim.chart.height,
                length: panels.panel.w,
                thick: matrixScrollSize.h
            };
            h_scrollbar = chart.drawScroll(chartPanel, "horizontal", scroll_dim, {
                from: 0,
                to: scroll.view.width,
                virt_length: scroll.canvas.width
            }, {
                from: scroll.pos.x / scroll.hscale,
                to: handleWidth
            }, matrix_scroll_to_callback)
        }
        if (dim.scroll_space.right > 0 && scroll.view.height > 0) {
            scroll.vscale = dim.cellsInfo.totalHeight / scroll.view.height;
            var handleHeight = (scroll.pos.y + scroll.view.height) / scroll.vscale;
            if (handleHeight < matrixScrollSize.w) {
                scroll.vscale *= (scroll.view.height - handleHeight) / (scroll.view.height - matrixScrollSize.w);
                handleHeight = matrixScrollSize.w
            }
            scroll_dim = {
                x: dim.chart.width,
                y: panels.panel.y,
                length: panels.panel.h,
                thick: matrixScrollSize.w
            };
            v_scrollbar = chart.drawScroll(chartPanel, "vertical", scroll_dim, {
                from: 0,
                to: scroll.view.height,
                virt_length: scroll.canvas.height
            }, {
                from: scroll.pos.y / scroll.vscale,
                to: handleHeight
            }, matrix_scroll_to_callback)
        }
        var i = chart.interaction;
        if ((i.touchDrag === "pan" || i.longTouchDrag === "pan") && (h_scrollbar || v_scrollbar)) {
            chartPanel.events("all");
            chart._postProcessCallbacks.push(function() {
                var root = tdgchart.d3.select("#" + chart.documentRoot);
                var svgNode = root.select("svg").node();
                var downPt, lastScroll = {
                    h: 0,
                    v: 0
                };
                function touchStart() {
                    chart.hideHoverNode();
                    chart.hideToolTip();
                    downPt = tdg.getMouseInViewPort(svgNode, tdgchart.d3.event)
                }
                function touchMove() {
                    tdgchart.d3.event.preventDefault();
                    if (downPt == null)
                        return;
                    var upPt = tdg.getMouseInViewPort(svgNode, tdgchart.d3.event);
                    if (h_scrollbar)
                        lastScroll.h = h_scrollbar.bar.touchScroll(downPt.x, upPt.x);
                    if (v_scrollbar)
                        lastScroll.v = v_scrollbar.bar.touchScroll(downPt.y, upPt.y)
                }
                function touchEnd() {
                    downPt = null;
                    if (h_scrollbar)
                        h_scrollbar.bar.touchScrollEnd(lastScroll.h);
                    if (v_scrollbar)
                        v_scrollbar.bar.touchScrollEnd(lastScroll.v)
                }
                if (i.touchDrag === "pan" || i.touchDrag === "select" && !chart.previewSelection.enabled && !chart.dataSelection.enabled)
                    chart.registerShortDrag(root.select(".chartPanel"), touchStart, touchMove, touchEnd);
                if (i.longTouchDrag === "pan")
                    chart.registerLongDrag(root.select(".chartPanel"), touchStart, touchMove, touchEnd)
            })
        }
    }
    function addInteraction(chart, chartPanel, panels) {
        if (chart.interaction.mousedrag === "pan") {
            var eventPanel = chartPanel.add(pv.Panel).className("eventPanel").events("all");
            addPanInteraction(chart, panels, eventPanel)
        }
    }
    function init_panels_svg_transform(chart) {
        var root = tdgchart.d3.select("#" + chart.documentRoot);
        var panels = chart.cache.get("matrixScrollPanels", {});
        for (var p in panels)
            if (panels.hasOwnProperty(p) && !panels[p].ignore) {
                var e = root.select("g[class=" + panels[p].className + "]").node();
                if (e)
                    panels[p].transform = e.transform.baseVal.appendItem(e.ownerSVGElement.createSVGTransform())
            }
    }
    function matrix_apply_scroll(chart, pos) {
        var panels = chart.cache.get("matrixScrollPanels", {});
        for (var p in panels)
            if (panels.hasOwnProperty(p) && !panels[p].ignore && panels[p].transform)
                panels[p].transform.setTranslate(pos.x * panels[p].scroll_h * -1, pos.y * panels[p].scroll_v * -1)
    }
    function matrix_scroll_onRedraw() {
        var chart = this
          , scroll = chart.cache.get("matrixScroll");
        init_panels_svg_transform(chart);
        matrix_apply_scroll(chart, scroll.pos)
    }
    function matrix_scroll_to_callback(orientation, pos, doNotScale) {
        var chart = this
          , scroll = chart.cache.get("matrixScroll");
        if (orientation === "horizontal")
            matrix_scroll_to(chart, pos * (doNotScale ? 1 : scroll.hscale), scroll.pos.y);
        else if (orientation === "vertical")
            matrix_scroll_to(chart, scroll.pos.x, pos * (doNotScale ? 1 : scroll.vscale))
    }
    function matrix_scroll_to(chart, newx, newy) {
        var scroll = chart.cache.get("matrixScroll");
        scroll.pos.x = tdg.bound(newx, 0, scroll.cellsInfo.totalWidth - scroll.view.width);
        scroll.pos.y = tdg.bound(newy, 0, scroll.cellsInfo.totalHeight - scroll.view.height);
        matrix_apply_scroll(chart, scroll.pos)
    }
    function addPanInteraction(chart, panels, eventPanel) {
        var x = 0
          , y = 0;
        var scroll = chart.cache.get("matrixScroll");
        function pan() {
            var t = eventPanel.transform();
            matrix_scroll_to(chart, scroll.pos.x - t.x + x, scroll.pos.y - t.y + y);
            x = t.x;
            y = t.y
        }
        eventPanel.event("mousedown", pv.Behavior.pan()).event("touchstart", pv.Behavior.pan()).event("pan", pan)
    }
    function drawMicroChart(chart, chartLayout, matrixChartPanels, dim) {
        var cellType = chart.matrixProperties.chartType;
        var panel, sizeMinMax;
        if (cellType === "marker")
            sizeMinMax = chart.getScaleMinMax(chart.zaxis, "z1", null, null, "size");
        for (var r = 0; r < dim.rows; r++)
            for (var c = 0; c < dim.cols; c++) {
                var d = chart._internalData[r][c];
                if (chart.cache.get("matrixFacetCols") && tdg.isEmpty(d))
                    continue;
                panel = matrixChartPanels[r][c].riser.panel;
                if (chartLayout && chartLayout.axisLayout && chartLayout.axisLayout.spacing)
                    panel.computedSize.axisWidth = chartLayout.axisLayout.spacing.w;
                chart.drawMicroChart(panel, chart.matrixProperties.chartType, d, sizeMinMax)
            }
        if (cellType === "bullet") {
            var isHorizontal = chart.blaProperties.orientation === "horizontal";
            var axisCount = isHorizontal ? dim.cols : dim.rows;
            for (var i = 0; i < axisCount; i++) {
                panel = isHorizontal ? matrixChartPanels[0][i] : matrixChartPanels[i][0];
                if (panel && panel.axis && panel.axis.y1)
                    panel.axis.y1.bg = panel.axis.y1.fg = null;
                chart.drawNumericAxis(panel, chartLayout.axisLayout.yScalesList, chartLayout.axisLayout.yAxisList, chartLayout.axisLayout.spacing)
            }
        }
    }
    function skipEmptyGaugeInMatrix(chart, d) {
        if (tdg.isEmpty(d))
            return true;
        if (Array.isArray(d) && d.length >= 1 && Array.isArray(d[0]) && d[0].length == 0)
            return true;
        if (chart.gaugeProperties.layout === "simple" || chart.gaugeProperties.layout === "textArrow" || chart.gaugeProperties.layout === "simpleText")
            if (Array.isArray(d) && d.length >= 1 && Array.isArray(d[0]) && d[0].length >= 1 && (d[0][0] == undefined || d[0][0].value == undefined))
                return true;
        return false
    }
    function drawGaugeChart(chart, chartLayout, matrixChartPanels, dim) {
        var minMax = chart.getScaleMinMax(chart.yaxis, "y1");
        for (var r = 0; r < dim.rows; r++)
            for (var c = 0; c < dim.cols; c++) {
                var d = chart._internalData[r][c];
                if (skipEmptyGaugeInMatrix(chart, d))
                    continue;
                chart.drawGaugeChart(matrixChartPanels[r][c].riser.panel, chartLayout, d, minMax)
            }
    }
    function drawMatrixPolarRadarChart(chart, chartLayout, matrixChartPanels, dim) {
        for (var r = 0; r < dim.rows; r++)
            for (var c = 0; c < dim.cols; c++) {
                var d = chart._internalData[r][c];
                var titlePanel = undefined;
                var drawTitle = c == 0;
                if (matrixChartPanels[r][c].axis && matrixChartPanels[r][c].axis.y1)
                    titlePanel = !drawTitle ? null : matrixChartPanels[r][c].axis.y1.axis;
                if (chart.matrixProperties.chartType == "polar")
                    chart.drawPolarChart(matrixChartPanels[r][c].riser.panel, titlePanel, chartLayout, d);
                else if (chart.matrixProperties.chartType == "radar")
                    chart.drawRadarChart(matrixChartPanels[r][c].riser.panel, titlePanel, chartLayout, d)
            }
    }
    function drawMatrixPieChart(chart, chartLayout, matrixChartPanels, dim) {
        var r, c, d, minMax, min = Infinity, max = -Infinity;
        if (chart.dataObjHasProp(chart._internalData, "size")) {
            for (r = 0; r < chart._internalData.length; r++)
                for (c = 0; c < chart._internalData[r].length; c++) {
                    var cell = chart._internalData[r][c];
                    for (var pie = 0; pie < cell.length; pie++) {
                        var sum = 0;
                        for (var slice = 0; slice < cell[pie].length; slice++) {
                            d = cell[pie][slice];
                            if (d.size != null)
                                sum += d.size
                        }
                        if (sum > 0) {
                            min = Math.min(min, sum);
                            max = Math.max(max, sum)
                        }
                    }
                }
            minMax = {
                min: min,
                max: max
            }
        }
        for (r = 0; r < dim.rows; r++)
            for (c = 0; c < dim.cols; c++) {
                d = chart._internalData[r][c];
                if (!tdg.isEmpty(d))
                    chart.drawPieChart(matrixChartPanels[r][c].riser.panel, chartLayout, d, null, minMax)
            }
    }
    function sizeMiniChart(dim, withAxes, skipPadding, c, r) {
        var cell = {
            width: 0,
            height: 0
        };
        cell.width = c != null ? dim.cellsInfo.ww[c] : dim.cellsInfo.totalWidth / dim.cellsInfo.ww.length;
        cell.height = r != null ? dim.cellsInfo.hh[r] : dim.cellsInfo.totalHeight / dim.cellsInfo.hh.length;
        if (withAxes) {
            cell.width += dim.hAxisSpace ? dim.hAxisSpace[0] + dim.hAxisSpace[1] : 0;
            cell.height += dim.vAxisSpace ? dim.vAxisSpace[0] + dim.vAxisSpace[1] : 0
        }
        if (!skipPadding && dim.padding) {
            cell.width -= dim.padding.left + dim.padding.right;
            cell.height -= dim.padding.top + dim.padding.bottom
        }
        return cell
    }
    function getBLAMatrixDataObj(chart, dim) {
        var globalMinMax = {
            min: Infinity,
            max: -Infinity
        };
        var dataObjByCell = []
          , lineMinMax = []
          , axisMinMax = {};
        var isVertical = chart.blaProperties.orientation !== "horizontal";
        var axisProp, needPerRowMinMax;
        var r, c, i, j;
        var axisNames = {}
          , axisNamesArray = [];
        for (r = 0; r < dim.rows; r++) {
            dataObjByCell[r] = [];
            for (c = 0; c < dim.cols; c++) {
                var cellData = chart._internalData[r][c];
                if (!Array.isArray(cellData))
                    continue;
                var idx = isVertical ? r : c;
                lineMinMax[idx] = lineMinMax[idx] || [];
                var dataObj = chart.rearangeBLAInternalData(cellData);
                dataObjByCell[r][c] = dataObj;
                var minMaxList = chart.getSplitAxesMinMaxList(dataObj.dataByAxis);
                for (i = 0; i < minMaxList.length; i++) {
                    var m = minMaxList[i];
                    if (!axisNames[m.name]) {
                        axisNames[m.name] = true;
                        axisNamesArray.push(m.name)
                    }
                    axisProp = chart.axisList[m.name];
                    needPerRowMinMax = Array.isArray(axisProp.min) || Array.isArray(axisProp.max) || axisProp.min === "autoPerRow" || axisProp.max === "autoPerRow";
                    if (Array.isArray(axisProp.min))
                        m.min = axisProp.min[idx];
                    if (Array.isArray(axisProp.max))
                        m.max = axisProp.max[idx];
                    axisMinMax[m.name] = axisMinMax[m.name] || tdg.clone(m);
                    axisMinMax[m.name].min = Math.min(m.min, axisMinMax[m.name].min);
                    axisMinMax[m.name].max = Math.max(m.max, axisMinMax[m.name].max);
                    if (!m.noData && axisMinMax[m.name].noData)
                        delete axisMinMax[m.name].noData;
                    if (needPerRowMinMax)
                        lineMinMax[idx][i] = tdg.clone(m);
                    else
                        lineMinMax[idx][i] = tdg.clone(axisMinMax[m.name]);
                    if (!m.noData && lineMinMax[idx][i].noData)
                        delete lineMinMax[idx][i].noData;
                    globalMinMax.min = Math.min(m.min, globalMinMax.min);
                    globalMinMax.max = Math.max(m.max, globalMinMax.max)
                }
            }
        }
        for (i = 0; i < lineMinMax.length; i++)
            for (j = 0; j < lineMinMax[i].length; j++) {
                var name = lineMinMax[i][j].name;
                axisProp = chart.axisList[name];
                needPerRowMinMax = Array.isArray(axisProp.min) || Array.isArray(axisProp.max) || axisProp.min === "autoPerRow" || axisProp.max === "autoPerRow";
                if (!needPerRowMinMax)
                    lineMinMax[i][j] = axisMinMax[lineMinMax[i][j].name]
            }
        return {
            dataObjByCell: dataObjByCell,
            globalMinMax: globalMinMax,
            perAxisMinMax: axisNamesArray.map(function(name) {
                return axisMinMax[name]
            }),
            lineAxisConfig: lineMinMax
        }
    }
    function getXYMatrixDataObj(chart, dim) {
        var dataObjByCell = []
          , lineMinMax = []
          , axisMinMax = {};
        var axisProp, needPerRowMinMax;
        var r, c, i;
        for (r = 0; r < dim.rows; r++) {
            dataObjByCell[r] = [];
            lineMinMax[r] = [];
            for (c = 0; c < dim.cols; c++) {
                var cellData = chart._internalData[r][c];
                if (!Array.isArray(cellData))
                    continue;
                var dataObj = chart.preprocessXYChartData(cellData);
                dataObjByCell[r][c] = dataObj;
                lineMinMax[r][c] = [];
                for (i = 0; i < dataObj.minMaxList.length; i++) {
                    var m = dataObj.minMaxList[i];
                    axisProp = chart.axisList[m.name];
                    needPerRowMinMax = Array.isArray(axisProp.min) || Array.isArray(axisProp.max) || axisProp.min === "autoPerRow" || axisProp.max === "autoPerRow";
                    var idx = m.name.startsWith("y") ? r : c;
                    if (Array.isArray(axisProp.min))
                        m.min = axisProp.min[idx];
                    if (Array.isArray(axisProp.max))
                        m.max = axisProp.max[idx];
                    axisMinMax[m.name] = axisMinMax[m.name] || tdg.clone(m);
                    axisMinMax[m.name].min = Math.min(m.min, axisMinMax[m.name].min);
                    axisMinMax[m.name].max = Math.max(m.max, axisMinMax[m.name].max);
                    if (needPerRowMinMax)
                        lineMinMax[r][c][i] = tdg.clone(m);
                    else
                        lineMinMax[r][c][i] = tdg.clone(axisMinMax[m.name])
                }
            }
        }
        for (r = 0; r < lineMinMax.length; r++)
            for (c = 0; c < lineMinMax[r].length; c++)
                for (i = 0; i < lineMinMax[r][c].length; i++) {
                    var name = lineMinMax[r][c][i].name;
                    axisProp = chart.axisList[name];
                    needPerRowMinMax = Array.isArray(axisProp.min) || Array.isArray(axisProp.max) || axisProp.min === "autoPerRow" || axisProp.max === "autoPerRow";
                    if (!needPerRowMinMax)
                        lineMinMax[r][c][i] = axisMinMax[lineMinMax[r][c][i].name]
                }
        return {
            dataObjByCell: dataObjByCell,
            lineAxisConfig: lineMinMax
        }
    }
    function isValidDataArray(d) {
        return Array.isArray(d) && d.some(function(el) {
            if (Array.isArray(el))
                return el.some(function(el) {
                    return el != null
                });
            return false
        })
    }
    function getDualYAxesData(chart, dim) {
        if (!chart.needDualY2Axis())
            return {};
        var blaMatrixDataObj = getBLAMatrixDataObj(chart, dim);
        return blaMatrixDataObj
    }
    function getSplitYAxesData(chart, dim) {
        if (!chart.splitNumericAxis.splitY.enabled)
            return {};
        var s, isVertical = chart.blaProperties.orientation === "vertical";
        var subSetCount = isVertical ? dim.rows : dim.cols;
        var blaMatrixDataObj = getBLAMatrixDataObj(chart, dim);
        var axisList = [];
        for (s = 0; s < subSetCount; s++) {
            var axisListByLine = chart.getAxisList(blaMatrixDataObj.lineAxisConfig[s]);
            axisList = axisList.concat(axisListByLine)
        }
        blaMatrixDataObj.isMinExcluded = false;
        for (var i = 0; i < axisList.length; i++)
            if (axisList[i].properties.labels.excludeMin) {
                blaMatrixDataObj.isMinExcluded = true;
                break
            }
        return blaMatrixDataObj
    }
    function twoDimensionalArray(array) {
        var bigArray = [];
        function flatten(subArray, pushTo) {
            if (subArray instanceof Array)
                for (var i = 0; i < subArray.length; i++)
                    if (subArray[i]instanceof Array)
                        flatten(subArray[i], pushTo);
                    else if (!(subArray[i]instanceof Array)) {
                        pushTo.push(subArray);
                        return
                    }
        }
        flatten(array, bigArray);
        return bigArray
    }
    function getArrayBy(array, func) {
        return array.reduce(function(p, c) {
            if (func === Math.max)
                return func.apply(null, p) > func.apply(null, c) ? p : c;
            if (func === Math.min)
                return func.apply(null, p) < func.apply(null, c) ? p : c;
            return null
        })
    }
    function addBLAChartCell(chart, chartLayout, chartPanels, c, r, dim, minMax) {
        var d = chart._internalData[r][c];
        if (!isValidDataArray(d))
            return;
        var blaData = chart.rearangeBLAInternalData(d);
        var odata = blaData.odata;
        var splitYInfo = minMax.splitYInfo || {};
        if (chart.cache.hasKey("matrixCompressedGroups")) {
            var compInfo = chart.cache.get("matrixCompressedGroups");
            var compressedGroups = (compInfo.compressedGroups || [])[chartPanels.compressedGroupsAxisNum];
            if (!tdg.isEmpty(compressedGroups))
                chart.cache.set("compressedGroups", compressedGroups)
        }
        var originalLabels = chart.groupLabels;
        if (chart.cache.hasKey("rowOrdAxisSortOrderList")) {
            var rowOrdAxisSortOrderList = chart.cache.get("rowOrdAxisSortOrderList");
            var sortByCol = rowOrdAxisSortOrderList.sortByCol;
            var rowSortOrder = rowOrdAxisSortOrderList[sortByCol ? c : r];
            chart.groupLabels = rowSortOrder.map(function(el) {
                return chart.groupLabels[el.i]
            })
        }
        var res = getBLAChartLayoutRC(chart, chartLayout, r, c, minMax);
        if (chart.needDualY2Axis())
            chart.drawXOrdinalYChart(chartPanels, res.layout, blaData, chart.drawBLARisers, minMax.dualYInfo.dataObjByCell[r][c].dataByAxis, res.minMax);
        else if (chart.splitNumericAxis.splitY.enabled)
            chart.drawXOrdinalYChart(chartPanels, res.layout, blaData, chart.drawBLARisers, splitYInfo.dataObjByCell[r][c].dataByAxis, res.minMax);
        else
            chart.drawXOrdinalYChart(chartPanels, res.layout, blaData, chart.drawBLARisers, null, res.minMax);
        chart.groupLabels = originalLabels
    }
    function getBLAChartLayoutRC(chart, chartLayout, r, c, minMax) {
        var isVertical = chart.blaProperties.orientation !== "horizontal";
        var rowAxisLayout = chartLayout.axisLayout.hasSplitAxes && chartLayout.perRowAxisLayouts && chartLayout.perRowAxisLayouts[isVertical ? r : c];
        var xCGScalesList = chart.cache.hasKey("matrixCompressedGroups") && chartLayout.axisLayout.xCompressedGroupsScalesLists && chartLayout.axisLayout.xCompressedGroupsScalesLists[isVertical ? c : r];
        var localMinMax = minMax, rowScaleEntry;
        if (minMax.rowMinMax) {
            rowScaleEntry = isVertical ? r : c;
            localMinMax = minMax.rowMinMax[rowScaleEntry]
        }
        return {
            minMax: localMinMax,
            layout: layoutClone(chartLayout, rowAxisLayout, xCGScalesList, rowScaleEntry)
        }
    }
    function layoutClone(chartLayout, axisLayoutSwap, xScalesListSwap, rowScaleEntry) {
        function copy(obj) {
            var clone = {};
            for (var key in obj)
                if (obj.hasOwnProperty(key))
                    if (key === "axisLayout") {
                        var al = axisLayoutSwap || obj[key];
                        clone[key] = !xScalesListSwap && rowScaleEntry == null ? al : copy(al)
                    } else if (xScalesListSwap && key === "xScalesList")
                        clone[key] = xScalesListSwap;
                    else if (rowScaleEntry != null && key === "yScalesList") {
                        var scale = obj[key];
                        clone[key] = tdg.clone(scale);
                        clone[key].panelSize = scale.panelSize;
                        if (scale.y1) {
                            clone[key].y1 = Array.isArray(scale.y1) ? scale.y1[rowScaleEntry] : scale.y1;
                            clone[key].y1.axisName = scale.y1.axisName
                        }
                        if (scale.y2) {
                            clone[key].y2 = Array.isArray(scale.y2) ? scale.y2[rowScaleEntry] : scale.y2;
                            clone[key].y2.axisName = scale.y2.axisName
                        }
                        clone[key].forEach(function(a, idx) {
                            clone[key][idx] = a[rowScaleEntry];
                            clone[key][idx].axisName = a.axisName
                        })
                    } else
                        clone[key] = obj[key];
            return clone
        }
        return !axisLayoutSwap && !xScalesListSwap && rowScaleEntry == null ? chartLayout : copy(chartLayout)
    }
    function createMatrixChartPanels(chart, panels, dim, chartLayout) {
        var isVertical = chart.blaProperties.orientation !== "horizontal";
        var matrixChartPanels = [];
        var haveColAxis = []
          , haveRowAxis = [];
        for (var r = 0; r < dim.rows; r++) {
            matrixChartPanels.push([]);
            for (var c = 0; c < dim.cols; c++) {
                if (chartLayout.matrixLayout.validCells && !chartLayout.matrixLayout.validCells[r][c]) {
                    matrixChartPanels[r].push(null);
                    continue
                }
                var axisLayout = chartLayout.axisLayout;
                if (chartLayout.axisLayout.hasSplitAxes && chartLayout.perRowAxisLayouts && chartLayout.perRowAxisLayouts[isVertical ? r : c] && !Array.isArray(chartLayout.perRowAxisLayouts[isVertical ? r : c]))
                    axisLayout = chartLayout.perRowAxisLayouts[isVertical ? r : c];
                var chartSize = sizeMiniChart(dim, JUST_CHART, null, c, r);
                chartSize.x = dim.cellsInfo.wo[c] + (dim.padding && dim.padding.left || 0);
                chartSize.y = dim.cellsInfo.ho[r] + (dim.padding && dim.padding.top || 0);
                var rootPanels = {
                    chart: panels.panel.p
                };
                if (!haveColAxis[c]) {
                    rootPanels["top"] = panels.colAxisPanelT.p;
                    rootPanels["bottom"] = panels.colAxisPanelB.p;
                    haveColAxis[c] = true
                }
                if (!haveRowAxis[r]) {
                    rootPanels["left"] = panels.rowAxisPanelL.p;
                    rootPanels["right"] = panels.rowAxisPanelR.p;
                    haveRowAxis[r] = true
                }
                var chartPanels = chart.createXYPanelsM(rootPanels, chartSize, axisLayout, true, dim.padding);
                var riserPanelList = [chartPanels.riser].concat(tdg.values(chartPanels.risers));
                riserPanelList.forEach(function(rp) {
                    if (rp && rp.bg && rp.fg && rp.panel) {
                        rp.bg.row = rp.fg.row = rp.panel.row = r;
                        rp.bg.col = rp.fg.col = rp.panel.col = c
                    }
                });
                chartPanels.compressedGroupsAxisNum = isVertical ? c : r;
                matrixChartPanels[r].push(chartPanels)
            }
        }
        return matrixChartPanels
    }
    function miniChartEach(matrixChartPanels, func) {
        for (var r = 0; r < matrixChartPanels.length; r++)
            for (var c = 0; c < matrixChartPanels[r].length; c++)
                if (matrixChartPanels[r][c])
                    func(matrixChartPanels[r][c], r, c)
    }
    function drawMatrixBLAChart(chart, chartLayout, matrixChartPanels, dim, minMax) {
        miniChartEach(matrixChartPanels, function(chartPanels, r, c) {
            addBLAChartCell(chart, chartLayout, chartPanels, c, r, dim, minMax)
        })
    }
    function drawMatrixHeatMapChart(chart, chartLayout, matrixChartPanels) {
        miniChartEach(matrixChartPanels, function(chartPanels, r, c) {
            var originalSeriesLabels = chart.getSeriesLabels();
            var originalGroupLabels = chart.groupLabels;
            if (chart.cache.hasKey("rowOrdAxisSortOrderList")) {
                var rowOrdAxisSortOrderList = chart.cache.get("rowOrdAxisSortOrderList");
                var rowSortOrder = rowOrdAxisSortOrderList[c];
                chart.groupLabels = rowSortOrder.map(function(el) {
                    return chart.groupLabels[el.i]
                })
            }
            if (chart.cache.hasKey("rowZOrdAxisSortOrderList")) {
                var rowZOrdAxisSortOrderList = chart.cache.get("rowZOrdAxisSortOrderList");
                var rowZSortOrder = rowZOrdAxisSortOrderList[r];
                chart.setSeriesLabels(rowZSortOrder.map(function(el) {
                    return originalSeriesLabels[el.i]
                }))
            }
            var d = chart._internalData[r][c];
            chart.drawHeatmap(chartPanels, chartLayout, d);
            chart.setSeriesLabels(originalSeriesLabels);
            chart.groupLabels = originalGroupLabels
        })
    }
    function getHistogramInfo(chart) {
        function getArrayByMaxVal(array) {
            var one_dimens = twoDimensionalArray(array);
            return getArrayBy(one_dimens, Math.max)
        }
        var data, histInfo = {};
        histInfo.dataCollection = [];
        var minMaxBucket = [];
        histInfo.binCount = chart.histogramProperties.binCount;
        for (var r = 0; r < chart._internalData.length; r++) {
            histInfo.dataCollection.push([]);
            var dataRow = chart._internalData[r];
            for (var c = 0; c < dataRow.length; c++) {
                var cellData = dataRow[c];
                if (!Array.isArray(cellData)) {
                    histInfo.dataCollection[r].push(null);
                    continue
                }
                if (cellData === 0 || cellData[0].length === 0) {
                    histInfo.dataCollection[r].push(null);
                    continue
                }
                data = chart.histogramData(cellData[0]);
                var min = chart.yaxis.min == null ? Math.floor(tdg.minR(data, "value")) : chart.yaxis.min;
                var max = chart.yaxis.max == null ? Math.ceil(tdg.maxR(data, "value")) : chart.yaxis.max;
                if (min === max) {
                    min -= 1;
                    max += 1
                }
                minMaxBucket.push(min);
                minMaxBucket.push(max);
                histInfo.dataCollection[r].push(data)
            }
        }
        histInfo.minMax = {};
        histInfo.minMax.min = Math.min.apply(null, minMaxBucket);
        histInfo.minMax.max = Math.max.apply(null, minMaxBucket);
        chart.histogramProperties.binCount = data.length;
        var maxValArray = getArrayByMaxVal(chart._internalData);
        chart.cachedMaxValArray = maxValArray;
        return histInfo
    }
    function drawMatrixHistogramChart(chart, chartLayout, matrixChartPanels, dim, histInfo) {
        chartLayout.axisLayout.xAxisList[0].shiftBaselineLabel = true;
        chartLayout.axisLayout.yAxisList[0].shiftBaselineLabel = true;
        chartLayout.axisLayout.yAxisList[0].properties.numberFormat = "#";
        chartLayout.axisLayout.xAxisList[0].properties.centerGroupLabels = false;
        miniChartEach(matrixChartPanels, function(chartPanels, r, c) {
            var d = histInfo.dataCollection[r][c];
            chart.drawXOrdinalYChart(chartPanels, chartLayout, d, chart.addHistogram)
        })
    }
    function drawMatrixXYChart(chart, chartLayout, matrixChartPanels, dim) {
        var sizeScale;
        if (chart.isDataDrivenMarkerSize()) {
            var maxRad = chart.bubbleMarkerRadius(dim.cell);
            var myMinMax = chart.getScaleMinMax(chart.zaxis, "z1", null, null, "size");
            sizeScale = chart.dataDrivenMarkerSize("size", {
                min: null,
                max: maxRad
            }, myMinMax)
        }
        var r, c;
        for (r = 0; r < dim.rows; r++)
            for (c = 0; c < dim.cols; c++) {
                var d = chart._internalData[r][c];
                if (!Array.isArray(d))
                    continue;
                if (chart.matrixProperties.chartType === "bubble")
                    chart.matrixBubbleData = d;
                chartLayout.xyDataInfo = chartLayout.matrixLayout.minMaxData.splitYInfo.dataObjByCell[r][c];
                var layout = getXYChartLayoutRC(chart, chartLayout, r, c);
                layout.axisLayout.xAxisList[0].shiftBaselineLabel = true;
                layout.axisLayout.yAxisList[chartLayout.axisLayout.yAxisList.length - 1].shiftBaselineLabel = true;
                chart.drawXYChart(matrixChartPanels[r][c], layout, d, sizeScale)
            }
    }
    function getXYChartLayoutRC(chart, chartLayout, r, c) {
        var haveXArray = chartLayout.axisLayout.xScalesList.some(function(el) {
            return Array.isArray(el)
        });
        var haveYArray = chartLayout.axisLayout.xScalesList.some(function(el) {
            return Array.isArray(el)
        });
        if (haveXArray || haveYArray) {
            chartLayout = tdg.clone(chartLayout);
            chartLayout.axisLayout.xScalesList = chartLayout.axisLayout.xScalesList.map(function(el) {
                return el[c]
            });
            chartLayout.axisLayout.yScalesList = chartLayout.axisLayout.yScalesList.map(function(el) {
                return el[r]
            })
        } else if (chartLayout.perRowAxisLayouts && chartLayout.perRowAxisLayouts[r] && chartLayout.perRowAxisLayouts[r][c]) {
            chartLayout = tdg.clone(chartLayout);
            chartLayout.axisLayout = chartLayout.perRowAxisLayouts[r][c]
        }
        return chartLayout
    }
    function sizeMatrixNoAxes(dim, chartLayout) {
        dim.hAxisSide = null;
        dim.vAxisSide = null;
        dim.hAxisSpace = [0, 0];
        dim.vAxisSpace = [0, 0];
        chartLayout.axisLayout = {}
    }
    function sizeMatrixBLAPadding(chart, minMax, isMinExcluded) {
        var isSplitY = chart.splitNumericAxis.splitY.enabled;
        var padding = {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
        };
        var baselineVal = 0;
        if (minMax && typeof minMax.min === "number" && minMax.min > 0)
            baselineVal = minMax.min;
        var yaxis = {
            properties: chart.yaxis,
            side: "left",
            name: "y1"
        };
        var domain = chart.getNumericScale({
            width: 1,
            height: 100
        }, yaxis, minMax).domain();
        var replaceMax = tdg.get("properties.labels.replaceMax", yaxis);
        if (!tdg.isEmpty(replaceMax))
            domain[1] = replaceMax + "";
        function lsize(l) {
            return chart.measureLabel(chart.formatNumber(l, chart.yaxis.numberFormat, minMax), chart.yaxis.labels.font)
        }
        if (chart.blaProperties.orientation === "horizontal") {
            if (baselineVal !== domain[1])
                padding.right = lsize(domain[1]).width / 2 + 5;
            if (baselineVal !== domain[0] && !isSplitY)
                padding.left = lsize(domain[0]).width / 2 + 1;
            if (baselineVal !== domain[0] && isSplitY && isMinExcluded === false)
                padding.left = lsize(domain[0]).width / 2
        } else {
            if (baselineVal !== domain[1])
                padding.top = lsize(domain[1]).height / 2;
            if (baselineVal !== domain[0] && !isSplitY)
                padding.bottom = lsize(domain[0]).height / 2;
            if (baselineVal !== domain[0] && isSplitY && isMinExcluded === false)
                padding.bottom = lsize(domain[0]).height / 2
        }
        var userPad = chart.get("matrixProperties.layout.cellPadding", {});
        padding.top = userPad.top || padding.top;
        padding.right = userPad.right || padding.right;
        padding.bottom = userPad.bottom || padding.bottom;
        padding.left = userPad.left || padding.left;
        return padding
    }
    function sizeMatrixHistogramPadding(chart, chartLayout, minMax) {
        var padding = {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
        };
        var baselineVal = 0;
        var yaxis = {
            properties: chart.yaxis
        };
        var domain = chart.getNumericScale({
            width: 1,
            height: 100
        }, yaxis, minMax).domain();
        function lsize(l) {
            return chart.measureLabel(chart.formatNumber(l, chart.yaxis.numberFormat), chart.yaxis.labels.font)
        }
        if (chart.blaProperties.orientation === "horizontal") {
            if (baselineVal !== domain[1])
                padding.right = lsize(domain[1]).width / 2 + 1
        } else if (baselineVal !== domain[1])
            padding.top = lsize(domain[1]).height / 2;
        return padding
    }
    function unused(chart, axisMinMax) {
        var padding = {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
        };
        var baselineVal = 0;
        var domainY = chart.getNumericScale({
            width: 1,
            height: 100
        }, chart.axisList.y1, axisMinMax.y).domain();
        var domainX = chart.getNumericScale({
            width: 1,
            height: 100
        }, chart.axisList.x1, axisMinMax.x).domain();
        function lsize(l) {
            return chart.measureLabel(chart.formatNumber(l, chart.yaxis.numberFormat), chart.yaxis.labels.font)
        }
        if (baselineVal !== domainX[0])
            padding.left = lsize(domainX[0]).width / 2 + 1;
        if (baselineVal !== domainX[1])
            padding.right = lsize(domainX[1]).width / 2 + 1;
        if (baselineVal !== domainY[1])
            padding.top = lsize(domainY[1]).height / 2;
        if (baselineVal !== domainY[0])
            padding.bottom = lsize(domainY[0]).height / 2;
        return padding
    }
    function sizeMatrixBLAAxes(chart, chartLayout, dim, minMax) {
        var isVertical = chart.blaProperties.orientation === "vertical";
        dim.hAxisSide = !isVertical ? chart.axisList.x1.swapChartSide : chart.axisList.y1.swapChartSide;
        dim.vAxisSide = !isVertical ? !chart.axisList.y1.swapChartSide : !chart.axisList.x1.swapChartSide;
        if (!minMax) {
            chartLayout.blaInfo = chart.preprocessBLAData();
            minMax = chartLayout.blaInfo.minMaxList
        }
        var passMinMax = minMax.dualYInfo && minMax.dualYInfo.perAxisMinMax || minMax;
        function getAxisLayout(chartSize) {
            return chart.getXOrdYAxisLayout(chartSize, passMinMax, chartLayout.matrixLayout.masterChartSize)
        }
        if (!isVertical && !chart.axisList.x1.swapChartSide && chart.axisList.x1.title.visible && !dim.hHeaderSide && !dim.vHeaderSide) {
            chart.cache.set("xaxisTitleInHeader", true);
            chart.cache.setProperty("axisList.x1.title.visible", false)
        }
        chartLayout.axisLayout = iterateLayout(chart, dim, getAxisLayout)
    }
    function sizeMatrixRadar(chart, chartLayout, dim) {
        if (chart.axisList.y1.title.visible) {
            var axisTitleSize = chart.measureLabel(chart.axisList.y1.title);
            var axisTitleMargin = 5;
            dim.hAxisTitleHeight = axisTitleSize.height + axisTitleMargin
        } else
            dim.hAxisTitleHeight = 0;
        dim.hAxisSide = false;
        dim.vAxisSide = false;
        dim.hAxisSpace = [dim.hAxisTitleHeight, 0];
        dim.vAxisSpace = [0, 0];
        var cellsWidth = dim.chart.width - (dim.hHeaderSpace[0] || 0) - (dim.hHeaderSpace[1] || 0);
        var cellsHeight = dim.chart.height - (dim.vHeaderSpace[0] || 0) - (dim.vHeaderSpace[1] || 0);
        dim.cellsInfo = cell_dimensions(chart, dim, cellsWidth, cellsHeight);
        if (chart.axisList.y1.title.visible)
            chartLayout.axisLayout = {
                xAxisList: [{
                    name: "y1",
                    side: "left",
                    layout: {
                        axisSize: {
                            width: dim.hAxisTitleHeight,
                            height: undefined
                        }
                    }
                }]
            };
        else
            chartLayout.axisLayout = {}
    }
    function sizeMatrixBullet(chart, chartLayout, dim) {
        var isHorizontal = chart.blaProperties.orientation === "horizontal";
        dim.hAxisSide = false;
        dim.vAxisSide = true;
        function getAxisLayout(chartSize) {
            var axisLayout = {};
            axisLayout.yAxisList = [{
                name: "y1",
                side: isHorizontal ? "bottom" : "left",
                properties: chart.axisList.y1,
                layout: {}
            }];
            axisLayout.spacing = chart.layoutAxis(chartSize, axisLayout.yAxisList, chartLayout.matrixLayout.masterChartSize);
            axisLayout.spacing[isHorizontal ? "w" : "h"] *= .95;
            var panelSize = chart.getAxisPanelSize({
                width: axisLayout.spacing.w,
                height: axisLayout.spacing.h
            }, 1, 1, false);
            axisLayout.yScalesList = chart.getScalesList(panelSize, axisLayout.yAxisList);
            axisLayout.yAxisList[0].shiftBaselineLabel = true;
            return axisLayout
        }
        chartLayout.axisLayout = iterateLayout(chart, dim, getAxisLayout)
    }
    function getPerRowAxisLayouts(chart, chartLayout, splitYInfo, dualYInfo) {
        if (chart.isBLA() && chart.needDualY2Axis()) {
            var dim = chartLayout.matrixLayout.dim;
            var size = sizeMiniChart(dim, WITH_AXES);
            chartLayout.dualYlayout = chart.getXOrdYAxisLayout(size, dualYInfo.perAxisMinMax, chartLayout.matrixLayout.masterChartSize);
            chartLayout.axisLayout.yAxisList.forEach(function(yaxis) {
                yaxis.shiftBaselineLabel = true
            })
        } else if (splitYInfo && splitYInfo.lineAxisConfig) {
            var i, j, lastAxis;
            var dim = chartLayout.matrixLayout.dim;
            var size = sizeMiniChart(dim, WITH_AXES);
            chartLayout.perRowAxisLayouts = [];
            if (chart.isBLA()) {
                var isVertical = chart.blaProperties.orientation === "vertical";
                for (i = 0; i < (isVertical ? dim.rows : dim.cols); i++) {
                    chartLayout.perRowAxisLayouts[i] = chart.getXOrdYAxisLayout(size, splitYInfo.lineAxisConfig[i], chartLayout.matrixLayout.masterChartSize);
                    lastAxis = isVertical ? chartLayout.perRowAxisLayouts[i].yAxisList.length - 1 : 0;
                    chartLayout.perRowAxisLayouts[i].yAxisList[lastAxis].shiftBaselineLabel = true;
                    if (isVertical)
                        chartLayout.perRowAxisLayouts[i].xScalesList = chart.getBLAXScalesList(chartLayout.matrixLayout.dim.cell, chartLayout.perRowAxisLayouts[i].xAxisList)
                }
            } else
                for (i = 0; i < dim.rows; i++) {
                    chartLayout.perRowAxisLayouts[i] = [];
                    for (j = 0; j < dim.cols; j++)
                        chartLayout.perRowAxisLayouts[i][j] = chart.getXYAxisLayout(size, splitYInfo.lineAxisConfig[i][j], chartLayout.matrixLayout.masterChartSize)
                }
        } else if (chartLayout && chartLayout.axisLayout && chartLayout.axisLayout.yAxisList)
            chartLayout.axisLayout.yAxisList.forEach(function(yaxis) {
                yaxis.shiftBaselineLabel = true
            })
    }
    function perColumnCompressedGroupsScales(chart, chartLayout) {
        if (chart.cache.hasKey("matrixCompressedGroups") && ["bar", "line", "area", "waterfall", "heatmap", "streamgraph"].includes(chart.matrixProperties.chartType)) {
            var isVertical = chart.blaProperties.orientation === "vertical";
            var dim = chartLayout.matrixLayout.dim;
            chartLayout.axisLayout.xCompressedGroupsScalesLists = [];
            for (var i = 0, count = isVertical ? dim.cols : dim.rows; i < count; i++) {
                var panelSize = sizeMiniChart(dim, JUST_CHART, null, isVertical ? i : 0, isVertical ? 0 : i);
                chartLayout.axisLayout.xCompressedGroupsScalesLists[i] = chart.getBLAXScalesList(panelSize, chartLayout.axisLayout.xAxisList, i)
            }
        }
    }
    function sizeMatrixScatterAxes(chart, chartLayout, dim) {
        dim.hAxisSide = chart.axisList.y1.swapChartSide;
        dim.vAxisSide = !chart.axisList.x1.swapChartSide;
        function getAxisLayout(chartSize) {
            var minMax = chartLayout.matrixLayout.minMaxData;
            if (!minMax.rowMinMax && !minMax.colMinMax)
                minMax = minMax.splitYInfo.lineAxisConfig[0][0];
            return chart.getXYAxisLayout(chartSize, minMax, chartLayout.matrixLayout.masterChartSize)
        }
        chartLayout.axisLayout = iterateLayout(chart, dim, getAxisLayout)
    }
    function iterateLayout(chart, dim, getAxisLayoutFn) {
        function applyLayoutToDim(dim, axisLayout, fixWidth) {
            if (!dim.hAxisSpace || !fixWidth)
                dim.hAxisSpace = [axisLayout.size.left, axisLayout.size.right];
            dim.vAxisSpace = [axisLayout.size.top, axisLayout.size.bottom];
            dim.vAxisTitleOffset = dim.vAxisSide ? dim.vAxisSpace[1] - axisLayout.titleOff.left : axisLayout.titleOff.right;
            dim.vAxisTitleHeight = dim.vAxisSide ? axisLayout.titleHeight.left : axisLayout.titleHeight.right;
            dim.hAxisTitleHeight = dim.hAxisSide ? axisLayout.titleHeight.top : axisLayout.titleHeight.bottom;
            var cellsWidth = dim.chart.width - (dim.hHeaderSpace[0] || 0) - (dim.hHeaderSpace[1] || 0);
            var cellsHeight = dim.chart.height - (dim.vHeaderSpace[0] || 0) - (dim.vHeaderSpace[1] || 0);
            dim.cellsInfo = cell_dimensions(chart, dim, cellsWidth, cellsHeight)
        }
        var axisLayout = getAxisLayoutFn(sizeMiniChart(dim, WITH_AXES));
        applyLayoutToDim(dim, axisLayout.spacing, false);
        axisLayout = getAxisLayoutFn(sizeMiniChart(dim, WITH_AXES));
        applyLayoutToDim(dim, axisLayout.spacing, false);
        axisLayout = getAxisLayoutFn(sizeMiniChart(dim, WITH_AXES));
        axisLayout = getAxisLayoutFn(sizeMiniChart(dim, WITH_AXES));
        applyLayoutToDim(dim, axisLayout.spacing, true);
        return axisLayout
    }
    function sizeMatrixHeatMapAxes(chart, chartLayout, dim) {
        var chartSize = sizeMiniChart(dim, WITH_AXES);
        chartLayout.axisLayout = chart.getHeatmapAxisLayout(chartSize, chartLayout.matrixLayout.masterChartSize);
        dim.hAxisSide = chart.zaxis.swapChartSide;
        dim.vAxisSide = !chart.axisList.x1.swapChartSide;
        dim.hAxisSpace = [chartLayout.axisLayout.spacing.inset.left, chartLayout.axisLayout.spacing.inset.right];
        dim.vAxisSpace = [chartLayout.axisLayout.spacing.inset.top, chartLayout.axisLayout.spacing.inset.bottom]
    }
    function fixRowLabel(chart, str, font, maxWidth, fitsToLines) {
        if (fitsToLines)
            return chart.applyWrapAndTruncate(str, font, 2, "rowLabels", maxWidth);
        else
            return chart.truncateLabel(str, font || "10pt Sans-Serif", maxWidth)
    }
    function buildRowLabelMap(chart, rowLabels, headerWidth, fitsToLines) {
        var rowLabelMap = {};
        function traverse(labelList) {
            if (labelList[0] && typeof labelList[0] === "object")
                for (var i = 0; i < labelList.length; i++) {
                    var v = labelList[i];
                    for (var key in v)
                        if (v.hasOwnProperty(key)) {
                            var newKey = fixRowLabel(chart, key, chart.matrixProperties.rowLabels.font, headerWidth, fitsToLines);
                            rowLabelMap[key] = newKey;
                            traverse(v[key])
                        }
                }
            else
                labelList.forEach(function(str) {
                    rowLabelMap[str] = fixRowLabel(chart, str, chart.matrixProperties.rowLabels.font, headerWidth, fitsToLines)
                })
        }
        traverse(rowLabels);
        return rowLabelMap
    }
    function countLines(label) {
        if (typeof label == "string")
            return label.split("\n").length;
        return 1
    }
    function sizeVHeader(chart, dim, ignorevHeaderLabels) {
        var colLabels = chart.get("matrixProperties.colLabels.labels");
        if (colLabels && !tdg.isNestedLabels(colLabels)) {
            var props = chart.matrixProperties.colLabels;
            var maxHeight = 0;
            dim.hHeaderNeedLines = 1;
            for (var c = 0; c < dim.cols; c++) {
                var label = colLabels[c];
                var forcedLines = countLines(label);
                var size = chart.measureLabel(label, props.font);
                if (dim.cellsInfo && dim.cellsInfo.ww && dim.cellsInfo.ww[c])
                    label = chart.applyWrapAndTruncate(label, props.font, props.wrap, "colLabels", dim.cellsInfo.ww[c] - 5);
                var angle = tdg.boundAngle(props.rotation || 0, "degrees");
                if (angle == 90 || angle == 270) {
                    maxHeight = Math.max(maxHeight, size.width);
                    dim.hHeaderNeedLines = 1
                } else {
                    maxHeight = Math.max(maxHeight, size.height / forcedLines);
                    dim.hHeaderNeedLines = Math.max(dim.hHeaderNeedLines, countLines(label))
                }
                dim.vHeaderLabelsHeight = ignorevHeaderLabels ? 0 : dim.hHeaderNeedLines * maxHeight + 5
            }
        } else if (colLabels) {
            dim.vHeaderSingleLabelHeight = tdg.measureFont(chart.matrixProperties.colLabels.font).height + 5;
            buildNestedColInfo(chart, colLabels, dim);
            dim.vHeaderLabelsHeight = ignorevHeaderLabels ? 0 : chart.nestedHeaderDepth(colLabels) * dim.vHeaderSingleLabelHeight
        } else
            dim.vHeaderLabelsHeight = 0
    }
    function flatten_rowHeaderLabel(labelObject) {
        var headerTitleLabel;
        if (!labelObject.text)
            return undefined;
        if (Array.isArray(labelObject.text)) {
            if (labelObject.text.length) {
                headerTitleLabel = tdg.cloneObject(labelObject);
                headerTitleLabel.text = labelObject.text.join(labelObject.separator || " : ")
            }
        } else
            headerTitleLabel = labelObject;
        return headerTitleLabel
    }
    function sizeMatrixHeaders(chart, dim, isLastPass) {
        dim.topHorizTitle = !dim.vHeaderSide;
        var horizPad = 8;
        var maxRowWidth = MATRIX_HEADER_MAX_LEN_NESTED * dim.chart.width;
        var rowLabels = chart.matrixProperties.rowLabels.labels;
        if (rowLabels && !tdg.isNestedLabels(rowLabels)) {
            var angle = tdg.boundAngle(chart.matrixProperties.rowLabels.rotation || 0, "degrees");
            maxRowWidth = MATRIX_HEADER_MAX_LEN * dim.chart.width;
            dim.hHeaderLabelsWidthFull = rowLabels.reduce(function(max, l) {
                return Math.max(max, chart.measureLabel(l, chart.matrixProperties.rowLabels.font).width)
            }, 0);
            if (angle == 90 || angle == 270) {
                dim.hHeaderLabelsWidth = Math.min(maxRowWidth, chart.measureLabel(rowLabels[0], chart.matrixProperties.rowLabels.font).height);
                dim.hHeaderLabelsHeight = maxRowWidth
            } else {
                dim.hHeaderLabelsWidth = Math.min(maxRowWidth, dim.hHeaderLabelsWidthFull);
                dim.hHeaderLabelsHeight = chart.measureLabel(rowLabels[0], chart.matrixProperties.rowLabels.font).height
            }
        } else if (rowLabels) {
            dim.hRowWidths = chart.nestedRowWidths(rowLabels, chart.matrixProperties.rowLabels.font);
            if (dim.topHorizTitle && chart.matrixProperties.rowHeader.alignColumns && Array.isArray(chart.matrixProperties.rowHeader.text))
                dim.hRowWidths = dim.hRowWidths.map(function(width, i) {
                    var titlePartText = chart.matrixProperties.rowHeader.text[i];
                    var titlePartSize = titlePartText ? chart.measureLabel(titlePartText + "z", chart.matrixProperties.rowHeader.font) : {
                        height: 0,
                        width: 0
                    };
                    return Math.max(width, titlePartSize.width)
                });
            dim.hHeaderLabelsWidth = tdg.sum(dim.hRowWidths);
            if (isLastPass && dim.hHeaderLabelsWidth > maxRowWidth) {
                var depth = chart.nestedHeaderDepth(rowLabels);
                var subRowHeaderWidth = dim.hHeaderSpace[dim.hHeaderSide] / depth;
                var rowLabelMap = buildRowLabelMap(chart, rowLabels, subRowHeaderWidth);
                chart.cache.set("rowLabelMap", rowLabelMap);
                dim.hRowWidths = tdg.repeat(subRowHeaderWidth, dim.hRowWidths.length);
                dim.hHeaderLabelsWidth = tdg.sum(dim.hRowWidths)
            } else {
                dim.hHeaderLabelsWidth = Math.min(dim.hHeaderLabelsWidth, maxRowWidth);
                dim.hHeaderLabelsHeight = chart.measureLabel("W", chart.matrixProperties.rowLabels.font).height
            }
        } else
            dim.hHeaderLabelsWidth = 0;
        var headerTitleLabel = flatten_rowHeaderLabel(chart.matrixProperties.rowHeader);
        dim.hHeaderTitleWidth = headerTitleLabel && !dim.topHorizTitle ? chart.measureLabel(headerTitleLabel).height + 2 : 0;
        dim.hHeaderTopTitleSize = headerTitleLabel && dim.topHorizTitle ? chart.measureLabel(headerTitleLabel) : {
            width: 0,
            height: 0
        };
        dim.vHeaderTitleHeight = chart.matrixProperties.colHeader.text ? chart.measureLabel(chart.matrixProperties.colHeader).height + 8 : 0;
        dim.hHeaderTopTitleSize.width += dim.hHeaderTopTitleSize.width === 0 ? 0 : horizPad;
        dim.hHeaderLabelsWidth += dim.hHeaderLabelsWidth === 0 ? 0 : horizPad;
        if (chart.cache.get("xaxisTitleInHeader")) {
            maxRowWidth = MATRIX_HEADER_MAX_LEN * dim.chart.width * 1.5;
            var axisTitleSize = chart.measureLabel(chart.axisList.x1.title);
            axisTitleSize.width = Math.min(Math.max(dim.hAxisWidth || 0, maxRowWidth / 2), axisTitleSize.width) + 10;
            dim.hHeaderTopTitleSize.width += axisTitleSize.width;
            dim.hHeaderTopTitleSize.height = Math.max(dim.hHeaderTopTitleSize.height, axisTitleSize.height);
            dim.hHeaderAxisTitleWidth = axisTitleSize.width
        }
        dim.hHeaderTopTitleSize.width = Math.min(dim.hHeaderTopTitleSize.width, maxRowWidth);
        if (dim.hHeaderTopTitleSize.height)
            dim.hHeaderTopTitleSize.height += 2;
        sizeVHeader(chart, dim, !!chart.cache.get("matrixFacetCols"));
        dim.vHeaderTitleHeight = Math.max(dim.vHeaderTitleHeight, dim.hHeaderTopTitleSize.height - dim.vAxisSpace[0] - dim.vHeaderLabelsHeight);
        var hHeaderWidth = dim.hHeaderTitleWidth + dim.hHeaderLabelsWidth + dim.hAxisSpace[dim.hHeaderSide];
        if (dim.hHeaderTopTitleSize.width > hHeaderWidth) {
            dim.hHeaderLabelsWidth += dim.hHeaderTopTitleSize.width - hHeaderWidth;
            hHeaderWidth = dim.hHeaderTopTitleSize.width
        }
        if (!dim.hHeaderSide)
            dim.hHeaderSpace = [hHeaderWidth, dim.hAxisSpace[1]];
        else
            dim.hHeaderSpace = [dim.hAxisSpace[0], hHeaderWidth];
        if (!dim.vHeaderSide)
            dim.vHeaderSpace = [Math.max(dim.hHeaderTopTitleSize.height, dim.vHeaderTitleHeight + dim.vHeaderLabelsHeight + dim.vAxisSpace[0]), dim.vAxisSpace[1]];
        else
            dim.vHeaderSpace = [dim.vAxisSpace[0], dim.vHeaderTitleHeight + dim.vHeaderLabelsHeight + dim.vAxisSpace[1]]
    }
    var get_label = function(data, index, align) {
        var text;
        if (data == null)
            return {
                visible: false
            };
        if (data.labels != null) {
            if (index == null || data.labels[index] == null)
                return {
                    visible: false
                };
            text = data.labels[index]
        } else
            text = data.text;
        return {
            text: text,
            visible: true,
            align: data.align || align || "center",
            font: data.font,
            color: data.color,
            tooltip: data.tooltip
        }
    };
    function drawMatrixHeaders(chart, panels, dim) {
        var hHeaderTopTitlePanel, i, t, lbl, labelInfo, className;
        var hHeaderWidth = dim.hHeaderSpace[dim.hHeaderSide];
        if (hHeaderWidth) {
            var matrixType = chart.matrixProperties.chartType;
            var xaxisTitleInHeader = chart.blaProperties.orientation === "horizontal" && (matrixType === "bar" || matrixType === "line" || matrixType === "area") && chart.cache.get("xaxisTitleInHeader");
            var rowTitlePanel = !dim.hHeaderSide ? panels.rowTitlePanelL : panels.rowTitlePanelR;
            if (chart.matrixProperties.rowHeader.text != null && !rowTitlePanel.ignore && panels.panel.p) {
                className = chart.buildClassName("rowHeader-label");
                if (dim.topHorizTitle) {
                    var maxSize = dim.hHeaderTopTitleSize.width - (xaxisTitleInHeader ? dim.hHeaderAxisTitleWidth : 0);
                    hHeaderTopTitlePanel = rowTitlePanel.p.add(pv.Panel).width(hHeaderWidth).left(0).top(-2).height(dim.vHeaderSpace[0]);
                    hHeaderTopTitlePanel.computedSize = {
                        width: hHeaderWidth,
                        height: dim.vHeaderSpace[0]
                    };
                    if (!chart.matrixProperties.rowHeader.alignColumns || !Array.isArray(chart.matrixProperties.rowHeader.text)) {
                        var headerTitleLabel = flatten_rowHeaderLabel(chart.matrixProperties.rowHeader);
                        chart.drawTruncatedTitle(hHeaderTopTitlePanel, get_label(headerTitleLabel, null, "left"), className, null, 2, "bottom", null, maxSize)
                    } else {
                        var rowHeaderLabel = tdg.cloneObject(chart.matrixProperties.rowHeader);
                        var pos = 0;
                        chart.matrixProperties.rowHeader.text.forEach(function(label, i) {
                            if (label) {
                                var lPanel = hHeaderTopTitlePanel.add(pv.Panel).width(dim.hRowWidths[i]);
                                lPanel.computedSize = {
                                    width: dim.hRowWidths[i],
                                    height: dim.vHeaderSpace[0]
                                };
                                if (!chart.matrixProperties.rowLabels.swapChartSide)
                                    lPanel.left(pos);
                                else
                                    lPanel.right(pos);
                                rowHeaderLabel.text = label;
                                chart.drawTruncatedTitle(lPanel, get_label(rowHeaderLabel, null, "left"), className, null, 2, "bottom", null, dim.hRowWidths[i])
                            }
                            pos += dim.hRowWidths[i]
                        })
                    }
                } else {
                    var hHeaderTitle = rowTitlePanel.p.add(pv.Panel).className("gHorizTitle");
                    hHeaderTitle.computedSize = {
                        width: rowTitlePanel.w,
                        height: rowTitlePanel.h
                    };
                    var headerTitleLabel = flatten_rowHeaderLabel(chart.matrixProperties.rowHeader);
                    chart.drawLabel(hHeaderTitle, get_label(headerTitleLabel), className, null, null, "center", !dim.hHeaderSide ? 90 : -90)
                }
            }
            if (xaxisTitleInHeader) {
                if (!hHeaderTopTitlePanel) {
                    hHeaderTopTitlePanel = rowTitlePanel.p.add(pv.Panel).width(hHeaderWidth).left(0).top(-2).height(dim.vHeaderSpace[0]);
                    hHeaderTopTitlePanel.computedSize = {
                        width: hHeaderWidth,
                        height: dim.vHeaderSpace[0]
                    }
                }
                chart.axisList.x1.title.align = "right";
                chart.axisList.x1.title.visible = true;
                chart.drawTruncatedTitle(hHeaderTopTitlePanel, chart.axisList.x1.title, "xaxisOrdinal-title", 0, 2, "bottom", null, dim.hHeaderAxisTitleWidth)
            }
            var hHeaderLabel;
            var rowLabelsPanel = !dim.hHeaderSide ? panels.rowLabelsPanelL : panels.rowLabelsPanelR;
            var rowLabels = rowLabelsPanel.p == null ? null : chart.matrixProperties.rowLabels.labels;
            if (rowLabels && !tdg.isNestedLabels(rowLabels))
                for (var r = 0; r < dim.rows; r++) {
                    hHeaderLabel = rowLabelsPanel.p.add(pv.Panel).height(dim.cellsInfo.hh[r]).left(0).top(dim.cellsInfo.ho[r]);
                    hHeaderLabel.computedSize = {
                        width: dim.hHeaderLabelsWidth,
                        height: dim.cellsInfo.hh[r]
                    };
                    var valign = chart.get("matrixProperties.rowLabels.valign", "middle");
                    className = chart.buildClassName("rowLabel", null, null, null, r, null);
                    var angle = tdg.boundAngle(chart.matrixProperties.rowLabels.rotation || 0, "degrees");
                    if (!(angle == 90 || angle == 180 || angle == 270))
                        if (dim.hHeaderLabelsWidthFull > dim.hHeaderLabelsWidth) {
                            var label = get_label(chart.matrixProperties.rowLabels, r, "left");
                            var wrapLines = Math.floor(hHeaderLabel.computedSize.height / dim.hHeaderLabelsHeight);
                            label.text = chart.applyWrapAndTruncate(label.text, label.font, wrapLines, "rowLabels", dim.hHeaderLabelsWidth - 5);
                            chart.drawTruncatedTitle(hHeaderLabel, label, className, null, 0, valign, null, dim.hHeaderLabelsWidth - 5)
                        } else {
                            var defaultAlign = !dim.hHeaderSide ? "left" : "right";
                            chart.drawLabel(hHeaderLabel, get_label(chart.matrixProperties.rowLabels, r, defaultAlign), className, null, 0, valign, undefined, 3)
                        }
                    else {
                        var labelStyle = get_label(chart.matrixProperties.rowLabels, r);
                        var scene = chart.cache.get("tdgscene");
                        var group = scene.group(hHeaderLabel);
                        var anchor = tdg.getAnchoredLabelAligns(!chart.matrixProperties.rowLabels.swapChartSide ? "left" : "right", angle);
                        labelStyle.className = className;
                        labelStyle.align = anchor.align;
                        labelStyle.valign = anchor.valign;
                        labelStyle.rotation = -angle;
                        var pad = 3;
                        labelStyle.translate = {
                            x: chart.matrixProperties.rowLabels.swapChartSide ? pad : hHeaderLabel.computedSize.width - pad,
                            y: hHeaderLabel.computedSize.height / 2
                        };
                        group.label(0, 0, labelStyle.text, labelStyle)
                    }
                }
            else if (rowLabels) {
                labelInfo = buildNestedRowInfo(rowLabels, dim) || [];
                for (i = 0; i < labelInfo.length; i++) {
                    lbl = labelInfo[i];
                    hHeaderLabel = rowLabelsPanel.p.add(pv.Panel).width(lbl.width).height(dim.cellsInfo.hh[lbl.rowID]).top(lbl.top);
                    if (!dim.hHeaderSide)
                        hHeaderLabel.left(lbl.left);
                    else
                        hHeaderLabel.right(lbl.left);
                    var rowLabelMap = chart.cache.get("rowLabelMap", {});
                    hHeaderLabel.computedSize = {
                        width: lbl.width,
                        height: dim.cellsInfo.hh[lbl.rowID]
                    };
                    t = {
                        text: rowLabelMap[lbl.text] || lbl.text,
                        font: chart.matrixProperties.rowLabels.font,
                        color: chart.matrixProperties.rowLabels.color
                    };
                    chart.drawLabel(hHeaderLabel, get_label(t, null, "left"), "gtitle", null, 0, "center", null, "center")
                }
            }
        }
        var vHeaderHeight = dim.vHeaderSpace[dim.vHeaderSide];
        if (vHeaderHeight) {
            var colTitlePanel = !dim.vHeaderSide ? panels.colTitlePanelT : panels.colTitlePanelB;
            if (!colTitlePanel.ignore && panels.panel.p) {
                var vHeader = colTitlePanel.p.add(pv.Panel);
                vHeader.computedSize = {
                    width: colTitlePanel.w,
                    height: colTitlePanel.h
                };
                if (chart.matrixProperties.colHeader.text != null) {
                    className = chart.buildClassName("colHeader-label");
                    var vHeaderTitle = vHeader.add(pv.Panel).height(dim.vHeaderTitleHeight).className("gVertTitle").top(!dim.vHeaderSide ? -6 : -2);
                    vHeaderTitle.computedSize = {
                        width: vHeader.computedSize.width,
                        height: dim.vHeaderTitleHeight
                    };
                    chart.drawLabel(vHeaderTitle, get_label(chart.matrixProperties.colHeader), className, null, 0, "bottom")
                }
            }
            var vHeaderLabel, colLabels = chart.matrixProperties.colLabels.labels;
            var colLabelsPanel = !dim.vHeaderSide ? panels.colLabelsPanelT : panels.colLabelsPanelB;
            if (chart.cache.get("matrixFacetCols"))
                ;
            else if (colLabels && !colLabelsPanel.ignore && !tdg.isNestedLabels(colLabels))
                for (var c = 0; c < dim.cols; c++) {
                    vHeaderLabel = colLabelsPanel.p.add(pv.Panel).width(dim.cellsInfo.ww[c]).left(dim.cellsInfo.wo[c]);
                    if (!dim.vHeaderSide)
                        vHeaderLabel.bottom(3);
                    else
                        vHeaderLabel.top(3);
                    vHeaderLabel.computedSize = {
                        width: dim.cellsInfo.ww[c],
                        height: colLabelsPanel.p.computedSize.height - 3
                    };
                    className = chart.buildClassName("colLabel", null, null, null, null, c);
                    var angle = tdg.boundAngle(chart.matrixProperties.colLabels.rotation || 0, "degrees");
                    if (!(angle == 90 || angle == 180 || angle == 270)) {
                        var label = get_label(chart.matrixProperties.colLabels, c);
                        label.text = chart.applyWrapAndTruncate(label.text, label.font, dim.hHeaderNeedLines, "colLabels", dim.cellsInfo.ww[c] - 5);
                        chart.drawTruncatedTitle(vHeaderLabel, label, className, null, 0, "bottom")
                    } else {
                        var labelStyle = get_label(chart.matrixProperties.colLabels, c);
                        var scene = chart.cache.get("tdgscene");
                        var group = scene.group(vHeaderLabel);
                        var anchor = tdg.getAnchoredLabelAligns(!chart.matrixProperties.colLabels.swapChartSide ? "top" : "bottom", angle);
                        labelStyle.className = className;
                        labelStyle.align = anchor.align;
                        labelStyle.valign = anchor.valign;
                        labelStyle.rotation = -angle;
                        var pad = 3;
                        labelStyle.translate = {
                            x: vHeaderLabel.computedSize.width / 2,
                            y: chart.matrixProperties.colLabels.swapChartSide ? pad : vHeaderLabel.computedSize.height - pad
                        };
                        group.label(0, 0, labelStyle.text, labelStyle)
                    }
                }
            else if (colLabels && !colLabelsPanel.ignore) {
                labelInfo = buildNestedColInfo(chart, colLabels, dim, true);
                for (i = 0; i < labelInfo.length; i++) {
                    lbl = labelInfo[i];
                    vHeaderLabel = colLabelsPanel.p.add(pv.Panel).width(lbl.width).left(lbl.left).height(dim.vHeaderSingleLabelHeight);
                    if (!dim.vHeaderSide)
                        vHeaderLabel.top(lbl.top - 2.5);
                    else
                        vHeaderLabel.bottom(lbl.top - .5);
                    vHeaderLabel.computedSize = {
                        width: lbl.width,
                        height: dim.vHeaderSingleLabelHeight
                    };
                    t = {
                        text: lbl.text,
                        font: chart.matrixProperties.colLabels.font,
                        color: chart.matrixProperties.colLabels.color
                    };
                    chart.drawLabel(vHeaderLabel, get_label(t), "gtitle", null, 0, "center")
                }
            }
        }
    }
    function drawCellColHeaders(chart, chartLayout, matrixChartPanels, dim) {
        miniChartEach(matrixChartPanels, function(chartPanels, r, c) {
            if (tdg.isEmpty(chart._internalData[r][c]))
                return;
            var index = r * dim.cols + c;
            vHeaderLabel = chartPanels.matrixCell.fg.add(pv.Panel).width(dim.cellsInfo.ww[c]);
            vHeaderLabel.computedSize = {
                width: dim.cellsInfo.ww[c],
                height: dim.vHeaderLabelsHeight
            };
            className = chart.buildClassName("colLabel", null, null, null, null, c);
            chart.drawTruncatedTitle(vHeaderLabel, get_label(chart.matrixProperties.colLabels, index), className, null, 6, "top")
        })
    }
    function buildNestedRowInfo(labels, dim) {
        var labelInfo = [];
        var depthSums = {};
        var rowID = 0;
        dim.hGridlineWidths = [];
        function visit(labelList, d) {
            var i;
            depthSums[d] = depthSums[d] || 0;
            if (labelList[0] && typeof labelList[0] === "object") {
                var childrenHeightSum = 0;
                for (i = 0; i < labelList.length; i++) {
                    if (rowID >= dim.rows)
                        continue;
                    var v = labelList[i];
                    for (var key in v)
                        if (v.hasOwnProperty(key)) {
                            var myRowID = rowID;
                            var childrenHeight = visit(v[key], d + 1);
                            dim.hGridlineWidths.pop();
                            dim.hGridlineWidths.push(d);
                            labelInfo.push({
                                text: key,
                                width: dim.hRowWidths[d],
                                left: tdg.sum(dim.hRowWidths.slice(0, d)),
                                top: depthSums[d],
                                rowID: myRowID
                            });
                            depthSums[d] = childrenHeight;
                            childrenHeightSum = childrenHeight
                        }
                }
                return childrenHeightSum
            } else {
                for (i = 0; i < labelList.length; i++) {
                    if (rowID >= dim.rows)
                        continue;
                    labelInfo.push({
                        text: labelList[i],
                        width: dim.hRowWidths[d],
                        left: tdg.sum(dim.hRowWidths.slice(0, d)),
                        top: depthSums[d],
                        rowID: rowID
                    });
                    depthSums[d] += dim.cellsInfo.hh[rowID];
                    dim.hGridlineWidths.push(d);
                    rowID += 1
                }
                return depthSums[d]
            }
        }
        visit(labels, 0);
        return labelInfo
    }
    function buildNestedColInfo(chart, labels, dim, giveCached) {
        if (giveCached && chart.cache.hasKey("cachedNestedColInfo"))
            return chart.cache.get("cachedNestedColInfo");
        var labelInfo = [];
        var depthSums = {};
        var currentColumn = 0;
        dim.vGridlineHeights = [];
        var leafLabel, parentLabel, props = chart.matrixProperties.colLabels;
        function visit(labelList, d) {
            var i, childrenWidth;
            depthSums[d] = depthSums[d] || 0;
            if (labelList[0] && typeof labelList[0] === "object") {
                var childrenWidthSum = 0;
                for (i = 0; i < labelList.length; i++) {
                    var v = labelList[i];
                    for (var key in v)
                        if (v.hasOwnProperty(key)) {
                            childrenWidth = visit(v[key], d + 1);
                            if (childrenWidth <= 0)
                                continue;
                            dim.vGridlineHeights.pop();
                            dim.vGridlineHeights.push(d - 1);
                            parentLabel = chart.truncateLabel(key, props.font, childrenWidth, true);
                            labelInfo.push({
                                text: parentLabel,
                                width: childrenWidth,
                                left: depthSums[d],
                                top: dim.vHeaderSingleLabelHeight * (d - 1)
                            });
                            depthSums[d] += childrenWidth;
                            childrenWidthSum += childrenWidth
                        }
                }
                return childrenWidthSum
            } else {
                childrenWidth = 0;
                for (i = 0; i < labelList.length; i++) {
                    if (currentColumn >= dim.cellsInfo.ww.length)
                        return childrenWidth;
                    var colWidth = dim.cellsInfo.ww[currentColumn];
                    leafLabel = chart.truncateLabel(labelList[i], props.font, colWidth, true);
                    labelInfo.push({
                        text: leafLabel,
                        width: colWidth,
                        left: depthSums[d],
                        top: dim.vHeaderSingleLabelHeight * (d - 1)
                    });
                    depthSums[d] += colWidth;
                    childrenWidth += colWidth;
                    dim.vGridlineHeights.push(d - 1);
                    currentColumn += 1
                }
                return childrenWidth
            }
        }
        visit(labels, 1);
        chart.cache.set("cachedNestedColInfo", labelInfo);
        return labelInfo
    }
    function colGridLineHeight(idx, dim) {
        if (idx > 0)
            return dim.vHeaderSingleLabelHeight * dim.vGridlineHeights[idx - 1];
        return dim.vHeaderTitleHeight
    }
    function rowGridLineWidth(idx, dim) {
        if (idx > 0)
            return tdg.sum(dim.hRowWidths.slice(0, dim.hGridlineWidths[idx - 1]));
        return dim.hHeaderTitleWidth
    }
    function drawMatrixGrid(chart, chartPanel, panels, dim) {
        var panel = panels.panel.p;
        if (!chart.matrixProperties.cellBorder.width || !panel)
            return;
        for (var c = 1; c < dim.cols; c++) {
            panel.add(pv.Rule).left(dim.cellsInfo.wo[c]).lineStyle(chart.matrixProperties.cellBorder);
            if (panels.colAxisPanelT.p)
                panels.colAxisPanelT.p.add(pv.Rule).bottom(0).left(dim.cellsInfo.wo[c]).top(0).lineStyle(chart.matrixProperties.cellBorder);
            if (panels.colAxisPanelB.p)
                panels.colAxisPanelB.p.add(pv.Rule).bottom(0).left(dim.cellsInfo.wo[c]).top(0).lineStyle(chart.matrixProperties.cellBorder);
            if (panels.colLabelsPanelT.p)
                panels.colLabelsPanelT.p.add(pv.Rule).bottom(0).left(dim.cellsInfo.wo[c]).top(dim.vGridlineHeights ? colGridLineHeight(c, dim) : 0).lineStyle(chart.matrixProperties.cellBorder);
            if (panels.colLabelsPanelB.p)
                panels.colLabelsPanelB.p.add(pv.Rule).top(0).left(dim.cellsInfo.wo[c]).bottom(dim.vGridlineHeights ? colGridLineHeight(c, dim) : 0).lineStyle(chart.matrixProperties.cellBorder)
        }
        chartPanel.add(pv.Rule).left(panels.panel.x).top(0).bottom(dim.scroll_space.bottom).lineStyle(chart.matrixProperties.cellBorder);
        chartPanel.add(pv.Rule).left(panels.panel.x + panels.panel.w - 1).top(0).bottom(dim.scroll_space.bottom).lineStyle(chart.matrixProperties.cellBorder);
        for (var r = 1; r < dim.rows; r++) {
            panel.add(pv.Rule).top(dim.cellsInfo.ho[r]).lineStyle(chart.matrixProperties.cellBorder);
            if (panels.rowAxisPanelL.p)
                panels.rowAxisPanelL.p.add(pv.Rule).top(dim.cellsInfo.ho[r]).lineStyle(chart.matrixProperties.cellBorder);
            if (panels.rowAxisPanelR.p)
                panels.rowAxisPanelR.p.add(pv.Rule).top(dim.cellsInfo.ho[r]).lineStyle(chart.matrixProperties.cellBorder);
            if (panels.rowLabelsPanelL.p)
                panels.rowLabelsPanelL.p.add(pv.Rule).right(0).left(dim.hGridlineWidths ? rowGridLineWidth(r, dim) : 0).top(dim.cellsInfo.ho[r]).lineStyle(chart.matrixProperties.cellBorder);
            if (panels.rowLabelsPanelR.p)
                panels.rowLabelsPanelR.p.add(pv.Rule).left(0).right(dim.hGridlineWidths ? rowGridLineWidth(r, dim) : 0).top(dim.cellsInfo.ho[r]).lineStyle(chart.matrixProperties.cellBorder)
        }
        chartPanel.add(pv.Rule).top(panels.panel.y).left(0).right(dim.scroll_space.right).lineStyle(chart.matrixProperties.cellBorder);
        chartPanel.add(pv.Rule).top(panels.panel.y + panels.panel.h).left(0).right(dim.scroll_space.right).lineStyle(chart.matrixProperties.cellBorder)
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    tdgchart.prototype.morph = function(finalChart) {
        var chart = this;
        var docRoot = chart.documentRoot || chart.containerID;
        var div = document.getElementById(docRoot);
        var duration = chart.morphAnimation.duration;
        var isPieChart = chart.chartType === "pie" || chart.chartType === "matrix" && chart.matrixProperties.chartType === "pie";
        if (!div || chart._isMorphing)
            return;
        var initialSVG = firstSVGChild(div);
        if (initialSVG == null) {
            chart.draw(docRoot);
            if (chart.dataPageSlider.enabled)
                window.setTimeout(function() {
                    chart.stepDataPageSlider()
                }, chart.dataPageSlider.animateButton.delay);
            return
        }
        if (finalChart != null)
            chart.set(finalChart);
        var error = false;
        var seriesCount = Math.max(chart.seriesCount(), 1);
        var groupCount = Math.max(chart.groupCount(), 1);
        if (chart.isExtension())
            error = true;
        else if (seriesCount * groupCount > 500)
            error = true;
        else if (chart.chartType === "matrix") {
            var rowCount = Math.max(chart.data.length, 1);
            var colCount = Math.max(Math.max.apply(null, chart.data.map(function(el) {
                return el.length
            })), 1);
            if (rowCount * colCount * seriesCount * groupCount > 300)
                error = true
        }
        if (error) {
            chart.draw(docRoot);
            if (chart.dataPageSlider.enabled)
                window.setTimeout(function() {
                    chart.stepDataPageSlider()
                }, chart.dataPageSlider.animateButton.delay);
            return
        }
        chart._isMorphing = true;
        var introAnimationEnabled = chart.introAnimation.enabled;
        chart.introAnimation.enabled = false;
        chart.draw(docRoot);
        chart.introAnimation.enabled = introAnimationEnabled;
        chart._disableHover = chart._disableToolTips = chart._disableSelection = true;
        var finalSVG = firstSVGChild(div);
        if (finalSVG == null) {
            delete chart._isMorphing;
            return
        }
        div.replaceChild(initialSVG, finalSVG);
        if (chart.narrativeText.enabled && chart.narrativeText.content == null && chart.cache.hasKey("narrative_text_result")) {
            var narrativeTextCache = chart.cache.get("narrative_text_result");
            if (narrativeTextCache.content == null) {
                narrativeTextCache.doMorph = true;
                delete chart._isMorphing;
                return
            }
        }
        var newDiv = document.createElementNS(tdg.ns.xhtml, "div");
        newDiv.setAttribute("style", "opacity: 0; position: absolute; left: 0px; top: 0px; z-index: -9999");
        newDiv.appendChild(finalSVG);
        div.parentNode.appendChild(newDiv);
        var updateMorphCount = function() {
            var transitionCount = 0;
            var done = false;
            window.setTimeout(function() {
                if (!done) {
                    done = true;
                    endMorph()
                }
            }, chart.morphAnimation.duration * 1.15);
            return function(transition) {
                transition.each("start", function() {
                    transitionCount += 1
                }).each("end", function() {
                    transitionCount -= 1;
                    if (transitionCount <= 0 && !done) {
                        done = true;
                        endMorph()
                    }
                })
            }
        }();
        function endMorph() {
            if (initialSVG.parentNode && initialSVG.parentNode === div)
                div.replaceChild(finalSVG, initialSVG);
            else {
                tdg.dom.empty(div);
                div.appendChild(finalSVG)
            }
            div.parentNode.removeChild(newDiv);
            chart._disableHover = chart._disableToolTips = chart._disableSelection = false;
            chart._isMorphing = false;
            if (chart.dataPageSlider.enabled)
                chart.stepDataPageSlider();
            chart.processRenderComplete()
        }
        if (chart.morphAnimation.mode === "slideLeft") {
            var x = tdgchart.util.get("chartLayout.axisLayout.xScalesList[0]", chart.cache.get("layout"));
            var scrollPanel = document.querySelector(".scrollriserPanel");
            if (!scrollPanel || x == null) {
                endMorph();
                return
            }
            var transform = scrollPanel.getAttribute("transform");
            transform = tdgchart.translateStrToObject(transform);
            var dx = x(1) - x(0);
            tdgchart.d3.select(".scrollriserPanel").transition().call(updateMorphCount).duration(chart.morphAnimation.duration).ease("linear").attr("transform", "translate(" + (transform.x - dx) + ", " + transform.y + ")");
            return
        }
        var attrMap = {
            path: ["d", "transform"],
            rect: ["x", "y", "width", "height"],
            line: ["x1", "y1", "x2", "y2"],
            text: ["transform", "textContent"],
            circle: ["transform", "r"],
            stop: ["offset", "stop-color"]
        };
        var urlMatch = /^url\(#(.*)\)$/;
        function transitionColor(t, initialNode, finalNode, attr) {
            var startFill = initialNode.getAttribute(attr);
            var endFill = finalNode.getAttribute(attr);
            if (startFill != null && endFill != null && startFill !== endFill)
                if (startFill.startsWith("url(#") && endFill.startsWith("url(#")) {
                    var startId = startFill.match(urlMatch)[1];
                    var endId = endFill.match(urlMatch)[1];
                    var startGradientDef = document.getElementById(startId);
                    var endGradientDef = document.getElementById(endId);
                    transitionExactSVG(startGradientDef, endGradientDef)
                } else
                    t.attrTween(attr, function() {
                        return tdgchart.d3.interpolateRgb(startFill, endFill)
                    })
        }
        function transitionStyles(t, initialNode, finalNode) {
            if (initialNode.hasAttribute("fill-opacity") || finalNode.hasAttribute("fill-opacity")) {
                if (!initialNode.hasAttribute("fill-opacity"))
                    initialNode.setAttribute("fill-opacity", 1);
                if (!finalNode.hasAttribute("fill-opacity"))
                    finalNode.setAttribute("fill-opacity", 1);
                t.attr("fill-opacity", finalNode.getAttribute("fill-opacity"))
            }
            transitionColor(t, initialNode, finalNode, "fill")
        }
        function transition(initialNode, finalNode) {
            var attrs = attrMap[initialNode.tagName];
            if (!attrs || !attrs.length)
                return;
            var className = initialNode.getAttribute("class");
            var dx = 0
              , dy = 0;
            var initialCTM = initialNode.parentNode && initialNode.parentNode.getCTM ? initialNode.parentNode.getCTM() : null;
            var finalCTM = finalNode.parentNode && finalNode.parentNode.getCTM ? finalNode.parentNode.getCTM() : null;
            if (initialCTM && finalCTM) {
                dx = finalCTM.e - initialCTM.e;
                dy = finalCTM.f - initialCTM.f
            }
            var t = tdgchart.d3.select(initialNode).transition().call(updateMorphCount).duration(className === "animateButtonIcon" ? 0 : duration).ease("linear");
            transitionStyles(t, initialNode, finalNode);
            attrs.map(function(el) {
                switch (el) {
                case "transform":
                    var finalT = tdgchart.translateStrToObject(finalNode.getAttribute(el)) || {
                        x: 0,
                        y: 0,
                        remainder: ""
                    };
                    finalT.x += dx;
                    finalT.y += dy;
                    if (finalT.x !== 0 || finalT.y !== 0 || finalT.remainder !== "") {
                        var morphT = "translate(" + finalT.x + "," + finalT.y + ") " + finalT.remainder;
                        morphT = morphT.trim();
                        t.attr("transform", morphT)
                    }
                    break;
                case "d":
                    if (initialNode.hasAttribute("d") && finalNode.hasAttribute("d"))
                        if (isPieChart && (className.includes("mwedge") || className.includes("mbevel")))
                            morphWedge(t, initialNode.getAttribute("d"), finalNode.getAttribute("d"));
                        else
                            t.attr("d", finalNode.getAttribute("d"));
                    break;
                case "stop-color":
                    transitionColor(t, initialNode, finalNode, "stop-color");
                    break;
                case "textContent":
                    if (className.includes("mdataLabels") && initialNode.textContent !== finalNode.textContent) {
                        var parent = initialNode.parentNode;
                        var clone = finalNode.cloneNode(true);
                        clone.isClone = true;
                        clone.style.opacity = "0";
                        parent.appendChild(clone);
                        tdgchart.d3.select(clone).transition().call(updateMorphCount).duration(duration).styleTween("opacity", function() {
                            return tdgchart.d3.interpolateNumber(0, 1)
                        }).attrTween("transform", function() {
                            return tdgchart.d3.interpolateString(initialNode.getAttribute("transform"), finalNode.getAttribute("transform"))
                        }).ease("linear");
                        t.styleTween("opacity", function() {
                            return tdgchart.d3.interpolateNumber(1, 0)
                        })
                    }
                    break;
                default:
                    var a = finalNode.getAttribute(el);
                    if (a != null)
                        t.attr(el, parseFloat(a) + (el.includes("x") ? dx : el.includes("y") ? dy : 0))
                }
            })
        }
        var arcPathRegEx = /[-+]?(\d+\.?\d*|\.?\d+)/g;
        var arcPathAttributeList = ["x0", "y0", "rx", "ry", "xrot", "large", "sf", "x1", "y1", "lineX0", "lineX1", "rInnerX", "rInnerY"];
        var arcNonringPathAttributeList = ["xzero", "yzero", "x0", "y0", "rx", "ry", "xrot", "large", "sf", "x1", "y1", "lineX0", "lineX1", "rInnerX", "rInnerY"];
        function parseArcPath(path) {
            if (!path.includes("L"))
                return "fullCircle";
            var pathObj = {};
            var pathAttributes = path.match(arcPathRegEx);
            function matchAttrs(key, idx) {
                pathObj[key] = parseFloat(pathAttributes[idx]);
                if (isNaN(pathObj[key]))
                    pathObj[key] = null
            }
            if (path.indexOf("M0,0 L") == 0)
                arcNonringPathAttributeList.forEach(matchAttrs);
            else
                arcPathAttributeList.forEach(matchAttrs);
            var config = {
                clockwise: true,
                base: Math.PI / 2
            };
            pathObj.startAngle = tdg.toPolar(pathObj.x0, -pathObj.y0, config).angle;
            pathObj.endAngle = tdg.toPolar(pathObj.x1, -pathObj.y1, config).angle;
            if (tdg.eq(pathObj.endAngle, 0))
                pathObj.endAngle = 2 * Math.PI;
            return pathObj
        }
        function pathObjToArc(path) {
            return tdgchart.d3.svg.arc().innerRadius(path.rInnerX || 0).outerRadius(path.rx).startAngle(path.startAngle).endAngle(path.endAngle)
        }
        function approximateFullCircle(path) {
            path = tdg.clone(path);
            if (tdg.eq(path.startAngle, 0))
                path.endAngle = 2 * Math.PI - .01;
            else
                path.endAngle = path.startAngle - .01;
            return path
        }
        function morphWedge(t, initPath, finalPath) {
            function getPath(initPath, finalPath) {
                initPath = parseArcPath(initPath);
                finalPath = parseArcPath(finalPath);
                if (initPath !== "fullCircle" && finalPath === "fullCircle")
                    finalPath = approximateFullCircle(initPath);
                else if (initPath === "fullCircle" && finalPath !== "fullCircle")
                    initPath = approximateFullCircle(finalPath);
                var arc = pathObjToArc(initPath);
                var startAngleInterpolator, endAngleInterpolator;
                if (!tdg.eq(initPath.startAngle, finalPath.startAngle))
                    startAngleInterpolator = tdgchart.d3.interpolateNumber(initPath.startAngle, finalPath.startAngle);
                if (!tdg.eq(initPath.endAngle, finalPath.endAngle))
                    endAngleInterpolator = tdgchart.d3.interpolateNumber(initPath.endAngle, finalPath.endAngle);
                return function(t) {
                    if (startAngleInterpolator)
                        arc.startAngle(startAngleInterpolator(t));
                    if (endAngleInterpolator)
                        arc.endAngle(endAngleInterpolator(t));
                    return arc()
                }
            }
            if (initPath != null && finalPath != null && initPath !== finalPath)
                t.attrTween("d", function() {
                    return getPath(initPath, finalPath)
                })
        }
        function toInvisible(node) {
            tdgchart.d3.select(node).transition().call(updateMorphCount).duration(duration).style("opacity", 0)
        }
        function childIndex(node) {
            return Array.prototype.indexOf.call(node.parentNode.childNodes, node)
        }
        function nodesEqual(a, b) {
            return a.nodeName === b.nodeName && a.getAttribute && b.getAttribute && a.getAttribute("class") === b.getAttribute("class") && a.getAttribute("transform") === b.getAttribute("transform")
        }
        function matchNodeInList(node, matchList) {
            function filterMatches(el) {
                el.parent = el.parent.parentNode;
                return nodesEqual(node, el.parent)
            }
            var childIndexMatches = tdg.filter(matchList, function(el) {
                return childIndex(el) === childIndex(node)
            });
            if (childIndexMatches.length === 1)
                return childIndexMatches[0];
            matchList = tdg.map(matchList, function(el) {
                return {
                    node: el,
                    parent: el
                }
            });
            while (node && node.parentNode && matchList.length > 1) {
                node = node.parentNode;
                matchList = tdg.filter(matchList, filterMatches)
            }
            if (matchList.length === 1)
                return matchList[0].node;
            return null
        }
        function findNodeMatch(node, cid, ids) {
            if (cid === "eventPanel" || cid === "rootPanel")
                return;
            cid = cid.replace(" leaflet-tile-loaded", "");
            var match, matchList = finalSVG.parentNode.getElementsByClassName(cid);
            matchList = tdg.filter(matchList, function(el) {
                return el.getAttribute("class") === cid
            });
            if (matchList.length > 1)
                match = matchNodeInList(node, matchList);
            else
                match = matchList[0];
            if (!match && ids.series && typeof ids.series === "string" && ids.series.includes(tdgchart.getTreemapLabelSeparator())) {
                var s = ids.series;
                var i = s.indexOf(tdgchart.getTreemapLabelSeparator());
                while (i >= 0 && i < s.length && !match) {
                    s = s.slice(i + 1);
                    match = finalSVG.parentNode.getElementsByClassName(ids.object + "!s" + s + "!g" + ids.group + "!m" + ids.misc)[0]
                }
            }
            if (match && !match.hasMatch) {
                transition(node, match);
                match.hasMatch = true
            } else if (!node.isClone)
                toInvisible(node)
        }
        var newNodes = [];
        function createUnmatchedNode(node, cid) {
            if (cid === "eventPanel" || cid === "rootPanel")
                return;
            if (!node.hasOwnProperty("hasMatch") || !node.hasMatch) {
                if (!node.getCTM)
                    return;
                var g = document.createElementNS(tdg.ns.svg, "g");
                var ctm = node.getCTM() || {
                    e: 0,
                    f: 0
                };
                var newNode = node.cloneNode(false);
                g.setAttribute("transform", "translate(" + ctm.e + "," + ctm.f + ")");
                newNode.setAttribute("transform", "");
                if (newNode.tagName === "text")
                    newNode.textContent = node.textContent;
                g.appendChild(newNode);
                initialSVG.appendChild(g);
                newNodes.push(newNode)
            }
        }
        function isValidNode(node) {
            return node && node.getAttribute && (!node.style || node.style.display !== "none")
        }
        function transitionExactSVG(initialNode, finalNode) {
            if (!isValidNode(initialNode) || !isValidNode(finalNode))
                return;
            transition(initialNode, finalNode);
            for (var i = 0; i < initialNode.childElementCount; i++)
                if (finalNode.childNodes[i])
                    transitionExactSVG(initialNode.childNodes[i], finalNode.childNodes[i])
        }
        function walkSVG(node, fx) {
            if (!isValidNode(node))
                return;
            var cid = node.getAttribute("class");
            if (cid) {
                var ids = chart.classNameToIds(cid);
                fx(node, cid, ids)
            }
            for (var i = 0; i < node.childElementCount; i++)
                walkSVG(node.childNodes[i], fx)
        }
        walkSVG(initialSVG, findNodeMatch);
        walkSVG(finalSVG, createUnmatchedNode);
        tdgchart.d3.selectAll(newNodes).style("opacity", 0).transition().call(updateMorphCount).duration(duration).style("opacity", 1)
    }
    ;
    function firstSVGChild(node) {
        for (var i = 0; i < node.children.length; i++)
            if (node.children[i].tagName === "svg")
                return node.children[i];
        return null
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    var defaultMarkerSize = 8;
    var chartAnnotations = ["chart", "xaxis", "yaxis"];
    tdgchart.prototype.drawChartFrameAnnotations = function(chartPanel, x, y, ySide) {
        var chart = this;
        if (!Array.isArray(chart.annotations) || tdg.isEmpty(chart.annotations))
            return;
        var scene = chart.cache.get("tdgscene");
        var groups = {
            chart: null,
            xaxis: null,
            yaxis: null
        };
        var scales = {};
        if (ySide === "left" || ySide === "right" || chart.chartType === "map") {
            scales.vertical = y;
            scales.horizontal = x
        } else {
            scales.vertical = x;
            scales.horizontal = y
        }
        chart.annotations.forEach(function(annotation, idx) {
            annotation = cloneAnnotation(annotation);
            if (annotation == null || annotation.position == null || typeof annotation.position.parent !== "string" || !chartAnnotations.includes(annotation.position.parent) && !annotation.position.parent.startsWith("series"))
                return;
            else if (!tryToDraw(annotation))
                return;
            var cb, panel, parent = (annotation.position.parent || "").toLowerCase();
            if (parent === "xaxis") {
                cb = addAxisAnnotation;
                panel = chartPanel.axis.x1.axis
            } else if (parent === "yaxis") {
                cb = addAxisAnnotation;
                panel = chartPanel.axis.y1.axis
            } else if (parent.startsWith("series")) {
                cb = addSeriesAnnotations;
                panel = chartPanel.riser.fg
            } else {
                cb = chart.chartType === "map" ? addMapChartAnnotations : addChartAnnotations;
                panel = chartPanel.riser.fg
            }
            if (!panel)
                return;
            if (!groups[parent])
                groups[parent] = scene.group(panel, parent + "AnnotationsGroup");
            if (tryToDraw(annotation))
                cb(chart, groups[parent], scales, annotation, idx, panel.computedSize)
        })
    }
    ;
    function getPropLookup(panel, index) {
        return function(prop) {
            prop = panel.$properties.filter(function(el) {
                return el.name === prop
            });
            if (prop[0]) {
                prop = prop[0];
                if (typeof prop.value === "function")
                    return prop.value.call({
                        parent: {
                            index: index
                        }
                    });
                return prop.value
            }
            return null
        }
    }
    tdgchart.prototype.drawChartAnnotations = function(childPanel, panelCount) {
        var chart = this;
        if (!Array.isArray(chart.annotations) || tdg.isEmpty(chart.annotations))
            return;
        var scene = chart.cache.get("tdgscene");
        var group;
        chart.annotations.forEach(function(annotation, idx) {
            annotation = cloneAnnotation(annotation);
            if (annotation == null || annotation.position == null || annotation.position.parent !== "chart")
                return;
            else if (!tryToDraw(annotation))
                return;
            if (!group)
                group = scene.group(childPanel.parent, "chartAnnotationsGroup");
            for (var i = 0; i < panelCount; i++) {
                var getProp = getPropLookup(childPanel, i);
                var computedSize = {
                    x: getProp("left"),
                    y: getProp("top"),
                    width: getProp("width"),
                    height: getProp("height")
                };
                addChartAnnotations(chart, group, {}, annotation, idx, computedSize)
            }
        })
    }
    ;
    tdgchart.prototype.drawAnnotations = function(rootPanel, layout) {
        var chart = this;
        if (!Array.isArray(chart.annotations) || tdg.isEmpty(chart.annotations))
            return;
        var scene = chart.cache.get("tdgscene");
        var backgroundGroup, legendGroup;
        chart.annotations.forEach(function(annotation, idx) {
            annotation = cloneAnnotation(annotation);
            if (annotation == null || annotation.position == null || chartAnnotations.includes(annotation.position.parent))
                return;
            else if (!tryToDraw(annotation))
                return;
            switch (annotation.position.parent) {
            case "legend":
                if (!legendGroup)
                    legendGroup = scene.group("legend", "legendAnnotationsGroup");
                addLegendAnnotations(chart, legendGroup, annotation, idx, layout.legend);
                break;
            case "background":
            default:
                if (!backgroundGroup)
                    backgroundGroup = scene.group("rootPanel", "backgroundAnnotationsGroup");
                addBackgroundAnnotations(chart, backgroundGroup, annotation, idx, rootPanel.computedSize);
                break
            }
        })
    }
    ;
    function cloneAnnotation(annotation) {
        annotation = tdg.clone(annotation);
        annotation.marker = annotation.marker || {};
        annotation.label = annotation.label || {};
        annotation.line = annotation.line || {};
        annotation.position = annotation.position || {};
        annotation.position.parent = annotation.position.parent || "background";
        return annotation
    }
    function tryToDraw(annotation) {
        var p = annotation.position;
        if (!p || typeof p.parent !== "string")
            return false;
        if (p.parent.toLowerCase().includes("axis")) {
            if (p.x == null && p.y == null)
                return false
        } else if (p.parent.toLowerCase().includes("series")) {
            if (p.y == null)
                return false
        } else if (tdg.isEmpty(p.points) && (p.x == null || p.y == null) && (p.top == null && p.bottom == null || p.left == null && p.right == null))
            return false;
        if (!annotation.marker.visible && !annotation.label.visible && !annotation.line.width && !tdg.color.isVisible(annotation.line.color))
            return false;
        return true
    }
    var convert = {
        "%": function(v, offsetProp) {
            return tdg.applyNumOrPercent(v + "%", offsetProp.height || offsetProp.size)
        },
        px: function(v) {
            return parseFloat(v)
        },
        scale: function(chart, v, offsetProp) {
            if (offsetProp.isMap) {
                var lat = offsetProp.height ? v : 0;
                var lng = offsetProp.height ? 0 : v;
                return offsetProp.scale({
                    lng: lng,
                    lat: lat
                })
            }
            var isExceptionChart = ["line", "waterfall", "histogram"].indexOf(chart.chartType) >= 0;
            var isStacked = chart.chartType === "bar" ? ["stacked", "percent"].indexOf(chart.blaProperties.seriesLayout) >= 0 : false;
            var isException = v.series == null || isStacked || isExceptionChart;
            if (typeof v === "string" && offsetProp.scale.type === "ordinal")
                v = offsetProp.scale.ordGroup(v) + .5;
            if (typeof v === "object" && offsetProp.scale.type === "ordinal") {
                if (v.group == null)
                    return null;
                var pos;
                if (isException)
                    pos = .5;
                else {
                    var series = v.series < offsetProp.scale.seriesCount ? v.series : null;
                    var step = offsetProp.scale.range().band / offsetProp.scale.seriesCount;
                    pos = (series * step + step / 2) / offsetProp.scale.range().band
                }
                if (typeof v.group === "number")
                    v = v.group < offsetProp.scale.groupCount ? v.group + pos : null;
                else if (typeof v.group === "string")
                    v = offsetProp.scale.ordGroup(v.group) + pos;
                else
                    return null
            }
            if (typeof v === "number" && offsetProp.scale.type === "ordinal") {
                if (offsetProp.scale.domain().length + 1 < v)
                    return null;
                var groupNumber = Math.floor(v);
                v = v % 1 === 0 ? v + .5 : v;
                var localOffset = offsetProp.scale.range().band * (v - Math.floor(v));
                return offsetProp.scale(groupNumber) + localOffset
            }
            if (typeof v === "number" && offsetProp.scale.type === "numeric") {
                var position = offsetProp.height ? offsetProp.height - offsetProp.scale(v) : offsetProp.scale(v);
                return position
            }
            return null
        }
    };
    function getCoordinate(v, offsetProp, chart) {
        var coordinate = 0;
        var pattern = /(-?[0-9.]+)(%|px)/;
        var args;
        if (offsetProp.displace)
            coordinate = offsetProp.displace;
        if (typeof v === "string" && (args = v.match(pattern)) && convert[args[2]])
            return coordinate + convert["" + args[2]](args[1], offsetProp);
        if (offsetProp.scale) {
            var scale = convert.scale(chart, v, offsetProp);
            return tdg.isANumber(scale) ? coordinate + scale : null
        }
        if (typeof v === "number")
            return coordinate + v;
        return null
    }
    function addAxisAnnotation(chart, group, scales, annotation, idx, chartFrame) {
        var dxProps = {
            displace: chartFrame.x,
            size: chartFrame.width,
            scale: scales.horizontal
        };
        var dyProps = {
            displace: chartFrame.y,
            size: chartFrame.height,
            height: chartFrame.height,
            scale: scales.vertical
        };
        var p = annotation.position;
        var swapAxes = chart.isBLA() && chart.blaProperties.orientation === "horizontal";
        var axisIsHorizontal = p.parent === "xaxis" && !swapAxes || p.parent === "yaxis" && swapAxes;
        if (axisIsHorizontal) {
            if (p.x == null && p.y != null)
                p.x = p.y;
            p.y = 0 + "px"
        } else {
            if (p.x != null && p.y == null)
                p.y = p.x;
            p.x = chartFrame.width + "px"
        }
        if (typeof annotation.marker.shape === "string" && annotation.marker.shape.toLowerCase() === "axisarrow")
            fixAxisArrow(chart, annotation, axisIsHorizontal);
        if (p.parent === "yaxis" && tdg.isPercentString(p.y))
            p.y = 100 - tdg.parsePercent(p.y, -5, 5) * 100 + "%";
        addAnnotation(chart, group, annotation, dxProps, dyProps, idx)
    }
    function fixAxisArrow(chart, annotation, axisIsHorizontal) {
        var p = annotation.position;
        var m = annotation.marker;
        m.color = "transparent";
        if (tdg.isEmpty(m.border))
            m.border = tdg.clone(chart[p.parent].bodyLineStyle);
        if (m.rotation != null)
            return;
        if (axisIsHorizontal) {
            if (tdg.isPercentString(p.x))
                m.rotation = tdg.parsePercent(p.x, -5, 5) >= 0 ? 0 : 180;
            else
                m.rotation = p.x >= 0 ? 0 : 180;
            p.y = m.border.width % 2 ? parseFloat(p.y) - .5 + "px" : p.y
        } else {
            if (tdg.isPercentString(p.y))
                if (p.parent === "yaxis")
                    m.rotation = tdg.parsePercent(p.y, -5, 5) >= 0 ? 270 : 90;
                else
                    m.rotation = tdg.parsePercent(p.y, -5, 5) >= 0 ? 90 : 270;
            else
                m.rotation = p.y >= 0 ? 270 : 90;
            p.x = m.border.width % 2 ? parseFloat(p.x) - .5 + "px" : p.x
        }
    }
    function addBackgroundAnnotations(chart, group, annotation, idx, computedSize) {
        var dxProps = {
            size: computedSize.width
        };
        var dyProps = {
            size: computedSize.height
        };
        addAnnotation(chart, group, annotation, dxProps, dyProps, idx)
    }
    function addMapChartAnnotations(chart, group, scales, annotation, idx, computedSize) {
        var dxProps = {
            displace: computedSize.x,
            size: computedSize.width,
            scale: scales.horizontal,
            isMap: true
        };
        var dyProps = {
            displace: computedSize.y,
            size: computedSize.height,
            height: computedSize.height,
            scale: scales.vertical,
            isMap: true
        };
        addAnnotation(chart, group, annotation, dxProps, dyProps, idx)
    }
    function addChartAnnotations(chart, group, scales, annotation, idx, computedSize) {
        var dxProps = {
            displace: computedSize.x,
            size: computedSize.width,
            scale: scales.horizontal
        };
        var dyProps = {
            displace: computedSize.y,
            size: computedSize.height,
            height: computedSize.height,
            scale: scales.vertical
        };
        addAnnotation(chart, group, annotation, dxProps, dyProps, idx)
    }
    function addLegendAnnotations(chart, group, annotation, idx, legend) {
        var dxProps = {
            size: legend.legendDrawInfo.width
        };
        var dyProps = {
            size: legend.legendDrawInfo.height
        };
        addAnnotation(chart, group, annotation, dxProps, dyProps, idx)
    }
    function addSeriesAnnotations(chart, group, scales, annotation, idx, computedSize) {
        annotation = tdg.clone(annotation);
        var seriesCount = chart.seriesCount();
        var series = annotation.position.parent.match(/^series (.*)$/i)[1];
        if (series === "all") {
            for (var s = 0; s < seriesCount; s++) {
                annotation.position.parent = "series " + s;
                addSeriesAnnotations(chart, group, scales, annotation, idx, computedSize)
            }
            return
        }
        series = parseInt(series, 10);
        if (!tdg.isANumber(series))
            return;
        var yValue = annotation.position.y;
        var isSideBySideBar = chart.chartType === "bar" && chart.blaProperties.seriesLayout === "sideBySide";
        var groupCount = chart.groupCount();
        for (var g = 0; g < groupCount; g++) {
            var dataSet = chart.getDataFromIds({
                series: series,
                group: g
            }) || {};
            if (isSideBySideBar)
                annotation.position.x = {
                    series: series,
                    group: g
                };
            else
                annotation.position.x = g;
            if (tdg.isPercentString(yValue)) {
                var d = dataSet.d;
                if (!d || d.value == null)
                    continue;
                annotation.position.y = tdg.applyNumOrPercent(yValue, d.value);
                if (d.hasOwnProperty("_yMin"))
                    annotation.position.y += d._yMin
            }
            annotation.series = series;
            annotation.group = g;
            annotation.d = dataSet.d;
            annotation.data = dataSet.data;
            addChartAnnotations(chart, group, scales, annotation, idx, computedSize)
        }
    }
    function transformPoint(chart, annotation, dxProps, dyProps, pos) {
        var x = pos.x
          , y = pos.y;
        if (x == null && pos.left != null)
            x = pos.left + "px";
        else if (x == null & pos.right != null && dxProps.size != null)
            x = dxProps.size - pos.right + "px";
        if (y == null && pos.top != null)
            y = pos.top + "px";
        else if (y == null && pos.bottom != null && dyProps.size != null)
            y = dyProps.size - pos.bottom + "px";
        if (chart.isBLA() && chart.blaProperties.orientation !== "vertical" && (annotation.position.parent === "chart" || annotation.position.parent.startsWith("series"))) {
            var tmp = x;
            x = y;
            y = tmp
        }
        return {
            x: getCoordinate(x, dxProps, chart),
            y: getCoordinate(y, dyProps, chart)
        }
    }
    function addAnnotation(chart, group, annotation, dxProps, dyProps, idx) {
        var pos = annotation.position;
        if (Array.isArray(pos.points) && !tdg.isEmpty(pos.points))
            addLineAnnotation(chart, group, annotation, dxProps, dyProps, idx);
        else {
            var p = transformPoint(chart, annotation, dxProps, dyProps, pos);
            if (tdg.isANumber(p.x) && tdg.isANumber(p.y)) {
                if (annotation.marker.visible === true)
                    addMarker(group, chart, annotation, p.x, p.y, idx);
                if (annotation.label.visible === true) {
                    var offset = labelAnchorOffset(annotation.marker.size, annotation.label.position, annotation.marker.visible);
                    addLabel(group, p.x + offset.x, p.y + offset.y, annotation.label)
                }
            }
        }
    }
    function addLineAnnotation(chart, group, annotation, dxProps, dyProps, idx) {
        var points = annotation.position.points.map(function(p) {
            return transformPoint(chart, annotation, dxProps, dyProps, p)
        });
        addLine(group, chart, points, annotation.line);
        if (annotation.marker.visible === true)
            points.forEach(function(p) {
                addMarker(group, chart, annotation, p.x, p.y, idx)
            });
        if (annotation.label.visible === true) {
            var minMaxX = tdg.minMax(points, "x");
            var minMaxY = tdg.minMax(points, "y");
            addLabel(group, (minMaxX.min + minMaxX.max) / 2, (minMaxY.min + minMaxY.max) / 2, annotation.label)
        }
    }
    function addLine(group, chart, points, line) {
        var path = new tdgchart.tdgscene.path;
        points.forEach(function(p, idx) {
            path[idx > 0 ? "lineTo" : "moveTo"](p.x, p.y)
        });
        group.path(0, 0, path, {
            lineStyle: line
        })
    }
    function addMarker(group, chart, annotation, x, y, idx) {
        var marker = annotation.marker || {};
        var shape = marker.shape;
        var border = marker.border || {};
        var radius = marker.size ? marker.size / 2 : 4;
        if (tdgchart.templateEngine.isTemplateString(shape))
            shape = chart.parseTemplate(shape, annotation.d, annotation.data, {
                series: annotation.series,
                group: annotation.group
            });
        group.dot(x, y, 2 * radius, shape, {
            className: chart.buildClassName("annotation", idx, null, annotation.label.text || null),
            includeEventCatcher: true,
            color: marker.color || "red",
            border: border.color,
            lineWidth: border.width,
            dash: border.dash,
            rotation: marker.rotation,
            scale: marker.scale,
            centerOffset: marker.centerOffset,
            title: marker.tooltip,
            background: tdg.clone(annotation.background)
        })
    }
    function addLabel(group, x, y, labelProperties) {
        var align = "middle";
        var dy = .35;
        switch (labelProperties.position) {
        case "top":
            dy = 0;
            break;
        case "bottom":
            dy = .71;
            break;
        case "left":
            align = "right";
            break;
        case "right":
            align = "left";
            break
        }
        group.label(x, y, labelProperties.text || "", {
            color: labelProperties.color || "black",
            font: labelProperties.font,
            shift: dy,
            align: align
        })
    }
    function labelAnchorOffset(r, position, markerVisible) {
        r = r || 0;
        markerVisible = !!markerVisible;
        var localRadius = markerVisible === false ? 1 : (r / 2 || defaultMarkerSize / 2) + 5;
        switch (position) {
        case "top":
            return {
                x: 0,
                y: -localRadius
            };
        case "bottom":
            return {
                x: 0,
                y: localRadius
            };
        case "left":
            return {
                x: -localRadius,
                y: 0
            };
        case "right":
            return {
                x: localRadius,
                y: 0
            }
        }
        return {
            x: 0,
            y: 0
        }
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    var longTouchDuration = 500;
    var globalCallbacks = {};
    function globalEvent(callbackList) {
        return function() {
            for (var i = 0, l = callbackList.length; i < l; i++) {
                var chart = callbackList[i].chart;
                if (chart && !chart.cache.get("disableAllInteractivity") && chart.documentRoot) {
                    var root = document.getElementById(chart.documentRoot);
                    if (root && root.offsetParent != null)
                        callbackList[i].cb(tdgchart.d3.event)
                }
            }
        }
    }
    function initEventHandler(eventName) {
        if (!globalCallbacks[eventName]) {
            globalCallbacks[eventName] = [];
            tdgchart.d3.select(document).on(eventName + ".tdg_global", globalEvent(globalCallbacks[eventName]))
        }
    }
    function arrayPushOrUpdate(globalArray, name, id, callback, chart) {
        var entry = name != null && globalArray.find(function(e) {
            return e.id == id && e.name == name
        });
        if (entry) {
            entry.cb = callback;
            entry.chart = chart
        } else
            globalArray.push({
                id: id,
                name: name,
                cb: callback,
                chart: chart
            })
    }
    function addCallback(eventName, callback, name) {
        initEventHandler(eventName);
        arrayPushOrUpdate(globalCallbacks[eventName], name, this.documentRoot, callback, this)
    }
    tdgchart.prototype.globalMouseMoveAdd = tdg.partial(addCallback, ["mousemove", null, null]);
    tdgchart.prototype.globalMouseUpAdd = tdg.partial(addCallback, ["mouseup", null, null]);
    tdgchart.prototype.globalKeyDownAdd = tdg.partial(addCallback, ["keydown", null, null]);
    tdgchart.prototype.globalKeyUpAdd = tdg.partial(addCallback, ["keyup", null, null]);
    function removeCallback(eventName, chart) {
        var i, id = chart.documentRoot;
        if (globalCallbacks[eventName])
            for (i = globalCallbacks[eventName].length - 1; i >= 0; i--)
                if (globalCallbacks[eventName][i] && globalCallbacks[eventName][i].id === id)
                    globalCallbacks[eventName].splice(i, 1)
    }
    tdgchart.prototype.globalKeyHandlerRemove = function() {
        removeCallback("keydown", this);
        removeCallback("keyup", this)
    }
    ;
    tdgchart.prototype.globalMouseRemove = function() {
        removeCallback("mouseup", this);
        removeCallback("mousemove", this)
    }
    ;
    tdgchart.prototype.registerShortDrag = function(target, downFn, moveFn, upFn, id) {
        var timer, downPt, isShortDrag = false;
        id = id || "";
        function timerExpired() {
            window.clearTimeout(timer);
            timer = downPt = null;
            isShortDrag = false
        }
        target.on("touchstart.shortDragTest" + id, function(d, data, e) {
            downPt = tdg.getMousePosition(e);
            isShortDrag = false;
            timer = window.setTimeout(timerExpired, longTouchDuration)
        });
        target.on("touchmove.shortDragTest" + id, function(d, data, e) {
            if (!downPt)
                return;
            var upPt = tdg.getMousePosition(e);
            if (timer) {
                if (Math.abs(downPt.x - upPt.x) > 3 || Math.abs(downPt.y - upPt.y) > 3) {
                    window.clearTimeout(timer);
                    timer = null;
                    isShortDrag = true;
                    if (downFn && typeof downFn === "function")
                        downFn.call(this, d, data, e);
                    if (moveFn && typeof moveFn === "function")
                        moveFn.call(this, d, data, e)
                }
            } else if (isShortDrag && moveFn)
                moveFn.call(this, d, data, e)
        });
        tdgchart.d3.select(document).on("touchend.shortDragTest" + id, function() {
            if (isShortDrag && upFn)
                upFn(tdgchart.d3.event);
            timerExpired()
        })
    }
    ;
    tdgchart.prototype.registerLongDrag = function(target, downFn, moveFn, upFn, id) {
        var originalDownFn = downFn;
        var timer, downPt, hasMoved = false, isLongDrag = false;
        id = id || "";
        function timerExpired() {
            window.clearTimeout(timer);
            timer = null;
            isLongDrag = true
        }
        target.on("touchstart.longDragTest" + id, function(d, data, e) {
            e.preventDefault();
            downPt = tdg.getMousePosition(e);
            if (downFn)
                downFn = function() {
                    originalDownFn.call(this, d, data, e)
                }
                ;
            isLongDrag = false;
            timer = window.setTimeout(timerExpired, longTouchDuration)
        });
        target.on("touchmove.longDragTest" + id, function(d, data, e) {
            if (!downPt)
                return;
            var upPt = tdg.getMousePosition(e);
            if (timer && (Math.abs(downPt.x - upPt.x) > 3 || Math.abs(downPt.y - upPt.y) > 3)) {
                window.clearTimeout(timer);
                timer = downPt = null;
                isLongDrag = false
            } else if (isLongDrag) {
                if (!hasMoved) {
                    downFn();
                    hasMoved = true
                }
                moveFn.call(this, d, data, e)
            }
        });
        tdgchart.d3.select(document).on("touchend.longDragTest" + id, function(d, data, e) {
            if (upFn && hasMoved && isLongDrag)
                upFn(d, data, e);
            window.clearTimeout(timer);
            timer = downPt = null;
            isLongDrag = hasMoved = false
        })
    }
    ;
    tdgchart.prototype.registerLongTouch = function(target, touchEndFn) {
        var event, timer, touchPt, touchStarted = false;
        function timerExpired() {
            if (touchEndFn && touchStarted)
                touchEndFn(event);
            endTouch()
        }
        target.on("touchstart.longTouchTest", function(d, data, e) {
            event = e;
            touchPt = tdg.getMousePosition(e);
            e.preventDefault();
            touchStarted = true;
            timer = window.setTimeout(timerExpired, longTouchDuration)
        });
        target.on("touchmove.longTouchTest", function(d, data, e) {
            if (e && touchPt) {
                var newTouchPt = tdg.getMousePosition(e);
                if (tdg.geom.distance(touchPt, newTouchPt) < 5)
                    return
            }
            endTouch()
        });
        target.on("touchend.longTouchTest", endTouch);
        function endTouch() {
            window.clearTimeout(timer);
            timer = null;
            touchStarted = false;
            event = null
        }
    }
    ;
    tdgchart.prototype.enableBehavior = function(behaviors, enabled) {
        var chart = this;
        enabled = enabled || false;
        if (!Array.isArray(behaviors))
            behaviors = [behaviors];
        if (behaviors.includes("all")) {
            behaviors = ["tooltips", "hover", "dataSelection", "previewSelection", "animation", "scroll"];
            chart.cache.set("disableAllInteractivity", true)
        }
        behaviors = tdg.map(behaviors, "toLowerCase");
        if (behaviors.includes("tooltips")) {
            chart._disableToolTips = !enabled;
            chart.htmlToolTip.enabled = enabled
        }
        if (behaviors.includes("hover")) {
            chart._disableHover = !enabled;
            chart.mouseOverIndicator.enabled = enabled
        }
        if (behaviors.includes("dataselection") || behaviors.includes("previewselection"))
            chart._disableSelection = !enabled;
        if (behaviors.includes("dataselection"))
            chart.dataSelection.enabled = enabled;
        if (behaviors.includes("previewselection"))
            chart.previewSelection.enabled = enabled;
        if (behaviors.includes("animation")) {
            chart.introAnimation.enabled = enabled;
            chart.mapProperties.leaflet.mapOptions = chart.mapProperties.leaflet.mapOptions || {};
            chart.mapProperties.leaflet.mapOptions.fadeAnimation = enabled
        }
        if (behaviors.includes("scroll"))
            if (chart.isLeaflet() && chart._internalMapCache && chart._internalMapCache.map)
                if (enabled)
                    chart._internalMapCache.map.dragging.enabled();
                else
                    chart._internalMapCache.map.dragging.disable();
            else
                chart._disableScroll = !enabled
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    var scene = tdgchart.tdgscene = function(chart) {
        this.documentRoot = chart.documentRoot;
        this.useHTMLtooltips = chart.htmlToolTip.enabled;
        this.root = new scene.groupObject("tdgsceneRoot");
        this.linked = []
    }
    ;
    scene.prototype.group = function(pvparent, className, x, y, w, h, clip, attrs) {
        if (pvparent) {
            var link = {
                parent: pvparent,
                group: new scene.groupObject(pvparent,className,x,y,w,h,clip,attrs)
            };
            this.linked.push(link);
            return link.group
        } else
            return this.root.group(className, x, y, w, h, clip, attrs)
    }
    ;
    scene.groupObject = function(parent, className, x, y, w, h, clip, attrs) {
        this.parent = parent;
        this.className = className;
        this.x = x || 0;
        this.y = y || 0;
        this.w = w;
        this.h = h;
        this.clip = clip;
        this.attrs = tdg.cloneObject(attrs);
        this.childs = [];
        this.interaction = {
            owner: this,
            events: {}
        }
    }
    ;
    scene.isTDGSceneGroup = function(group) {
        return group instanceof tdgchart.tdgscene.groupObject
    }
    ;
    scene.isTDGSceneMark = function(mark) {
        return mark instanceof tdgchart.tdgscene.markObject || mark.hasOwnProperty("props") && mark.props.hasOwnProperty("attrs")
    }
    ;
    scene.getMarkType = function(mark) {
        return this.isTDGSceneMark(mark) ? mark.type : null
    }
    ;
    scene.baseObject = {
        childIndex: function() {
            if (this.parent)
                return this.parent.childs.indexOf(this);
            return null
        },
        prevSibling: function() {
            if (this.parent) {
                var idx = this.parent.childs.indexOf(this);
                return this.parent.childs[idx - 1]
            }
            return null
        },
        nextSibling: function() {
            if (this.parent) {
                var idx = this.parent.childs.indexOf(this);
                return this.parent.childs[idx + 1]
            }
            return null
        },
        moveTo: function(x, y) {
            if (this._instance && this.backend && this.backend.moveElement)
                this.backend.moveElement(this._instance, x, y, false)
        },
        moveBy: function(x, y) {
            if (this._instance && this.backend && this.backend.moveElement)
                this.backend.moveElement(this._instance, x, y, true)
        },
        rotate: function(angle) {
            if (this._instance && this.backend && this.backend.rotateElement)
                this.backend.rotateElement(this._instance, angle);
            else
                this._rot = angle;
            return this
        },
        visible: function(vis) {
            if (this._instance && this.backend && this.backend.visibleElement)
                this.backend.visibleElement(this._instance, vis);
            else
                this.isVisible = vis
        },
        selectChildren: function(className) {
            var res = [];
            if (this.className === className)
                res.push(this);
            if (Array.isArray(this.childs))
                for (var i = 0; i < this.childs.length; i++)
                    res = res.concat(this.childs[i].selectChildren(className));
            return res
        }
    };
    scene.markObject = function(type, props, attrs, parent) {
        this.type = type;
        this.props = props;
        this.parent = parent;
        this.interaction = {
            owner: this,
            events: {}
        };
        if (attrs) {
            if (attrs.className)
                this.className = attrs.className;
            this.props.attrs = tdg.cloneObject(attrs);
            if (attrs.interaction && !tdg.isEmpty(attrs.interaction.events))
                this.interaction.events = attrs.interaction.events
        }
    }
    ;
    scene.markObject.prototype = tdg.cloneObject(scene.baseObject);
    scene.markObject.prototype.color = function(color) {
        if (color == null)
            return this.props.attrs.color;
        this.props.attrs.color = color;
        if (this._instance && this.backend && this.backend.colorElement)
            this.backend.colorElement(this._instance, color);
        return this
    }
    ;
    scene.markObject.prototype.borderColor = function(color) {
        if (color == null)
            return this.props.attrs.lineStyle.color;
        this.props.attrs.lineStyle.color = color;
        if (this._instance && this.backend && this.backend.borderColorElement)
            this.backend.borderColorElement(this._instance, color);
        return this
    }
    ;
    scene.markObject.prototype.markerShape = function(shape) {
        if (shape == null)
            return this.props.shape;
        this.props.shape = shape;
        if (this._instance && this.backend && this.backend.markerShapeElement)
            this.backend.markerShapeElement(this._instance, shape);
        return this
    }
    ;
    scene.markObject.prototype.duplicate = function() {
        return new scene.markObject(this.type,tdg.cloneObject(this.props))
    }
    ;
    scene.markObject.prototype.getClientData = function() {
        return this.props.attrs.clientData
    }
    ;
    scene.markObject.prototype.setAttr = function(name, value) {
        this.props.attrs[name] = value;
        return this
    }
    ;
    scene.markObject.prototype.getAttr = function(name) {
        return this.props.attrs[name]
    }
    ;
    scene.markObject.prototype.getInnerRadius = function() {
        return this.props.ri || 0
    }
    ;
    scene.markObject.prototype.getRadius = function() {
        return this.props.ro || this.props.r || (this.props.size ? this.props.size / 2 : 0)
    }
    ;
    scene.markObject.prototype.getPosition = function() {
        return {
            x: this.props.x,
            y: this.props.y
        }
    }
    ;
    scene.markObject.prototype.remove = function() {
        var idx = this.parent.childs.indexOf(this);
        if (idx >= 0)
            this.parent.childs.splice(idx, 1)
    }
    ;
    scene.groupObject.prototype = tdg.cloneObject(scene.baseObject);
    scene.groupObject.prototype.insertBefore = function(mark, beforeWhat) {
        var pos = this.childs.indexOf(beforeWhat);
        if (pos >= 0)
            this.childs.splice(pos, 0, mark);
        else
            this.childs.push(mark);
        return mark
    }
    ;
    scene.groupObject.prototype.insertAfter = function(mark, afterWhat) {
        var pos = this.childs.indexOf(afterWhat);
        if (pos >= 0 && pos < this.childs.length - 1)
            this.childs.splice(pos + 1, 0, mark);
        else
            this.childs.push(mark);
        return mark
    }
    ;
    scene.groupObject.prototype.getChild = function(className) {
        for (var i = 0; i < this.childs.length; i++)
            if (this.childs[i].className === className)
                return this.childs[i];
        return null
    }
    ;
    scene.groupObject.prototype.empty = function() {
        this.childs = []
    }
    ;
    scene.groupObject.prototype.removeChild = function(child) {
        var idx = this.childs.indexOf(child);
        if (idx >= 0)
            this.childs.splice(idx, 1)
    }
    ;
    scene.groupObject.prototype.color = function(c) {
        for (var i = 0, l = this.childs.length; i < l; i++) {
            var mark = this.childs[i];
            if (mark instanceof scene.markObject)
                mark.color(c)
        }
    }
    ;
    scene.groupObject.prototype.group = function(className, x, y, w, h, clip, attrs) {
        var g = new scene.groupObject(this,className,x,y,w,h,clip,attrs);
        this.childs.push(g);
        return g
    }
    ;
    scene.groupObject.prototype.label = function(x, y, text, attrs) {
        var m = new scene.markObject("label",{
            x: x,
            y: y,
            text: text
        },attrs,this);
        this.childs.push(m);
        return m
    }
    ;
    scene.groupObject.prototype.rect = function(x, y, w, h, attrs) {
        var m = new scene.markObject("rect",{
            x: x,
            y: y,
            w: w,
            h: h
        },attrs,this);
        this.childs.push(m);
        return m
    }
    ;
    scene.groupObject.prototype.circle = function(x, y, r, attrs) {
        var m = new scene.markObject("circle",{
            x: x,
            y: y,
            r: r
        },attrs,this);
        this.childs.push(m);
        return m
    }
    ;
    scene.groupObject.prototype.arc = function(x, y, r, from, to, attrs) {
        var m = new scene.markObject("arc",{
            x: x,
            y: y,
            r: r,
            from: from,
            to: to
        },attrs,this);
        this.childs.push(m);
        return m
    }
    ;
    scene.groupObject.prototype.wedge = function(x, y, r, ri, from, to, attrs) {
        var m = new scene.markObject("wedge",{
            x: x,
            y: y,
            r: r,
            ri: ri,
            from: from,
            to: to
        },attrs,this);
        this.childs.push(m);
        return m
    }
    ;
    scene.groupObject.prototype.line = function(x1, y1, x2, y2, attrs) {
        var m = new scene.markObject("line",{
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
        },attrs,this);
        this.childs.push(m);
        return m
    }
    ;
    scene.groupObject.prototype.dot = function(x, y, size, shape, attrs) {
        var m = new scene.markObject("dot",{
            x: x,
            y: y,
            size: size,
            shape: shape
        },attrs,this);
        this.childs.push(m);
        return m
    }
    ;
    scene.groupObject.prototype.image = function(x, y, w, h, url, attrs) {
        var m = new scene.markObject("image",{
            x: x,
            y: y,
            w: w,
            h: h,
            url: url
        },attrs,this);
        this.childs.push(m);
        return m
    }
    ;
    scene.groupObject.prototype.path = function(x, y, path, attrs) {
        var m = new scene.markObject("path",{
            x: x,
            y: y,
            path: path
        },attrs,this);
        this.childs.push(m);
        return m
    }
    ;
    scene.groupObject.prototype.riserPath = function(x, y, topPoints, bottomPoints, attrs) {
        var m = new scene.markObject("riserPath",{
            x: x,
            y: y,
            topPoints: topPoints,
            bottomPoints: bottomPoints
        },attrs,this);
        this.childs.push(m);
        return m
    }
    ;
    scene.path = function(points) {
        this.p = [];
        if (Array.isArray(points))
            for (var i = 0; i < points.length; i++) {
                var p = points[i];
                if (p && tdg.isANumber(p.x) && tdg.isANumber(p.y))
                    this[i === 0 ? "moveTo" : "lineTo"](p.x, p.y)
            }
        return this
    }
    ;
    scene.path.prototype.moveTo = function(x, y, relative) {
        this.p.push({
            type: "moveTo",
            x: x,
            y: y,
            relative: relative
        })
    }
    ;
    scene.path.prototype.lineTo = function(x, y, relative) {
        this.p.push({
            type: "lineTo",
            x: x,
            y: y,
            relative: relative
        })
    }
    ;
    scene.path.prototype.arcTo = function(rx, ry, rotation, large, sweep, x, y, relative) {
        this.p.push({
            type: "arcTo",
            rx: rx,
            ry: ry,
            rotation: rotation,
            large: large,
            sweep: sweep,
            x: x,
            y: y,
            relative: relative
        })
    }
    ;
    scene.path.prototype.closePath = function() {
        this.p.push({
            type: "closePath"
        })
    }
    ;
    function processAttrs(attrs, addAttrs) {
        attrs = attrs || {};
        for (var a in addAttrs)
            if (addAttrs.hasOwnProperty(a))
                attrs[a] = addAttrs[a];
        return attrs
    }
    scene.prototype.initBackend = function() {
        var backend_type = "svg";
        this.backend = tdgchart.drawbackend[backend_type]
    }
    ;
    scene.prototype.render = function() {
        var backend_type = "svg";
        this.backend = tdgchart.drawbackend[backend_type];
        var root = this.backend.root(this.documentRoot);
        root.setAttribute("xmlns:tdg", "http://informationbuilders.com/tdg");
        var ctx = this.backend.initContext(this.documentRoot, root);
        for (var i = 0; i < this.linked.length; i++) {
            var link = this.linked[i];
            var parentNode = this.backend.findNode(root, link.parent);
            if (parentNode) {
                var xoff = null
                  , yoff = null;
                if (link.parent instanceof pv.Panel) {
                    xoff = link.parent.left();
                    yoff = link.parent.top()
                }
                this.backend.useHTMLtooltips(ctx, this.useHTMLtooltips);
                this.renderGroup(link.group, ctx, parentNode, xoff, yoff)
            }
        }
        this.backend.useHTMLtooltips(ctx, this.useHTMLtooltips);
        this.renderGroup(this.root, ctx, root)
    }
    ;
    scene.prototype.renderGroup = function(group, ctx, parentNode, xoff, yoff) {
        var backend = group.backend = this.backend;
        if (ctx == null && group.parent != null && group.parent._instance != null) {
            parentNode = group.parent._instance;
            ctx = backend.initContext(parentNode);
            backend.useHTMLtooltips(ctx, this.useHTMLtooltips)
        }
        if (group._instance != null)
            backend.removeElement(group._instance);
        if (!group.childs.length) {
            group._instance = null;
            return
        }
        var attrs = {
            interaction: group.interaction
        };
        if (group.attrs)
            tdg.mergeObjects(group.attrs, attrs);
        if (group._rot != null) {
            attrs.rotation = group._rot;
            delete group._rot
        }
        group._instance = backend.group(ctx, parentNode, group.className, group.x + (xoff || 0), group.y + (yoff || 0), group.w, group.h, group.clip, attrs);
        if (group.isVisible != null && backend.visibleElement) {
            backend.visibleElement(group._instance, group.isVisible);
            delete group.isVisible
        }
        for (var j = 0; j < group.childs.length; j++) {
            var mark = group.childs[j];
            if (mark instanceof scene.groupObject)
                this.renderGroup(mark, ctx, group._instance);
            else if (mark instanceof scene.markObject)
                this.renderMark(ctx, mark, group._instance)
        }
    }
    ;
    function renderShape(scene, ctx, mark, parent, attrs) {
        switch (mark.type) {
        case "polygon":
            return scene.renderPolygon(ctx, parent, mark.props.points, true, attrs);
        case "polyline":
            return scene.renderPolygon(ctx, parent, mark.props.points, false, attrs);
        case "rect":
            return scene.backend.rect(ctx, parent, mark.props.x, mark.props.y, mark.props.w, mark.props.h, attrs);
        case "circle":
            return scene.backend.circle(ctx, parent, mark.props.x, mark.props.y, mark.props.r, attrs);
        case "arc":
            return scene.backend.arc(ctx, parent, mark.props.x, mark.props.y, mark.props.r, mark.props.from, mark.props.to, attrs);
        case "wedge":
            return scene.backend.wedge(ctx, parent, mark.props.x, mark.props.y, mark.props.r, mark.props.ri, mark.props.from, mark.props.to, attrs);
        case "line":
            return scene.backend.line(ctx, parent, mark.props.x1, mark.props.y1, mark.props.x2, mark.props.y2, attrs);
        case "label":
            return scene.backend.text(ctx, parent, mark.props.x, mark.props.y, mark.props.text, attrs);
        case "image":
            return scene.backend.image(ctx, parent, mark.props.x, mark.props.y, mark.props.w, mark.props.h, mark.props.url, attrs);
        case "path":
            return scene.renderPath(ctx, mark, parent, attrs);
        case "riserPath":
            return scene.backend.riserPath(ctx, parent, mark.props.topPoints, mark.props.bottomPoints, attrs);
        case "dot":
            return scene.renderDot(ctx, mark, parent, attrs)
        }
        return null
    }
    scene.prototype.renderMark = function(ctx, mark, parent) {
        mark.backend = this.backend;
        mark._instance = null;
        if (mark._rot != null) {
            mark.props.attrs.rotation = mark._rot;
            delete mark._rot
        }
        processAttrs(mark.props.attrs, {
            interaction: mark.interaction
        });
        mark._instance = renderShape(this, ctx, mark, parent, mark.props.attrs)
    }
    ;
    scene.prototype.renderPolygon = function(ctx, parent, points, isClosed, attrs) {
        var path = new this.backend.newPath;
        for (var i = 0; i < points.length; i++)
            if (i === 0)
                path.moveTo(points[i]);
            else
                path.lineTo(points[i]);
        if (isClosed)
            path.closePath();
        return this.backend.path(ctx, parent, path, attrs)
    }
    ;
    scene.prototype.renderPath = function(ctx, mark, parent, attrs) {
        var x, y;
        var path = attrs.path = mark.props.path;
        if (mark.props.path instanceof scene.path && !attrs.depth) {
            path = new this.backend.newPath;
            for (var i = 0; i < mark.props.path.p.length; i++) {
                var el = mark.props.path.p[i];
                if (!el.relative || i == 0 && el.type === "moveTo") {
                    x = mark.props.x;
                    y = mark.props.y
                } else
                    x = y = 0;
                switch (el.type) {
                case "moveTo":
                    path.moveTo(x + el.x, y + el.y, el.relative);
                    break;
                case "lineTo":
                    path.lineTo(x + el.x, y + el.y, el.relative);
                    break;
                case "arcTo":
                    path.arcTo(el.rx, el.ry, el.rotation, el.large, el.sweep, x + el.x, y + el.y, el.relative);
                    break;
                case "closePath":
                    path.closePath();
                    break
                }
            }
        }
        return this.backend.path(ctx, parent, path, attrs)
    }
    ;
    scene.prototype.renderDot = function(ctx, mark, parent, attrs) {
        if (mark.props && typeof mark.props.shape === "string" && mark.props.shape.startsWith("url(")) {
            var size = mark.props.size;
            return this.backend.image(ctx, parent, mark.props.x - size / 2, mark.props.y - size / 2, size, size, mark.props.shape, attrs)
        }
        attrs.translate = {
            x: mark.props.x,
            y: mark.props.y
        };
        if (!mark.props.shape || mark.props.shape === "circle")
            return this.backend.circle(ctx, parent, 0, 0, mark.props.size / 2, attrs);
        var path = this.addShapePath(0, 0, mark.props.shape, mark.props.size / 2);
        if (!path.p.length && typeof mark.props.shape === "string") {
            var shape = mark.props.shape.trim();
            if (shape.startsWith("m") || shape.startsWith("M"))
                path = mark.props.shape
        }
        return this.backend.path(ctx, parent, path, attrs)
    }
    ;
    scene.prototype.addShapePath = function(x, y, shape, radius) {
        var path = new this.backend.newPath;
        var r = radius
          , rh = r / 2
          , r2 = r * 2;
        var w, h, h2, xx, yy, aspectRatio;
        switch ((shape + "").toLowerCase()) {
        case "quartercircle":
            path.moveTo(x - r, y + 0);
            path.arcTo(r, r, 0, 0, 1, x + 0, y - r);
            break;
        case "ring":
            var ri = Math.min(r * .85, r - 2.5);
            path.moveTo(x - r, y);
            path.arcTo(r, r, 0, 0, 0, x + r, y);
            path.arcTo(r, r, 0, 0, 0, x - r, y);
            path.closePath();
            path.moveTo(x - ri, y);
            path.arcTo(ri, ri, 0, 0, 1, x + ri, y);
            path.arcTo(ri, ri, 0, 0, 1, x - ri, y);
            path.closePath();
            break;
        case "arrow":
            var h3 = r / 3
              , h23 = h3 * 2
              , h43 = h23 * 2;
            path.moveTo(x - h23, y - h3);
            path.lineTo(h23, -h23, true);
            path.lineTo(h23, h23, true);
            path.lineTo(-h3, 0, true);
            path.lineTo(0, h43, true);
            path.lineTo(-h23, 0, true);
            path.lineTo(0, -h43, true);
            path.closePath();
            break;
        case "arrowslim":
            var tipSize = r / 2.5;
            path.moveTo(x - tipSize, y - r + tipSize);
            path.lineTo(x, y - r);
            path.lineTo(x + tipSize, y - r + tipSize);
            path.moveTo(x, y - r);
            path.lineTo(x, y + r);
            break;
        case "arrowslimdouble":
            var tipSize2 = r / 2.5;
            path.moveTo(x - tipSize2, y - r + tipSize2);
            path.lineTo(x, y - r);
            path.lineTo(x + tipSize2, y - r + tipSize2);
            path.moveTo(x - tipSize2, y + r - tipSize2);
            path.lineTo(x, y + r);
            path.lineTo(x + tipSize2, y + r - tipSize2);
            path.moveTo(x, y - r);
            path.lineTo(x, y + r);
            break;
        case "bar":
            path.moveTo(x + 0, y + r);
            path.lineTo(x + 0, y - r);
            break;
        case "cross":
            path.moveTo(x - r, y - r);
            path.lineTo(x + r, y + r);
            path.moveTo(x + r, y - r);
            path.lineTo(x - r, y + r);
            break;
        case "diamond":
            path.moveTo(x + 0, y - r);
            path.lineTo(x + r, y + 0);
            path.lineTo(x + 0, y + r);
            path.lineTo(x - r, y + 0);
            path.closePath();
            break;
        case "fivestar":
            var t36 = .7265
              , t72 = 3.0777
              , c72 = .309
              , s72 = .951
              , c36 = .809
              , s36 = .588;
            var b = r / 3.236
              , hp = b / c36;
            path.moveTo(x + 0, y - r);
            path.lineTo(x + b * t36, y - b);
            path.lineTo(x + b * t72, y - b);
            path.lineTo(x + hp * s72, y + hp * c72);
            path.lineTo(x + r * s36, y + r * c36);
            path.lineTo(x + 0, y + hp);
            path.lineTo(x - r * s36, y + r * c36);
            path.lineTo(x - hp * s72, y + hp * c72);
            path.lineTo(x - b * t72, y - b);
            path.lineTo(x - b * t36, y - b);
            path.closePath();
            break;
        case "hexagon":
            xx = r * .5;
            yy = r * .866;
            path.moveTo(x - xx, y - yy);
            path.lineTo(r, 0, true);
            path.lineTo(x + r, y + 0);
            path.lineTo(x + xx, y + yy);
            path.lineTo(-r, 0, true);
            path.lineTo(x - r, y + 0);
            path.closePath();
            break;
        case "hourglass":
            h2 = r * 2;
            path.moveTo(x - r, y - r);
            path.lineTo(h2, 0, true);
            path.lineTo(x - r, y + r);
            path.lineTo(h2, 0, true);
            path.closePath();
            break;
        case "house":
            path.moveTo(x + 0, y - r);
            path.lineTo(x + r, y + 0);
            path.lineTo(0, r, true);
            path.lineTo(-(r * 2), 0, true);
            path.lineTo(0, -r, true);
            path.closePath();
            break;
        case "piratecross":
            w = r / 1.6;
            var w2 = w * 2;
            path.moveTo(x + 0, y + 0);
            path.lineTo(x - w, y - r);
            path.lineTo(w2, 0, true);
            path.lineTo(x + 0, y + 0);
            path.lineTo(x + r, y - w);
            path.lineTo(0, w2, true);
            path.lineTo(x + 0, y + 0);
            path.lineTo(x - w, y + r);
            path.lineTo(w2, 0, true);
            path.lineTo(x + 0, y + 0);
            path.lineTo(x - r, y - w);
            path.lineTo(0, w2, true);
            path.lineTo(x + 0, y + 0);
            break;
        case "plus":
            xx = 2 / 3 * r;
            path.moveTo(x - xx / 2, y - r);
            path.lineTo(xx, 0, true);
            path.lineTo(0, xx, true);
            path.lineTo(xx, 0, true);
            path.lineTo(0, xx, true);
            path.lineTo(-xx, 0, true);
            path.lineTo(0, xx, true);
            path.lineTo(-xx, 0, true);
            path.lineTo(0, -xx, true);
            path.lineTo(-xx, 0, true);
            path.lineTo(0, -xx, true);
            path.lineTo(xx, 0, true);
            path.lineTo(0, -xx, true);
            break;
        case "circleplus":
            path.moveTo(x - r, y + 0);
            path.arcTo(r, r, 0, 1, 0, r2, 0, true);
            path.arcTo(r, r, 0, 1, 0, -r2, 0, true);
            path.moveTo(x - rh, y + 0);
            path.lineTo(r, 0, true);
            path.moveTo(x + 0, y - rh);
            path.lineTo(0, r, true);
            break;
        case "circleminus":
            path.moveTo(x - r, y + 0);
            path.arcTo(r, r, 0, 1, 0, r2, 0, true);
            path.arcTo(r, r, 0, 1, 0, -r2, 0, true);
            path.moveTo(x - rh, y);
            path.lineTo(r, 0, true);
            break;
        case "rectangle":
            aspectRatio = 1 / 4;
            path.moveTo(x - r, y - r * aspectRatio);
            path.lineTo(r2, 0, true);
            path.lineTo(0, r2 * aspectRatio, true);
            path.lineTo(-r2, 0, true);
            path.closePath();
            break;
        case "rectanglethin":
            aspectRatio = 1 / 10;
            path.moveTo(x - r, y - r * aspectRatio);
            path.lineTo(r2, 0, true);
            path.lineTo(0, r2 * aspectRatio, true);
            path.lineTo(-r2, 0, true);
            path.closePath();
            break;
        case "sixstar":
            h2 = r / 2;
            var rx = h2 / .866;
            xx = h2 * .577;
            path.moveTo(x + 0, y - r);
            path.lineTo(x + xx, y - h2);
            path.lineTo(rx, 0, true);
            path.lineTo(x + rx, y + 0);
            path.lineTo(x + (rx + xx), y + h2);
            path.lineTo(-rx, 0, true);
            path.lineTo(x + 0, y + r);
            path.lineTo(x - xx, y + h2);
            path.lineTo(-rx, 0, true);
            path.lineTo(x - rx, y + 0);
            path.lineTo(x - (rx + xx), y - h2);
            path.lineTo(x - xx, y - h2);
            path.closePath();
            break;
        case "fill":
        case "square":
            path.moveTo(x - r, y - r);
            path.lineTo(x + r, y - r);
            path.lineTo(x + r, y + r);
            path.lineTo(x - r, y + r);
            path.closePath();
            break;
        case "thinplus":
            xx = r / 4;
            yy = r - xx;
            path.moveTo(x - xx / 2, y - r);
            path.lineTo(xx, 0, true);
            path.lineTo(0, yy, true);
            path.lineTo(yy, 0, true);
            path.lineTo(0, xx, true);
            path.lineTo(-yy, 0, true);
            path.lineTo(0, yy, true);
            path.lineTo(-xx, 0, true);
            path.lineTo(0, -yy, true);
            path.lineTo(-yy, 0, true);
            path.lineTo(0, -xx, true);
            path.lineTo(yy, 0, true);
            path.lineTo(0, -yy, true);
            break;
        case "tick":
            path.moveTo(x, y);
            path.lineTo(x, y - r);
            break;
        case "triangle":
            w = r * .866;
            path.moveTo(x + 0, y + w);
            path.lineTo(x + r, y - w);
            path.lineTo(x - r, y - w);
            path.closePath();
            break;
        case "triangle-d":
            h = r / 1.1547;
            w = r;
            path.moveTo(x + 0, y + h);
            path.lineTo(x + w, y - h);
            path.lineTo(x - w, y - h);
            path.closePath();
            break;
        case "triangle-u":
            h = r / 1.1547;
            w = r;
            path.moveTo(x + 0, y - h);
            path.lineTo(x + w, y + h);
            path.lineTo(x - w, y + h);
            path.closePath();
            break;
        case "triangle-l":
            w = r / 1.1547;
            path.moveTo(x + w, y - r);
            path.lineTo(x + w, y + r);
            path.lineTo(x - w, y - 0);
            path.closePath();
            break;
        case "triangle-r":
            w = r / 1.1547;
            path.moveTo(x - w, y - r);
            path.lineTo(x - w, y + r);
            path.lineTo(x + w, y - 0);
            path.closePath();
            break;
        case "chevron-u":
            path.moveTo(x - r, y + rh);
            path.lineTo(x, y - rh);
            path.lineTo(x + r, y + rh);
            break;
        case "chevron-r":
            path.moveTo(x - rh, y - r);
            path.lineTo(x + rh, y);
            path.lineTo(x - rh, y + r);
            break;
        case "chevron-d":
            path.moveTo(x - r, y - rh);
            path.lineTo(x, y + rh);
            path.lineTo(x + r, y - rh);
            break;
        case "chevron-l":
            path.moveTo(x + rh, y - r);
            path.lineTo(x - rh, y);
            path.lineTo(x + rh, y + r);
            break;
        case "needle":
            w = 4;
            path.moveTo(x + 0, y + r);
            path.lineTo(x + w, y + 0);
            path.lineTo(x - w, y + 0);
            path.closePath();
            break;
        case "pin":
            var rn = (r - 1) / 2;
            var rp = rn / 1.6;
            var a = tdg.radians(15);
            xx = Math.sin(a) * rn;
            yy = Math.cos(a) * rn;
            path.moveTo(x - xx, y - yy);
            path.arcTo(rp, rp, 0, 1, 1, x + xx, y - yy);
            path.lineTo(x + 0, y + 0);
            path.closePath();
            break;
        case "axisarrow":
            path.moveTo(x - r, y - rh);
            path.lineTo(x, y);
            path.lineTo(x - r, y + rh);
            break;
        case "roundedsquare":
            var rm = r * .92;
            var cr = rm / 1.5;
            path.moveTo(x - rm, y - rm + cr);
            path.arcTo(cr, cr, 0, 0, 1, x - rm + cr, y - rm);
            path.lineTo(x + rm - cr, y - rm);
            path.arcTo(cr, cr, 0, 0, 1, x + rm, y - rm + cr);
            path.lineTo(x + rm, y + rm - cr);
            path.arcTo(cr, cr, 0, 0, 1, x + rm - cr, y + rm);
            path.lineTo(x - rm + cr, y + rm);
            path.arcTo(cr, cr, 0, 0, 1, x - rm, y + rm - cr);
            path.closePath();
            break
        }
        return path
    }
}
)();
(function() {
    var svgNS = "http://www.w3.org/2000/svg";
    var xlinkNS = "http://www.w3.org/1999/xlink";
    var xhtmlNS = "http://www.w3.org/1999/xhtml";
    var tdg = tdgchart.util;
    tdgchart.drawbackend = tdgchart.drawbackend || {};
    tdgchart.drawbackend.svg = {};
    tdgchart.drawbackend.svg.root = function(documentRoot) {
        return document.getElementById(documentRoot).getElementsByTagName("svg")[0]
    }
    ;
    tdgchart.drawbackend.svg.initContext = function(containerID, root) {
        return {
            containerID: containerID,
            root: root,
            defs: root ? (root.getElementsByTagName("defs") || [])[0] : null,
            htmlTooltips: false
        }
    }
    ;
    tdgchart.drawbackend.svg.useHTMLtooltips = function(ctx, use) {
        ctx.htmlTooltips = use
    }
    ;
    tdgchart.drawbackend.svg.visibleElement = function(element, vis) {
        if (element)
            element.style.display = vis ? "" : "none"
    }
    ;
    tdgchart.drawbackend.svg.colorElement = function(element, color) {
        if (element && element.getAttribute("fill"))
            element.setAttribute("fill", color)
    }
    ;
    tdgchart.drawbackend.svg.borderColorElement = function(element, color) {
        if (element && element.getAttribute("stroke"))
            element.setAttribute("stroke", color)
    }
    ;
    tdgchart.drawbackend.svg.markerShapeElement = function(element, shape) {
        if (element && element.getAttribute("d"))
            element.setAttribute("d", shape)
    }
    ;
    tdgchart.drawbackend.svg.moveElement = function(element, x, y, isRelative) {
        x = x || 0;
        y = y || 0;
        if (element.transform.baseVal.numberOfItems < 1)
            element.transform.baseVal.appendItem(element.ownerSVGElement.createSVGTransform());
        if (isRelative) {
            var matrix = element.transform.baseVal.getItem(0).matrix;
            x += matrix.e;
            y += matrix.f
        }
        element.transform.baseVal.getItem(0).matrix.e = x;
        element.transform.baseVal.getItem(0).matrix.f = y
    }
    ;
    tdgchart.drawbackend.svg.rotateElement = function(element, angle) {
        angle = angle || 0;
        if (!element.rotateTransform) {
            var transform = element.ownerSVGElement.createSVGTransform();
            element.rotateTransform = element.transform.baseVal.appendItem(transform)
        }
        element.rotateTransform.setRotate(angle, 0, 0)
    }
    ;
    tdgchart.drawbackend.svg.removeElement = function(element) {
        element.parentNode.removeChild(element)
    }
    ;
    tdgchart.drawbackend.svg.group = function(ctx, parent, className, x, y, w, h, clip, attrs) {
        var translate;
        if (x || y)
            translate = "translate(" + (x || 0) + "," + (y || 0) + ")";
        if (attrs.rotation)
            translate = (translate || "") + " rotate(" + attrs.rotation + ")";
        var params = {};
        addStyleDef(ctx, params, attrs);
        addFontDef(params, null, attrs.font, attrs.size);
        var clipURL;
        if (clip)
            if (clip === true)
                clipURL = addClipRectDef(ctx, 0, 0, w, h);
            else if (typeof clip === "object" && clip.hasOwnProperty("width") && clip.hasOwnProperty("height"))
                clipURL = addClipRectDef(ctx, clip.x || 0, clip.y || 0, clip.width, clip.height);
        var r = svgel("g", {
            "class": className,
            transform: translate,
            width: w,
            height: h,
            attrs: params,
            "clip-path": clipURL
        });
        if (attrs.interaction && attrs.interaction.events && !tdg.isEmpty(attrs.interaction.events))
            addEvents(ctx, r, attrs.interaction);
        if (parent)
            parent.appendChild(r);
        return r
    }
    ;
    function addEvents(ctx, el, interaction) {
        function eventHandler(event) {
            event.preventDefault();
            if (interaction.events[event.type]) {
                var pos = this.getBoundingClientRect();
                var props = {
                    x: event.clientX,
                    y: event.clientY,
                    relX: event.clientX - pos.left,
                    relY: event.clientY - pos.top
                };
                interaction.events[event.type].call(this, interaction.owner, props, event)
            }
        }
        if (interaction && interaction.events && !tdg.isEmpty(interaction.events))
            for (var e in interaction.events)
                if (interaction.events.hasOwnProperty(e))
                    el.addEventListener(e, eventHandler, true)
    }
    function rect25dSide(ctx, parent, params, attrs, colorAdj, o, x, y, dx, dy) {
        params = tdg.clone(params);
        if (colorAdj) {
            var fill = pv.SvgScene.adjcolor(tdg.color(attrs.color), colorAdj);
            if (fill.isComplexFill)
                fill = addFillDef(ctx, fill);
            params.fill = fill.toString()
        }
        delete params.width;
        delete params.height;
        delete params.x;
        delete params.y;
        params.d = "M" + x + "," + y + "L" + (x + o) + "," + (y - o) + "L" + (x + o + dx) + "," + (y - o + dy) + "L" + (x + dx) + "," + (y + dy) + "Z";
        append("path", ctx, parent, attrs.interaction, attrs.title, params)
    }
    function rect25d(ctx, parent, params, attrs) {
        var o = Math.ceil(attrs.depth * (1 - attrs.dmargin) / Math.SQRT2);
        var dt = Math.ceil(attrs.depth * attrs.dmargin / 2 / Math.SQRT2);
        params.x += dt;
        params.y -= dt;
        var w = params.width
          , h = params.height;
        var x = params.x
          , xw = x + w;
        var y = params.y
          , yh = y + h;
        var groupParams = {
            tdg_x: x,
            tdg_y: y,
            "class": "bar25d"
        };
        var g = append("g", ctx, parent, null, null, groupParams);
        if (!tdgchart.util.color.isOpaque(attrs.color)) {
            var backParams = tdg.clone(params);
            backParams.x += o;
            backParams.y -= o;
            append("rect", ctx, g, attrs.interaction, attrs.title, backParams);
            rect25dSide(ctx, g, params, attrs, 0, o, x, yh, w, 0);
            rect25dSide(ctx, g, params, attrs, 1.4, o, x, y, 0, h)
        }
        rect25dSide(ctx, g, params, attrs, 1.5, o, xw, y, 0, h);
        rect25dSide(ctx, g, params, attrs, .8, o, x, y, w, 0);
        append("rect", ctx, g, attrs.interaction, attrs.title, params)
    }
    tdgchart.drawbackend.svg.rect = function(ctx, parent, x, y, w, h, attrs) {
        var params = {
            x: x,
            y: y,
            width: w,
            height: h
        };
        addStyleDef(ctx, params, attrs);
        addCommonDef(params, attrs);
        if (attrs.depth)
            return rect25d(ctx, parent, params, attrs);
        return append("rect", ctx, parent, attrs.interaction, attrs.title, params)
    }
    ;
    function append(type, ctx, parent, interaction, title, params, child) {
        var r = svgel(type, params, child);
        if (title)
            if (ctx.htmlTooltips) {
                r.setAttribute("tdgtitle", "placeholder");
                r.tdgtitle = title
            } else {
                var t = svgel("title", {
                    tdgtitle: "placeholder"
                });
                t.tdgtitle = title;
                r.appendChild(t)
            }
        if (interaction && !tdg.isEmpty(interaction.events))
            addEvents(ctx, r, interaction);
        if (parent)
            parent.appendChild(r);
        return r
    }
    tdgchart.drawbackend.svg.circle = function(ctx, parent, x, y, r, attrs) {
        var params = {
            r: r
        };
        if (x)
            params.cx = x;
        if (y)
            params.cy = y;
        addStyleDef(ctx, params, attrs);
        addCommonDef(params, attrs);
        return append("circle", ctx, parent, attrs.interaction, attrs.title, params)
    }
    ;
    tdgchart.drawbackend.svg.arc = function(ctx, parent, cx, cy, r, from, to, attrs) {
        if (Math.abs(from - to) >= 360)
            return this.circle(ctx, parent, cx, cy, r, attrs);
        var large = ((to - from) % 360 + 360) % 360 > 180 ? 1 : 0;
        var path = "";
        path += " M" + (cx + r * Math.cos(from / 180 * Math.PI)) + "," + (cy - r * Math.sin(from / 180 * Math.PI));
        path += " A" + r + "," + r + " 0 " + large + " 0 " + (cx + r * Math.cos(to / 180 * Math.PI)) + "," + (cy - r * Math.sin(to / 180 * Math.PI));
        var params = {
            d: path
        };
        addStyleDef(ctx, params, attrs);
        addCommonDef(params, attrs);
        return append("path", ctx, parent, attrs.interaction, attrs.title, params)
    }
    ;
    tdgchart.drawbackend.svg.wedge = function(ctx, parent, cx, cy, r, ri, from, to, attrs) {
        var path = "";
        if (Math.abs(from - to) >= 360)
            if (ri > 0) {
                path += " M" + (cx + r) + "," + cy;
                path += " A" + r + "," + r + " 0 1 0 " + (cx - r) + "," + cy;
                path += " A" + r + "," + r + " 0 1 0 " + (cx + r) + "," + cy;
                path += " M" + (cx + ri) + "," + cy;
                path += " A" + ri + "," + ri + " 0 1 1 " + (cx - ri) + "," + cy;
                path += " A" + ri + "," + ri + " 0 1 1 " + (cx + ri) + "," + cy
            } else
                return this.circle(ctx, parent, cx, cy, r, attrs);
        else {
            var large = ((to - from) % 360 + 360) % 360 > 180 ? 1 : 0;
            path += " M" + (cx + r * Math.cos(from / 180 * Math.PI)) + "," + (cy - r * Math.sin(from / 180 * Math.PI));
            path += " A" + r + "," + r + " 0 " + large + " 0 " + (cx + r * Math.cos(to / 180 * Math.PI)) + "," + (cy - r * Math.sin(to / 180 * Math.PI));
            if (ri > 0) {
                path += " L" + (cx + ri * Math.cos(to / 180 * Math.PI)) + "," + (cy - ri * Math.sin(to / 180 * Math.PI));
                path += " A" + ri + "," + ri + " 0 " + large + " 1 " + (cx + ri * Math.cos(from / 180 * Math.PI)) + "," + (cy - ri * Math.sin(from / 180 * Math.PI))
            } else
                path += " L" + cx + "," + cy;
            path += " Z"
        }
        var params = {
            d: path
        };
        addStyleDef(ctx, params, attrs);
        addCommonDef(params, attrs);
        return append("path", ctx, parent, attrs.interaction, attrs.title, params)
    }
    ;
    tdgchart.drawbackend.svg.line = function(ctx, parent, x1, y1, x2, y2, attrs) {
        var path = "M" + x1 + "," + y1 + " L" + x2 + "," + y2;
        var params = {
            d: path
        };
        addStyleDef(ctx, params, attrs);
        addCommonDef(params, attrs);
        return append("path", ctx, parent, attrs.interaction, attrs.title, params)
    }
    ;
    var alignOptions = {
        left: "begin",
        begin: "begin",
        center: "middle",
        middle: "middle",
        right: "end",
        end: "end"
    };
    var isIE = /MSIE|Trident/.test(typeof window !== "undefined" && window.navigator ? window.navigator.userAgent : undefined);
    function hasUTF8(t) {
        for (var i = 0; i < t.length; i++)
            if (t.charCodeAt(i) > 127)
                return true;
        return false
    }
    tdgchart.drawbackend.svg.text = function(ctx, parent, x, y, text, attrs) {
        attrs = attrs || {};
        text += "";
        if (tdg.textContainsHTML(text))
            return this.textHTML(ctx, parent, x, y, text, attrs);
        var lines = text.split("\n");
        var params = {
            x: x,
            y: y,
            dy: "1em"
        };
        var dy;
        if (attrs.shift != null)
            dy = attrs.shift || 0;
        switch (attrs.valign) {
        case "top":
        case "begin":
            dy = (dy || 0) + 1;
            break;
        case "middle":
        case "center":
            dy = (dy || 0) + .5 - (lines.length - 1) / 2;
            break;
        case "bottom":
        case "end":
            dy = (dy || 0) - (lines.length - 1);
            break
        }
        if (dy != null)
            params.dy = dy + "em";
        if (attrs.align && attrs.align !== "left") {
            var IE11workaround = !!isIE;
            if (!IE11workaround || !hasUTF8(text))
                params["text-anchor"] = alignOptions[attrs.align];
            else {
                var parentElement = parent;
                var font = attrs.font;
                while ((!font || font == " ") && parentElement) {
                    font = parentElement.getAttribute("font-family") + " " + parentElement.getAttribute("font-size");
                    parentElement = parentElement.tagName == "SVG" ? null : parentElement.parentElement
                }
                var lblSize = tdgchart.measureLabel(text, font);
                if (attrs.align == "center" || attrs.align == "middle")
                    params.x -= lblSize.width / 2;
                else if (attrs.align == "right" || attrs.align == "end")
                    params.x -= lblSize.width
            }
        }
        addFontDef(params, attrs.color, attrs.font, attrs.size);
        addStyleDef(ctx, params, attrs);
        addCommonDef(params, attrs);
        if (lines.length > 1)
            text = lines.map(function(s, idx) {
                return svgel("tspan", {
                    x: x,
                    dy: idx > 0 ? "1.1em" : null
                }, s)
            });
        return append("text", ctx, parent, attrs.interaction, attrs.title, params, text)
    }
    ;
    function createHTMLLabelContainer(svg) {
        var rootContainer = svg.parentNode;
        var div = document.createElement("div");
        div.style.display = "block";
        div.style.position = "relative";
        div.style.border = "none";
        div.style.fontSize = "10px";
        div.style.fontFamily = "sans-serif";
        div.style.zIndex = 10;
        div.setAttribute("class", "htmlLabelHolder");
        rootContainer.insertBefore(div, svg);
        return div
    }
    function transformToElement(el, target) {
        var transform = {
            x: 0,
            y: 0
        };
        while (el && el !== target) {
            if (el.transform.baseVal.numberOfItems > 0) {
                transform.x += el.transform.baseVal.getItem(0).matrix.e;
                transform.y += el.transform.baseVal.getItem(0).matrix.f
            }
            el = el.parentNode
        }
        return transform
    }
    tdgchart.drawbackend.svg.textHTML = function(ctx, parent, x, y, text, attrs) {
        var useForeignObject = document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Extensibility", "1.1");
        var lblSize = tdgchart.measureLabel(text, attrs.font || null);
        if (attrs.maxWidth) {
            if (lblSize.width > attrs.maxWidth)
                lblSize = tdgchart.measureLabel(text, attrs.font || null, attrs.maxWidth);
            lblSize.width = Math.min(lblSize.width + 1, attrs.maxWidth)
        }
        switch (attrs.align) {
        case "center":
        case "middle":
            x -= lblSize.width / 2;
            break;
        case "right":
            x -= lblSize.width;
            break
        }
        switch (attrs.valign) {
        case "center":
        case "middle":
            y -= lblSize.height / 2;
            break;
        case "bottom":
        case "end":
            y -= lblSize.height;
            break
        }
        var res;
        var params = {
            x: x,
            y: y
        };
        var style = {
            fill: "black"
        };
        addFontDef(style, attrs.color, attrs.font, attrs.size);
        addStyleDef(ctx, params, attrs);
        addCommonDef(params, attrs);
        style.color = style.fill;
        style.fill = null;
        var styleArray = ["all: unset"];
        for (var s in style)
            if (style[s])
                styleArray.push(s + ": " + style[s]);
        params.width = lblSize.width + 2;
        params.height = lblSize.height + 2;
        if (useForeignObject) {
            var objectBody = document.createElementNS(xhtmlNS, "body");
            objectBody.setAttribute("xmlns", xhtmlNS);
            objectBody.setAttribute("marginWidth", "0");
            objectBody.setAttribute("marginHeight", "0");
            objectBody.setAttribute("style", styleArray.join("; "));
            var div = document.createElement("div");
            div.innerHTML = text;
            if (attrs.maxWidth)
                div.setAttribute("style", "width: " + lblSize.width + "px;");
            objectBody.appendChild(div);
            if (typeof params.transform === "string" && params.transform.includes("translate")) {
                var g = append("g", {}, parent, null, null, {
                    transform: params.transform
                });
                params.transform = null;
                parent = g
            }
            res = append("foreignObject", ctx, parent, attrs.interaction, attrs.title, params, objectBody)
        } else {
            var svg = ctx.root;
            var localTransform = transformToElement(parent, svg);
            var container = svg.parentNode.getElementsByClassName("htmlLabelHolder")[0];
            if (!container)
                container = createHTMLLabelContainer(svg);
            var lbl = document.createElement("div");
            lbl.setAttribute("class", params.className || params["class"] || null);
            if (attrs.title && ctx.htmlTooltips)
                lbl.setAttribute("tdgtitle", attrs.title);
            if (attrs.rotation) {
                x += lblSize.height;
                y += lblSize.width / 2;
                lbl.style.transform = "rotate(" + attrs.rotation + "deg)"
            }
            lbl.style.cursor = attrs.cursor || null;
            lbl.style.display = "inline-block";
            lbl.style.position = "absolute";
            lbl.style.left = x + (attrs.translate ? attrs.translate.x || 0 : 0) + localTransform.x + "px";
            lbl.style.top = y + (attrs.translate ? attrs.translate.y || 0 : 0) + localTransform.y + "px";
            lbl.style.font = attrs.font;
            lbl.style.color = attrs.color;
            lbl.innerHTML = text;
            container.appendChild(lbl);
            res = container
        }
        return res
    }
    ;
    tdgchart.drawbackend.svg.image = function(ctx, parent, x, y, w, h, url, attrs) {
        var params = {
            x: x,
            y: y,
            width: w,
            height: h
        };
        addStyleDef(ctx, params, attrs);
        addCommonDef(params, attrs);
        var imgParams = tdg.clone(params);
        delete imgParams.class;
        var img = append("image", ctx, parent, null, null, imgParams);
        var interactionBoxParams = tdg.clone(params);
        interactionBoxParams.fill = "transparent";
        interactionBoxParams.stroke = "transparent";
        var imgBorder = append("rect", ctx, parent, attrs.interaction, attrs.title, interactionBoxParams);
        url = url.replace(/^url\((.*)\)$/ig, "$1");
        img.setAttributeNS(xlinkNS, "href", url);
        if (attrs.centerOffset) {
            var dx = attrs.centerOffset.x
              , dy = attrs.centerOffset.y;
            if (tdg.isPercentString(dx) || tdg.isPercentString(dy)) {
                var bbox = img.getBBox();
                dx = tdg.applyNumOrPercent(dx, bbox.width, -1, 1);
                dy = tdg.applyNumOrPercent(dy, bbox.height, -1, 1)
            }
            var transform = tdg.transform.appendXY(img, dx, dy);
            img.setAttribute("transform", transform);
            imgBorder.setAttribute("transform", transform)
        }
        return img
    }
    ;
    tdgchart.drawbackend.svg.newPath = function() {
        this.p = []
    }
    ;
    tdgchart.drawbackend.svg.newPath.prototype.moveTo = function(x, y, relative) {
        this.p.push((relative ? "m" : "M") + x + "," + y)
    }
    ;
    tdgchart.drawbackend.svg.newPath.prototype.lineTo = function(x, y, relative) {
        this.p.push((relative ? "l" : "L") + x + "," + y)
    }
    ;
    tdgchart.drawbackend.svg.newPath.prototype.arcTo = function(rx, ry, rotation, large, sweep, x, y, relative) {
        var type = relative ? "a" : "A";
        this.p.push(type + rx + "," + ry + "," + rotation + "," + large + "," + sweep + "," + x + "," + y)
    }
    ;
    tdgchart.drawbackend.svg.newPath.prototype.closePath = function() {
        this.p.push("Z")
    }
    ;
    tdgchart.drawbackend.svg.path = function(ctx, parent, path, attrs) {
        var params = {
            d: typeof path === "string" ? path : path.p.join(" ")
        };
        addStyleDef(ctx, params, attrs);
        addCommonDef(params, attrs);
        var shape, bbox;
        var transform = params.transform;
        var className = params["class"] || "";
        if (attrs.includeEventCatcher || tdg.color.isRectVisible(attrs.background)) {
            params["class"] = className.replace(/(.*?)!/, "placeholder$1!");
            params["pointer-events"] = "none";
            shape = append("path", ctx, parent, null, attrs.title, params)
        } else
            shape = append("path", ctx, parent, attrs.interaction, attrs.title, params);
        if (attrs.centerOffset) {
            var dx = attrs.centerOffset.x
              , dy = attrs.centerOffset.y;
            if (tdg.isPercentString(dx) || tdg.isPercentString(dy)) {
                bbox = bbox || shape.getBBox();
                dx = tdg.applyNumOrPercent(dx, bbox.width, -1, 1);
                dy = tdg.applyNumOrPercent(dy, bbox.height, -1, 1)
            }
            transform = tdg.transform.appendXY(shape, dx, dy);
            shape.setAttribute("transform", transform)
        }
        if (attrs.includeEventCatcher || tdg.color.isRectVisible(attrs.background)) {
            var background = attrs.background || {};
            bbox = bbox || shape.getBBox();
            var rectParams = tdg.clone(bbox);
            rectParams.transform = transform;
            rectParams["class"] = className;
            rectParams.fill = tdg.color.isVisible(background.color) ? attrs.background.color : "transparent";
            if (tdg.color.isLineVisible(background.border)) {
                rectParams.stroke = background.border.color;
                rectParams["stroke-width"] = background.border.width;
                rectParams["shape-rendering"] = "crispEdges"
            }
            var rect = append("rect", ctx, null, attrs.interaction, attrs.title, rectParams);
            parent.insertBefore(rect, shape)
        }
        return shape
    }
    ;
    tdgchart.drawbackend.svg.riserPath = function(ctx, parent, topPoints, bottomPoints, attrs) {
        var i, polygons = [[]];
        for (i = 0; i < topPoints.length; i++) {
            var point = topPoints[i];
            if (tdg.isANumber(point.x) && tdg.isANumber(point.y))
                polygons[polygons.length - 1].push(i);
            else
                polygons.push([])
        }
        polygons.forEach(function(p) {
            if (!p || p.length < 1)
                return;
            var start = p[0]
              , end = p[p.length - 1] + 1;
            var top = topPoints.slice(start, end);
            var bottom = bottomPoints ? bottomPoints.slice(start, end) : null;
            if (attrs.depth)
                riser25DPathSegment(ctx, parent, top, bottom, attrs);
            else
                riserPathSegment(ctx, parent, top, bottom, attrs)
        })
    }
    ;
    function riserPathSegment(ctx, parent, topPoints, bottomPoints, attrs) {
        var svgPath, params = {};
        if (attrs.riserShape === "area" && topPoints.length === 1 && bottomPoints && bottomPoints.length === 1) {
            params["shape-rendering"] = "crispEdges";
            var p1 = topPoints[0]
              , p2 = bottomPoints[0];
            if (attrs.isHorizontal)
                svgPath = "M" + p1.x + "," + p1.y + "l0,-1L" + p2.x + "," + (p2.y - 1) + "l0,1Z";
            else
                svgPath = "M" + p1.x + "," + p1.y + "l1,0L" + (p2.x + 1) + "," + p2.y + "l-1,0Z"
        } else {
            svgPath = interpolatePoints(topPoints, attrs.interpolation, attrs.isHorizontal, attrs.baseline).join("");
            if (bottomPoints) {
                var t = interpolatePoints(tdg.reverse(bottomPoints), reverseInterpolation(attrs.interpolation), attrs.isHorizontal, attrs.baseline).join("");
                svgPath += "L" + t.slice(1) + "Z"
            }
        }
        params.d = svgPath;
        addStyleDef(ctx, params, attrs);
        addCommonDef(params, attrs);
        return append("path", ctx, parent, attrs.interaction, attrs.title, params)
    }
    function riser25DPathSegment(ctx, parent, topPoints, bottomPoints, attrs) {
        var params = {}, o, topPath;
        function leftWall() {
            if (bottomPoints) {
                var x1 = topPoints[0].x;
                var y1 = topPoints[0].y;
                var x2 = bottomPoints[0].x;
                var y2 = bottomPoints[0].y;
                if (tdg.isANumber(x1) && tdg.isANumber(x2) && tdg.isANumber(y1) && tdg.isANumber(y2))
                    rect25dSide(ctx, parent, params, attrs, 1.5, o, x1, y1, x2 - x1, y2 - y1)
            }
        }
        function bottomWall() {
            if (bottomPoints)
                for (var i = 1; i < bottomPoints.length; i++) {
                    var x1 = bottomPoints[i - 1].x;
                    var y1 = bottomPoints[i - 1].y;
                    var x2 = bottomPoints[i].x;
                    var y2 = bottomPoints[i].y;
                    if (!tdg.isANumber(x1) || !tdg.isANumber(x2) || !tdg.isANumber(y1) || !tdg.isANumber(y2))
                        continue;
                    rect25dSide(ctx, parent, params, attrs, 1.5, o, x1, y1, x2 - x1, y2 - y1)
                }
        }
        function rightWall() {
            if (bottomPoints) {
                var x1 = topPoints[topPoints.length - 1].x;
                var y1 = topPoints[topPoints.length - 1].y;
                var x2 = bottomPoints[bottomPoints.length - 1].x;
                var y2 = bottomPoints[bottomPoints.length - 1].y;
                if (tdg.isANumber(x1) && tdg.isANumber(x2) && tdg.isANumber(y1) && tdg.isANumber(y2))
                    rect25dSide(ctx, parent, params, attrs, 1.5, o, x1, y1, x2 - x1, y2 - y1)
            }
        }
        function getXY(pathSegment) {
            var points = pathSegment.slice(1).split(/[, ]/);
            switch (pathSegment.charAt(0)) {
            case "S":
            case "Q":
                return {
                    x: parseFloat(points[2]),
                    y: parseFloat(points[3])
                };
            case "C":
                return {
                    x: parseFloat(points[4]),
                    y: parseFloat(points[5])
                }
            }
            return {
                x: parseFloat(points[0]),
                y: parseFloat(points[1])
            }
        }
        function topWall() {
            var topPointsReversed = tdg.reverse(topPoints).map(function(el) {
                return {
                    x: el.x + o,
                    y: el.y - o
                }
            });
            var topPathReversed = interpolatePoints(topPointsReversed, reverseInterpolation(attrs.interpolation), attrs.isHorizontal, attrs.baseline);
            for (var i = 1; i < topPath.length; i++) {
                var xy1 = getXY(topPath[i - 1]);
                var colorAdjustment = 1.5;
                if (!bottomPoints) {
                    var xy2 = getXY(topPath[i]);
                    colorAdjustment = Math.pow(Math.abs((xy2.y - xy1.y) / (attrs.containerHeight || 0)), .8) * 3 * (xy2.y - xy1.y < 0 ? -1 : 1);
                    if (xy2.y - xy1.y < xy1.x - xy2.x)
                        colorAdjustment += 3
                }
                var path = "M" + xy1.x + "," + xy1.y + topPath[i - 1] + topPath[i] + "l" + o + "," + -o + topPathReversed[topPathReversed.length - i] + "Z";
                var faceParams = tdg.clone(params);
                if (colorAdjustment) {
                    var fill = pv.SvgScene.adjcolor(tdg.color(attrs.color), colorAdjustment);
                    if (fill.isComplexFill)
                        fill = addFillDef(ctx, fill);
                    faceParams.fill = fill.toString()
                }
                delete faceParams.width;
                delete faceParams.height;
                delete faceParams.x;
                delete faceParams.y;
                faceParams.d = path;
                append("path", ctx, parent, attrs.interaction, attrs.title, faceParams)
            }
        }
        function face(o) {
            if (bottomPoints) {
                var bottomPointsReversed = tdg.reverse(bottomPoints);
                var bottomPathReversed = interpolatePoints(bottomPointsReversed, reverseInterpolation(attrs.interpolation), attrs.isHorizontal, attrs.baseline);
                var path = topPath.join("") + "L" + bottomPathReversed.join("").slice(1) + "Z";
                var faceParams = tdg.clone(params);
                faceParams.d = path;
                if (o)
                    faceParams.transform = "translate(" + o + "," + -o + ")";
                append("path", ctx, parent, attrs.interaction, attrs.title, faceParams)
            }
        }
        addStyleDef(ctx, params, attrs);
        addCommonDef(params, attrs);
        o = Math.ceil(attrs.depth * (1 - attrs.dmargin) / Math.SQRT2);
        var dt = Math.ceil(attrs.depth * attrs.dmargin / 2 / Math.SQRT2);
        var alphaWalls = !tdgchart.util.color.isOpaque(attrs.color);
        topPoints = topPoints.map(function(el) {
            return {
                x: el.x + dt,
                y: el.y - dt
            }
        });
        topPath = interpolatePoints(topPoints, attrs.interpolation, attrs.isHorizontal, attrs.baseline);
        if (bottomPoints)
            bottomPoints = bottomPoints.map(function(el) {
                return {
                    x: el.x + dt,
                    y: el.y - dt
                }
            });
        if (topPoints.length < 2 && bottomPoints) {
            leftWall();
            return
        }
        if (alphaWalls)
            face(o);
        if (attrs.isHorizontal) {
            if (alphaWalls) {
                bottomWall();
                rightWall()
            }
            topWall();
            leftWall()
        } else {
            if (alphaWalls) {
                leftWall();
                bottomWall()
            }
            rightWall();
            topWall()
        }
        face(0)
    }
    function reverseInterpolation(interpolation) {
        interpolation = (interpolation || "linear").toLowerCase();
        if (interpolation === "stepafter")
            return "stepbefore";
        else if (interpolation === "stepbefore")
            return "stepafter";
        return interpolation
    }
    function tangentsPoints(points) {
        var a = .15;
        var p0 = points[0]
          , p1 = points[1]
          , p2 = points[2];
        var tangents = [];
        for (var i = 3; i < points.length; i++) {
            tangents.push({
                x: a * (p2.x - p0.x),
                y: a * (p2.y - p0.y)
            });
            p0 = p1;
            p1 = p2;
            p2 = points[i]
        }
        tangents.push({
            x: a * (p2.x - p0.x),
            y: a * (p2.y - p0.y)
        });
        return tangents
    }
    function curvedLine(points, tangents, d) {
        if (tangents.length < 1 || points.length !== tangents.length && points.length !== tangents.length + 2)
            return null;
        var quad = points.length !== tangents.length;
        var p0 = points[0]
          , p = points[1]
          , t0 = tangents[0]
          , t = t0
          , pi = 1;
        var a = 2 / 3;
        if (quad) {
            d.push("Q" + (p.x - a * t0.x) + "," + (p.y - a * t0.y) + "," + p.x + "," + p.y);
            p0 = points[1];
            pi = 2
        }
        if (tangents.length > 1) {
            t = tangents[1];
            p = points[pi];
            pi++;
            d.push("C" + (p0.x + t0.x) + "," + (p0.y + t0.y) + "," + (p.x - t.x) + "," + (p.y - t.y) + "," + p.x + "," + p.y);
            for (var i = 2; i < tangents.length; i++,
            pi++) {
                p = points[pi];
                t = tangents[i];
                d.push("S" + (p.x - t.x) + "," + (p.y - t.y) + "," + p.x + "," + p.y)
            }
        }
        if (quad) {
            var lp = points[pi];
            d.push("Q" + (p.x + a * t.x) + "," + (p.y + a * t.y) + "," + lp.x + "," + lp.y)
        }
        return d
    }
    function interpolatePoints(points, interpolation, isHorizontal, baseline) {
        interpolation = (interpolation || "linear").toLowerCase();
        var d = [], prevPoint = null, point, i;
        if (interpolation === "curved") {
            var segments = [[]];
            for (i = 0; i < points.length; i++) {
                point = points[i];
                if (point.x == null || point.y == null) {
                    if (segments[segments.length - 1].length > 0)
                        segments.push([])
                } else
                    segments[segments.length - 1].push(point)
            }
            for (i = 0; i < segments.length; i++) {
                var segment = segments[i];
                if (segment.length > 1) {
                    d.push("M" + segment[0].x + "," + segment[0].y);
                    if (segment.length > 2)
                        d = curvedLine(segment, tangentsPoints(segment), d);
                    else
                        d.push("L" + segment[1].x + "," + segment[1].y)
                }
            }
        } else if (interpolation === "baselinedescender") {
            var direction = isHorizontal ? "H" : "V";
            for (i = 0; i < points.length; i++)
                d.push("M" + points[i].x + "," + (points[i].y + direction + baseline))
        } else if (interpolation.includes("step"))
            for (i = 0; i < points.length; i++) {
                point = points[i];
                if (i === 0)
                    d.push("M" + point.x + "," + point.y);
                else {
                    if (prevPoint != null)
                        if (interpolation === "stepbefore")
                            if (isHorizontal)
                                d.push("L" + point.x + "," + prevPoint.y);
                            else
                                d.push("L" + prevPoint.x + "," + point.y);
                        else if (interpolation === "stepafter")
                            if (isHorizontal)
                                d.push("L" + prevPoint.x + "," + point.y);
                            else
                                d.push("L" + point.x + "," + prevPoint.y);
                        else if (isHorizontal) {
                            var midY = (prevPoint.y + point.y) / 2;
                            d.push("L" + prevPoint.x + "," + midY);
                            d.push("L" + point.x + "," + midY)
                        } else {
                            var midX = (prevPoint.x + point.x) / 2;
                            d.push("L" + midX + "," + prevPoint.y);
                            d.push("L" + midX + "," + point.y)
                        }
                    d.push("L" + point.x + "," + point.y)
                }
                prevPoint = point
            }
        else
            for (i = 0; i < points.length; i++)
                d.push((i === 0 ? "M" : "L") + points[i].x + "," + points[i].y);
        return d
    }
    tdgchart.drawbackend.svg.findNode = function(root, p) {
        var node;
        if (typeof p === "string")
            node = root.parentNode.getElementsByClassName(p)[0] || root;
        else if (typeof p === "object" && p.$dom)
            node = p.$dom;
        else if (typeof p === "object" && typeof p.className === "function")
            node = root.parentNode.getElementsByClassName(p.className())[0] || root;
        if (!node)
            return null;
        if (node.childElementCount > 0 && node.childNodes[0].getAttribute("clip-path"))
            node = node.childNodes[0];
        return node
    }
    ;
    function addColor(params, paramname, color) {
        if (color)
            if (typeof color === "object") {
                if (color.color)
                    params[paramname] = color.color;
                if (color.opacity && color.opacity !== 1)
                    params[paramname + "-opacity"] = color.opacity
            } else
                params[paramname] = color
    }
    var numRegEx = new RegExp(/^\d/);
    function addCommonDef(params, attrs) {
        attrs = attrs || {};
        if (attrs["class"])
            params["class"] = attrs["class"];
        else if (attrs.className)
            params["class"] = attrs.className;
        if (attrs.id)
            params.id = attrs.id;
        if (attrs["pointer-events"])
            params["pointer-events"] = attrs["pointer-events"];
        if (attrs.style)
            params.style = attrs.style
    }
    function addFontDef(params, color, font, size) {
        addColor(params, "fill", color);
        if (font)
            tdg.merge(tdg.fontToFontParts(font).toKebabCase(), params);
        if (size != null)
            if (typeof size === "number")
                params["font-size"] = size.toString() + "px";
            else if (numRegEx.test(size))
                params["font-size"] = size
    }
    var clip_no = 0;
    function addDefinition(ctx, def) {
        if (!ctx.root)
            return;
        if (!ctx.defs)
            ctx.defs = (ctx.root.getElementsByTagName("defs") || [])[0];
        if (!ctx.defs) {
            ctx.defs = svgel("defs");
            ctx.root.insertBefore(ctx.defs, ctx.root.firstChild)
        }
        ctx.defs.appendChild(def)
    }
    function addClipRectDef(ctx, x, y, w, h) {
        clip_no += 1;
        var id = "cl" + clip_no;
        var clip = svgel("clipPath", {
            id: id
        }, svgel("rect", {
            x: x,
            y: y,
            width: w,
            height: h
        }));
        addDefinition(ctx, clip);
        return "url(#" + id + ")"
    }
    function getPatternID(pattern, containerID) {
        var shape = typeof pattern.shape === "function" ? pattern.shape() : pattern.shape;
        var p = [pattern.type, shape, pattern.size, pattern.pad, pattern.foregroundColor, pattern.backgroundColor];
        var s = containerID + "__" + p.join("_");
        s = s.replace(/rgb\(/g, "").replace(/[ ;({}'"#:.,)]/g, "");
        return s
    }
    function getFillID(fill, containerID) {
        var p, type = fill.type || "";
        if (type === "pattern")
            return getPatternID(fill, containerID);
        else if (type.startsWith("linear"))
            if (fill.angle != null)
                p = [type, "angle", fill.angle];
            else
                p = [type, fill.x1, fill.y1, fill.x2, fill.y2];
        else
            p = [type, fill.cx, fill.cy, fill.r];
        var s = containerID + "__" + p.join("_") + "_";
        s += fill.stops.map(function(el) {
            return el.join("_")
        }).join("_");
        s = s.replace(/~/g, "t").replace(/%/g, "p");
        s = s.replace(/rgba?\(/g, "").replace(/[ #:.,)]/g, "");
        return s
    }
    function createGradient(id, gradient) {
        var g = {
            id: id
        };
        var gtype;
        if (gradient.type.startsWith("linear")) {
            gtype = "linearGradient";
            if (gradient.angle != null)
                switch (gradient.angle) {
                default:
                case 0:
                    g.x1 = "0%";
                    g.x2 = "100%";
                    g.y1 = "0%";
                    g.y2 = "0%";
                    break;
                case 180:
                    g.x1 = "100%";
                    g.x2 = "0%";
                    g.y1 = "0%";
                    g.y2 = "0%";
                    break;
                case 90:
                    g.x1 = "0%";
                    g.x2 = "0%";
                    g.y1 = "100%";
                    g.y2 = "0%";
                    break;
                case 270:
                    g.x1 = "0%";
                    g.x2 = "0%";
                    g.y1 = "0%";
                    g.y2 = "100%";
                    break
                }
            else {
                g.x1 = gradient.x1;
                g.y1 = gradient.y1;
                g.x2 = gradient.x2;
                g.y2 = gradient.y2
            }
        } else if (gradient.type.startsWith("radial")) {
            gtype = "radialGradient";
            g.cx = gradient.cx;
            g.cy = gradient.cy;
            g.r = gradient.r;
            g.fx = gradient.fx;
            g.fy = gradient.fy
        }
        var stops = gradient.stops.map(function(s) {
            var color = tdg.color(s[1]);
            var alpha = s[2] != null && s[2] < 1 ? s[2] : null;
            var offset = tdg.applyNumOrPercent(s[0], 1);
            return svgel("stop", {
                offset: offset,
                "stop-color": color.toOpaqueColorString(),
                "stop-opacity": alpha
            })
        });
        if (gradient.gradientUnits)
            g.gradientUnits = gradient.gradientUnits;
        if (gtype && stops)
            return svgel(gtype, g, stops);
        return null
    }
    function createPattern(id, pattern) {
        var shapeEl, rectEl, gEl, shapePath;
        var size = pattern.size
          , shape = pattern.shape;
        var r = tdgchart.util.isPercentString(size) ? 50 : size / 2 - (pattern.pad || 0);
        var isStroke = pv.SvgScene.pathRequiresStroke(shape);
        var antialias = pattern.antialias == null ? pv.SvgScene.pathRequiresAntiAlias(shape) : pattern.antialias;
        rectEl = svgel("rect", {
            width: size,
            height: size,
            fill: pattern.backgroundColor
        });
        if (typeof shape === "string" && shape.includes(",")) {
            shapePath = shape;
            isStroke = true
        } else {
            shapePath = pv.SvgScene.getPath({
                radius: r,
                size: r,
                shape: shape
            });
            if (shapePath == null) {
                var res = pv.SvgScene.getPattern(shape, pattern.pad, pattern.lineWidth);
                if (res) {
                    shapePath = res.path;
                    size = res.size;
                    isStroke = true
                }
            }
        }
        if (shapePath) {
            var shapeAttrs = {
                d: shapePath,
                fill: isStroke ? null : pattern.foregroundColor,
                stroke: isStroke ? pattern.foregroundColor : null,
                "stroke-width": isStroke ? pattern.lineWidth : null,
                "shape-rendering": antialias ? null : "crispEdges"
            };
            shapeEl = svgel("path", shapeAttrs)
        } else
            shapeEl = svgel("circle", {
                cx: 0,
                cy: 0,
                r: r,
                fill: pattern.foregroundColor
            });
        var attrs = {
            id: id,
            x: 1,
            y: 1,
            width: size,
            height: size
        };
        if (tdgchart.util.isPercentString(size)) {
            attrs.patternUnits = "objectBoundingBox";
            attrs.patternContentUnits = "objectBoundingBox";
            var pct = tdgchart.util.parsePercent(size);
            var translate = .5 * pct
              , scale = 1 / r / 2 * pct;
            gEl = svgel("g", {
                transform: "translate(" + translate + ", " + translate + ") scale(" + scale + ")"
            }, shapeEl)
        } else {
            attrs.patternUnits = "userSpaceOnUse";
            gEl = svgel("g", {
                transform: "translate(" + size / 2 + ", " + size / 2 + ")"
            }, shapeEl)
        }
        return svgel("pattern", attrs, [rectEl, gEl])
    }
    function addFillDef(ctx, fill) {
        var id = getFillID(fill, ctx.containerID);
        var urlID = "url(#" + id + ")";
        if (ctx.defs && ctx.defs.childNodes.length)
            for (var i = 0; i < ctx.defs.childNodes.length; i++) {
                var childID = ctx.defs.childNodes[i].getAttribute("id");
                if (childID === id)
                    return urlID
            }
        var node;
        if (fill.type.startsWith("radial") || fill.type.startsWith("linear"))
            node = createGradient(id, fill);
        else if (fill.type === "pattern")
            node = createPattern(id, fill);
        addDefinition(ctx, node);
        return urlID
    }
    function addStyleDef(ctx, params, attrs) {
        attrs = attrs || {};
        var fill = attrs.color;
        var fillColor = tdg.color(fill);
        if (fillColor.isComplexFill)
            fill = addFillDef(ctx, fillColor);
        else if (fillColor.isInvalid)
            fill = "rgb(0, 0, 0)";
        addColor(params, "fill", fill);
        if (typeof attrs.style === "string")
            params.style = attrs.style;
        if (attrs.lineStyle && attrs.lineStyle.width && attrs.lineStyle.color) {
            var lineColor = tdg.color(attrs.lineStyle.color);
            if (lineColor.isComplexFill)
                lineColor = addFillDef(ctx, lineColor);
            else
                lineColor = attrs.lineStyle.color;
            addColor(params, "stroke", lineColor);
            params["stroke-width"] = attrs.lineStyle.width;
            if (attrs.lineStyle.dash)
                if (pv.SvgScene.dashPresets[attrs.lineStyle.dash])
                    params["stroke-dasharray"] = pv.SvgScene.dashPresets[attrs.lineStyle.dash];
                else
                    params["stroke-dasharray"] = attrs.lineStyle.dash
        }
        if (attrs.lineWidth) {
            addColor(params, "stroke", attrs.border);
            params["stroke-width"] = attrs.lineWidth
        }
        if (attrs.dash)
            if (pv.SvgScene.dashPresets[attrs.dash])
                params["stroke-dasharray"] = pv.SvgScene.dashPresets[attrs.dash];
            else
                params["stroke-dasharray"] = attrs.dash;
        if (attrs.antialias != null)
            params["shape-rendering"] = attrs.antialias === true ? "auto" : "crispEdges";
        if (attrs.lineCap)
            params["stroke-linecap"] = attrs.lineCap;
        if (attrs.cursor != null)
            params.cursor = attrs.cursor;
        if (attrs.cornerRadius) {
            if (typeof attrs.cornerRadius === "object" && attrs.cornerRadius.hasOwnProperty("x")) {
                params.rx = attrs.cornerRadius.x;
                params.ry = attrs.cornerRadius.y
            } else
                params.rx = params.ry = attrs.cornerRadius;
            params["shape-rendering"] = "auto"
        }
        if (attrs.translate && (attrs.translate.x || attrs.translate.y))
            params.transform = "translate(" + attrs.translate.x + ", " + attrs.translate.y + ")";
        if (attrs.scale != null) {
            params.transform = params.transform ? params.transform + " " : "";
            if (typeof attrs.scale === "number")
                params.transform += "scale(" + attrs.scale + ")";
            else if (typeof attrs.scale === "object")
                params.transform += "scale(" + attrs.scale.x + ", " + attrs.scale.y + ")"
        }
        if (attrs.rotation) {
            var angle = attrs.rotation
              , origin = "";
            if (typeof attrs.rotation === "object" && attrs.rotation.angle != null) {
                angle = attrs.rotation.angle;
                if (attrs.rotation.x || attrs.rotation.y)
                    origin = " " + (attrs.rotation.x || 0) + " " + (attrs.rotation.y || 0)
            }
            params.transform = params.transform ? params.transform + " " : "";
            params.transform += "rotate(" + angle + origin + ")"
        }
        if (attrs.includeRadius)
            params["tdg:radius"] = attrs.includeRadius;
        if (attrs.visible === false)
            params.display = "none";
        if (attrs.attributes)
            for (var a in attrs.attributes)
                if (attrs.attributes.hasOwnProperty(a))
                    params[a] = attrs.attributes[a]
    }
    function svgel(name, attrs, child) {
        var el = document.createElementNS(svgNS, name);
        function addAttributes(attrs) {
            for (var a in attrs)
                if (a === "attrs" && typeof attrs[a] === "object")
                    addAttributes(attrs[a]);
                else if (attrs[a] != null)
                    el.setAttribute(a, attrs[a])
        }
        if (attrs)
            addAttributes(attrs);
        if (child != null)
            if (Array.isArray(child))
                child.forEach(function(c) {
                    el.appendChild(c)
                });
            else if (typeof child === "string")
                el.appendChild(document.createTextNode(child));
            else
                el.appendChild(child);
        return el
    }
}
)();
(function() {
    var tdg = tdgchart.util;
    function fixOneURL(el, chart, container) {
        if (el && el.event === "setURL") {
            var url = el.url
              , target = el.target;
            if (el.userInfo && !tdg.isEmpty(el.userInfo.url)) {
                url = el.userInfo.url;
                target = el.userInfo.target
            }
            if (typeof url === "string" && !url.includes("MDitemClickGraph") && (target === "_self" || tdg.isEmpty(target)))
                el.callback = tdg.partial(sizeAndDrawChart, [chart, container, {
                    remoteDataURL: url
                }])
        }
    }
    function fixSetURL(chart, container) {
        var fix = tdg.partial(fixOneURL, [null, chart, container]);
        if (chart.eventDispatcher && Array.isArray(chart.eventDispatcher.events))
            chart.eventDispatcher.events.forEach(fix);
        if (Array.isArray(chart._callbackList))
            chart._callbackList.forEach(fix)
    }
    function loadRemoteChart(chart, container, props) {
        function onError(e, res) {
            var url = props.remoteDataURL;
            chart.__isLoading = false;
            props.remoteDataURL = null;
            if (res && e && e.type === "empty_page") {
                var needIFrame = true;
                if (res.includes("window.tdgchart_widgetLoader"))
                    needIFrame = !loadCustomContent(chart, container, res, props);
                if (needIFrame)
                    addIFrame(chart, container, res, props)
            } else {
                var err = '<div style="width:0px;">Request Error: {0}<hr>{1}</div>';
                drawError(chart, tdg.formatString(err, url, e.msg));
                sizeAndDrawChart(chart, container, props)
            }
        }
        function onLoad() {
            chart.__isLoading = false;
            props.remoteDataURL = null;
            sizeAndDrawChart(chart, container, props)
        }
        chart.__isLoading = true;
        chart.unregisterAllEvents();
        chart.set(tdgchart.defaultProperties);
        var config = {
            onLoad: onLoad,
            onError: onError,
            requestMethod: props.remoteDataFetchMode
        };
        chart.loadRemoteProperties(props.remoteDataURL, "jschart", config)
    }
    function loadCustomContent(chart, container, content, props) {
        var doc = (new DOMParser).parseFromString(content, "text/html");
        for (var i = 0; i < doc.scripts.length; i++)
            if (doc.scripts[i].innerHTML.includes("window.tdgchart_widgetLoader")) {
                eval(doc.scripts[i].innerHTML);
                var widgetProps = window.tdgchart_widgetLoader;
                if (!widgetProps || typeof widgetProps !== "object")
                    return false;
                if (widgetProps.destroy) {
                    var originalDestroy = chart.destroy;
                    chart.destroy = function() {
                        originalDestroy.call(this);
                        if (widgetProps && typeof widgetProps.destroy === "function")
                            widgetProps.destroy()
                    }
                }
                if (widgetProps.url) {
                    props.remoteDataURL = typeof widgetProps.url === "function" ? widgetProps.url() : widgetProps.url + "";
                    loadRemoteChart(chart, container, props)
                }
                return true
            }
        return true
    }
    function addIFrame(chart, container, content, props) {
        tdg.dom.empty(container);
        var iframe = document.createElement("iframe");
        iframe.setAttribute("width", "100%");
        iframe.setAttribute("height", "100%");
        iframe.setAttribute("style", "border: 0px");
        iframe.setAttribute("name", container.getAttribute("id") + "_iframe");
        container.appendChild(iframe);
        var doc = iframe.contentWindow.document;
        doc.open();
        doc.write(content);
        doc.close();
        if (props && typeof props.renderComplete === "function")
            props.renderComplete.call(chart, iframe);
        drawQueue(chart);
        if (typeof ibx !== "undefined" && props && props.waitSpinnerContainer)
            ibx.waitStop(props.waitSpinnerContainer)
    }
    function drawQueue(chart) {
        while (chart.__drawQueue && chart.__drawQueue.length)
            chart.__drawQueue.shift()()
    }
    function sizeAndDrawChart(chart, container, props) {
        if (props && props.remoteDataURL) {
            delete chart.destroy;
            loadRemoteChart(chart, container, props);
            return
        }
        if (container.firstChild && container.firstChild.nodeName.toLowerCase() === "iframe") {
            var size = getSize(container, props);
            container.firstChild.setAttribute("width", size.width);
            container.firstChild.setAttribute("height", size.height)
        } else {
            chart.set(getSize(container, props));
            if (chart.errorMessage) {
                var w = chart.width * .9;
                chart.errorMessage = chart.errorMessage.replace(/^(<div style="width:)[.0-9]*px;/, "$1" + w + "px;")
            }
            if (props && typeof props.renderComplete === "function")
                chart.registerEvent(function() {
                    props.renderComplete.call(this, container)
                }, "renderComplete", "jquery_widget");
            fixSetURL(chart, container);
            chart.catchErrors = false;
            chart.draw(container);
            drawQueue(chart)
        }
        if (typeof ibx !== "undefined" && props && props.waitSpinnerContainer)
            ibx.waitStop(props.waitSpinnerContainer)
    }
    function getSize(container, props) {
        if (props && props.width != null && props.height != null)
            return {
                width: props.width,
                height: props.height
            };
        else if (container && container.clientWidth != null && container.clientHeight != null)
            return {
                width: container.clientWidth,
                height: container.clientHeight
            };
        return {
            width: 800,
            height: 600
        }
    }
    function drawError(chart, msg) {
        chart.set({
            legend: {
                visible: false
            },
            title: {
                visible: false
            },
            subtitle: {
                visible: false
            },
            footnote: {
                visible: false
            },
            errorMessage: msg,
            simpleLabelProperties: {
                font: "12pt arial",
                color: "darkred",
                align: "middle",
                valign: "middle"
            }
        })
    }
    function interceptClicks(e, chart, container, props) {
        if (!e || !e.target)
            return;
        var url;
        if (e.target.nodeName === "A" && e.target.hasAttribute("href"))
            url = e.target.getAttribute("href");
        else if (e.target.hasAttribute("onclick")) {
            var click = e.target.getAttribute("onclick");
            var match = click.match(/^window\.open\(['"](.*)['"],\s*['"]_self['"]\);?$/i);
            if (match && match.length > 1)
                url = match[1];
            else {
                match = click.match(/^tdgchart.__runReplaceUrl\(this,\s*['"](.*)['"]\);?$/);
                if (match && match.length > 1)
                    url = match[1]
            }
        }
        if (url) {
            e.preventDefault();
            e.stopPropagation();
            props = props || {};
            props.remoteDataURL = url;
            delete chart.destroy;
            loadRemoteChart(chart, container, props)
        }
    }
    tdgchart.initializeJQueryWidget = function() {
        if (typeof window !== "undefined" && window.jQuery && window.jQuery.fn && !window.jQuery.fn.tdgchart)
            window.jQuery.fn.tdgchart = function(props) {
                if (!this || !this[0])
                    return null;
                var div, container = this[0];
                if (typeof props === "string" && props.toLowerCase() === "destroy") {
                    if (container.chart)
                        container.chart.destroy();
                    return null
                }
                if (!props && !container.chart)
                    return null;
                var chart = container.chart || new tdgchart(props);
                container.chart = chart;
                if (!container.firstChild) {
                    div = document.createElement("div");
                    div.addEventListener("click", tdg.partial(interceptClicks, [null, chart, div, props]), true);
                    div.setAttribute("style", "width: 100%; height: 100%; overflow: hidden;");
                    div.setAttribute("id", container.getAttribute("id") + "__tdgWidgetContainer");
                    container.appendChild(div)
                }
                div = container.firstChild;
                tdg.dom.empty(div);
                if (typeof ibx !== "undefined") {
                    this.off("ibx_resize.tdgchart_widget").on("ibx_resize.tdgchart_widget", function(chart, div, props) {
                        return function() {
                            if (!chart.__isLoading)
                                sizeAndDrawChart(chart, div, props)
                        }
                    }(chart, div, props));
                    if (props && props.useWaitSpinner) {
                        props.waitSpinnerContainer = container;
                        ibx.waitStart(container, {
                            showProgress: false
                        })
                    }
                }
                if (chart.__isLoading) {
                    chart.__drawQueue = chart.__drawQueue || [];
                    chart.__drawQueue.push(tdg.partial(sizeAndDrawChart, [chart, div, props]))
                } else
                    sizeAndDrawChart(chart, div, props);
                return this
            }
    }
    ;
    tdgchart.initializeJQueryWidget()
}
)();
(function() {
    var tdg = tdgchart.util;
    var imageData = "<img alt='' src='data:image/gif;base64,R0lGODlhGAAYAPQAAP///wAAAM7Ozvr6+uDg4LCwsOjo6I6OjsjIyJycnNjY2KioqMDAwPLy8nZ2doaGhri4uGhoaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+GkNyZWF0ZWQgd2l0aCBhamF4bG9hZC5pbmZvACH5BAAHAAAAIf8LTkVUU0NBUEUyLjADAQAAACwAAAAAGAAYAAAFriAgjiQAQWVaDgr5POSgkoTDjFE0NoQ8iw8HQZQTDQjDn4jhSABhAAOhoTqSDg7qSUQwxEaEwwFhXHhHgzOA1xshxAnfTzotGRaHglJqkJcaVEqCgyoCBQkJBQKDDXQGDYaIioyOgYSXA36XIgYMBWRzXZoKBQUMmil0lgalLSIClgBpO0g+s26nUWddXyoEDIsACq5SsTMMDIECwUdJPw0Mzsu0qHYkw72bBmozIQAh+QQABwABACwAAAAAGAAYAAAFsCAgjiTAMGVaDgR5HKQwqKNxIKPjjFCk0KNXC6ATKSI7oAhxWIhezwhENTCQEoeGCdWIPEgzESGxEIgGBWstEW4QCGGAIJEoxGmGt5ZkgCRQQHkGd2CESoeIIwoMBQUMP4cNeQQGDYuNj4iSb5WJnmeGng0CDGaBlIQEJziHk3sABidDAHBgagButSKvAAoyuHuUYHgCkAZqebw0AgLBQyyzNKO3byNuoSS8x8OfwIchACH5BAAHAAIALAAAAAAYABgAAAW4ICCOJIAgZVoOBJkkpDKoo5EI43GMjNPSokXCINKJCI4HcCRIQEQvqIOhGhBHhUTDhGo4diOZyFAoKEQDxra2mAEgjghOpCgz3LTBIxJ5kgwMBShACREHZ1V4Kg1rS44pBAgMDAg/Sw0GBAQGDZGTlY+YmpyPpSQDiqYiDQoCliqZBqkGAgKIS5kEjQ21VwCyp76dBHiNvz+MR74AqSOdVwbQuo+abppo10ssjdkAnc0rf8vgl8YqIQAh+QQABwADACwAAAAAGAAYAAAFrCAgjiQgCGVaDgZZFCQxqKNRKGOSjMjR0qLXTyciHA7AkaLACMIAiwOC1iAxCrMToHHYjWQiA4NBEA0Q1RpWxHg4cMXxNDk4OBxNUkPAQAEXDgllKgMzQA1pSYopBgonCj9JEA8REQ8QjY+RQJOVl4ugoYssBJuMpYYjDQSliwasiQOwNakALKqsqbWvIohFm7V6rQAGP6+JQLlFg7KDQLKJrLjBKbvAor3IKiEAIfkEAAcABAAsAAAAABgAGAAABbUgII4koChlmhokw5DEoI4NQ4xFMQoJO4uuhignMiQWvxGBIQC+AJBEUyUcIRiyE6CR0CllW4HABxBURTUw4nC4FcWo5CDBRpQaCoF7VjgsyCUDYDMNZ0mHdwYEBAaGMwwHDg4HDA2KjI4qkJKUiJ6faJkiA4qAKQkRB3E0i6YpAw8RERAjA4tnBoMApCMQDhFTuySKoSKMJAq6rD4GzASiJYtgi6PUcs9Kew0xh7rNJMqIhYchACH5BAAHAAUALAAAAAAYABgAAAW0ICCOJEAQZZo2JIKQxqCOjWCMDDMqxT2LAgELkBMZCoXfyCBQiFwiRsGpku0EshNgUNAtrYPT0GQVNRBWwSKBMp98P24iISgNDAS4ipGA6JUpA2WAhDR4eWM/CAkHBwkIDYcGiTOLjY+FmZkNlCN3eUoLDmwlDW+AAwcODl5bYl8wCVYMDw5UWzBtnAANEQ8kBIM0oAAGPgcREIQnVloAChEOqARjzgAQEbczg8YkWJq8nSUhACH5BAAHAAYALAAAAAAYABgAAAWtICCOJGAYZZoOpKKQqDoORDMKwkgwtiwSBBYAJ2owGL5RgxBziQQMgkwoMkhNqAEDARPSaiMDFdDIiRSFQowMXE8Z6RdpYHWnEAWGPVkajPmARVZMPUkCBQkJBQINgwaFPoeJi4GVlQ2Qc3VJBQcLV0ptfAMJBwdcIl+FYjALQgimoGNWIhAQZA4HXSpLMQ8PIgkOSHxAQhERPw7ASTSFyCMMDqBTJL8tf3y2fCEAIfkEAAcABwAsAAAAABgAGAAABa8gII4k0DRlmg6kYZCoOg5EDBDEaAi2jLO3nEkgkMEIL4BLpBAkVy3hCTAQKGAznM0AFNFGBAbj2cA9jQixcGZAGgECBu/9HnTp+FGjjezJFAwFBQwKe2Z+KoCChHmNjVMqA21nKQwJEJRlbnUFCQlFXlpeCWcGBUACCwlrdw8RKGImBwktdyMQEQciB7oACwcIeA4RVwAODiIGvHQKERAjxyMIB5QlVSTLYLZ0sW8hACH5BAAHAAgALAAAAAAYABgAAAW0ICCOJNA0ZZoOpGGQrDoOBCoSxNgQsQzgMZyIlvOJdi+AS2SoyXrK4umWPM5wNiV0UDUIBNkdoepTfMkA7thIECiyRtUAGq8fm2O4jIBgMBA1eAZ6Knx+gHaJR4QwdCMKBxEJRggFDGgQEREPjjAMBQUKIwIRDhBDC2QNDDEKoEkDoiMHDigICGkJBS2dDA6TAAnAEAkCdQ8ORQcHTAkLcQQODLPMIgIJaCWxJMIkPIoAt3EhACH5BAAHAAkALAAAAAAYABgAAAWtICCOJNA0ZZoOpGGQrDoOBCoSxNgQsQzgMZyIlvOJdi+AS2SoyXrK4umWHM5wNiV0UN3xdLiqr+mENcWpM9TIbrsBkEck8oC0DQqBQGGIz+t3eXtob0ZTPgNrIwQJDgtGAgwCWSIMDg4HiiUIDAxFAAoODwxDBWINCEGdSTQkCQcoegADBaQ6MggHjwAFBZUFCm0HB0kJCUy9bAYHCCPGIwqmRq0jySMGmj6yRiEAIfkEAAcACgAsAAAAABgAGAAABbIgII4k0DRlmg6kYZCsOg4EKhLE2BCxDOAxnIiW84l2L4BLZKipBopW8XRLDkeCiAMyMvQAA+uON4JEIo+vqukkKQ6RhLHplVGN+LyKcXA4Dgx5DWwGDXx+gIKENnqNdzIDaiMECwcFRgQCCowiCAcHCZIlCgICVgSfCEMMnA0CXaU2YSQFoQAKUQMMqjoyAglcAAyBAAIMRUYLCUkFlybDeAYJryLNk6xGNCTQXY0juHghACH5BAAHAAsALAAAAAAYABgAAAWzICCOJNA0ZVoOAmkY5KCSSgSNBDE2hDyLjohClBMNij8RJHIQvZwEVOpIekRQJyJs5AMoHA+GMbE1lnm9EcPhOHRnhpwUl3AsknHDm5RN+v8qCAkHBwkIfw1xBAYNgoSGiIqMgJQifZUjBhAJYj95ewIJCQV7KYpzBAkLLQADCHOtOpY5PgNlAAykAEUsQ1wzCgWdCIdeArczBQVbDJ0NAqyeBb64nQAGArBTt8R8mLuyPyEAOwAAAAAAAAAAAA==' />";
    tdgchart.prototype.drawSpinner = function(x, y, placeholderDiv) {
        var chart = this;
        var root = document.getElementById(chart.documentRoot);
        tdg.dom.empty(root);
        var appendTo = root || placeholderDiv;
        var outerDiv = document.createElement("div");
        var w = chart.width > 0 ? chart.width - 2 + "px" : "100%";
        var h = chart.height > 0 ? chart.height - 2 + "px" : "100%";
        outerDiv.style.position = "relative";
        outerDiv.style.display = "table-cell";
        outerDiv.style.width = w;
        outerDiv.style.height = h;
        var innerDiv = document.createElement("div");
        innerDiv.style.position = "relative";
        innerDiv.innerHTML = imageData;
        outerDiv.appendChild(innerDiv);
        if (x > -1 && y > -1) {
            innerDiv.style.left = x + "px";
            innerDiv.style.top = y + "px"
        } else {
            outerDiv.style["vertical-align"] = "middle";
            outerDiv.style["text-align"] = "center"
        }
        appendTo.append(outerDiv)
    }
}
)();
if (typeof window !== "undefined" && typeof window.tdgLibraryLoadCallback === "function")
    window.tdgLibraryLoadCallback();
tdgchart.defaultProperties = {
    chartType: "bar",
    containerID: undefined,
    catchErrors: true,
    errorStatus: undefined,
    showVersion: false,
    showDebugString: false,
    validateProperties: false,
    drawTimeout: 0,
    dataSetLimits: {
        enabled: false,
        limits: {
            bla: 5E4,
            xy: 1E5,
            pie: 1E3,
            dataGrid: 5E4
        }
    },
    drawStaticChart: false,
    backend: "js",
    allowBackendFallback: false,
    width: 367,
    height: 260,
    transform: {
        scale: undefined,
        referenceSize: {
            width: undefined,
            height: undefined
        }
    },
    fill: {
        color: "white"
    },
    border: {
        width: 1,
        color: "black",
        dash: ""
    },
    chartFrame: {
        fill: {
            color: "transparent"
        },
        border: {
            width: 1,
            color: "transparent",
            dash: ""
        },
        proportions: undefined,
        shadow: false,
        leftedge: {
            fill: {
                color: "auto"
            }
        },
        bottomedge: {
            fill: {
                color: "auto"
            }
        }
    },
    errorMessage: undefined,
    introAnimation: {
        enabled: false,
        duration: 1400,
        animateOnce: false
    },
    morphAnimation: {
        duration: 1500,
        mode: undefined
    },
    interaction: {
        click: undefined,
        mousedrag: undefined,
        mousemove: "over",
        dblclick: undefined,
        touchDrag: "pan",
        longTouchDrag: "select"
    },
    truncation: {
        symbol: "..."
    },
    mouseOverIndicator: {
        enabled: true,
        overLegend: "series",
        color: undefined,
        border: {
            width: undefined,
            color: undefined,
            dash: ""
        },
        marker: {
            visible: undefined,
            color: "lightblue",
            size: 5,
            shape: "circle",
            rotation: 0,
            position: "top",
            border: {
                width: 1,
                color: "darkblue",
                dash: ""
            },
            tooltip: undefined
        }
    },
    data: [[.6, .8, .9], [1, .2, .3], [.65, .7, .25], [.3, .3, 1]],
    dataArrayMap: undefined,
    dataSubset: {
        startGroup: undefined,
        stopGroup: undefined
    },
    dataStream: {
        enabled: false,
        url: undefined,
        refreshTimeout: 1E3,
        useMorph: true
    },
    dataMerge: {
        mergePixelDistance: undefined
    },
    nullRepresentation: "",
    noDataMode: false,
    inPreviewMode: false,
    locale: undefined,
    serverProperties: {},
    autoNumberFormats: {
        dataLabels: "[<=-100000000000000]-#,,,,T;[<=-10000000000000]-#,,,,.#T;[<=-1000000000000]-#,,,,.##T;[<=-100000000000]-#,,,B;[<=-10000000000]-#,,,.#B;[<=-1000000000]-#,,,.##B;[<=-100000000]-#,,M;[<=-10000000]-#,,.#M;[<=-1000000]-#,,.##M;[<=-100000]-#,K;[<=-100]-#,#;[<=-10]-#.#;[<=-1]-#.##;[<0]-#.###;[=0]#;[<1]#.###;[<10]#.##;[<100]#.#;[<100000]#,#;[<1000000]#,K;[<10000000]#,,.##M;[<100000000]#,,.#M;[<1000000000]#,,M;[<10000000000]#,,,.##B;[<100000000000]#,,,.#B;[<1000000000000]#,,,B;[<10000000000000]#,,,,.##T;[<100000000000000]#,,,,.#T;[<1000000000000000]#,,,,T;#,,,,T",
        tooltip: "[<=-100000000000000]-#,,,,T;[<=-10000000000000]-#,,,,.#T;[<=-1000000000000]-#,,,,.##T;[<=-100000000000]-#,,,B;[<=-10000000000]-#,,,.#B;[<=-1000000000]-#,,,.##B;[<=-100000000]-#,,M;[<=-10000000]-#,,.#M;[<=-1000000]-#,,.##M;[<=-100000]-#,K;[<=-100]-#,#;[<=-10]-#.#;[<=-1]-#.##;[<0]-#.###;[=0]#;[<1]#.###;[<10]#.##;[<100]#.#;[<100000]#,#;[<1000000]#,K;[<10000000]#,,.##M;[<100000000]#,,.#M;[<1000000000]#,,M;[<10000000000]#,,,.##B;[<100000000000]#,,,.#B;[<1000000000000]#,,,B;[<10000000000000]#,,,,.##T;[<100000000000000]#,,,,.#T;[<1000000000000000]#,,,,T;#,,,,T",
        stackTotalLabel: "[<=-100000000000000]-#,,,,T;[<=-10000000000000]-#,,,,.#T;[<=-1000000000000]-#,,,,.##T;[<=-100000000000]-#,,,B;[<=-10000000000]-#,,,.#B;[<=-1000000000]-#,,,.##B;[<=-100000000]-#,,M;[<=-10000000]-#,,.#M;[<=-1000000]-#,,.##M;[<=-100000]-#,K;[<=-100]-#,#;[<=-10]-#.#;[<=-1]-#.##;[<0]-#.###;[=0]#;[<1]#.###;[<10]#.##;[<100]#.#;[<100000]#,#;[<1000000]#,K;[<10000000]#,,.##M;[<100000000]#,,.#M;[<1000000000]#,,M;[<10000000000]#,,,.##B;[<100000000000]#,,,.#B;[<1000000000000]#,,,B;[<10000000000000]#,,,,.##T;[<100000000000000]#,,,,.#T;[<1000000000000000]#,,,,T;#,,,,T",
        totalLabel: "[<=-100000000000000]-#,,,,T;[<=-10000000000000]-#,,,,.#T;[<=-1000000000000]-#,,,,.##T;[<=-100000000000]-#,,,B;[<=-10000000000]-#,,,.#B;[<=-1000000000]-#,,,.##B;[<=-100000000]-#,,M;[<=-10000000]-#,,.#M;[<=-1000000]-#,,.##M;[<=-100000]-#,K;[<=-100]-#,#;[<=-10]-#.#;[<=-1]-#.##;[<0]-#.###;[=0]#;[<1]#.###;[<10]#.##;[<100]#.#;[<100000]#,#;[<1000000]#,K;[<10000000]#,,.##M;[<100000000]#,,.#M;[<1000000000]#,,M;[<10000000000]#,,,.##B;[<100000000000]#,,,.#B;[<1000000000000]#,,,B;[<10000000000000]#,,,,.##T;[<100000000000000]#,,,,.#T;[<1000000000000000]#,,,,T;#,,,,T"
    },
    swapData: false,
    swapDataAndLabels: false,
    showNullGroups: true,
    showNullSeries: true,
    riserCycleEndLightness: .8,
    colorMode: {
        mode: "bySeries",
        colorList: undefined,
        data: undefined,
        posColor: "green",
        negColor: "red",
        neutralColor: "grey"
    },
    accessibility: {
        navigation: {
            enabled: false,
            mode: "cycleRisers",
            tabLimit: 100
        },
        title: undefined,
        description: undefined
    },
    labelPadding: {
        frame: {
            left: 5,
            right: 5,
            top: 5,
            bottom: 5
        },
        label: {
            left: 5,
            right: 5,
            top: 5,
            bottom: 5
        }
    },
    chartsPerRow: undefined,
    depth: undefined,
    riserDepthGap: .2,
    riserShadow: false,
    riserBevel: undefined,
    axisAutoLayout: {},
    bubbleMarker: {},
    blaProperties: {
        splitY: false,
        seriesLayout: "sideBySide",
        sort: undefined,
        orientation: "vertical",
        extendToFrameEdge: false,
        lineConnection: undefined,
        missingDataMode: undefined,
        missingDataExtrapolate: true,
        missingDataLineStyle: {
            width: 1,
            color: undefined,
            dash: "8 4"
        },
        barEffect: undefined,
        lineFillEffect: undefined,
        areaFillEffect: undefined,
        barGroupGapWidth: .2,
        absoluteInset: .7,
        stackTotalLabel: {
            visible: false,
            font: "9pt Sans-Serif",
            color: "black",
            numberFormat: "auto",
            displayZero: false,
            rotation: 0
        },
        comboCharts: {
            barSeriesLayout: undefined,
            lineSeriesLayout: undefined,
            areaSeriesLayout: undefined
        }
    },
    controlProperties: {
        mode: "i",
        defaultStabilityMarker: {
            color: "red",
            shape: "diamond",
            size: 10
        },
        stabilityRules: []
    },
    pieProperties: {
        multiRing: false,
        groupPiesBySelection: false,
        holeSize: 0,
        rotation: 0,
        skew: 0,
        label: {
            visible: true,
            font: "9pt Sans-Serif",
            color: "black"
        },
        totalLabel: {
            visible: "auto",
            content: "auto",
            font: "9pt Sans-Serif",
            fontSize: undefined,
            color: "black",
            numberFormat: "auto"
        },
        otherSlice: {
            threshold: undefined,
            legendLabel: "Other",
            color: "grey",
            border: {
                width: 2,
                color: "black",
                dash: ""
            },
            showDataValues: true,
            marker: {
                shape: "square",
                border: {
                    width: 0,
                    color: "transparent",
                    dash: ""
                }
            }
        },
        zeroStyle: {
            color: "transparent",
            border: {
                color: "black",
                width: 1,
                dash: ""
            }
        },
        explodeClick: {
            enabled: false,
            duration: 700,
            distance: 25,
            limitExplodeCount: false
        },
        sort: undefined,
        effect: undefined,
        feelerLine: {}
    },
    threedProperties: {
        rotate: 30,
        tilt: 30,
        shadeSides: true
    },
    gaugeProperties: {
        startAngle: 135,
        endAngle: 45,
        secondaryNeedlesAsMarkers: false,
        secondaryRingFillColor: undefined,
        layout: "gauge",
        groupLabel: {
            visible: true,
            font: "9pt Sans-Serif",
            color: "black",
            position: "bottom"
        },
        totalLabel: {
            visible: true,
            content: "auto",
            font: "10pt Sans-Serif",
            fontSize: undefined,
            color: "black",
            numberFormat: "auto"
        },
        fill: {
            color: "transparent"
        },
        needleBase: {
            size: "6%",
            color: "#1f77b4",
            border: {
                width: 0,
                color: "transparent",
                dash: ""
            }
        },
        axisWidth: "30%",
        axisTickLength: "15%",
        axisMinorTickLength: "8%",
        outerBorder: {
            width: "10%",
            shape: "circle",
            fill: {
                color: "#1f77b4"
            },
            border: {
                width: 0,
                color: "transparent",
                dash: ""
            }
        }
    },
    funnelProperties: {
        topWidth: "100%",
        baseWidth: "20%",
        riserGap: 0,
        groupLabel: {
            visible: true,
            font: "9pt Sans-Serif",
            color: "black"
        }
    },
    waterfallProperties: {
        appendTotalRiser: true,
        totalLabel: "Total",
        positiveRiserColor: "#77b39a",
        negativeRiserColor: "#e2675b",
        zeroRiserColor: "#7593bd",
        totalRiserColor: "#7593bd",
        otherRiserColor: "#aaaaaa",
        subtotalRisers: [],
        otherRisers: [],
        subtotalFormat: {
            bold: undefined,
            color: undefined,
            numberFormat: undefined,
            dataLabelPosition: undefined,
            dividerLine: {
                width: 0,
                color: "black",
                dash: ""
            }
        },
        firstLastFormat: {
            color: undefined,
            border: {
                width: 0,
                color: undefined,
                dash: ""
            }
        },
        connectorLine: {
            width: 1,
            color: "black",
            dash: ""
        }
    },
    boxPlotProperties: {
        hatWidth: "50%",
        drawHatAsBox: false,
        notch: {
            width: undefined,
            multiplier: 1.58
        },
        medianLine: {
            width: 1,
            color: "black",
            dash: ""
        },
        connectorLine: {
            width: 1,
            color: "black",
            dash: ""
        },
        meanMarker: {
            visible: false,
            color: "orange",
            border: {
                width: 1,
                color: undefined,
                dash: undefined
            },
            size: 8,
            shape: "circle",
            rotation: 0,
            tooltip: undefined
        }
    },
    histogramProperties: {
        binCount: undefined,
        binSize: undefined,
        startBinValue: undefined,
        minThreshold: undefined,
        maxThreshold: undefined
    },
    stockProperties: {
        startTime: undefined,
        stopTime: undefined,
        interval: undefined,
        labelFormat: undefined,
        upRiserColor: "#77b39a",
        downRiserColor: "#e2675b",
        hiLowLine: {
            width: 1,
            color: undefined,
            dash: ""
        }
    },
    ganttProperties: {
        startTime: undefined,
        stopTime: undefined,
        interval: undefined,
        labelFormat: undefined,
        durationValues: false,
        staggerRisers: true
    },
    polarProperties: {
        straightGridLines: false,
        extrudeAxisLabels: false,
        drawAsArea: false
    },
    treemapProperties: {
        scaleCellFonts: false,
        internalLabelSeparator: "-",
        header: {
            height: undefined,
            fill: "lightgrey",
            border: {
                width: 0,
                color: "lightgrey",
                dash: ""
            },
            label: {
                visible: true,
                font: "8pt Sans-Serif",
                color: "black"
            },
            tooltip: "auto"
        },
        cellBorder: {
            width: 1,
            color: "white",
            dash: "",
            outerCellWidth: 3
        }
    },
    mapProperties: {
        map: undefined,
        mapPath: undefined,
        antiAlias: true,
        mapOpacity: .82,
        landmarks: {
            visible: false,
            maxCount: 20,
            marker: {
                visible: undefined,
                color: "transparent",
                size: 3,
                shape: "circle",
                rotation: 0,
                position: "top",
                border: {
                    width: 1,
                    color: "grey",
                    dash: ""
                },
                tooltip: undefined
            },
            label: {
                visible: true,
                font: "8pt Sans-Serif",
                color: "grey"
            }
        },
        region: {
            color: "#ddd",
            border: {
                width: .3,
                color: "grey",
                dash: ""
            }
        },
        secondaryRegion: {
            color: "transparent",
            border: {
                width: .6,
                color: "brown",
                dash: ""
            }
        },
        viewBox: {
            left: "auto",
            right: "auto",
            top: "auto",
            bottom: "auto"
        },
        markerType: "choropleth",
        geocode: {
            type: undefined,
            geocode: undefined,
            exact: false
        },
        engine: "leaflet",
        leaflet: {
            layerControl: {
                visible: false,
                position: "bottomright",
                collapsed: true,
                autoZIndex: true
            },
            initPos: {
                center: [0, 0],
                level: 1
            },
            baselayers: undefined,
            overlayLayers: undefined,
            unmatchedLabel: "Unknown",
            controls: [{
                control: "L.Control.Layers"
            }, {
                control: "L.Control.Scale",
                options: {
                    imperial: true,
                    metric: true
                }
            }]
        }
    },
    bulletProperties: {
        drawFirstValueAsBar: true
    },
    simpleLabelProperties: {
        text: undefined,
        align: "left",
        valign: "top",
        font: "bold 10pt Sans-Serif",
        color: "black"
    },
    tagcloudProperties: {
        maxNumberOfTags: 50,
        font: "bold 12pt Georgia",
        engine: undefined
    },
    paraboxProperties: {
        activeGroup: undefined,
        bubbleRadius: undefined,
        border: {
            width: undefined
        }
    },
    matrixProperties: {
        chartType: "bar",
        rowLabels: {
            labels: undefined,
            font: "8pt Sans-Serif",
            color: "black",
            align: "left",
            valign: undefined,
            tooltip: undefined,
            swapChartSide: undefined,
            rotation: undefined
        },
        colLabels: {
            labels: undefined,
            font: "8pt Sans-Serif",
            wrap: 1,
            color: "black",
            tooltip: undefined,
            swapChartSide: undefined,
            rotation: undefined
        },
        rowHeader: {
            text: undefined,
            separator: " : ",
            font: "10pt Sans-Serif",
            color: "black",
            tooltip: undefined,
            alignColumns: undefined
        },
        colHeader: {
            text: undefined,
            font: "10pt Sans-Serif",
            color: "black",
            tooltip: undefined
        },
        cellBorder: {
            width: 1,
            color: "grey",
            dash: ""
        },
        layout: {
            cellPadding: {
                top: undefined,
                right: undefined,
                bottom: undefined,
                left: undefined
            }
        },
        minCellSize: "auto",
        colWrapCount: undefined
    },
    dataGridProperties: {
        altRowFill: undefined,
        cell: {
            layout: {
                width: {
                    rule: "maxSize",
                    value: 300
                },
                height: {
                    rule: "maxSize",
                    value: 500
                },
                cellPadding: {
                    left: 5,
                    top: 5,
                    right: 5,
                    bottom: 5
                }
            },
            innerGridLines: {
                horizontal: {
                    width: 1,
                    color: "#E0E0E0",
                    dash: ""
                },
                vertical: {
                    width: 1,
                    color: "#EEEEEE",
                    dash: ""
                }
            },
            labels: {
                font: "10pt Sans-Serif",
                color: "rgb(20, 20, 20)",
                numberFormat: "auto",
                align: "right",
                valign: "top"
            },
            tooltip: undefined,
            formatList: []
        },
        rowHeader: {
            fill: "#FAFAFA",
            border: {
                width: 1,
                color: "#D0D0D0",
                dash: ""
            },
            innerGridLines: {
                horizontal: {
                    width: 1,
                    color: "#D8D8D8",
                    dash: ""
                },
                vertical: {
                    width: 1,
                    color: "#E0E0E0",
                    dash: ""
                }
            },
            dividerLine: {
                width: 1,
                color: "#D0D0D0",
                dash: ""
            },
            title: {
                text: [],
                font: "bold 10pt Sans-Serif",
                color: "rgb(20, 20, 20)",
                align: "left",
                valign: "top",
                tooltip: undefined,
                dividerLine: {
                    width: 1,
                    color: "#D0D0D0",
                    dash: ""
                }
            },
            labels: {
                font: "10pt Sans-Serif",
                color: "rgb(20, 20, 20)",
                align: "left",
                valign: "top",
                wrap: 1,
                mergeMatching: true,
                content: []
            }
        },
        colHeader: {
            sorting: {
                enabled: false,
                icon: {
                    size: 10,
                    selectedColor: "rgb(51, 51, 51)",
                    unSelectedColor: "rgba(51, 51, 51, 0.5)",
                    borderWidth: 1
                }
            },
            resize: {
                enabled: false
            },
            fill: "#FAFAFA",
            border: {
                width: 1,
                color: "#D0D0D0",
                dash: ""
            },
            innerGridLines: {
                horizontal: {
                    width: 1,
                    color: "#E0E0E0",
                    dash: ""
                },
                vertical: {
                    width: 1,
                    color: "#ECECEC",
                    dash: ""
                }
            },
            dividerLine: {
                width: 1,
                color: "#D0D0D0",
                dash: ""
            },
            title: {
                text: [],
                font: "bold 10pt Sans-Serif",
                color: "rgb(20, 20, 20)",
                align: "right",
                valign: "top",
                tooltip: undefined,
                dividerLine: {
                    width: 1,
                    color: "#EEEEEE",
                    dash: ""
                }
            },
            labels: {
                font: "10pt Sans-Serif",
                color: "rgb(20, 20, 20)",
                align: "center",
                valign: "top",
                mergeMatching: true,
                content: []
            },
            lastLabels: {
                font: "bold 10pt Sans-Serif",
                color: "rgb(20, 20, 20)",
                align: "right",
                valign: "center"
            }
        },
        columnTotals: {
            visible: false,
            calculation: "sum",
            headerLabel: {
                text: undefined,
                font: "bold 10pt Sans-Serif",
                color: "rgb(20, 20, 20)",
                align: "left",
                valign: "center"
            },
            cellLabel: {
                font: "bold 10pt Sans-Serif",
                color: "rgb(20, 20, 20)",
                align: "right",
                valign: "top"
            },
            border: {
                width: 1,
                color: "#D0D0D0",
                dash: ""
            },
            dividerLine: {
                width: 2,
                color: "#D0D0D0",
                dash: ""
            }
        },
        scroll: {
            enabled: true,
            freezeRowHeader: true,
            freezeColHeader: true,
            size: 15,
            color: "rgb(240, 240, 240)",
            handle: {
                color: "#C2C2C2",
                hoverColor: "#A8A8A8",
                border: {
                    width: 0,
                    color: "transparent",
                    dash: ""
                }
            }
        }
    },
    pictogramProperties: {
        fillMode: "repeatClip",
        backFill: undefined,
        lockToGrid: false
    },
    legend: {
        visible: "auto",
        position: "right",
        maxSize: "50%",
        fixedSize: undefined,
        fixedSizeAlign: "outside",
        orientation: "auto",
        align: undefined,
        xy: {},
        reverseOrder: false,
        markerSize: 10,
        markerPosition: "left",
        matchSeriesMarkers: false,
        maxEntries: undefined,
        title: {
            visible: false,
            text: "",
            font: "9pt Sans-Serif",
            color: "black",
            tooltip: undefined,
            wrap: 1
        },
        labels: {
            font: "9pt Sans-Serif",
            color: "black",
            tooltip: undefined,
            wrap: 1,
            content: undefined
        },
        lineStyle: {
            width: 1,
            color: "transparent",
            dash: ""
        },
        backgroundcolor: "transparent",
        shadow: false,
        scroll: {
            enabled: false,
            size: 15,
            color: "rgb(240, 240, 240)",
            handle: {
                color: "grey",
                hoverColor: "rgb(88, 88, 88)",
                border: {
                    width: 0,
                    color: "transparent",
                    dash: ""
                }
            }
        },
        dock: {
            enabled: false,
            animate: true,
            minimized: false,
            resizeFrame: true,
            showMarkers: true,
            expandDirection: undefined,
            button: {
                size: "auto",
                color: "grey",
                hoverColor: "black",
                border: {
                    width: 0,
                    color: "transparent",
                    dash: ""
                }
            }
        },
        sizeLegend: {
            layout: "circle",
            lineStyle: {
                width: 0,
                color: "black",
                dash: ""
            }
        },
        labelMarkerPad: undefined,
        labelLabelPad: undefined
    },
    title: {
        text: "Chart Title",
        visible: false,
        align: "center",
        font: "bold 10pt Sans-Serif",
        color: "black",
        backgroundColor: undefined,
        border: {
            width: 0,
            color: "transparent",
            dash: "",
            cornerRadius: 0
        },
        tooltip: undefined,
        wrap: "auto"
    },
    subtitle: {
        text: "Chart Subtitle",
        visible: false,
        align: "center",
        font: "10pt Sans-Serif",
        color: "black",
        backgroundColor: undefined,
        border: {
            width: 0,
            color: "transparent",
            dash: "",
            cornerRadius: 0
        },
        tooltip: undefined,
        wrap: "auto"
    },
    footnote: {
        text: "Chart Footnote",
        visible: false,
        align: "center",
        font: "10pt Sans-Serif",
        color: "black",
        backgroundColor: undefined,
        border: {
            width: 0,
            color: "transparent",
            dash: "",
            cornerRadius: 0
        },
        tooltip: undefined,
        wrap: "auto"
    },
    dataPageSlider: {
        enabled: false,
        startPage: undefined,
        endPage: undefined,
        currentPage: 0,
        discrete: true,
        labels: [],
        animateButton: {
            enabled: true,
            delay: 1E3
        }
    },
    narrativeText: {
        enabled: false,
        hideChart: false,
        position: "top",
        maxSize: "20%",
        url: "",
        requestKey: "",
        user: "",
        password: "",
        content: undefined,
        label: {
            font: "11pt Sans-Serif",
            color: "black",
            align: "left"
        },
        backgroundColor: undefined,
        border: {
            width: 0,
            color: "black",
            dash: ""
        },
        dockButton: {
            enabled: false,
            animationDelay: 300,
            size: undefined,
            color: "rgb(50, 50, 50)",
            hoverColor: "black"
        },
        voiceTextButton: {
            enabled: false,
            voiceTextProperties: {}
        },
        textGenerationAPI: {}
    },
    htmlToolTip: {
        enabled: true,
        mouseMargin: 10,
        autoTitleFont: "bold 9pt Sans-Serif",
        autoContentFont: "8pt Sans-Serif",
        snap: false,
        sticky: "auto",
        hideTimeout: {
            time: 1200,
            clickable: 3600,
            touch: 3600,
            touchClickable: 6E3
        },
        fill: "linear-gradient(to bottom, rgba(250,250,250,0.98) 8%,rgba(230,230,230,0.98) 95%)",
        border: {
            width: 1,
            color: "rgba(150,150,150,0.95)",
            cornerRadius: 0
        },
        cascadeMenuStyle: {
            label: {
                font: undefined,
                color: undefined
            },
            nameValue: {
                name: {
                    font: "9pt sans-serif",
                    color: "#505050"
                },
                value: {
                    font: "bold 9pt sans-serif",
                    color: "black"
                }
            },
            hover: {
                fill: "rgba(220,220,220,0.9)",
                labelColor: "black"
            }
        },
        style: {
            cursor: "default",
            boxShadow: "0px 3px 4px 0px rgba(50, 50, 50, 0.66)",
            filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr='#FAFAFA', endColorstr='#D2D2D2',GradientType=0)"
        },
        containerNode: undefined
    },
    xaxis: {
        mode: undefined,
        min: undefined,
        max: undefined,
        rawMin: undefined,
        rawMax: undefined,
        intervalMode: undefined,
        intervalValue: undefined,
        mustIncludeZero: undefined,
        headroom: 1.05,
        globalAxisHeadroom: 1.1,
        inset: "auto",
        position: undefined,
        bIsLog: false,
        numberFormat: "auto",
        swapChartSide: false,
        invert: false,
        absValues: undefined,
        centerGroupLabels: true,
        altFrameColor: undefined,
        altFrameColor1: undefined,
        colorBands: undefined,
        marker: {},
        title: {
            text: "",
            visible: false,
            font: "bold 9pt Sans-Serif",
            color: "black",
            tooltip: undefined,
            position: "parallel"
        },
        labels: {
            visible: true,
            font: "9pt Sans-Serif",
            color: "black",
            excludeMin: false,
            excludeMax: "auto",
            replaceMin: undefined,
            replaceMax: undefined,
            rotation: "auto",
            tooltip: undefined,
            nestingConcatSymbol: undefined,
            nestingLineStyle: {
                width: 1,
                color: "black",
                dash: ""
            },
            pad: undefined,
            align: undefined
        },
        labelLayout: {
            stagger: "auto",
            skip: "auto",
            scroll: false,
            truncate: "auto",
            spaceLimit: undefined
        },
        baseLineValue: undefined,
        baseLineStyle: {
            width: 0,
            color: "black",
            dash: ""
        },
        bodyLineStyle: {
            width: 1,
            color: "transparent",
            dash: ""
        },
        majorGrid: {
            visible: true,
            aboveRisers: false,
            lockToY1: false,
            lineStyle: {
                width: 1,
                color: "black",
                dash: ""
            },
            ticks: {
                length: 5,
                visible: true,
                style: "outer",
                lineStyle: {
                    width: 1,
                    color: "black"
                }
            }
        },
        minorGrid: {
            visible: false,
            count: undefined,
            lineStyle: {
                width: 1,
                color: "black",
                dash: ""
            },
            ticks: {
                length: 5,
                visible: false,
                style: "inner",
                lineStyle: {
                    width: 1,
                    color: "black"
                }
            }
        },
        timeAxis: {
            enabled: false,
            startTime: undefined,
            stopTime: undefined,
            interval: undefined,
            stepSize: undefined,
            labelFormat: undefined,
            tooltipFormat: undefined,
            dataAggregation: {
                enabled: false,
                interval: "auto",
                round: undefined,
                method: "average",
                runningRange: undefined
            }
        },
        colorScale: {},
        sort: undefined,
        groupFit: {
            rule: "auto",
            value: undefined
        },
        scroll: {
            enabled: false,
            style: "simple",
            groups: {},
            miniChartProperties: {},
            intervalButtons: [],
            initialPosition: undefined
        }
    },
    yaxis: {
        mode: undefined,
        min: undefined,
        max: undefined,
        rawMin: undefined,
        rawMax: undefined,
        intervalMode: undefined,
        intervalValue: undefined,
        mustIncludeZero: undefined,
        headroom: 1.05,
        globalAxisHeadroom: 1.1,
        inset: "auto",
        position: undefined,
        bIsLog: false,
        numberFormat: "auto",
        swapChartSide: false,
        invert: false,
        absValues: undefined,
        centerGroupLabels: true,
        altFrameColor: undefined,
        altFrameColor1: undefined,
        colorBands: undefined,
        marker: {},
        title: {
            text: "",
            visible: false,
            font: "bold 9pt Sans-Serif",
            color: "black",
            tooltip: undefined,
            position: "parallel"
        },
        labels: {
            visible: true,
            font: "9pt Sans-Serif",
            color: "black",
            excludeMin: false,
            excludeMax: "auto",
            replaceMin: undefined,
            replaceMax: undefined,
            rotation: "auto",
            tooltip: undefined,
            nestingConcatSymbol: undefined,
            nestingLineStyle: {
                width: 1,
                color: "black",
                dash: ""
            },
            pad: undefined
        },
        labelLayout: {
            stagger: "auto",
            skip: "auto",
            scroll: false,
            truncate: "auto",
            spaceLimit: undefined
        },
        baseLineValue: undefined,
        baseLineStyle: {
            width: 1,
            color: "black",
            dash: ""
        },
        bodyLineStyle: {
            width: 1,
            color: "transparent",
            dash: ""
        },
        majorGrid: {
            visible: true,
            aboveRisers: false,
            lockToY1: false,
            lineStyle: {
                width: 1,
                color: "black",
                dash: ""
            },
            ticks: {
                length: 5,
                visible: true,
                style: "inner",
                lineStyle: {
                    width: 1,
                    color: "black"
                }
            }
        },
        minorGrid: {
            visible: false,
            count: undefined,
            lineStyle: {
                width: 1,
                color: "black",
                dash: ""
            },
            ticks: {
                length: 5,
                visible: false,
                style: "inner",
                lineStyle: {
                    width: 1,
                    color: "black"
                }
            }
        },
        timeAxis: {
            enabled: false,
            startTime: undefined,
            stopTime: undefined,
            interval: undefined,
            stepSize: undefined,
            labelFormat: undefined,
            tooltipFormat: undefined,
            dataAggregation: {
                enabled: false,
                interval: "auto",
                round: undefined,
                method: "average",
                runningRange: undefined
            }
        },
        colorScale: {},
        sort: undefined,
        groupFit: {
            rule: "auto",
            value: undefined
        },
        scroll: {
            enabled: false,
            style: "simple",
            groups: {},
            miniChartProperties: {},
            intervalButtons: []
        }
    },
    y2axis: {
        mode: undefined,
        min: undefined,
        max: undefined,
        rawMin: undefined,
        rawMax: undefined,
        intervalMode: undefined,
        intervalValue: undefined,
        mustIncludeZero: undefined,
        headroom: 1.05,
        globalAxisHeadroom: 1.1,
        inset: "auto",
        position: undefined,
        bIsLog: false,
        numberFormat: "auto",
        swapChartSide: false,
        invert: false,
        absValues: undefined,
        centerGroupLabels: true,
        altFrameColor: undefined,
        altFrameColor1: undefined,
        colorBands: undefined,
        marker: {},
        title: {
            text: "",
            visible: false,
            font: "bold 9pt Sans-Serif",
            color: "black",
            tooltip: undefined,
            position: "parallel"
        },
        labels: {
            visible: true,
            font: "9pt Sans-Serif",
            color: "black",
            excludeMin: false,
            excludeMax: false,
            replaceMin: undefined,
            replaceMax: undefined,
            rotation: "auto",
            tooltip: undefined,
            nestingConcatSymbol: undefined,
            nestingLineStyle: {
                width: 1,
                color: "black",
                dash: ""
            },
            pad: undefined
        },
        labelLayout: {
            stagger: "auto",
            skip: "auto",
            scroll: false,
            truncate: "auto",
            spaceLimit: undefined
        },
        baseLineValue: undefined,
        baseLineStyle: {
            width: 1,
            color: "black",
            dash: ""
        },
        bodyLineStyle: {
            width: 1,
            color: "transparent",
            dash: ""
        },
        majorGrid: {
            visible: true,
            aboveRisers: false,
            lockToY1: false,
            lineStyle: {
                width: 1,
                color: "black",
                dash: ""
            },
            ticks: {
                length: 5,
                visible: true,
                style: "inner",
                lineStyle: {
                    width: 1,
                    color: "black"
                }
            }
        },
        minorGrid: {
            visible: false,
            count: undefined,
            lineStyle: {
                width: 1,
                color: "black",
                dash: ""
            },
            ticks: {
                length: 5,
                visible: false,
                style: "inner",
                lineStyle: {
                    width: 1,
                    color: "black"
                }
            }
        },
        timeAxis: {
            enabled: false,
            startTime: undefined,
            stopTime: undefined,
            interval: undefined,
            stepSize: undefined,
            labelFormat: undefined,
            tooltipFormat: undefined,
            dataAggregation: {
                enabled: false,
                interval: "auto",
                round: undefined,
                method: "average",
                runningRange: undefined
            }
        },
        colorScale: {},
        sort: undefined,
        groupFit: {
            rule: "auto",
            value: undefined
        },
        scroll: {
            enabled: false,
            style: "simple",
            groups: {},
            miniChartProperties: {},
            intervalButtons: []
        }
    },
    zaxis: {
        mode: undefined,
        min: "min",
        max: "max",
        rawMin: undefined,
        rawMax: undefined,
        intervalMode: undefined,
        intervalValue: undefined,
        mustIncludeZero: undefined,
        headroom: 1.05,
        globalAxisHeadroom: 1.1,
        inset: "auto",
        position: undefined,
        bIsLog: false,
        numberFormat: "auto",
        swapChartSide: false,
        invert: false,
        absValues: undefined,
        centerGroupLabels: true,
        altFrameColor: undefined,
        altFrameColor1: undefined,
        colorBands: undefined,
        marker: {
            minSize: 2,
            maxSize: "25%"
        },
        title: {
            text: "Z Axis Title",
            visible: false,
            font: "bold 9pt Sans-Serif",
            color: "black",
            tooltip: undefined,
            position: "parallel"
        },
        labels: {
            visible: true,
            font: "9pt Sans-Serif",
            color: "black",
            excludeMin: false,
            excludeMax: false,
            replaceMin: undefined,
            replaceMax: undefined,
            rotation: "auto",
            tooltip: undefined,
            nestingConcatSymbol: undefined,
            nestingLineStyle: {
                width: 1,
                color: "black",
                dash: ""
            },
            pad: undefined
        },
        labelLayout: {
            stagger: "auto",
            skip: "auto",
            scroll: false,
            truncate: "auto",
            spaceLimit: undefined
        },
        baseLineValue: undefined,
        baseLineStyle: {
            width: 1,
            color: "black",
            dash: ""
        },
        bodyLineStyle: {
            width: 1,
            color: "transparent",
            dash: ""
        },
        majorGrid: {
            visible: true,
            aboveRisers: false,
            lockToY1: false,
            lineStyle: {
                width: 1,
                color: "black",
                dash: ""
            },
            ticks: {
                length: 5,
                visible: true,
                style: "outer",
                lineStyle: {
                    width: 1,
                    color: "black"
                }
            }
        },
        minorGrid: {
            visible: false,
            count: undefined,
            lineStyle: {
                width: 1,
                color: "black",
                dash: ""
            },
            ticks: {
                length: 5,
                visible: false,
                style: "inner",
                lineStyle: {
                    width: 1,
                    color: "black"
                }
            }
        },
        timeAxis: {
            enabled: false,
            startTime: undefined,
            stopTime: undefined,
            interval: undefined,
            stepSize: undefined,
            labelFormat: undefined,
            tooltipFormat: undefined,
            dataAggregation: {
                enabled: false,
                interval: "auto",
                round: undefined,
                method: "average",
                runningRange: undefined
            }
        },
        colorScale: {},
        sort: undefined,
        groupFit: {
            rule: "auto",
            value: undefined
        },
        scroll: {
            enabled: false,
            style: "simple",
            groups: {},
            miniChartProperties: {},
            intervalButtons: []
        }
    },
    axisList: {},
    colorScale: {
        colors: ["#FFFFCC", "#A1DAB4", "#41B6C4", "#2C7FB8", "#253494"],
        min: "min",
        max: "max",
        rawMin: undefined,
        rawMax: undefined,
        colorMode: "continuous",
        colorBands: undefined,
        headroom: 1,
        mustIncludeZero: undefined,
        bIsLog: false,
        numberFormat: "auto",
        swapChartSide: false,
        invert: false,
        title: {
            text: "Color Axis Title",
            visible: false,
            font: "7.5pt Sans-Serif",
            color: "black",
            wrap: 1
        },
        labels: {
            visible: true,
            font: "7.5pt Sans-Serif",
            color: "black",
            excludeMin: false,
            excludeMax: false
        },
        binMarkers: {
            visible: true,
            concatSymbol: " ... ",
            size: 8,
            shape: "square",
            rotation: 0,
            position: "left",
            border: {
                width: 1,
                color: "black",
                dash: ""
            }
        },
        baseLineValue: undefined,
        baseLineStyle: {
            width: 1,
            color: "black",
            dash: ""
        },
        bodyLineStyle: {
            width: 1,
            color: "transparent",
            dash: ""
        },
        majorGrid: {
            visible: true,
            aboveRisers: true,
            lineStyle: {
                width: 1,
                color: "black",
                dash: ""
            },
            ticks: {
                length: 5,
                visible: true,
                style: "inner",
                lineStyle: {
                    width: 1,
                    color: "black"
                }
            }
        },
        minorGrid: {
            visible: false,
            count: undefined,
            lineStyle: {
                width: 1,
                color: "black",
                dash: ""
            },
            ticks: {
                length: 5,
                visible: false,
                style: "inner",
                lineStyle: {
                    width: 1,
                    color: "black"
                }
            }
        }
    },
    splitNumericAxis: {
        splitX: {
            enabled: false,
            axisGap: .1,
            dividerLine: {
                width: 1,
                color: "black",
                dash: ""
            }
        },
        splitY: {
            enabled: false,
            axisGap: .1,
            dividerLine: {
                width: 1,
                color: "black",
                dash: ""
            }
        }
    },
    errorBars: {
        yData: undefined,
        xData: undefined,
        hatWidth: "50%",
        line: {
            color: "black",
            width: 1,
            dash: ""
        },
        marker: {
            visible: undefined,
            color: "grey",
            size: undefined,
            shape: "diamond",
            position: undefined,
            rotation: 0,
            border: {
                width: 1,
                color: "black",
                dash: ""
            },
            tooltip: undefined
        }
    },
    trendline: {
        enabled: false,
        mode: "linear",
        order: 3,
        line: {},
        lineStyle: {
            width: 1,
            color: "black",
            dash: ""
        },
        equationLabel: {
            visible: false,
            content: "auto",
            highOrderFirst: true,
            font: "8pt Sans-Serif",
            color: "black",
            mode: "equation"
        }
    },
    referenceLines: [],
    dataLabels: {
        feelerLine: {}
    },
    dataSelection: {
        enabled: false,
        selectionMode: ["click", "ctrlClick", "dragRect"],
        selectedColor: undefined,
        selectedBorder: {
            width: 0,
            color: "transparent",
            dash: ""
        },
        selectRelatedObjects: false,
        unselectedColor: "grey",
        unselectedBorder: {
            width: 0,
            color: "transparent",
            dash: ""
        },
        selectionRect: {
            fill: "rgba(120, 120, 120, 0.6)",
            border: {
                width: 0,
                color: "black",
                dash: ""
            }
        },
        eventCallback: undefined,
        customCallback: undefined,
        linkedCharts: []
    },
    previewSelection: {
        enabled: false,
        selectionMode: ["click"],
        selectRelatedObjects: false,
        selectedColor: "rgba(100, 100, 100, 0.4)",
        selectedBorder: {
            width: 2,
            color: "rgba(0, 0, 0, 0.6)",
            dash: "5 0"
        },
        clearBackgroundSelectOnNextSelect: true,
        eventCallback: undefined
    },
    globalSelection: {
        enabled: false,
        eventCallback: undefined,
        type: undefined,
        url: undefined
    },
    eventDispatcher: {
        events: []
    },
    markerShapeList: ["circle", "square", "diamond", "plus", "cross", "hexagon", "triangle", "fivestar", "ring", "arrowslim", "arrowslimdouble"],
    groupLabels: ["Group 0", "Group 1", "Group 2", "Group 3", "Group 4", "Group 5", "Group 6", "Group 7", "Group 8", "Group 9", "Group 10"],
    series: [{
        series: "all",
        border: {
            width: 2
        },
        marker: {
            visible: true,
            size: 5,
            shape: "circle",
            border: {
                width: 1,
                color: "transparent"
            }
        },
        dataLabels: {
            visible: "auto",
            dataLabelMask: undefined,
            content: "auto",
            position: "top",
            positionMode: undefined,
            rotation: 0,
            font: "9pt Sans-Serif",
            numberFormat: "auto",
            color: "black",
            useNegativeColor: false,
            negativeColor: "red",
            clipToContainer: true,
            displayZero: true,
            feelerLine: {
                width: 1,
                color: "black",
                dash: ""
            }
        }
    }, {
        series: 0,
        color: "red"
    }, {
        series: 1,
        color: "green"
    }, {
        series: 2,
        color: "orange"
    }],
    annotations: [],
    defaultShadow: {
        angle: 315,
        distance: 10,
        blur: 0
    },
    defaultColorStop: {
        start: "0%",
        stop: "100%",
        color: "transparent"
    },
    defaultReferenceLine: {
        elementUsed: false,
        value: undefined,
        axis: undefined,
        bottom: "axisLine",
        ordinalAlign: "center",
        aboveRisers: true,
        line: {
            color: "black",
            width: 1,
            dash: ""
        },
        label: {
            text: "",
            font: "7.5pt Sans-Serif",
            color: "black"
        },
        anchor: "start",
        showValue: false
    },
    defaultSeries: {
        series: "default",
        group: undefined,
        visible: true,
        label: "Default Series",
        color: "black",
        riserShape: undefined,
        connectMarkers: false,
        dataLabels: {
            visible: false,
            dataLabelMask: undefined,
            content: "auto",
            position: "top",
            font: "9pt Sans-Serif",
            numberFormat: "auto",
            color: "black",
            useNegativeColor: false,
            negativeColor: "red",
            clipToContainer: true,
            displayZero: true,
            feelerLine: {
                width: 1,
                color: "black",
                dash: ""
            },
            pad: undefined
        },
        border: {
            width: 0,
            color: "transparent",
            dash: "",
            cornerRadius: undefined
        },
        marker: {
            visible: false,
            color: undefined,
            size: 8,
            shape: "circle",
            rotation: 0,
            position: "middle",
            fillEffect: undefined,
            tooltip: undefined,
            border: {
                width: 1,
                color: "black",
                dash: ""
            }
        },
        trendline: {
            enabled: false,
            mode: undefined,
            order: 3,
            lineStyle: {
                width: 1,
                color: undefined,
                dash: ""
            },
            equationLabel: {
                visible: false,
                content: "auto",
                highOrderFirst: undefined,
                font: "8pt Sans-Serif",
                color: undefined,
                mode: "equation",
                position: "start"
            }
        },
        showDataValues: true,
        explodeSlice: 0,
        deleteSlice: false,
        xAxisAssignment: 1,
        yAxisAssignment: 1,
        tooltip: undefined
    },
    defaultAnnotation: {
        elementUsed: false,
        position: {
            parent: undefined,
            x: undefined,
            y: undefined,
            points: undefined
        },
        background: {
            color: undefined,
            border: {
                width: 1,
                color: undefined,
                dash: ""
            }
        },
        marker: {
            visible: false,
            color: undefined,
            size: 8,
            scale: undefined,
            centerOffset: {
                x: undefined,
                y: undefined
            },
            shape: "circle",
            rotation: 0,
            border: {
                width: 1,
                color: "black",
                dash: ""
            },
            tooltip: undefined
        },
        line: {
            width: 1,
            color: undefined,
            dash: ""
        },
        label: {
            visible: false,
            text: "Annotation Label",
            font: "10pt Sans-Serif",
            color: "black",
            position: "center"
        }
    },
    defaultLeafletBaseLayer: {
        title: undefined,
        url: undefined,
        layerInfo: {
            attribution: undefined,
            minZoom: 0,
            maxZoom: 15
        }
    },
    defaultLeafletOverlayLayer: {
        seriesID: undefined,
        markerType: "bubble",
        type: undefined,
        url: undefined,
        title: undefined,
        layerInfo: {
            minZoom: 0,
            maxZoom: 15,
            type: undefined
        },
        dataLookup: undefined
    },
    defautlScrollbarIntervalButton: {
        groupCount: undefined,
        fill: "grey",
        label: {
            text: undefined,
            color: "black",
            font: "12pt Sans-Serif"
        }
    },
    defaultEventDispatchObject: {
        event: undefined,
        object: undefined,
        series: undefined,
        group: undefined,
        row: undefined,
        col: undefined,
        misc: undefined,
        userInfo: undefined,
        context: undefined,
        callback: undefined,
        url: undefined,
        target: undefined,
        namespace: undefined
    },
    defaultCellFormat: {
        row: undefined,
        col: undefined,
        color: undefined,
        tooltip: undefined,
        labels: {
            font: undefined,
            color: undefined,
            numberFormat: undefined,
            align: undefined,
            valign: undefined
        }
    },
    heatmapProperties: {},
    xaxisOrdinal: {
        marker: {},
        title: {},
        labels: {
            nestingLineStyle: {}
        },
        baseLineStyle: {},
        bodyLineStyle: {},
        labelLayout: {},
        majorGrid: {
            lineStyle: {},
            ticks: {
                lineStyle: {}
            }
        },
        minorGrid: {
            lineStyle: {},
            ticks: {
                lineStyle: {}
            }
        },
        timeAxis: {
            dataAggregation: {}
        },
        colorScale: {},
        groupFit: {},
        scroll: {
            groups: {}
        }
    },
    xaxisNumeric: {
        marker: {},
        title: {},
        labels: {
            nestingLineStyle: {}
        },
        baseLineStyle: {},
        bodyLineStyle: {},
        labelLayout: {},
        majorGrid: {
            lineStyle: {},
            ticks: {
                lineStyle: {}
            }
        },
        minorGrid: {
            lineStyle: {},
            ticks: {
                lineStyle: {}
            }
        },
        timeAxis: {
            dataAggregation: {}
        },
        colorScale: {},
        groupFit: {},
        scroll: {
            groups: {}
        }
    },
    zaxisOrdinal: {
        marker: {},
        title: {},
        labels: {
            nestingLineStyle: {}
        },
        baseLineStyle: {},
        bodyLineStyle: {},
        labelLayout: {},
        majorGrid: {
            lineStyle: {},
            ticks: {
                lineStyle: {}
            }
        },
        minorGrid: {
            lineStyle: {},
            ticks: {
                lineStyle: {}
            }
        },
        timeAxis: {
            dataAggregation: {}
        },
        colorScale: {},
        groupFit: {},
        scroll: {
            groups: {}
        }
    }
};
tdgchart.defaultPropertyObjects = {
    defaultShadow: {
        angle: 315,
        distance: 10,
        blur: 0
    },
    defaultColorStop: {
        start: "0%",
        stop: "100%",
        color: "transparent"
    },
    defaultReferenceLine: {
        elementUsed: false,
        value: undefined,
        axis: undefined,
        bottom: "axisLine",
        ordinalAlign: "center",
        aboveRisers: true,
        line: {
            color: "black",
            width: 1,
            dash: ""
        },
        label: {
            text: "",
            font: "7.5pt Sans-Serif",
            color: "black"
        },
        anchor: "start",
        showValue: false
    },
    defaultSeries: {
        series: "default",
        group: undefined,
        visible: true,
        label: "Default Series",
        color: "black",
        riserShape: undefined,
        connectMarkers: false,
        dataLabels: {
            visible: false,
            content: "x",
            position: "top",
            font: "9pt Sans-Serif",
            numberFormat: "auto",
            color: "black",
            useNegativeColor: false,
            negativeColor: "red",
            clipToContainer: true,
            displayZero: true,
            feelerLine: {
                width: 1,
                color: "black",
                dash: ""
            },
            pad: undefined
        },
        border: {
            width: 0,
            color: "transparent",
            dash: "",
            cornerRadius: undefined
        },
        marker: {
            visible: false,
            color: undefined,
            size: 8,
            shape: "circle",
            rotation: 0,
            position: "middle",
            fillEffect: undefined,
            tooltip: undefined,
            border: {
                width: 1,
                color: "black",
                dash: ""
            }
        },
        trendline: {
            enabled: false,
            mode: undefined,
            order: 3,
            lineStyle: {
                width: 1,
                color: undefined,
                dash: ""
            },
            equationLabel: {
                visible: false,
                content: "auto",
                highOrderFirst: undefined,
                font: "8pt Sans-Serif",
                color: undefined,
                mode: "equation",
                position: "start"
            }
        },
        showDataValues: true,
        explodeSlice: 0,
        deleteSlice: false,
        xAxisAssignment: 1,
        yAxisAssignment: 1,
        tooltip: undefined,
        fillBetweenSeries: {
            toSeries: undefined,
            fill: undefined
        }
    },
    defaultAnnotation: {
        elementUsed: false,
        position: {
            parent: undefined,
            x: undefined,
            y: undefined,
            points: undefined
        },
        background: {
            color: undefined,
            border: {
                width: 1,
                color: undefined,
                dash: ""
            }
        },
        marker: {
            visible: false,
            color: undefined,
            size: 8,
            scale: undefined,
            centerOffset: {
                x: undefined,
                y: undefined
            },
            shape: "circle",
            rotation: 0,
            border: {
                width: 1,
                color: "black",
                dash: ""
            },
            tooltip: undefined
        },
        line: {
            width: 1,
            color: undefined,
            dash: ""
        },
        label: {
            visible: false,
            text: "Annotation Label",
            font: "10pt Sans-Serif",
            color: "black",
            position: "center"
        }
    },
    defaultLeafletBaseLayer: {
        title: undefined,
        url: undefined,
        layerInfo: {
            attribution: undefined,
            minZoom: 0,
            maxZoom: 15
        }
    },
    defaultLeafletOverlayLayer: {
        seriesID: undefined,
        markerType: "bubble",
        type: undefined,
        url: undefined,
        title: undefined,
        layerInfo: {
            minZoom: 0,
            maxZoom: 15,
            type: undefined
        },
        dataLookup: undefined
    },
    defautlScrollbarIntervalButton: {
        groupCount: undefined,
        fill: "grey",
        label: {
            text: undefined,
            color: "black",
            font: "12pt Sans-Serif"
        }
    },
    defaultEventDispatchObject: {
        event: undefined,
        object: undefined,
        series: undefined,
        group: undefined,
        row: undefined,
        col: undefined,
        misc: undefined,
        userInfo: undefined,
        context: undefined,
        callback: undefined,
        url: undefined,
        target: undefined,
        namespace: undefined
    },
    defaultCellFormat: {
        row: undefined,
        col: undefined,
        color: undefined,
        tooltip: undefined,
        labels: {
            font: undefined,
            color: undefined,
            numberFormat: undefined,
            align: undefined,
            valign: undefined
        }
    }
};
tdgchart.propertyAnnotations = {
    global: {
        chartType: {
            typeAnnotation: "str",
            stringValues: ["bar", "line", "area", "pie", "scatter", "bubble", "gauge", "waterfall", "sparkline", "bullet", "simplelabel", "marker", "matrix", "funnel", "boxplot", "histogram", "treemap", "bar3d", "area3d", "stock", "gantt", "surface3d", "pareto", "radar", "polar", "legend", "mekko", "streamgraph", "parabox", "control", "heatmap", "tagcloud", "map", "grid", "datagrid", "circlepack", "circlepack2", "pictogram"]
        },
        numberFormat: {
            typeAnnotation: "type",
            typeValues: ["str", "function"]
        },
        point: {
            x: "global.numberOrPercent",
            y: "global.numberOrPercent"
        },
        numberOrPercent: {
            typeAnnotation: "type",
            typeValues: ["percentString", "number"]
        },
        colorOrPercent: {
            typeAnnotation: "type",
            typeValues: ["color", "percentString"]
        },
        boolOrAuto: {
            typeAnnotation: "type",
            typeValues: ["bool", "str"],
            stringValues: ["auto"]
        },
        numberOrAuto: {
            typeAnnotation: "type",
            typeValues: ["number", "str"],
            stringValues: ["auto"]
        },
        colorOrAuto: {
            typeAnnotation: "type",
            typeValues: ["color", "str"],
            stringValues: ["auto"]
        },
        stringOrFunction: {
            typeAnnotation: "type",
            typeValues: ["str", "function"]
        },
        rotation: {
            typeAnnotation: "number",
            numericRange: [-360, 360]
        },
        rotationOrAuto: {
            typeAnnotation: "type",
            typeValues: ["global.rotation", "str"],
            stringValues: ["auto"]
        },
        fraction: {
            typeAnnotation: "number",
            numericRange: [0, 1]
        },
        position: {
            typeAnnotation: "str",
            stringValues: ["top", "bottom", "left", "right"]
        },
        align: {
            typeAnnotation: "str",
            stringValues: ["left", "middle", "center", "right"]
        },
        valign: {
            typeAnnotation: "str",
            stringValues: ["top", "middle", "center", "bottom"]
        },
        markerPosition: {
            typeAnnotation: "str",
            stringValues: ["top", "bottom", "left", "right", "middle"]
        },
        labelPosition: {
            typeAnnotation: "str",
            stringValues: ["top", "center", "bottom", "left", "right", "insideBottom", "insideTop", "outside", "auto"]
        },
        legendPosition: {
            side: {
                typeAnnotation: "str",
                stringValues: ["top", "bottom", "left", "right"]
            },
            anchor: {
                typeAnnotation: "str",
                stringValues: ["chartBackground", "chartFrame", "chartAxisFrame"]
            },
            excludeFromLayout: "bool",
            left: "global.numberOrPercent",
            right: "global.numberOrPercent",
            top: "global.numberOrPercent",
            bottom: "global.numberOrPercent",
            align: {
                typeAnnotation: "str",
                stringValues: ["top", "bottom", "left", "right", "center", "middle"]
            }
        },
        box: {
            left: "number",
            right: "number",
            top: "number",
            bottom: "number"
        },
        border: {
            width: "number",
            color: "global.colorOrAuto",
            dash: "str"
        },
        roundBorder: {
            width: "number",
            color: "color",
            dash: "str",
            cornerRadius: {
                typeAnnotation: "type",
                typeValues: ["number", "str", "json"]
            }
        },
        colorStop: {
            start: "global.numberOrPercent",
            stop: "global.numberOrPercent",
            color: "color",
            label: {
                text: "str",
                visible: "bool",
                font: "font",
                color: "color"
            }
        },
        tooltip: {
            typeAnnotation: "type",
            typeValues: ["str", "function", "array", "json"],
            arrayTypes: ["str", "function", "json"]
        },
        label: {
            visible: "bool",
            font: "font",
            color: "color"
        },
        numericLabel: {
            visible: "global.boolOrAuto",
            font: "font",
            color: "color",
            numberFormat: "global.numberFormat"
        },
        numericContentLabel: {
            visible: "global.boolOrAuto",
            content: "str",
            font: "font",
            fontSize: "str",
            color: "color",
            numberFormat: "global.numberFormat"
        },
        fill: {
            typeAnnotation: "type",
            typeValues: ["color", "linearGradient", "radialGradient", "pattern", "str"]
        },
        marker: {
            visible: "bool",
            color: "color",
            size: "number",
            scale: "number",
            centerOffset: "global.point",
            shape: "str",
            width: "number",
            height: "number",
            position: "global.markerPosition",
            rotation: "global.rotation",
            border: "global.border",
            tooltip: "global.tooltip"
        },
        seriesMarker: {
            visible: "bool",
            color: "color",
            size: {
                typeAnnotation: "type",
                typeValues: ["number", "str"]
            },
            shape: "str",
            width: "number",
            height: "number",
            rotation: "global.rotation",
            position: "global.markerPosition",
            tooltip: "global.tooltip",
            border: "global.border",
            fillEffect: {
                typeAnnotation: "type",
                typeValues: ["percentString", "str"],
                stringValues: ["seriesHollow", "seriesFill", "seriesWhite", "seriesAuto", "seriesCustom"]
            },
            fillMode: {
                typeAnnotation: "type",
                typeValues: ["percentString", "str"],
                stringValues: ["seriesHollow", "seriesFill", "seriesWhite", "seriesAuto"]
            }
        },
        title: {
            text: "str",
            visible: "bool",
            align: {
                typeAnnotation: "str",
                stringValues: ["center", "left", "right", "chartFrame"]
            },
            font: "font",
            color: "color",
            backgroundColor: "color",
            border: "global.roundBorder",
            tooltip: "global.tooltip",
            wrap: {
                typeAnnotation: "type",
                typeValues: ["str", "number"],
                numericRange: [0, 10],
                stringValues: ["auto"]
            }
        },
        riserLayout: {
            typeAnnotation: "str",
            stringValues: ["stacked", "absolute", "percent", "sideBySide"]
        },
        trendline: {
            enabled: "bool",
            mode: {
                typeAnnotation: "str",
                stringValues: ["none", "exponential", "geometric", "hyperbolic", "linear", "logarithmic", "logQuadratic", "modExponential", "modHyperbolic", "polynomial", "quadratic", "rational", "min", "max", "mean"]
            },
            order: "number",
            line: "global.border",
            lineStyle: "global.border",
            equationLabel: {
                visible: "bool",
                content: "str",
                highOrderFirst: "bool",
                font: "font",
                color: "color",
                mode: {
                    typeAnnotation: "str",
                    stringValues: ["equation", "r", "label", "value", "labelAndValue"]
                },
                position: {
                    typeAnnotation: "str",
                    stringValues: ["start", "end"]
                }
            }
        },
        axisBound: {
            typeAnnotation: "type",
            typeValues: ["number", "str", "array", "json"],
            stringValues: ["min", "max", "xymin", "xymax", "xyauto", "autoPerRow"],
            arrayTypes: ["number", "str"]
        },
        axisTicks: {
            length: "number",
            visible: "bool",
            style: {
                typeAnnotation: "str",
                stringValues: ["inner", "outer", "span"]
            },
            lineStyle: {
                width: "number",
                color: "color"
            }
        },
        sort: {
            typeAnnotation: "type",
            typeValues: ["str", "json"],
            stringValues: ["ascending", "descending"]
        },
        axis: {
            mode: {
                typeAnnotation: "str",
                stringValues: ["ordinal", "numeric", "time", "color", "count"]
            },
            min: "global.axisBound",
            max: "global.axisBound",
            rawMin: "number",
            rawMax: "number",
            intervalMode: {
                typeAnnotation: "str",
                stringValues: ["skip", "interval", "count"]
            },
            intervalValue: "number",
            mustIncludeZero: "bool",
            headroom: "number",
            globalAxisHeadroom: "number",
            inset: {
                typeAnnotation: "type",
                typeValues: ["number", "percentString", "str"],
                stringValues: ["auto"]
            },
            position: {
                typeAnnotation: "str",
                stringValues: ["start", "middle", "end"]
            },
            bIsLog: "bool",
            numberFormat: "global.numberFormat",
            swapChartSide: "bool",
            invert: "bool",
            absValues: "bool",
            centerGroupLabels: "bool",
            altFrameColor: "color",
            altFrameColor1: "color",
            colorBands: {
                typeAnnotation: "array",
                arrayTypes: "global.colorStop"
            },
            marker: {
                minSize: "global.numberOrPercent",
                maxSize: "global.numberOrPercent"
            },
            title: {
                text: "str",
                visible: "bool",
                font: "font",
                color: "color",
                tooltip: "global.tooltip",
                position: {
                    typeAnnotation: "str",
                    stringValues: ["parallel", "orthogonal", "flip"]
                }
            },
            labels: {
                visible: "bool",
                font: "font",
                color: "color",
                excludeMin: "global.boolOrAuto",
                excludeMax: "global.boolOrAuto",
                replaceMin: "str",
                replaceMax: "str",
                rotation: "global.numberOrAuto",
                tooltip: "global.tooltip",
                nestingConcatSymbol: "str",
                nestingLineStyle: "global.border",
                pad: "global.numberOrPercent",
                align: {
                    typeAnnotation: "str",
                    stringValues: ["top", "bottom", "left", "right", "center", "inside", "outside"]
                }
            },
            labelLayout: {
                stagger: "global.boolOrAuto",
                skip: "global.numberOrAuto",
                scroll: "global.boolOrAuto",
                truncate: "global.boolOrAuto",
                spaceLimit: "percentString"
            },
            baseLineValue: "number",
            baseLineStyle: "global.border",
            bodyLineStyle: "global.border",
            majorGrid: {
                visible: "bool",
                aboveRisers: "bool",
                lockToY1: "bool",
                lineStyle: "global.border",
                ticks: "global.axisTicks"
            },
            minorGrid: {
                visible: "bool",
                count: "number",
                lineStyle: "global.border",
                ticks: "global.axisTicks"
            },
            timeAxis: {
                enabled: "bool",
                startTime: "str",
                stopTime: "str",
                interval: {
                    typeAnnotation: "str",
                    stringValues: ["second", "minute", "hour", "day", "week", "month", "quater", "year"]
                },
                stepSize: "number",
                labelFormat: "str",
                tooltipFormat: "str",
                dataAggregation: {
                    enabled: "bool",
                    interval: {
                        typeAnnotation: "type",
                        typeValues: ["number", "str"],
                        stringValues: ["auto", "autods"]
                    },
                    round: "bool",
                    method: {
                        typeAnnotation: "str",
                        stringValues: ["average", "min", "max", "first", "last"]
                    },
                    runningRange: "number"
                }
            },
            colorScale: {
                colors: {
                    typeAnnotation: "array",
                    arrayTypes: "color"
                }
            },
            groupFit: {
                rule: {
                    typeAnnotation: "str",
                    stringValues: ["auto", "minSize", "maxSize", "exactSize", "maxCount", "labelHeight"]
                },
                value: "global.numberOrPercent"
            },
            sort: "global.sort",
            scroll: {
                enabled: "bool",
                style: {
                    typeAnnotation: "str",
                    stringValues: ["simple", "miniChart"]
                },
                groups: {
                    minSize: "global.numberOrAuto",
                    maxCount: "global.numberOrAuto"
                },
                miniChartProperties: "json",
                intervalButtons: {
                    typeAnnotation: "array",
                    arrayTypes: "global.scrollbarIntervalButtons",
                    defaultType: "defautlScrollbarIntervalButton"
                },
                initialPosition: {
                    typeAnnotation: "type",
                    typeValues: ["global.numberOrPercent", "array"],
                    arrayTypes: "global.numberOrPercent"
                }
            }
        },
        referenceLine: {
            elementUsed: "bool",
            value: "number",
            axis: {
                typeAnnotation: "str",
                stringValues: ["x", "y", "y1", "y2", "y3", "y4", "y5", "y6", "y7", "y8", "y9"]
            },
            bottom: {
                typeAnnotation: "str",
                stringValues: ["chartBorder", "axisLine"]
            },
            ordinalAlign: {
                typeAnnotation: "str",
                stringValues: ["center", "left", "right", "riserLeft", "riserRight"]
            },
            aboveRisers: "bool",
            line: "global.border",
            label: {
                text: "str",
                font: "font",
                color: "color"
            },
            anchor: {
                typeAnnotation: "str",
                stringValues: ["start", "end"]
            },
            showValue: "bool"
        },
        series: {
            series: {
                typeAnnotation: "type",
                typeValues: ["str", "number"],
                stringValues: ["all", "reset", "clear", "default"]
            },
            dataLabels: {
                visible: "global.boolOrAuto",
                dataLabelMask: {
                    typeAnnotation: "array",
                    arrayTypes: "str"
                },
                content: "str",
                labelPlacement: "str",
                position: "global.labelPosition",
                positionMode: {
                    typeAnnotation: "str",
                    stringValues: ["ignoreOrientation"]
                },
                rotation: "global.rotation",
                font: "font",
                numberFormat: "global.numberFormat",
                color: "global.colorOrAuto",
                useNegativeColor: "bool",
                negativeColor: "color",
                backgroundColor: "color",
                clipToContainer: "bool",
                displayZero: "bool",
                feelerLine: {
                    visible: "bool",
                    width: "number",
                    color: "color",
                    dash: "str"
                },
                pad: "global.numberOrPercent"
            },
            group: "number",
            visible: "bool",
            label: "str",
            color: "global.fill",
            riserShape: {
                typeAnnotation: "type",
                typeValues: ["str", "json"],
                stringValues: ["bar", "line", "area"]
            },
            connectMarkers: "bool",
            border: "global.roundBorder",
            marker: "global.seriesMarker",
            trendline: "global.trendline",
            showDataValues: "bool",
            explodeSlice: "number",
            deleteSlice: "bool",
            xAxisAssignment: "number",
            yAxisAssignment: "number",
            tooltip: "global.tooltip",
            fillBetweenSeries: {
                toSeries: "number",
                fill: "global.fill"
            }
        },
        annotation: {
            elementUsed: "bool",
            position: {
                parent: "str",
                x: {
                    typeAnnotation: "type",
                    typeValues: ["number", "percentString", "str"]
                },
                y: {
                    typeAnnotation: "type",
                    typeValues: ["number", "percentString", "str"]
                },
                points: {
                    typeAnnotation: "array",
                    arrayTypes: "global.point"
                }
            },
            background: {
                color: "color",
                border: "global.border"
            },
            marker: "global.marker",
            line: "global.border",
            label: {
                visible: "bool",
                text: "str",
                font: "font",
                color: "color",
                position: "global.labelPosition"
            }
        },
        stabilityRule: {
            name: "str",
            n: "number",
            marker: {
                color: "color",
                shape: "str",
                size: "number"
            },
            ruleCallback: "function"
        },
        leafletBaseLayer: {
            title: "str",
            url: "global.stringOrFunction",
            layerInfo: {
                attribution: "global.stringOrFunction",
                minZoom: "number",
                maxZoom: "number"
            }
        },
        leafletOverlayLayer: {
            seriesID: "number",
            markerType: {
                typeAnnotation: "str",
                stringValues: ["choropleth", "bubble"]
            },
            type: {
                typeAnnotation: "str",
                stringValues: ["geojson", "tdg", "csv", "latlng"]
            },
            url: "global.stringOrFunction",
            title: "str",
            layerInfo: {
                minZoom: "number",
                maxZoom: "number",
                type: "str",
                fieldNames: {
                    typeAnnotation: "array",
                    arrayTypes: "str"
                },
                fieldSep: "str",
                lineSep: "str",
                firstRowIsTitles: "bool",
                removeSurroundingQuotes: "bool"
            },
            dataLookup: "global.stringOrFunction"
        },
        scrollbarIntervalButtons: {
            groupCount: "number",
            fill: "color",
            label: {
                text: "str",
                color: "color",
                font: "font"
            }
        },
        eventDispatchObject: {
            event: "str",
            object: "str",
            series: "number",
            group: "number",
            row: "number",
            col: "number",
            misc: "str",
            userInfo: "json",
            context: "object",
            callback: "function",
            url: "str",
            target: "str",
            namespace: "str"
        },
        cellFormat: {
            row: {
                typeAnnotation: "type",
                typeValues: ["number", "str"],
                stringValues: ["total"]
            },
            col: "number",
            color: "color",
            tooltip: "global.tooltip",
            labels: {
                font: "font",
                color: "color",
                numberFormat: "global.numberFormat",
                align: "global.align",
                valign: "global.valign"
            }
        },
        uniqueId: {
            typeAnnotation: "str"
        }
    },
    chartType: "global.chartType",
    containerID: "str",
    catchErrors: "bool",
    errorStatus: "str",
    showVersion: "bool",
    showDebugString: "bool",
    validateProperties: "bool",
    drawTimeout: "number",
    dataSetLimits: {
        enabled: "bool",
        limits: "json"
    },
    drawStaticChart: "bool",
    backend: {
        typeAnnotation: "str",
        stringValues: ["js", "flash"]
    },
    allowBackendFallback: "bool",
    width: "number",
    height: "number",
    transform: {
        scale: "global.numberOrAuto",
        referenceSize: {
            width: "number",
            height: "number"
        }
    },
    fill: {
        color: "global.fill"
    },
    border: "global.border",
    chartFrame: {
        fill: {
            color: "global.fill"
        },
        border: "global.border",
        proportions: {
            mode: {
                typeAnnotation: "str",
                stringValues: ["byChartFrameAspect", "byCellAspect"]
            },
            aspectRatio: "number"
        },
        shadow: "bool",
        leftedge: {
            fill: {
                color: {
                    typeAnnotation: "type",
                    typeValues: ["color", "linearGradient", "radialGradient", "pattern", "str"],
                    stringValues: ["auto"]
                }
            }
        },
        bottomedge: {
            fill: {
                color: {
                    typeAnnotation: "type",
                    typeValues: ["color", "linearGradient", "radialGradient", "pattern", "str"],
                    stringValues: ["auto"]
                }
            }
        }
    },
    errorMessage: "str",
    introAnimation: {
        enabled: "bool",
        duration: "number",
        animateOnce: "bool"
    },
    morphAnimation: {
        duration: "number",
        mode: {
            typeAnnotation: "str",
            stringValues: ["slideLeft"]
        }
    },
    interaction: {
        click: {
            typeAnnotation: "str",
            stringValues: ["otherSliceDrillDown", "zoom"]
        },
        mousedrag: {
            typeAnnotation: "str",
            stringValues: ["pan", "select", "riserDrag", "rotate"]
        },
        mousemove: {
            typeAnnotation: "str",
            stringValues: ["over", "nearestNeighbor"]
        },
        dblclick: {
            typeAnnotation: "str",
            stringValues: ["resetView"]
        },
        touchDrag: {
            typeAnnotation: "str",
            stringValues: ["pan", "select"]
        },
        longTouchDrag: {
            typeAnnotation: "str",
            stringValues: ["pan", "select"]
        }
    },
    truncation: {
        symbol: "str"
    },
    mouseOverIndicator: {
        enabled: "bool",
        overLegend: {
            typeAnnotation: "type",
            typeValues: ["bool", "str"],
            stringValues: ["series"]
        },
        color: {
            typeAnnotation: "type",
            typeValues: ["color", "percentString"]
        },
        border: "global.border",
        marker: "global.marker"
    },
    data: "object",
    dataArrayMap: {
        typeAnnotation: "array",
        arrayTypes: "str"
    },
    dataSubset: {
        startGroup: "number",
        stopGroup: "number"
    },
    dataStream: {
        enabled: "bool",
        url: "str",
        refreshTimeout: "number",
        useMorph: "bool"
    },
    dataMerge: {
        mergePixelDistance: "number"
    },
    nullRepresentation: "str",
    noDataMode: "bool",
    inPreviewMode: "bool",
    locale: {
        decimalSeparator: "str",
        thousandSeparator: "str",
        currencySymbol: "str",
        thousandCompression: "str",
        millionCompression: "str",
        billionCompression: "str"
    },
    serverProperties: "json",
    autoNumberFormats: {
        dataLabels: "str",
        tooltip: "str",
        stackTotalLabel: "str",
        totalLabel: "str"
    },
    swapData: "bool",
    swapDataAndLabels: "bool",
    showNullGroups: "bool",
    showNullSeries: "bool",
    riserCycleEndLightness: "global.fraction",
    colorMode: {
        mode: {
            typeAnnotation: "str",
            stringValues: ["bySeries", "byGroup", "byHeight", "byInterpolation", "byInterpolationAlt", "byMetric", "bySeriesSelection", "byGroupSelection", "byPosNeg", "byNegPos", "byFirstSeries"]
        },
        colorList: {
            typeAnnotation: "array",
            arrayTypes: "str"
        },
        data: "object",
        posColor: "color",
        negColor: "color",
        neutralColor: "color"
    },
    accessibility: {
        navigation: {
            enabled: "bool",
            mode: {
                typeAnnotation: "str",
                stringValues: ["cycleRisers"]
            },
            tabLimit: "number"
        },
        title: "str",
        description: "str"
    },
    labelPadding: {
        frame: "global.box",
        label: "global.box"
    },
    chartsPerRow: {
        typeAnnotation: "number",
        numericRange: [0, 100]
    },
    depth: {
        typeAnnotation: "number",
        numericRange: [0, 100]
    },
    riserDepthGap: "global.fraction",
    riserShadow: "bool",
    riserBevel: {
        typeAnnotation: "str",
        stringValues: ["none", "darken", "lighten", "darkenInverted", "lightenInverted", "bevel", "cylinder", "donut"]
    },
    axisAutoLayout: {
        rotate45: "bool",
        rotate90: "bool",
        truncate: "bool",
        stagger: "bool",
        skip: "bool"
    },
    bubbleMarker: {
        maxSize: "global.numberOrPercent"
    },
    blaProperties: {
        splitY: "bool",
        seriesLayout: "global.riserLayout",
        sort: "global.sort",
        orientation: {
            typeAnnotation: "str",
            stringValues: ["horizontal", "vertical"]
        },
        extendToFrameEdge: "bool",
        lineConnection: {
            typeAnnotation: "str",
            stringValues: ["linear", "curved", "baselineDescender", "stepBefore", "stepBetween", "stepAfter", "curvedB"]
        },
        missingDataMode: {
            typeAnnotation: "str",
            stringValues: ["none", "zero", "linear", "curved"]
        },
        missingDataExtrapolate: "bool",
        missingDataLineStyle: "global.border",
        barEffect: {
            typeAnnotation: "str",
            stringValues: ["halfRound", "fullRound"]
        },
        lineFillEffect: {
            typeAnnotation: "type",
            typeValues: ["color", "linearGradient", "radialGradient", "percentString", "str"],
            stringValues: ["seriesLighten"]
        },
        areaFillEffect: {
            typeAnnotation: "type",
            typeValues: ["color", "linearGradient", "radialGradient", "percentString", "str"],
            stringValues: ["seriesLighten"]
        },
        barGroupGapWidth: "global.fraction",
        absoluteInset: "global.fraction",
        stackTotalLabel: {
            visible: "bool",
            font: "font",
            color: "color",
            numberFormat: "global.numberFormat",
            displayZero: "bool",
            rotation: "global.rotationOrAuto"
        },
        comboCharts: {
            barSeriesLayout: "global.riserLayout",
            lineSeriesLayout: "global.riserLayout",
            areaSeriesLayout: "global.riserLayout"
        }
    },
    controlProperties: {
        mode: {
            typeAnnotation: "str",
            stringValues: ["i", "c", "u", "p"]
        },
        defaultStabilityMarker: {
            color: "color",
            shape: "str",
            size: "number"
        },
        stabilityRules: {
            typeAnnotation: "array",
            arrayTypes: ["str", "global.stabilityRule"]
        }
    },
    pieProperties: {
        multiRing: "bool",
        groupPiesBySelection: "bool",
        holeSize: "global.numberOrPercent",
        rotation: "global.rotation",
        skew: "number",
        label: "global.label",
        totalLabel: "global.numericContentLabel",
        otherSlice: {
            threshold: {
                typeAnnotation: "type",
                typeValues: ["percentString", "number", "str"],
                stringValues: ["topX"]
            },
            legendLabel: "str",
            color: "color",
            border: "global.border",
            showDataValues: "bool",
            marker: {
                shape: "str",
                border: "global.border"
            }
        },
        zeroStyle: {
            color: "color",
            border: "global.border"
        },
        explodeClick: {
            enabled: "bool",
            duration: "number",
            distance: "number",
            limitExplodeCount: "bool"
        },
        sort: "global.sort",
        effect: {
            typeAnnotation: "str",
            stringValues: ["roundRing"]
        },
        feelerLine: {
            visible: "bool",
            width: "number",
            color: "color",
            dash: "str"
        }
    },
    threedProperties: {
        rotate: {
            typeAnnotation: "number",
            numericRange: [0, 90]
        },
        tilt: {
            typeAnnotation: "number",
            numericRange: [0, 90]
        },
        shadeSides: "bool"
    },
    gaugeProperties: {
        startAngle: "global.rotation",
        endAngle: "global.rotation",
        secondaryNeedlesAsMarkers: "bool",
        secondaryRingFillColor: "color",
        layout: {
            typeAnnotation: "str",
            stringValues: ["gauge", "simple", "textArrow", "simpleText"]
        },
        groupLabel: {
            visible: "bool",
            font: "font",
            color: "color",
            position: "global.position"
        },
        totalLabel: "global.numericContentLabel",
        fill: {
            color: "global.fill"
        },
        needleBase: {
            size: "global.numberOrPercent",
            color: "global.colorOrAuto",
            border: "global.border"
        },
        axisWidth: "global.numberOrPercent",
        axisTickLength: "global.numberOrPercent",
        axisMinorTickLength: "global.numberOrPercent",
        outerBorder: {
            width: "global.numberOrPercent",
            shape: {
                typeAnnotation: "str",
                stringValues: ["circle", "tight"]
            },
            fill: {
                color: "global.colorOrAuto"
            },
            border: "global.border"
        }
    },
    funnelProperties: {
        topWidth: "global.numberOrPercent",
        baseWidth: "global.numberOrPercent",
        riserGap: "global.numberOrPercent",
        groupLabel: "global.label"
    },
    waterfallProperties: {
        appendTotalRiser: "bool",
        totalLabel: "str",
        positiveRiserColor: "color",
        negativeRiserColor: "color",
        zeroRiserColor: "color",
        totalRiserColor: "color",
        otherRiserColor: "color",
        subtotalRisers: {
            typeAnnotation: "array",
            arrayTypes: ["str", "number"]
        },
        otherRisers: {
            typeAnnotation: "array",
            arrayTypes: ["str", "number"]
        },
        subtotalFormat: {
            bold: "bool",
            color: "color",
            numberFormat: "global.numberFormat",
            dataLabelPosition: "global.labelPosition",
            dividerLine: "global.border"
        },
        firstLastFormat: {
            color: "color",
            border: "global.border"
        },
        connectorLine: "global.border"
    },
    boxPlotProperties: {
        hatWidth: "global.numberOrPercent",
        drawHatAsBox: "bool",
        notch: {
            width: "percentString",
            multiplier: "number"
        },
        medianLine: "global.border",
        connectorLine: "global.border",
        meanMarker: {
            visible: "bool",
            color: "color",
            size: "number",
            shape: "str",
            rotation: "global.rotation",
            tooltip: "global.tooltip",
            border: "global.border"
        }
    },
    histogramProperties: {
        binCount: "number",
        binSize: {
            typeAnnotation: "type",
            typeValues: ["number", "array"],
            arrayTypes: "number"
        },
        startBinValue: "number",
        minThreshold: "number",
        maxThreshold: "number"
    },
    stockProperties: {
        startTime: "str",
        stopTime: "str",
        interval: "str",
        labelFormat: "str",
        upRiserColor: "color",
        downRiserColor: "color",
        hiLowLine: "global.border"
    },
    ganttProperties: {
        startTime: "str",
        stopTime: "str",
        interval: "str",
        labelFormat: "str",
        durationValues: "bool",
        staggerRisers: "bool"
    },
    polarProperties: {
        straightGridLines: "bool",
        extrudeAxisLabels: "bool",
        drawAsArea: "bool"
    },
    treemapProperties: {
        scaleCellFonts: "bool",
        internalLabelSeparator: "str",
        header: {
            height: "global.numberOrPercent",
            fill: "global.fill",
            border: "global.border",
            label: "global.label",
            tooltip: "global.tooltip"
        },
        cellBorder: {
            width: "number",
            color: "color",
            dash: "str",
            outerCellWidth: "number"
        }
    },
    mapProperties: {
        map: "str",
        mapPath: "str",
        antiAlias: "bool",
        mapOpacity: "global.fraction",
        landmarks: {
            visible: "bool",
            maxCount: "number",
            marker: "global.marker",
            label: "global.label"
        },
        region: {
            color: "color",
            border: "global.border"
        },
        secondaryRegion: {
            color: "color",
            border: "global.border"
        },
        viewBox: {
            left: "global.numberOrAuto",
            right: "global.numberOrAuto",
            top: "global.numberOrAuto",
            bottom: "global.numberOrAuto"
        },
        markerType: {
            typeAnnotation: "str",
            stringValues: ["choropleth", "bubble"]
        },
        geocode: {
            type: "str",
            geocode: "str",
            exact: "bool"
        },
        engine: {
            typeAnnotation: "str",
            stringValues: ["leaflet"]
        },
        leaflet: {
            layerControl: {
                visible: "bool",
                position: {
                    typeAnnotation: "str",
                    stringValues: ["topleft", "topright", "bottomleft", "bottomright"]
                },
                collapsed: "bool",
                autoZIndex: "bool"
            },
            initPos: {
                center: {
                    typeAnnotation: "array",
                    arrayTypes: "number"
                },
                level: "number"
            },
            baselayers: {
                typeAnnotation: "array",
                arrayTypes: "global.leafletBaseLayer",
                defaultType: "defaultLeafletBaseLayer"
            },
            overlayLayers: {
                typeAnnotation: "array",
                arrayTypes: "global.leafletOverlayLayer",
                defaultType: "defaultLeafletOverlayLayer"
            },
            unmatchedLabel: "str",
            controls: {
                typeAnnotation: "array",
                arrayTypes: "json"
            }
        }
    },
    bulletProperties: {
        drawFirstValueAsBar: "bool"
    },
    simpleLabelProperties: {
        text: "str",
        align: "global.align",
        valign: "global.valign",
        font: "font",
        color: "color"
    },
    tagcloudProperties: {
        maxNumberOfTags: "number",
        font: "font",
        engine: {
            typeAnnotation: "str",
            stringValues: ["new"]
        }
    },
    paraboxProperties: {
        activeGroup: "str",
        bubbleRadius: "global.numberOrAuto",
        border: {
            width: "number"
        }
    },
    matrixProperties: {
        chartType: {
            typeAnnotation: "str",
            stringValues: ["bar", "line", "area", "bubble", "scatter", "histogram", "heatmap", "bullet", "pie", "gauge", "marker", "sparkline", "polar", "radar"]
        },
        rowLabels: {
            labels: {
                typeAnnotation: "array",
                arrayTypes: "str"
            },
            font: "font",
            color: "color",
            align: "global.align",
            valign: "global.valign",
            tooltip: "global.tooltip",
            swapChartSide: "bool",
            rotation: "global.rotation"
        },
        colLabels: {
            labels: {
                typeAnnotation: "array",
                arrayTypes: "str"
            },
            font: "font",
            wrap: "global.numberOrAuto",
            color: "color",
            tooltip: "global.tooltip",
            swapChartSide: "bool",
            rotation: "global.rotation"
        },
        rowHeader: {
            text: {
                typeAnnotation: "type",
                typeValues: ["str", "array"],
                arrayTypes: "str"
            },
            separator: "str",
            font: "font",
            color: "color",
            tooltip: "global.tooltip",
            alignColumns: "bool"
        },
        colHeader: {
            text: "str",
            font: "font",
            color: "color",
            tooltip: "global.tooltip"
        },
        cellBorder: "global.border",
        layout: {
            cellPadding: "global.box"
        },
        minCellSize: "global.numberOrAuto",
        colWrapCount: "global.numberOrAuto"
    },
    dataGridProperties: {
        altRowFill: {
            typeAnnotation: "type",
            typeValues: ["color", "array"],
            arrayTypes: "color"
        },
        cell: {
            layout: {
                width: {
                    typeAnnotation: "type",
                    typeValues: ["number", "json"]
                },
                height: {
                    typeAnnotation: "type",
                    typeValues: ["number", "json"]
                },
                cellPadding: "global.box"
            },
            innerGridLines: {
                horizontal: "global.border",
                vertical: "global.border"
            },
            labels: {
                font: "font",
                color: "color",
                numberFormat: "global.numberFormat",
                align: "global.align",
                valign: "global.valign"
            },
            tooltip: "global.tooltip",
            formatList: {
                typeAnnotation: "array",
                arrayTypes: "global.cellFormat",
                defaultType: "defaultCellFormat"
            }
        },
        rowHeader: {
            fill: "color",
            border: "global.border",
            innerGridLines: {
                horizontal: "global.border",
                vertical: "global.border"
            },
            dividerLine: "global.border",
            title: {
                text: {
                    typeAnnotation: "type",
                    typeValues: ["str", "array"],
                    arrayTypes: "str"
                },
                font: "font",
                color: "color",
                align: "global.align",
                valign: "global.valign",
                tooltip: "global.tooltip",
                dividerLine: "global.border"
            },
            labels: {
                font: "font",
                color: "color",
                align: "global.align",
                valign: "global.valign",
                wrap: "number",
                mergeMatching: "bool",
                content: {
                    typeAnnotation: "array",
                    arrayTypes: ["str", "json"]
                }
            }
        },
        colHeader: {
            sorting: {
                enabled: "bool",
                icon: {
                    size: "number",
                    selectedColor: "color",
                    unSelectedColor: "color",
                    borderWidth: "number"
                }
            },
            resize: {
                enabled: "bool"
            },
            fill: "color",
            border: "global.border",
            innerGridLines: {
                horizontal: "global.border",
                vertical: "global.border"
            },
            dividerLine: "global.border",
            title: {
                text: {
                    typeAnnotation: "type",
                    typeValues: ["str", "array"],
                    arrayTypes: "str"
                },
                font: "font",
                color: "color",
                align: "global.align",
                valign: "global.valign",
                tooltip: "global.tooltip",
                dividerLine: "global.border"
            },
            labels: {
                font: "font",
                color: "color",
                align: "global.align",
                valign: "global.valign",
                mergeMatching: "bool",
                content: {
                    typeAnnotation: "array",
                    arrayTypes: ["str", "json"]
                }
            },
            lastLabels: {
                font: "font",
                color: "color",
                align: "global.align",
                valign: "global.valign"
            }
        },
        columnTotals: {
            visible: "bool",
            calculation: {
                typeAnnotation: "str",
                stringValues: ["sum", "min", "max", "mean"]
            },
            headerLabel: {
                text: "str",
                font: "font",
                color: "color",
                align: "global.align",
                valign: "global.valign"
            },
            cellLabel: {
                font: "font",
                color: "color",
                align: "global.align",
                valign: "global.valign"
            },
            border: "global.border",
            dividerLine: "global.border"
        },
        scroll: {
            enabled: "bool",
            freezeRowHeader: "bool",
            freezeColHeader: "bool",
            size: "number",
            color: "color",
            handle: {
                color: "color",
                hoverColor: "color",
                border: "global.border"
            }
        }
    },
    pictogramProperties: {
        fillMode: {
            typeAnnotation: "str",
            stringValues: ["repeatClip", "stretch"]
        },
        backFill: "color",
        lockToGrid: "bool"
    },
    legend: {
        visible: "global.boolOrAuto",
        position: {
            typeAnnotation: "type",
            typeValues: ["str", "json"],
            stringValues: ["free", "left", "right", "bottom", "top", "auto"]
        },
        maxSize: "global.numberOrPercent",
        fixedSize: "global.numberOrPercent",
        fixedSizeAlign: {
            typeAnnotation: "str",
            stringValues: ["inside", "middle", "outside"]
        },
        orientation: {
            typeAnnotation: "str",
            stringValues: ["auto", "horizontal", "vertical"]
        },
        align: {
            typeAnnotation: "str",
            stringValues: ["center", "left", "right", "bottom", "top"]
        },
        xy: {
            x: "number",
            y: "number"
        },
        reverseOrder: "global.boolOrAuto",
        markerSize: "number",
        markerPosition: "global.position",
        matchSeriesMarkers: "bool",
        maxEntries: "number",
        title: {
            visible: "bool",
            text: "str",
            font: "font",
            color: "color",
            tooltip: "global.tooltip",
            wrap: "number"
        },
        labels: {
            font: "font",
            color: "color",
            tooltip: "global.tooltip",
            wrap: "number",
            content: "str"
        },
        lineStyle: "global.border",
        backgroundcolor: "color",
        shadow: "bool",
        scroll: {
            enabled: "global.boolOrAuto",
            size: "number",
            color: "color",
            handle: {
                color: "color",
                hoverColor: "color",
                border: "global.border"
            }
        },
        dock: {
            enabled: "bool",
            animate: "bool",
            minimized: "bool",
            resizeFrame: "bool",
            showMarkers: "bool",
            expandDirection: "global.position",
            button: {
                size: "global.numberOrAuto",
                color: "color",
                hoverColor: "color",
                border: "global.border"
            }
        },
        sizeLegend: {
            layout: {
                typeAnnotation: "str",
                stringValues: ["circle", "quarterCircle"]
            },
            lineStyle: "global.border"
        },
        labelMarkerPad: "global.numberOrPercent",
        labelLabelPad: "global.numberOrPercent"
    },
    title: "global.title",
    subtitle: "global.title",
    footnote: "global.title",
    dataPageSlider: {
        enabled: "bool",
        startPage: "number",
        endPage: "number",
        currentPage: "number",
        discrete: "bool",
        labels: {
            typeAnnotation: "array",
            arrayTypes: "str"
        },
        animateButton: {
            enabled: "bool",
            delay: "number"
        }
    },
    narrativeText: {
        enabled: "bool",
        hideChart: "bool",
        position: {
            typeAnnotation: "str",
            stringValues: ["left", "right", "bottom", "top"]
        },
        maxSize: "global.numberOrPercent",
        url: "str",
        requestKey: "str",
        user: "str",
        password: "str",
        content: "str",
        label: {
            font: "font",
            color: "color",
            align: {
                typeAnnotation: "str",
                stringValues: ["left", "right", "center", "middle"]
            }
        },
        backgroundColor: "color",
        border: "global.border",
        dockButton: {
            enabled: "bool",
            animationDelay: "number",
            size: "number",
            color: "color",
            hoverColor: "color"
        },
        voiceTextButton: {
            enabled: "bool",
            voiceTextProperties: "json"
        },
        textGenerationAPI: "json"
    },
    htmlToolTip: {
        enabled: "bool",
        mouseMargin: "number",
        style: {
            typeAnnotation: "type",
            typeValues: ["str", "json"]
        },
        autoTitleFont: "font",
        autoContentFont: "font",
        snap: "bool",
        sticky: "global.boolOrAuto",
        hideTimeout: {
            time: "number",
            clickable: "number",
            touch: "number",
            touchClickable: "number"
        },
        fill: {
            typeAnnotation: "type",
            typeValues: ["color", "linearGradient", "radialGradient", "pattern", "str"]
        },
        border: {
            width: "number",
            color: "color",
            cornerRadius: {
                typeAnnotation: "type",
                typeValues: ["number", "str", "json"]
            }
        },
        cascadeMenuStyle: {
            label: {
                font: "font",
                color: "color"
            },
            nameValue: {
                name: {
                    font: "font",
                    color: "color"
                },
                value: {
                    font: "font",
                    color: "color"
                }
            },
            hover: {
                fill: {
                    typeAnnotation: "type",
                    typeValues: ["color", "linearGradient", "radialGradient", "pattern", "str"]
                },
                labelColor: "color"
            }
        },
        containerNode: "str"
    },
    xaxis: "global.axis",
    yaxis: "global.axis",
    y2axis: "global.axis",
    zaxis: "global.axis",
    xaxisOrdinal: "global.axis",
    xaxisNumeric: "global.axis",
    zaxisOrdinal: "global.axis",
    axisList: "object",
    colorScale: {
        colors: {
            typeAnnotation: "array",
            arrayTypes: ["str", "color", "json"]
        },
        min: "global.axisBound",
        max: "global.axisBound",
        rawMin: "number",
        rawMax: "number",
        colorMode: {
            typeAnnotation: "str",
            stringValues: ["continuous", "discrete", "bin"]
        },
        colorBands: {
            typeAnnotation: "array",
            arrayTypes: "global.colorStop"
        },
        headroom: "number",
        mustIncludeZero: "bool",
        bIsLog: "bool",
        numberFormat: "global.numberFormat",
        swapChartSide: "bool",
        invert: "bool",
        title: {
            text: "str",
            visible: "bool",
            font: "font",
            color: "color",
            wrap: "number"
        },
        labels: {
            visible: "bool",
            font: "font",
            color: "color",
            excludeMin: "global.boolOrAuto",
            excludeMax: "global.boolOrAuto"
        },
        binMarkers: {
            visible: "bool",
            concatSymbol: "str",
            size: "number",
            shape: "str",
            rotation: "global.rotation",
            position: "global.position",
            border: "global.border"
        },
        baseLineValue: "number",
        baseLineStyle: "global.border",
        bodyLineStyle: "global.border",
        majorGrid: {
            visible: "bool",
            aboveRisers: "bool",
            lineStyle: "global.border",
            ticks: "global.axisTicks"
        },
        minorGrid: {
            visible: "bool",
            count: "number",
            lineStyle: "global.border",
            ticks: "global.axisTicks"
        }
    },
    splitNumericAxis: {
        splitX: {
            enabled: "bool",
            axisGap: "number",
            dividerLine: "global.border"
        },
        splitY: {
            enabled: "bool",
            axisGap: "number",
            dividerLine: "global.border"
        }
    },
    errorBars: {
        yData: "object",
        xData: "object",
        hatWidth: "global.numberOrPercent",
        line: "global.border",
        marker: "global.marker"
    },
    trendline: "global.trendline",
    referenceLines: {
        typeAnnotation: "array",
        arrayTypes: "global.referenceLine",
        defaultType: "defaultReferenceLine"
    },
    dataLabels: {
        visible: "global.boolOrAuto",
        displayMode: {
            typeAnnotation: "str",
            stringValues: ["x", "y", "z", "%", "%+", "seriesLabel", "groupLabel", "cumulative"]
        },
        position: "global.labelPosition",
        font: "font",
        color: "global.colorOrAuto",
        useNegativeColor: "bool",
        negativeColor: "color",
        numberFormat: "global.numberFormat",
        clipToContainer: "bool",
        displayZero: "bool",
        formatCallback: "function",
        feelerLine: {
            visible: "bool",
            width: "number",
            color: "color",
            dash: "str"
        }
    },
    dataSelection: {
        enabled: "bool",
        selectionMode: {
            typeAnnotation: "array",
            arrayTypes: "str",
            stringValues: ["click", "ctrlClick", "dragRect"]
        },
        selectedColor: "global.colorOrPercent",
        selectedBorder: "global.border",
        selectRelatedObjects: "bool",
        unselectedColor: "str",
        unselectedBorder: "global.border",
        selectionRect: {
            fill: "global.fill",
            border: "global.border"
        },
        eventCallback: "function",
        customCallback: "function",
        linkedCharts: "object"
    },
    previewSelection: {
        enabled: "bool",
        selectionMode: {
            typeAnnotation: "array",
            arrayTypes: "str",
            stringValues: ["click", "rightClick", "dragRect"]
        },
        selectRelatedObjects: "bool",
        selectedColor: "global.colorOrPercent",
        selectedBorder: "global.border",
        clearBackgroundSelectOnNextSelect: "bool",
        eventCallback: "function"
    },
    globalSelection: {
        enabled: "bool",
        eventCallback: "function",
        type: "str",
        url: {
            typeAnnotation: "type",
            typeValues: ["str", "array"],
            arrayTypes: "str"
        }
    },
    eventDispatcher: {
        events: {
            typeAnnotation: "array",
            arrayTypes: "global.eventDispatchObject",
            defaultType: "defaultEventDispatchObject"
        }
    },
    markerShapeList: {
        typeAnnotation: "array",
        arrayTypes: "str"
    },
    groupLabels: {
        typeAnnotation: "array",
        arrayTypes: "str"
    },
    series: {
        typeAnnotation: "array",
        arrayTypes: "global.series",
        defaultType: "defaultSeries"
    },
    annotations: {
        typeAnnotation: "array",
        arrayTypes: "global.annotation",
        defaultType: "defaultAnnotation"
    },
    heatmapProperties: {
        dataColors: {
            typeAnnotation: "array",
            arrayTypes: "color"
        }
    }
};
//# sourceMappingURL=tdgchart-min.js.map
